CCS PCM C Compiler, Version 5.025, 7201               17-Nov-21 19:46

               Filename:   E:\University\Microcontrollers\PCW Projects\eletronic-lock-system\Struct-test\main.lst

               ROM used:   2003 words (24%)
                           Largest free fragment is 2048
               RAM used:   51 (14%) at main() level
                           85 (23%) worst case
               Stack used: 9 locations (4 in main + 5 for interrupts)
               Stack size: 8

*
0000:  MOVLW  06
0001:  MOVWF  0A
0002:  GOTO   66C
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  BTFSS  0B.5
0028:  GOTO   02B
0029:  BTFSC  0B.2
002A:  GOTO   052
002B:  MOVLW  8C
002C:  MOVWF  04
002D:  BTFSS  00.0
002E:  GOTO   031
002F:  BTFSC  0C.0
0030:  GOTO   055
0031:  MOVF   22,W
0032:  MOVWF  04
0033:  MOVF   23,W
0034:  MOVWF  77
0035:  MOVF   24,W
0036:  MOVWF  78
0037:  MOVF   25,W
0038:  MOVWF  79
0039:  MOVF   26,W
003A:  MOVWF  7A
003B:  MOVF   27,W
003C:  BSF    03.6
003D:  MOVWF  0D
003E:  BCF    03.6
003F:  MOVF   28,W
0040:  BSF    03.6
0041:  MOVWF  0F
0042:  BCF    03.6
0043:  MOVF   29,W
0044:  BSF    03.6
0045:  MOVWF  0C
0046:  BCF    03.6
0047:  MOVF   2A,W
0048:  BSF    03.6
0049:  MOVWF  0E
004A:  BCF    03.6
004B:  MOVF   20,W
004C:  MOVWF  0A
004D:  SWAPF  21,W
004E:  MOVWF  03
004F:  SWAPF  7F,F
0050:  SWAPF  7F,W
0051:  RETFIE
0052:  BCF    0A.3
0053:  BCF    0A.4
0054:  GOTO   4F3
0055:  BCF    0A.3
0056:  BCF    0A.4
0057:  GOTO   30C
....................  
.................... #include <16F877A.h> 
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
0058:  BCF    0A.0
0059:  BCF    0A.1
005A:  BCF    0A.2
005B:  ADDWF  02,F
005C:  RETLW  28
005D:  RETLW  0F
005E:  RETLW  01
005F:  RETLW  06
*
025F:  MOVF   0B,W
0260:  MOVWF  64
0261:  BCF    0B.7
0262:  BSF    03.5
0263:  BSF    03.6
0264:  BSF    0C.7
0265:  BSF    0C.0
0266:  NOP
0267:  NOP
0268:  BCF    03.5
0269:  BCF    03.6
026A:  BTFSC  64.7
026B:  BSF    0B.7
026C:  BTFSC  03.0
026D:  GOTO   296
026E:  BSF    03.6
026F:  MOVF   0C,W
0270:  ANDLW  7F
0271:  BCF    03.6
0272:  MOVWF  64
0273:  BSF    03.6
0274:  MOVF   0D,W
0275:  BCF    03.6
0276:  MOVWF  65
0277:  BSF    03.6
0278:  MOVF   0F,W
0279:  BCF    03.6
027A:  MOVWF  66
027B:  MOVF   64,W
027C:  MOVWF  67
027D:  CALL   228
027E:  MOVF   65,W
027F:  BSF    03.6
0280:  MOVWF  0D
0281:  BCF    03.6
0282:  MOVF   66,W
0283:  BSF    03.6
0284:  MOVWF  0F
0285:  BCF    03.6
0286:  MOVF   0B,W
0287:  MOVWF  67
0288:  BCF    0B.7
0289:  BSF    03.5
028A:  BSF    03.6
028B:  BSF    0C.7
028C:  BSF    0C.0
028D:  NOP
028E:  NOP
028F:  BCF    03.5
0290:  BCF    03.6
0291:  BTFSC  67.7
0292:  BSF    0B.7
0293:  DECFSZ 63,F
0294:  GOTO   296
0295:  GOTO   2B5
0296:  BSF    03.6
0297:  RLF    0C,W
0298:  RLF    0E,W
0299:  ANDLW  7F
029A:  BCF    03.6
029B:  MOVWF  64
029C:  BSF    03.6
029D:  MOVF   0D,W
029E:  BCF    03.6
029F:  MOVWF  65
02A0:  BSF    03.6
02A1:  MOVF   0F,W
02A2:  BCF    03.6
02A3:  MOVWF  66
02A4:  MOVF   64,W
02A5:  MOVWF  67
02A6:  CALL   228
02A7:  MOVF   65,W
02A8:  BSF    03.6
02A9:  MOVWF  0D
02AA:  BCF    03.6
02AB:  MOVF   66,W
02AC:  BSF    03.6
02AD:  MOVWF  0F
02AE:  INCF   0D,F
02AF:  BTFSC  03.2
02B0:  INCF   0F,F
02B1:  BCF    03.0
02B2:  BCF    03.6
02B3:  DECFSZ 63,F
02B4:  GOTO   25F
02B5:  RETURN
02B6:  MOVF   0B,W
02B7:  MOVWF  63
02B8:  BCF    0B.7
02B9:  BSF    03.5
02BA:  BSF    03.6
02BB:  BSF    0C.7
02BC:  BSF    0C.0
02BD:  NOP
02BE:  NOP
02BF:  BCF    03.5
02C0:  BCF    03.6
02C1:  BTFSC  63.7
02C2:  BSF    0B.7
02C3:  BSF    03.6
02C4:  MOVF   0C,W
02C5:  ANDLW  7F
02C6:  BTFSC  03.2
02C7:  GOTO   30A
02C8:  BCF    03.6
02C9:  MOVWF  63
02CA:  BSF    03.6
02CB:  MOVF   0D,W
02CC:  BCF    03.6
02CD:  MOVWF  64
02CE:  BSF    03.6
02CF:  MOVF   0F,W
02D0:  BCF    03.6
02D1:  MOVWF  65
02D2:  MOVF   63,W
02D3:  MOVWF  67
02D4:  CALL   228
02D5:  MOVF   64,W
02D6:  BSF    03.6
02D7:  MOVWF  0D
02D8:  BCF    03.6
02D9:  MOVF   65,W
02DA:  BSF    03.6
02DB:  MOVWF  0F
02DC:  BCF    03.6
02DD:  MOVF   0B,W
02DE:  MOVWF  66
02DF:  BCF    0B.7
02E0:  BSF    03.5
02E1:  BSF    03.6
02E2:  BSF    0C.7
02E3:  BSF    0C.0
02E4:  NOP
02E5:  NOP
02E6:  BCF    03.5
02E7:  BCF    03.6
02E8:  BTFSC  66.7
02E9:  BSF    0B.7
02EA:  BSF    03.6
02EB:  RLF    0C,W
02EC:  RLF    0E,W
02ED:  ANDLW  7F
02EE:  BTFSC  03.2
02EF:  GOTO   30A
02F0:  BCF    03.6
02F1:  MOVWF  63
02F2:  BSF    03.6
02F3:  MOVF   0D,W
02F4:  BCF    03.6
02F5:  MOVWF  64
02F6:  BSF    03.6
02F7:  MOVF   0F,W
02F8:  BCF    03.6
02F9:  MOVWF  65
02FA:  MOVF   63,W
02FB:  MOVWF  67
02FC:  CALL   228
02FD:  MOVF   64,W
02FE:  BSF    03.6
02FF:  MOVWF  0D
0300:  BCF    03.6
0301:  MOVF   65,W
0302:  BSF    03.6
0303:  MOVWF  0F
0304:  INCF   0D,F
0305:  BTFSC  03.2
0306:  INCF   0F,F
0307:  BCF    03.6
0308:  GOTO   2B6
0309:  BSF    03.6
030A:  BCF    03.6
030B:  RETURN
*
04F7:  DATA 0C,10
04F8:  DATA A0,34
04F9:  DATA EE,34
04FA:  DATA E3,34
04FB:  DATA 61,37
04FC:  DATA E4,37
04FD:  DATA 2E,17
04FE:  DATA 2E,10
04FF:  DATA 00,00
0500:  DATA 8C,24
0501:  DATA C6,26
0502:  DATA 54,10
0503:  DATA 2D,10
0504:  DATA D3,32
0505:  DATA F2,34
0506:  DATA 61,36
0507:  DATA 00,01
0508:  DATA 0C,21
0509:  DATA EC,37
050A:  DATA E3,35
050B:  DATA DF,29
050C:  DATA 69,3D
050D:  DATA 65,1D
050E:  DATA A5,3A
050F:  DATA 00,00
0510:  DATA 8C,34
0511:  DATA 64,1D
0512:  DATA A5,3A
0513:  DATA A5,3A
0514:  DATA 00,00
0515:  DATA 8C,2A
0516:  DATA F3,3A
0517:  DATA 61,39
0518:  DATA E9,37
0519:  DATA A0,21
051A:  DATA 61,32
051B:  DATA E1,39
051C:  DATA 74,39
051D:  DATA 61,32
051E:  DATA 6F,00
051F:  DATA 8C,24
0520:  DATA 44,10
0521:  DATA 69,37
0522:  DATA E3,37
0523:  DATA 6D,38
0524:  DATA 61,3A
0525:  DATA 69,3B
0526:  DATA 65,36
0527:  DATA 00,01
0528:  DATA 0D,05
0529:  DATA D4,32
052A:  DATA 6E,3A
052B:  DATA 65,10
052C:  DATA EE,37
052D:  DATA F6,30
052E:  DATA ED,32
052F:  DATA 6E,3A
0530:  DATA 65,00
0531:  DATA 0C,10
0532:  DATA C2,3A
0533:  DATA 74,3A
0534:  DATA 6F,37
0535:  DATA 3A,10
0536:  DATA 25,32
0537:  DATA 00,10
0538:  DATA 0D,05
0539:  DATA D0,3B
053A:  DATA BA,12
053B:  DATA E4,12
053C:  DATA E4,12
053D:  DATA E4,12
053E:  DATA 64,10
053F:  DATA 53,3A
0540:  DATA BA,12
0541:  DATA 64,10
0542:  DATA 25,32
0543:  DATA 00,00
0544:  DATA 8C,24
0545:  DATA 44,10
0546:  DATA 45,37
0547:  DATA E3,37
0548:  DATA 6E,3A
0549:  DATA F2,30
054A:  DATA E4,37
054B:  DATA BA,12
054C:  DATA F5,12
054D:  DATA 75,00
054E:  DATA 0C,10
054F:  DATA 49,22
0550:  DATA 20,27
0551:  DATA A0,22
0552:  DATA EE,31
0553:  DATA 6F,37
0554:  DATA 74,39
0555:  DATA 61,32
0556:  DATA 6F,00
0557:  DATA 0C,10
0558:  DATA D5,39
0559:  DATA 65,39
055A:  DATA A0,32
055B:  DATA F2,30
055C:  DATA F3,32
055D:  DATA 64,10
055E:  DATA 00,00
055F:  DATA 8C,20
0560:  DATA 64,32
0561:  DATA F2,32
0562:  DATA F3,39
0563:  DATA 3A,10
0564:  DATA 25,32
0565:  DATA 00,00
0566:  DATA 8C,24
0567:  DATA 44,1D
0568:  DATA A5,3A
0569:  DATA 2C,10
056A:  DATA 45,3C
056B:  DATA E9,39
056C:  DATA F4,32
056D:  DATA 00,01
056E:  DATA 8C,24
056F:  DATA 44,1D
0570:  DATA A5,3A
0571:  DATA 2C,10
0572:  DATA 4E,10
0573:  DATA 45,3C
0574:  DATA E9,39
0575:  DATA F4,32
0576:  DATA 00,00
0577:  DATA 0C,10
0578:  DATA C2,3A
0579:  DATA 74,3A
057A:  DATA 6F,37
057B:  DATA 3A,10
057C:  DATA A5,31
057D:  DATA 00,01
057E:  DATA 0C,10
057F:  DATA 20,10
0580:  DATA D4,22
0581:  DATA 43,26
0582:  DATA 41,22
0583:  DATA 4F,10
0584:  DATA 20,00
0585:  DATA 0C,3A
0586:  DATA E5,36
0587:  DATA F0,2F
0588:  DATA 73,3A
0589:  DATA 61,3A
058A:  DATA F5,39
058B:  DATA 3A,10
058C:  DATA A5,3A
058D:  DATA 00,01
058E:  DATA 8C,20
058F:  DATA E4,36
0590:  DATA 69,37
0591:  DATA A0,22
0592:  DATA EE,31
0593:  DATA 6F,37
0594:  DATA 74,39
0595:  DATA 61,32
0596:  DATA 6F,00
*
05FF:  MOVF   78,W
0600:  MOVF   54,W
0601:  MOVWF  56
0602:  MOVLW  64
0603:  MOVWF  57
0604:  MOVF   57,W
0605:  CLRF   78
0606:  SUBWF  56,W
0607:  BTFSC  03.0
0608:  GOTO   60C
0609:  MOVF   56,W
060A:  MOVWF  77
060B:  GOTO   618
060C:  CLRF   77
060D:  MOVLW  08
060E:  MOVWF  58
060F:  RLF    56,F
0610:  RLF    77,F
0611:  MOVF   57,W
0612:  SUBWF  77,W
0613:  BTFSC  03.0
0614:  MOVWF  77
0615:  RLF    78,F
0616:  DECFSZ 58,F
0617:  GOTO   60F
0618:  MOVF   77,W
0619:  MOVWF  54
061A:  MOVF   78,W
061B:  MOVLW  30
061C:  BTFSS  03.2
061D:  GOTO   625
061E:  BTFSS  55.1
061F:  GOTO   632
0620:  BTFSC  55.3
0621:  GOTO   632
0622:  BTFSC  55.4
0623:  MOVLW  20
0624:  GOTO   628
0625:  BCF    55.3
0626:  BCF    55.4
0627:  BSF    55.0
0628:  ADDWF  78,F
0629:  CLRF   2B
062A:  BTFSC  0B.7
062B:  BSF    2B.7
062C:  BCF    0B.7
062D:  MOVF   78,W
062E:  MOVWF  67
062F:  CALL   228
0630:  BTFSC  2B.7
0631:  BSF    0B.7
0632:  MOVF   54,W
0633:  MOVWF  56
0634:  MOVLW  0A
0635:  MOVWF  57
0636:  MOVF   57,W
0637:  CLRF   78
0638:  SUBWF  56,W
0639:  BTFSC  03.0
063A:  GOTO   63E
063B:  MOVF   56,W
063C:  MOVWF  77
063D:  GOTO   64A
063E:  CLRF   77
063F:  MOVLW  08
0640:  MOVWF  58
0641:  RLF    56,F
0642:  RLF    77,F
0643:  MOVF   57,W
0644:  SUBWF  77,W
0645:  BTFSC  03.0
0646:  MOVWF  77
0647:  RLF    78,F
0648:  DECFSZ 58,F
0649:  GOTO   641
064A:  MOVF   77,W
064B:  MOVWF  54
064C:  MOVF   78,W
064D:  MOVLW  30
064E:  BTFSS  03.2
064F:  GOTO   656
0650:  BTFSC  55.3
0651:  GOTO   660
0652:  BTFSS  55.0
0653:  GOTO   660
0654:  BTFSC  55.4
0655:  MOVLW  20
0656:  ADDWF  78,F
0657:  CLRF   2B
0658:  BTFSC  0B.7
0659:  BSF    2B.7
065A:  BCF    0B.7
065B:  MOVF   78,W
065C:  MOVWF  67
065D:  CALL   228
065E:  BTFSC  2B.7
065F:  BSF    0B.7
0660:  MOVLW  30
0661:  ADDWF  54,F
0662:  CLRF   2B
0663:  BTFSC  0B.7
0664:  BSF    2B.7
0665:  BCF    0B.7
0666:  MOVF   54,W
0667:  MOVWF  67
0668:  CALL   228
0669:  BTFSC  2B.7
066A:  BSF    0B.7
066B:  RETURN
....................  
.................... #list 
....................  
.................... #device ADC=8 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES HS  
....................  
.................... #use delay(crystal=20000000) 
*
0060:  MOVLW  68
0061:  MOVWF  04
0062:  BCF    03.7
0063:  MOVF   00,W
0064:  BTFSC  03.2
0065:  GOTO   073
0066:  MOVLW  06
0067:  MOVWF  78
0068:  CLRF   77
0069:  DECFSZ 77,F
006A:  GOTO   069
006B:  DECFSZ 78,F
006C:  GOTO   068
006D:  MOVLW  7B
006E:  MOVWF  77
006F:  DECFSZ 77,F
0070:  GOTO   06F
0071:  DECFSZ 00,F
0072:  GOTO   066
0073:  RETURN
.................... //#use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=PORT1) 
....................  
.................... // -------Variables' Declaration 
.................... signed int8 address_data_delete; 
....................  
.................... typedef struct {  
....................    int id[2]; 
....................    int pass[4]; //password 
....................    int status; //0 - Unpaid, 1 - Paid, 3 - Admin 
.................... }User; 
....................  
.................... #define RX_BUFFER_SIZE 10 
.................... #define BLOCK_SIZE sizeof(User)  
.................... int8 rx_wr_index = 0; 
.................... int8 lock_pos = 0, rxd, read, valid_data_count; 
.................... unsigned int8 rx_buffer[RX_BUFFER_SIZE]; 
.................... int data_avail = FALSE, got_id = FALSE; 
....................  
.................... // ------- 
....................  
....................  
.................... // -----------------Functions 
.................... void saveUser(int * id, int * pass, int status); 
.................... void printUser(); 
.................... int getAddressByID(int id);     
.................... int isIdAvailable(int id);     
.................... int deleteUser(int address); 
.................... void erase_program_eeprom(int addrr); 
.................... int incrementID(); 
.................... int lastNewUserPosition(); 
.................... void resetMemory(); 
.................... void adminMenu(); 
.................... unsigned char readKeyboard();  
.................... int * getAdminID(); 
.................... // ---------------- 
.................... /* 
.................... // ---- MSG from serial communication 
.................... #int_RDA 
.................... void RDA_isr(void){ 
....................    rx_buffer[rx_wr_index] = getc(); 
....................    rxd = rx_buffer[rx_wr_index]; 
....................    rx_wr_index++; 
....................  
....................    if(rx_wr_index > RX_BUFFER_SIZE){ 
....................       rx_wr_index = 0; 
....................    } 
....................  
....................    //Look for unique ID: "IFMT" 
....................    if(rxd == 'I' && lock_pos == 0){ 
....................       lock_pos++; 
....................    } 
....................    else if(rxd == 'F' && lock_pos == 1){ 
....................       lock_pos++; 
....................    } 
....................    else if(rxd == 'M' && lock_pos == 2){ 
....................       lock_pos++; 
....................    } 
....................    else if(rxd == 'T' && lock_pos == 3){ 
....................       lock_pos=0; //Reset the "combination lock" 
....................       got_id = TRUE; 
....................       read = rxd; 
....................       //get ready to count the number of data bytes 
....................       valid_data_count = 0xff;  
....................  
....................       //buffer is reset to index 0 
....................       rx_wr_index = 0; 
....................    }else { 
....................       lock_pos = 0; 
....................    } 
....................  
....................    if(got_id && ++valid_data_count >= 6){ 
....................       data_avail = TRUE; 
....................       got_id = FALSE; 
....................    } 
....................     
.................... } 
.................... */ 
....................  
.................... //Define the default pins before calling the LCD driver 
.................... #ifndef lcd_enable  
....................    #define lcd_enable     pin_e1 
....................    #define lcd_rs         pin_e2 
....................    //#define lcd_rw       pin_e2   
....................    #define lcd_d4         pin_d4 
....................    #define lcd_d5         pin_d5 
....................    #define lcd_d6         pin_d6 
....................    #define lcd_d7         pin_d7 
.................... #endif 
....................  
.................... #include "mod_lcd.c" 
.................... /************************************************************************/ 
.................... /*  MOD_LCD.C - Biblioteca de manipulaï¿½ï¿½o de mï¿½dulo LCD                 */ 
.................... /*                                                                      */ 
.................... /*  Autor: Fï¿½bio Pereira                                                */ 
.................... /*                                                                      */ 
.................... /************************************************************************/ 
....................  
.................... // As definiï¿½ï¿½es a seguir sï¿½o utilizadas para acesso aos pinos do display 
.................... // caso o pino RW nï¿½o seja utilizado, comente a definiï¿½ï¿½o lcd_rw 
.................... #ifndef lcd_enable 
.................... 	#define lcd_enable 		pin_e1		// pino enable do LCD 
.................... 	#define lcd_rs			pin_e0		// pino rs do LCD 
.................... 	//#define lcd_rw		pin_e2		// pino rw do LCD 
.................... 	#define lcd_d4			pin_d4		// pino de dados d4 do LCD 
.................... 	#define lcd_d5			pin_d5		// pino de dados d5 do LCD 
.................... 	#define lcd_d6			pin_d6		// pino de dados d6 do LCD 
.................... 	#define lcd_d7			pin_d7		// pino de dados d7 do LCD 
.................... #endif 
....................  
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 linhas 
.................... #define lcd_seg_lin 0x40    // Endereï¿½o da segunda linha na RAM do LCD 
....................  
.................... // a constante abaixo define a seqï¿½ï¿½ncia de inicializaï¿½ï¿½o do mï¿½dulo LCD 
.................... byte CONST INI_LCD[4] = {0x20 | (lcd_type << 2), 0xf, 1, 6}; 
....................  
.................... byte lcd_le_byte() 
.................... // lï¿½ um byte do LCD (somente com pino RW) 
.................... { 
.................... 	byte dado; 
.................... 	// configura os pinos de dados como entradas 
.................... 	input(lcd_d4); 
.................... 	input(lcd_d5); 
.................... 	input(lcd_d6); 
.................... 	input(lcd_d7); 
.................... 	// se o pino rw for utilizado, coloca em 1 
.................... 	#ifdef lcd_rw 
.................... 		output_high(lcd_rw); 
.................... 	#endif 
....................    output_high(lcd_enable); // habilita display 
.................... 	dado = 0;	// zera a variï¿½vel de leitura 
.................... 	// lï¿½ os quatro bits mais significativos 
.................... 	if (input(lcd_d7)) bit_set(dado,7); 
.................... 	if (input(lcd_d6)) bit_set(dado,6); 
.................... 	if (input(lcd_d5)) bit_set(dado,5); 
.................... 	if (input(lcd_d4)) bit_set(dado,4); 
.................... 	// dï¿½ um pulso na linha enable 
.................... 	output_low(lcd_enable); 
.................... 	output_high(lcd_enable); 
.................... 	// lï¿½ os quatro bits menos significativos 
.................... 	if (input(lcd_d7)) bit_set(dado,3); 
.................... 	if (input(lcd_d6)) bit_set(dado,2); 
.................... 	if (input(lcd_d5)) bit_set(dado,1); 
.................... 	if (input(lcd_d4)) bit_set(dado,0); 
.................... 	output_low(lcd_enable);	// desabilita o display 
.................... 	return dado;	// retorna o byte lido 
.................... } 
....................  
.................... void lcd_envia_nibble( byte dado ) 
.................... // envia um dado de quatro bits para o display 
.................... { 
.................... 	// coloca os quatro bits nas saidas 
.................... 	output_bit(lcd_d4,bit_test(dado,0)); 
*
01E0:  BTFSC  6F.0
01E1:  GOTO   1E4
01E2:  BCF    08.4
01E3:  GOTO   1E5
01E4:  BSF    08.4
01E5:  BSF    03.5
01E6:  BCF    08.4
.................... 	output_bit(lcd_d5,bit_test(dado,1)); 
01E7:  BCF    03.5
01E8:  BTFSC  6F.1
01E9:  GOTO   1EC
01EA:  BCF    08.5
01EB:  GOTO   1ED
01EC:  BSF    08.5
01ED:  BSF    03.5
01EE:  BCF    08.5
.................... 	output_bit(lcd_d6,bit_test(dado,2)); 
01EF:  BCF    03.5
01F0:  BTFSC  6F.2
01F1:  GOTO   1F4
01F2:  BCF    08.6
01F3:  GOTO   1F5
01F4:  BSF    08.6
01F5:  BSF    03.5
01F6:  BCF    08.6
.................... 	output_bit(lcd_d7,bit_test(dado,3)); 
01F7:  BCF    03.5
01F8:  BTFSC  6F.3
01F9:  GOTO   1FC
01FA:  BCF    08.7
01FB:  GOTO   1FD
01FC:  BSF    08.7
01FD:  BSF    03.5
01FE:  BCF    08.7
.................... 	// dï¿½ um pulso na linha enable 
.................... 	output_high(lcd_enable); 
01FF:  BCF    09.1
0200:  BCF    03.5
0201:  BSF    09.1
.................... 	output_low(lcd_enable); 
0202:  BSF    03.5
0203:  BCF    09.1
0204:  BCF    03.5
0205:  BCF    09.1
0206:  RETURN
.................... } 
....................  
....................  
.................... void lcd_envia_byte( boolean endereco, byte dado ) 
.................... { 
.................... 	// coloca a linha rs em 0 
.................... 	output_low(lcd_rs); 
0207:  BSF    03.5
0208:  BCF    09.2
0209:  BCF    03.5
020A:  BCF    09.2
.................... 	// aguarda o display ficar desocupado 
.................... 	//while ( bit_test(lcd_le_byte(),7) ) ; 
.................... 	// configura a linha rs dependendo do modo selecionado 
.................... 	output_bit(lcd_rs,endereco); 
020B:  MOVF   6C,F
020C:  BTFSS  03.2
020D:  GOTO   210
020E:  BCF    09.2
020F:  GOTO   211
0210:  BSF    09.2
0211:  BSF    03.5
0212:  BCF    09.2
.................... 	delay_us(100);	// aguarda 100 us 
0213:  MOVLW  A6
0214:  MOVWF  77
0215:  DECFSZ 77,F
0216:  GOTO   215
0217:  NOP
.................... 	// caso a linha rw esteja definida, coloca em 0 
.................... 	#ifdef lcd_rw 
.................... 		output_low(lcd_rw); 
.................... 	#endif 
.................... 	// desativa linha enable 
.................... 	output_low(lcd_enable); 
0218:  BCF    09.1
0219:  BCF    03.5
021A:  BCF    09.1
.................... 	// envia a primeira parte do byte 
.................... 	lcd_envia_nibble(dado >> 4); 
021B:  SWAPF  6D,W
021C:  MOVWF  6E
021D:  MOVLW  0F
021E:  ANDWF  6E,F
021F:  MOVF   6E,W
0220:  MOVWF  6F
0221:  CALL   1E0
.................... 	// envia a segunda parte do byte 
.................... 	lcd_envia_nibble(dado & 0x0f); 
0222:  MOVF   6D,W
0223:  ANDLW  0F
0224:  MOVWF  6E
0225:  MOVWF  6F
0226:  CALL   1E0
0227:  RETURN
.................... } 
....................  
....................  
.................... void lcd_ini() 
.................... // rotina de inicializaï¿½ï¿½o do display 
.................... { 
.................... 	byte conta; 
.................... 	output_low(lcd_d4); 
*
05A4:  BSF    03.5
05A5:  BCF    08.4
05A6:  BCF    03.5
05A7:  BCF    08.4
.................... 	output_low(lcd_d5); 
05A8:  BSF    03.5
05A9:  BCF    08.5
05AA:  BCF    03.5
05AB:  BCF    08.5
.................... 	output_low(lcd_d6); 
05AC:  BSF    03.5
05AD:  BCF    08.6
05AE:  BCF    03.5
05AF:  BCF    08.6
.................... 	output_low(lcd_d7); 
05B0:  BSF    03.5
05B1:  BCF    08.7
05B2:  BCF    03.5
05B3:  BCF    08.7
.................... 	output_low(lcd_rs); 
05B4:  BSF    03.5
05B5:  BCF    09.2
05B6:  BCF    03.5
05B7:  BCF    09.2
.................... 	#ifdef lcd_rw 
.................... 		output_high(lcd_rw); 
.................... 	#endif 
.................... 	output_low(lcd_enable); 
05B8:  BSF    03.5
05B9:  BCF    09.1
05BA:  BCF    03.5
05BB:  BCF    09.1
05BC:  CLRF   2B
05BD:  BTFSC  0B.7
05BE:  BSF    2B.7
05BF:  BCF    0B.7
.................... 	delay_ms(15); 
05C0:  MOVLW  0F
05C1:  MOVWF  68
05C2:  CALL   060
05C3:  BTFSC  2B.7
05C4:  BSF    0B.7
.................... 	// envia uma seqï¿½ï¿½ncia de 3 vezes 0x03 
.................... 	// e depois 0x02 para configurar o mï¿½dulo 
.................... 	// para modo de 4 bits 
.................... 	for(conta=1;conta<=3;++conta) 
05C5:  MOVLW  01
05C6:  MOVWF  4F
05C7:  MOVF   4F,W
05C8:  SUBLW  03
05C9:  BTFSS  03.0
05CA:  GOTO   5DF
05CB:  CLRF   2B
05CC:  BTFSC  0B.7
05CD:  BSF    2B.7
05CE:  BCF    0B.7
.................... 	{ 
.................... 		lcd_envia_nibble(3); 
05CF:  MOVLW  03
05D0:  MOVWF  6F
05D1:  CALL   1E0
05D2:  BTFSC  2B.7
05D3:  BSF    0B.7
05D4:  CLRF   2B
05D5:  BTFSC  0B.7
05D6:  BSF    2B.7
05D7:  BCF    0B.7
.................... 		delay_ms(5); 
05D8:  MOVLW  05
05D9:  MOVWF  68
05DA:  CALL   060
05DB:  BTFSC  2B.7
05DC:  BSF    0B.7
05DD:  INCF   4F,F
05DE:  GOTO   5C7
05DF:  CLRF   2B
05E0:  BTFSC  0B.7
05E1:  BSF    2B.7
05E2:  BCF    0B.7
.................... 	} 
.................... 	lcd_envia_nibble(2); 
05E3:  MOVLW  02
05E4:  MOVWF  6F
05E5:  CALL   1E0
05E6:  BTFSC  2B.7
05E7:  BSF    0B.7
.................... 	// envia string de inicializaï¿½ï¿½o do display 
.................... 	for(conta=0;conta<=3;++conta) lcd_envia_byte(0,INI_LCD[conta]); 
05E8:  CLRF   4F
05E9:  MOVF   4F,W
05EA:  SUBLW  03
05EB:  BTFSS  03.0
05EC:  GOTO   5FC
05ED:  MOVF   4F,W
05EE:  CALL   058
05EF:  MOVWF  50
05F0:  CLRF   2B
05F1:  BTFSC  0B.7
05F2:  BSF    2B.7
05F3:  BCF    0B.7
05F4:  CLRF   6C
05F5:  MOVF   50,W
05F6:  MOVWF  6D
05F7:  CALL   207
05F8:  BTFSC  2B.7
05F9:  BSF    0B.7
05FA:  INCF   4F,F
05FB:  GOTO   5E9
05FC:  BCF    0A.3
05FD:  BCF    0A.4
05FE:  GOTO   690 (RETURN)
.................... } 
....................  
.................... void lcd_pos_xy( byte x, byte y) 
.................... { 
....................    byte endereco; 
....................    if(y!=1) 
*
0242:  DECFSZ 69,W
0243:  GOTO   245
0244:  GOTO   248
....................    	endereco = lcd_seg_lin; 
0245:  MOVLW  40
0246:  MOVWF  6A
0247:  GOTO   249
....................    else 
....................    	endereco = 0; 
0248:  CLRF   6A
....................    endereco += x-1; 
0249:  MOVLW  01
024A:  SUBWF  68,W
024B:  ADDWF  6A,F
....................    lcd_envia_byte(0,0x80|endereco); 
024C:  MOVF   6A,W
024D:  IORLW  80
024E:  MOVWF  6B
024F:  CLRF   6C
0250:  MOVF   6B,W
0251:  MOVWF  6D
0252:  CALL   207
.................... } 
....................  
.................... void lcd_escreve( char c) 
.................... // envia caractere para o display 
.................... { 
....................    switch (c) 
*
0228:  MOVF   67,W
0229:  XORLW  0C
022A:  BTFSC  03.2
022B:  GOTO   236
022C:  XORLW  06
022D:  BTFSC  03.2
022E:  GOTO   23E
022F:  XORLW  07
0230:  BTFSC  03.2
0231:  GOTO   23E
0232:  XORLW  05
0233:  BTFSC  03.2
0234:  GOTO   254
0235:  GOTO   259
.................... 	{ 
....................      case '\f' 	:	lcd_envia_byte(0,1); 
0236:  CLRF   6C
0237:  MOVLW  01
0238:  MOVWF  6D
0239:  CALL   207
.................... 	  			delay_ms(2); 
023A:  MOVLW  02
023B:  MOVWF  68
023C:  CALL   060
.................... 				break; 
023D:  GOTO   25E
....................      case '\n'	: 
.................... 	   case '\r' 	:	lcd_pos_xy(1,2); 
023E:  MOVLW  01
023F:  MOVWF  68
0240:  MOVLW  02
0241:  MOVWF  69
.................... 	  			break; 
*
0253:  GOTO   25E
....................      case '\b' 	:	lcd_envia_byte(0,0x10); 
0254:  CLRF   6C
0255:  MOVLW  10
0256:  MOVWF  6D
0257:  CALL   207
.................... 	  			break; 
0258:  GOTO   25E
....................      default	:	lcd_envia_byte(1,c); 
0259:  MOVLW  01
025A:  MOVWF  6C
025B:  MOVF   67,W
025C:  MOVWF  6D
025D:  CALL   207
.................... 	  			break; 
....................    } 
025E:  RETURN
.................... } 
....................  
.................... char lcd_le( byte x, byte y) 
.................... // le caractere do display 
.................... { 
.................... 	char valor; 
.................... 	// seleciona a posiï¿½ï¿½o do caractere 
.................... 	lcd_pos_xy(x,y); 
.................... 	// ativa rs 
.................... 	output_high(lcd_rs); 
.................... 	// lï¿½ o caractere 
.................... 	valor = lcd_le_byte(); 
.................... 	// desativa rs 
.................... 	output_low(lcd_rs); 
.................... 	// retorna o valor do caractere 
.................... 	return valor; 
.................... } 
....................  
....................  
.................... #include "2401.c" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a MicroChip 24LC01B configured for a x8 org         //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);  Read the byte d from the address a     //// 
.................... ////                                                                   //// 
.................... ////   b = ext_eeprom_ready();  Returns TRUE if the eeprom is ready    //// 
.................... ////                            to receive opcodes                     //// 
.................... ////                                                                   //// 
.................... ////   The main program may define EEPROM_SDA                          //// 
.................... ////   and EEPROM_SCL to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... ////                            Pin Layout                             //// 
.................... ////   -----------------------------------------------------------     //// 
.................... ////   |                                                         |     //// 
.................... ////   | 1: NC   Not Connected | 8: VCC   +5V                    |     //// 
.................... ////   |                       |                                 |     //// 
.................... ////   | 2: NC   Not Connected | 7: WP    GND                    |     //// 
.................... ////   |                       |                                 |     //// 
.................... ////   | 3: NC   Not Connected | 6: SCL   EEPROM_SCL and Pull-Up |     //// 
.................... ////   |                       |                                 |     //// 
.................... ////   | 4: VSS  GND           | 5: SDA   EEPROM_SDA and Pull-Up |     //// 
.................... ////   -----------------------------------------------------------     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2003 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef EEPROM_SDA 
....................  
.................... #define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C3 
....................  
.................... #endif 
....................  
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
0074:  MOVLW  08
0075:  MOVWF  78
0076:  MOVLW  04
0077:  MOVWF  77
0078:  DECFSZ 77,F
0079:  GOTO   078
007A:  BCF    07.3
007B:  BCF    3E.3
007C:  MOVF   3E,W
007D:  BSF    03.5
007E:  MOVWF  07
007F:  MOVLW  03
0080:  MOVWF  77
0081:  DECFSZ 77,F
0082:  GOTO   081
0083:  BCF    03.5
0084:  RLF    66,F
0085:  BCF    07.4
0086:  BTFSS  03.0
0087:  GOTO   08E
0088:  BSF    3E.4
0089:  MOVF   3E,W
008A:  BSF    03.5
008B:  MOVWF  07
008C:  GOTO   092
008D:  BCF    03.5
008E:  BCF    3E.4
008F:  MOVF   3E,W
0090:  BSF    03.5
0091:  MOVWF  07
0092:  NOP
0093:  BCF    03.5
0094:  BSF    3E.3
0095:  MOVF   3E,W
0096:  BSF    03.5
0097:  MOVWF  07
0098:  BCF    03.5
0099:  BTFSS  07.3
009A:  GOTO   099
009B:  DECFSZ 78,F
009C:  GOTO   076
009D:  MOVLW  04
009E:  MOVWF  77
009F:  DECFSZ 77,F
00A0:  GOTO   09F
00A1:  BCF    07.3
00A2:  BCF    3E.3
00A3:  MOVF   3E,W
00A4:  BSF    03.5
00A5:  MOVWF  07
00A6:  NOP
00A7:  BCF    03.5
00A8:  BSF    3E.4
00A9:  MOVF   3E,W
00AA:  BSF    03.5
00AB:  MOVWF  07
00AC:  MOVLW  03
00AD:  MOVWF  77
00AE:  DECFSZ 77,F
00AF:  GOTO   0AE
00B0:  MOVLW  03
00B1:  MOVWF  77
00B2:  DECFSZ 77,F
00B3:  GOTO   0B2
00B4:  BCF    03.5
00B5:  BSF    3E.3
00B6:  MOVF   3E,W
00B7:  BSF    03.5
00B8:  MOVWF  07
00B9:  BCF    03.5
00BA:  BTFSS  07.3
00BB:  GOTO   0BA
00BC:  CLRF   78
00BD:  MOVLW  03
00BE:  MOVWF  77
00BF:  DECFSZ 77,F
00C0:  GOTO   0BF
00C1:  BTFSC  07.4
00C2:  BSF    78.0
00C3:  BCF    07.3
00C4:  BCF    3E.3
00C5:  MOVF   3E,W
00C6:  BSF    03.5
00C7:  MOVWF  07
00C8:  BCF    03.5
00C9:  BCF    07.4
00CA:  BCF    3E.4
00CB:  MOVF   3E,W
00CC:  BSF    03.5
00CD:  MOVWF  07
00CE:  BCF    03.5
00CF:  RETURN
*
016C:  MOVLW  08
016D:  MOVWF  66
016E:  MOVF   77,W
016F:  MOVWF  67
0170:  BSF    3E.4
0171:  MOVF   3E,W
0172:  BSF    03.5
0173:  MOVWF  07
0174:  MOVLW  03
0175:  MOVWF  77
0176:  DECFSZ 77,F
0177:  GOTO   176
0178:  BCF    03.5
0179:  BSF    3E.3
017A:  MOVF   3E,W
017B:  BSF    03.5
017C:  MOVWF  07
017D:  BCF    03.5
017E:  BTFSS  07.3
017F:  GOTO   17E
0180:  BTFSC  07.4
0181:  BSF    03.0
0182:  BTFSS  07.4
0183:  BCF    03.0
0184:  RLF    78,F
0185:  MOVLW  04
0186:  MOVWF  77
0187:  DECFSZ 77,F
0188:  GOTO   187
0189:  BCF    3E.3
018A:  MOVF   3E,W
018B:  BSF    03.5
018C:  MOVWF  07
018D:  BCF    03.5
018E:  BCF    07.3
018F:  DECFSZ 66,F
0190:  GOTO   170
0191:  BSF    3E.4
0192:  MOVF   3E,W
0193:  BSF    03.5
0194:  MOVWF  07
0195:  MOVLW  03
0196:  MOVWF  77
0197:  DECFSZ 77,F
0198:  GOTO   197
0199:  BCF    03.5
019A:  BCF    07.4
019B:  MOVF   67,W
019C:  BTFSC  03.2
019D:  GOTO   1A3
019E:  BCF    3E.4
019F:  MOVF   3E,W
01A0:  BSF    03.5
01A1:  MOVWF  07
01A2:  BCF    03.5
01A3:  NOP
01A4:  BSF    3E.3
01A5:  MOVF   3E,W
01A6:  BSF    03.5
01A7:  MOVWF  07
01A8:  BCF    03.5
01A9:  BTFSS  07.3
01AA:  GOTO   1A9
01AB:  MOVLW  04
01AC:  MOVWF  77
01AD:  DECFSZ 77,F
01AE:  GOTO   1AD
01AF:  BCF    07.3
01B0:  BCF    3E.3
01B1:  MOVF   3E,W
01B2:  BSF    03.5
01B3:  MOVWF  07
01B4:  MOVLW  03
01B5:  MOVWF  77
01B6:  DECFSZ 77,F
01B7:  GOTO   1B6
01B8:  BCF    03.5
01B9:  BCF    07.4
01BA:  BCF    3E.4
01BB:  MOVF   3E,W
01BC:  BSF    03.5
01BD:  MOVWF  07
....................  
.................... #define EEPROM_ADDRESS BYTE 
.................... #define EEPROM_SIZE    128 
....................  
.................... void init_ext_eeprom() { 
....................    output_float(EEPROM_SCL); 
*
0597:  BSF    3E.3
0598:  MOVF   3E,W
0599:  BSF    03.5
059A:  MOVWF  07
....................    output_float(EEPROM_SDA); 
059B:  BCF    03.5
059C:  BSF    3E.4
059D:  MOVF   3E,W
059E:  BSF    03.5
059F:  MOVWF  07
05A0:  BCF    03.5
05A1:  BCF    0A.3
05A2:  BCF    0A.4
05A3:  GOTO   68F (RETURN)
.................... } 
....................  
.................... BOOLEAN ext_eeprom_ready() { 
....................    int1 ack; 
....................    i2c_start();            // If the write command is acknowledged, 
*
00D0:  BSF    3E.4
00D1:  MOVF   3E,W
00D2:  BSF    03.5
00D3:  MOVWF  07
00D4:  MOVLW  04
00D5:  MOVWF  77
00D6:  DECFSZ 77,F
00D7:  GOTO   0D6
00D8:  BCF    03.5
00D9:  BSF    3E.3
00DA:  MOVF   3E,W
00DB:  BSF    03.5
00DC:  MOVWF  07
00DD:  MOVLW  03
00DE:  MOVWF  77
00DF:  DECFSZ 77,F
00E0:  GOTO   0DF
00E1:  BCF    03.5
00E2:  BCF    07.4
00E3:  BCF    3E.4
00E4:  MOVF   3E,W
00E5:  BSF    03.5
00E6:  MOVWF  07
00E7:  MOVLW  04
00E8:  MOVWF  77
00E9:  DECFSZ 77,F
00EA:  GOTO   0E9
00EB:  BCF    03.5
00EC:  BCF    07.3
00ED:  BCF    3E.3
00EE:  MOVF   3E,W
00EF:  BSF    03.5
00F0:  MOVWF  07
*
043B:  BSF    3E.4
043C:  MOVF   3E,W
043D:  BSF    03.5
043E:  MOVWF  07
043F:  MOVLW  04
0440:  MOVWF  77
0441:  DECFSZ 77,F
0442:  GOTO   441
0443:  BCF    03.5
0444:  BSF    3E.3
0445:  MOVF   3E,W
0446:  BSF    03.5
0447:  MOVWF  07
0448:  MOVLW  03
0449:  MOVWF  77
044A:  DECFSZ 77,F
044B:  GOTO   44A
044C:  BCF    03.5
044D:  BCF    07.4
044E:  BCF    3E.4
044F:  MOVF   3E,W
0450:  BSF    03.5
0451:  MOVWF  07
0452:  MOVLW  04
0453:  MOVWF  77
0454:  DECFSZ 77,F
0455:  GOTO   454
0456:  BCF    03.5
0457:  BCF    07.3
0458:  BCF    3E.3
0459:  MOVF   3E,W
045A:  BSF    03.5
045B:  MOVWF  07
....................    ack = i2c_write(0xa0);  // then the device is ready. 
*
00F1:  MOVLW  A0
00F2:  BCF    03.5
00F3:  MOVWF  66
00F4:  CALL   074
00F5:  MOVF   78,W
00F6:  BCF    65.0
00F7:  BTFSC  78.0
00F8:  BSF    65.0
*
045C:  MOVLW  A0
045D:  BCF    03.5
045E:  MOVWF  66
045F:  CALL   074
0460:  MOVF   78,W
0461:  BCF    65.0
0462:  BTFSC  78.0
0463:  BSF    65.0
....................    i2c_stop(); 
*
00F9:  BCF    3E.4
00FA:  MOVF   3E,W
00FB:  BSF    03.5
00FC:  MOVWF  07
00FD:  NOP
00FE:  BCF    03.5
00FF:  BSF    3E.3
0100:  MOVF   3E,W
0101:  BSF    03.5
0102:  MOVWF  07
0103:  BCF    03.5
0104:  BTFSS  07.3
0105:  GOTO   104
0106:  MOVLW  04
0107:  MOVWF  77
0108:  DECFSZ 77,F
0109:  GOTO   108
010A:  GOTO   10B
010B:  NOP
010C:  BSF    3E.4
010D:  MOVF   3E,W
010E:  BSF    03.5
010F:  MOVWF  07
0110:  MOVLW  04
0111:  MOVWF  77
0112:  DECFSZ 77,F
0113:  GOTO   112
*
0464:  BCF    3E.4
0465:  MOVF   3E,W
0466:  BSF    03.5
0467:  MOVWF  07
0468:  NOP
0469:  BCF    03.5
046A:  BSF    3E.3
046B:  MOVF   3E,W
046C:  BSF    03.5
046D:  MOVWF  07
046E:  BCF    03.5
046F:  BTFSS  07.3
0470:  GOTO   46F
0471:  MOVLW  04
0472:  MOVWF  77
0473:  DECFSZ 77,F
0474:  GOTO   473
0475:  GOTO   476
0476:  NOP
0477:  BSF    3E.4
0478:  MOVF   3E,W
0479:  BSF    03.5
047A:  MOVWF  07
047B:  MOVLW  04
047C:  MOVWF  77
047D:  DECFSZ 77,F
047E:  GOTO   47D
....................    return !ack; 
*
0114:  MOVLW  00
0115:  BCF    03.5
0116:  BTFSS  65.0
0117:  MOVLW  01
0118:  MOVWF  78
*
047F:  MOVLW  00
0480:  BCF    03.5
0481:  BTFSS  65.0
0482:  MOVLW  01
0483:  MOVWF  78
.................... } 
....................  
.................... void write_ext_eeprom(BYTE address, BYTE data) { 
....................    while(!ext_eeprom_ready()); 
0484:  MOVF   78,F
0485:  BTFSC  03.2
0486:  GOTO   43B
....................    i2c_start(); 
0487:  BSF    3E.4
0488:  MOVF   3E,W
0489:  BSF    03.5
048A:  MOVWF  07
048B:  MOVLW  04
048C:  MOVWF  77
048D:  DECFSZ 77,F
048E:  GOTO   48D
048F:  BCF    03.5
0490:  BSF    3E.3
0491:  MOVF   3E,W
0492:  BSF    03.5
0493:  MOVWF  07
0494:  MOVLW  03
0495:  MOVWF  77
0496:  DECFSZ 77,F
0497:  GOTO   496
0498:  BCF    03.5
0499:  BCF    07.4
049A:  BCF    3E.4
049B:  MOVF   3E,W
049C:  BSF    03.5
049D:  MOVWF  07
049E:  MOVLW  04
049F:  MOVWF  77
04A0:  DECFSZ 77,F
04A1:  GOTO   4A0
04A2:  BCF    03.5
04A3:  BCF    07.3
04A4:  BCF    3E.3
04A5:  MOVF   3E,W
04A6:  BSF    03.5
04A7:  MOVWF  07
....................    i2c_write(0xa0); 
04A8:  MOVLW  A0
04A9:  BCF    03.5
04AA:  MOVWF  66
04AB:  CALL   074
....................    i2c_write(address); 
04AC:  MOVF   63,W
04AD:  MOVWF  66
04AE:  CALL   074
....................    i2c_write(data); 
04AF:  MOVF   64,W
04B0:  MOVWF  66
04B1:  CALL   074
....................    i2c_stop(); 
04B2:  BCF    3E.4
04B3:  MOVF   3E,W
04B4:  BSF    03.5
04B5:  MOVWF  07
04B6:  NOP
04B7:  BCF    03.5
04B8:  BSF    3E.3
04B9:  MOVF   3E,W
04BA:  BSF    03.5
04BB:  MOVWF  07
04BC:  BCF    03.5
04BD:  BTFSS  07.3
04BE:  GOTO   4BD
04BF:  MOVLW  04
04C0:  MOVWF  77
04C1:  DECFSZ 77,F
04C2:  GOTO   4C1
04C3:  GOTO   4C4
04C4:  NOP
04C5:  BSF    3E.4
04C6:  MOVF   3E,W
04C7:  BSF    03.5
04C8:  MOVWF  07
04C9:  MOVLW  04
04CA:  MOVWF  77
04CB:  DECFSZ 77,F
04CC:  GOTO   4CB
.................... } 
....................  
....................  
.................... BYTE read_ext_eeprom(BYTE address) { 
....................    BYTE data; 
....................  
....................    while(!ext_eeprom_ready()); 
*
0119:  MOVF   78,F
011A:  BTFSC  03.2
011B:  GOTO   0D0
....................    i2c_start(); 
011C:  BSF    3E.4
011D:  MOVF   3E,W
011E:  BSF    03.5
011F:  MOVWF  07
0120:  MOVLW  04
0121:  MOVWF  77
0122:  DECFSZ 77,F
0123:  GOTO   122
0124:  BCF    03.5
0125:  BSF    3E.3
0126:  MOVF   3E,W
0127:  BSF    03.5
0128:  MOVWF  07
0129:  MOVLW  03
012A:  MOVWF  77
012B:  DECFSZ 77,F
012C:  GOTO   12B
012D:  BCF    03.5
012E:  BCF    07.4
012F:  BCF    3E.4
0130:  MOVF   3E,W
0131:  BSF    03.5
0132:  MOVWF  07
0133:  MOVLW  04
0134:  MOVWF  77
0135:  DECFSZ 77,F
0136:  GOTO   135
0137:  BCF    03.5
0138:  BCF    07.3
0139:  BCF    3E.3
013A:  MOVF   3E,W
013B:  BSF    03.5
013C:  MOVWF  07
....................    i2c_write(0xa0); 
013D:  MOVLW  A0
013E:  BCF    03.5
013F:  MOVWF  66
0140:  CALL   074
....................    i2c_write(address); 
0141:  MOVF   63,W
0142:  MOVWF  66
0143:  CALL   074
....................    i2c_start(); 
0144:  BSF    3E.4
0145:  MOVF   3E,W
0146:  BSF    03.5
0147:  MOVWF  07
0148:  MOVLW  04
0149:  MOVWF  77
014A:  DECFSZ 77,F
014B:  GOTO   14A
014C:  BCF    03.5
014D:  BSF    3E.3
014E:  MOVF   3E,W
014F:  BSF    03.5
0150:  MOVWF  07
0151:  MOVLW  03
0152:  MOVWF  77
0153:  DECFSZ 77,F
0154:  GOTO   153
0155:  BCF    03.5
0156:  BTFSS  07.3
0157:  GOTO   156
0158:  BCF    07.4
0159:  BCF    3E.4
015A:  MOVF   3E,W
015B:  BSF    03.5
015C:  MOVWF  07
015D:  MOVLW  04
015E:  MOVWF  77
015F:  DECFSZ 77,F
0160:  GOTO   15F
0161:  BCF    03.5
0162:  BCF    07.3
0163:  BCF    3E.3
0164:  MOVF   3E,W
0165:  BSF    03.5
0166:  MOVWF  07
....................    i2c_write(0xa1); 
0167:  MOVLW  A1
0168:  BCF    03.5
0169:  MOVWF  66
016A:  CALL   074
....................    data=i2c_read(0); 
016B:  CLRF   77
*
01BE:  MOVF   78,W
01BF:  BCF    03.5
01C0:  MOVWF  64
....................    i2c_stop(); 
01C1:  BCF    3E.4
01C2:  MOVF   3E,W
01C3:  BSF    03.5
01C4:  MOVWF  07
01C5:  NOP
01C6:  BCF    03.5
01C7:  BSF    3E.3
01C8:  MOVF   3E,W
01C9:  BSF    03.5
01CA:  MOVWF  07
01CB:  BCF    03.5
01CC:  BTFSS  07.3
01CD:  GOTO   1CC
01CE:  MOVLW  04
01CF:  MOVWF  77
01D0:  DECFSZ 77,F
01D1:  GOTO   1D0
01D2:  GOTO   1D3
01D3:  NOP
01D4:  BSF    3E.4
01D5:  MOVF   3E,W
01D6:  BSF    03.5
01D7:  MOVWF  07
01D8:  MOVLW  04
01D9:  MOVWF  77
01DA:  DECFSZ 77,F
01DB:  GOTO   1DA
....................    return(data); 
01DC:  BCF    03.5
01DD:  MOVF   64,W
01DE:  MOVWF  78
01DF:  RETURN
.................... } 
....................  
....................  
.................... #include "kbd_board4.c" 
.................... /*######################################################################  
....................    Rotina utilização do teclado da placa PicSim board4 
....................    Adaptada para o compilador CCS 
....................    Autor: Alberto Willia Mascarenhas (adaptou para o compilador) 
....................    For e-mail suggestions :  awmascarenhas@gmail.com 
.................... ######################################################################## */ 
.................... unsigned char tc_tecla(unsigned int timeout) 
*
030E:  CLRF   64
030F:  CLRF   65
.................... { 
....................   unsigned int to=0; 
....................   unsigned char k = 0;   
....................   while(((to < timeout)||(!timeout))&&(!k)){ 
0310:  MOVF   63,W
0311:  SUBWF  64,W
0312:  BTFSS  03.0
0313:  GOTO   317
0314:  MOVF   63,F
0315:  BTFSS  03.2
0316:  GOTO   42C
0317:  MOVF   65,F
0318:  BTFSS  03.2
0319:  GOTO   42C
....................       
....................        
....................       //------------------------------------------------------------------------- 
....................       //inicio do programa de varredura do teclado matricial 
....................       //-------------------------------------------------------------------------- 
....................       //habilita primeira coluna do teclado 
....................       output_low(PIN_B0);output_high(PIN_B1);output_high(PIN_B2);output_high(PIN_B3); 
031A:  BSF    03.5
031B:  BCF    06.0
031C:  BCF    03.5
031D:  BCF    06.0
031E:  BSF    03.5
031F:  BCF    06.1
0320:  BCF    03.5
0321:  BSF    06.1
0322:  BSF    03.5
0323:  BCF    06.2
0324:  BCF    03.5
0325:  BSF    06.2
0326:  BSF    03.5
0327:  BCF    06.3
0328:  BCF    03.5
0329:  BSF    06.3
....................       delay_ms(20); 
032A:  MOVLW  14
032B:  MOVWF  68
032C:  CALL   060
....................       if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='1';}; 
032D:  BSF    03.5
032E:  BSF    08.0
032F:  BCF    03.5
0330:  BTFSC  08.0
0331:  GOTO   339
0332:  BSF    03.5
0333:  BSF    08.0
0334:  BCF    03.5
0335:  BTFSS  08.0
0336:  GOTO   332
0337:  MOVLW  31
0338:  MOVWF  65
....................       if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='4';}; 
0339:  BSF    03.5
033A:  BSF    08.1
033B:  BCF    03.5
033C:  BTFSC  08.1
033D:  GOTO   345
033E:  BSF    03.5
033F:  BSF    08.1
0340:  BCF    03.5
0341:  BTFSS  08.1
0342:  GOTO   33E
0343:  MOVLW  34
0344:  MOVWF  65
....................       if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='7';}; 
0345:  BSF    03.5
0346:  BSF    08.2
0347:  BCF    03.5
0348:  BTFSC  08.2
0349:  GOTO   351
034A:  BSF    03.5
034B:  BSF    08.2
034C:  BCF    03.5
034D:  BTFSS  08.2
034E:  GOTO   34A
034F:  MOVLW  37
0350:  MOVWF  65
....................       if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='*';}; 
0351:  BSF    03.5
0352:  BSF    08.3
0353:  BCF    03.5
0354:  BTFSC  08.3
0355:  GOTO   35D
0356:  BSF    03.5
0357:  BSF    08.3
0358:  BCF    03.5
0359:  BTFSS  08.3
035A:  GOTO   356
035B:  MOVLW  2A
035C:  MOVWF  65
....................       //habilita segunda coluna do teclado 
....................       output_high(PIN_B0);output_low(PIN_B1);output_high(PIN_B2);output_high(PIN_B3); 
035D:  BSF    03.5
035E:  BCF    06.0
035F:  BCF    03.5
0360:  BSF    06.0
0361:  BSF    03.5
0362:  BCF    06.1
0363:  BCF    03.5
0364:  BCF    06.1
0365:  BSF    03.5
0366:  BCF    06.2
0367:  BCF    03.5
0368:  BSF    06.2
0369:  BSF    03.5
036A:  BCF    06.3
036B:  BCF    03.5
036C:  BSF    06.3
....................       delay_ms(20);       
036D:  MOVLW  14
036E:  MOVWF  68
036F:  CALL   060
....................       if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='2';}; 
0370:  BSF    03.5
0371:  BSF    08.0
0372:  BCF    03.5
0373:  BTFSC  08.0
0374:  GOTO   37C
0375:  BSF    03.5
0376:  BSF    08.0
0377:  BCF    03.5
0378:  BTFSS  08.0
0379:  GOTO   375
037A:  MOVLW  32
037B:  MOVWF  65
....................       if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='5';}; 
037C:  BSF    03.5
037D:  BSF    08.1
037E:  BCF    03.5
037F:  BTFSC  08.1
0380:  GOTO   388
0381:  BSF    03.5
0382:  BSF    08.1
0383:  BCF    03.5
0384:  BTFSS  08.1
0385:  GOTO   381
0386:  MOVLW  35
0387:  MOVWF  65
....................       if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='8';}; 
0388:  BSF    03.5
0389:  BSF    08.2
038A:  BCF    03.5
038B:  BTFSC  08.2
038C:  GOTO   394
038D:  BSF    03.5
038E:  BSF    08.2
038F:  BCF    03.5
0390:  BTFSS  08.2
0391:  GOTO   38D
0392:  MOVLW  38
0393:  MOVWF  65
....................       if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='0';}; 
0394:  BSF    03.5
0395:  BSF    08.3
0396:  BCF    03.5
0397:  BTFSC  08.3
0398:  GOTO   3A0
0399:  BSF    03.5
039A:  BSF    08.3
039B:  BCF    03.5
039C:  BTFSS  08.3
039D:  GOTO   399
039E:  MOVLW  30
039F:  MOVWF  65
....................        
....................       //habilita terceira coluna do teclado 
....................       output_high(PIN_B0);output_high(PIN_B1);output_low(PIN_B2);output_high(PIN_B3); 
03A0:  BSF    03.5
03A1:  BCF    06.0
03A2:  BCF    03.5
03A3:  BSF    06.0
03A4:  BSF    03.5
03A5:  BCF    06.1
03A6:  BCF    03.5
03A7:  BSF    06.1
03A8:  BSF    03.5
03A9:  BCF    06.2
03AA:  BCF    03.5
03AB:  BCF    06.2
03AC:  BSF    03.5
03AD:  BCF    06.3
03AE:  BCF    03.5
03AF:  BSF    06.3
....................       delay_ms(20);       
03B0:  MOVLW  14
03B1:  MOVWF  68
03B2:  CALL   060
....................       if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='3';}; 
03B3:  BSF    03.5
03B4:  BSF    08.0
03B5:  BCF    03.5
03B6:  BTFSC  08.0
03B7:  GOTO   3BF
03B8:  BSF    03.5
03B9:  BSF    08.0
03BA:  BCF    03.5
03BB:  BTFSS  08.0
03BC:  GOTO   3B8
03BD:  MOVLW  33
03BE:  MOVWF  65
....................       if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='6';}; 
03BF:  BSF    03.5
03C0:  BSF    08.1
03C1:  BCF    03.5
03C2:  BTFSC  08.1
03C3:  GOTO   3CB
03C4:  BSF    03.5
03C5:  BSF    08.1
03C6:  BCF    03.5
03C7:  BTFSS  08.1
03C8:  GOTO   3C4
03C9:  MOVLW  36
03CA:  MOVWF  65
....................       if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='9';}; 
03CB:  BSF    03.5
03CC:  BSF    08.2
03CD:  BCF    03.5
03CE:  BTFSC  08.2
03CF:  GOTO   3D7
03D0:  BSF    03.5
03D1:  BSF    08.2
03D2:  BCF    03.5
03D3:  BTFSS  08.2
03D4:  GOTO   3D0
03D5:  MOVLW  39
03D6:  MOVWF  65
....................       if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='#';}; 
03D7:  BSF    03.5
03D8:  BSF    08.3
03D9:  BCF    03.5
03DA:  BTFSC  08.3
03DB:  GOTO   3E3
03DC:  BSF    03.5
03DD:  BSF    08.3
03DE:  BCF    03.5
03DF:  BTFSS  08.3
03E0:  GOTO   3DC
03E1:  MOVLW  23
03E2:  MOVWF  65
....................   
....................        //habilita quarta coluna do teclado 
....................       output_high(PIN_B0);output_high(PIN_B1);output_high(PIN_B2);output_low(PIN_B3); 
03E3:  BSF    03.5
03E4:  BCF    06.0
03E5:  BCF    03.5
03E6:  BSF    06.0
03E7:  BSF    03.5
03E8:  BCF    06.1
03E9:  BCF    03.5
03EA:  BSF    06.1
03EB:  BSF    03.5
03EC:  BCF    06.2
03ED:  BCF    03.5
03EE:  BSF    06.2
03EF:  BSF    03.5
03F0:  BCF    06.3
03F1:  BCF    03.5
03F2:  BCF    06.3
....................       delay_ms(20);       
03F3:  MOVLW  14
03F4:  MOVWF  68
03F5:  CALL   060
....................       if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='A';}; 
03F6:  BSF    03.5
03F7:  BSF    08.0
03F8:  BCF    03.5
03F9:  BTFSC  08.0
03FA:  GOTO   402
03FB:  BSF    03.5
03FC:  BSF    08.0
03FD:  BCF    03.5
03FE:  BTFSS  08.0
03FF:  GOTO   3FB
0400:  MOVLW  41
0401:  MOVWF  65
....................       if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='B';}; 
0402:  BSF    03.5
0403:  BSF    08.1
0404:  BCF    03.5
0405:  BTFSC  08.1
0406:  GOTO   40E
0407:  BSF    03.5
0408:  BSF    08.1
0409:  BCF    03.5
040A:  BTFSS  08.1
040B:  GOTO   407
040C:  MOVLW  42
040D:  MOVWF  65
....................       if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='C';}; 
040E:  BSF    03.5
040F:  BSF    08.2
0410:  BCF    03.5
0411:  BTFSC  08.2
0412:  GOTO   41A
0413:  BSF    03.5
0414:  BSF    08.2
0415:  BCF    03.5
0416:  BTFSS  08.2
0417:  GOTO   413
0418:  MOVLW  43
0419:  MOVWF  65
....................       if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='D';}; 
041A:  BSF    03.5
041B:  BSF    08.3
041C:  BCF    03.5
041D:  BTFSC  08.3
041E:  GOTO   426
041F:  BSF    03.5
0420:  BSF    08.3
0421:  BCF    03.5
0422:  BTFSS  08.3
0423:  GOTO   41F
0424:  MOVLW  44
0425:  MOVWF  65
....................   
....................       //printf (lcd_escreve,"\f saiu geral %u",k); 
....................       //delay_ms(1000); 
....................       delay_ms(5); 
0426:  MOVLW  05
0427:  MOVWF  68
0428:  CALL   060
....................       to+=5; 
0429:  MOVLW  05
042A:  ADDWF  64,F
042B:  GOTO   310
....................   } 
....................    if(!k)k=255; 
042C:  MOVF   65,F
042D:  BTFSS  03.2
042E:  GOTO   431
042F:  MOVLW  FF
0430:  MOVWF  65
....................   return k;   
0431:  MOVF   65,W
0432:  MOVWF  78
.................... } 
....................  
....................  
....................  
.................... #int_TIMER1 
.................... void TIMER1_isr(void) 
.................... { 
....................    readKeyboard(); 
.................... } 
....................  
*
04EF:  BCF    0C.0
04F0:  BCF    0A.3
04F1:  BCF    0A.4
04F2:  GOTO   031
.................... #int_RTCC 
.................... void RTCC_isr(void) 
.................... { 
....................  
....................  
....................     
....................        
04F3:  BCF    0B.2
04F4:  BCF    0A.3
04F5:  BCF    0A.4
04F6:  GOTO   031
.................... } 
....................  
.................... void main() 
*
066C:  MOVF   03,W
066D:  ANDLW  1F
066E:  MOVWF  03
066F:  CLRF   2D
0670:  CLRF   2E
0671:  CLRF   3C
0672:  CLRF   3D
0673:  MOVLW  FF
0674:  MOVWF  3E
0675:  BSF    03.5
0676:  BSF    1F.0
0677:  BSF    1F.1
0678:  BSF    1F.2
0679:  BCF    1F.3
067A:  MOVLW  07
067B:  MOVWF  1C
067C:  BCF    03.7
*
0685:  CLRF   49
.................... { 
....................    //VARIAVEIS 
....................    byte result; 
....................    unsigned char tmp; 
....................    unsigned char tmp_result; 
....................     
....................    eeprom_address address = 0; 
....................  
....................    // unsigned char tmp_result; 
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_256|RTCC_8_bit);      //13.1ms overflow 
0686:  BSF    03.5
0687:  MOVF   01,W
0688:  ANDLW  C0
0689:  IORLW  07
068A:  MOVWF  01
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); //Overflow in 104ms | Resolution 1.6 us 
068B:  MOVLW  B5
068C:  BCF    03.5
068D:  MOVWF  10
....................  
....................    init_ext_eeprom(); 
068E:  GOTO   597
....................  
....................    // enable_interrupts(INT_TIMER0); 
....................    // enable_interrupts(INT_TIMER1); 
....................  
....................    // enable_interrupts(GLOBAL); 
....................  
....................  
....................    lcd_ini(); 
068F:  GOTO   5A4
....................    delay_us(50); 
0690:  MOVLW  52
0691:  MOVWF  77
0692:  DECFSZ 77,F
0693:  GOTO   692
0694:  GOTO   695
0695:  NOP
....................    printf(lcd_escreve, "\f  iniciando... "); 
0696:  MOVLW  F7
0697:  BSF    03.6
0698:  MOVWF  0D
0699:  MOVLW  04
069A:  MOVWF  0F
069B:  BCF    03.6
069C:  CLRF   2B
069D:  BTFSC  0B.7
069E:  BSF    2B.7
069F:  BCF    0B.7
06A0:  CALL   2B6
06A1:  BTFSC  2B.7
06A2:  BSF    0B.7
....................    delay_ms(500); 
06A3:  MOVLW  02
06A4:  MOVWF  4F
06A5:  CLRF   2B
06A6:  BTFSC  0B.7
06A7:  BSF    2B.7
06A8:  BCF    0B.7
06A9:  MOVLW  FA
06AA:  MOVWF  68
06AB:  CALL   060
06AC:  BTFSC  2B.7
06AD:  BSF    0B.7
06AE:  DECFSZ 4F,F
06AF:  GOTO   6A5
....................  
....................    printf(lcd_escreve, "\fIFMT - Serial"); 
06B0:  MOVLW  00
06B1:  BSF    03.6
06B2:  MOVWF  0D
06B3:  MOVLW  05
06B4:  MOVWF  0F
06B5:  BCF    03.6
06B6:  CLRF   2B
06B7:  BTFSC  0B.7
06B8:  BSF    2B.7
06B9:  BCF    0B.7
06BA:  CALL   2B6
06BB:  BTFSC  2B.7
06BC:  BSF    0B.7
06BD:  CLRF   2B
06BE:  BTFSC  0B.7
06BF:  BSF    2B.7
06C0:  BCF    0B.7
....................    delay_ms(50); 
06C1:  MOVLW  32
06C2:  MOVWF  68
06C3:  CALL   060
06C4:  BTFSC  2B.7
06C5:  BSF    0B.7
....................  
....................    int size = BLOCK_SIZE; 
06C6:  MOVLW  07
06C7:  MOVWF  4A
....................    printf(lcd_escreve, "\fBlock_Size:%u", size); 
06C8:  MOVLW  08
06C9:  BSF    03.6
06CA:  MOVWF  0D
06CB:  MOVLW  05
06CC:  MOVWF  0F
06CD:  BCF    03.0
06CE:  BCF    03.6
06CF:  CLRF   2B
06D0:  BTFSC  0B.7
06D1:  BSF    2B.7
06D2:  BCF    0B.7
06D3:  MOVLW  0C
06D4:  MOVWF  63
06D5:  CALL   25F
06D6:  BTFSC  2B.7
06D7:  BSF    0B.7
06D8:  MOVF   4A,W
06D9:  MOVWF  54
06DA:  MOVLW  1B
06DB:  MOVWF  55
06DC:  CALL   5FF
....................    delay_ms(500); 
06DD:  MOVLW  02
06DE:  MOVWF  4F
06DF:  CLRF   2B
06E0:  BTFSC  0B.7
06E1:  BSF    2B.7
06E2:  BCF    0B.7
06E3:  MOVLW  FA
06E4:  MOVWF  68
06E5:  CALL   060
06E6:  BTFSC  2B.7
06E7:  BSF    0B.7
06E8:  DECFSZ 4F,F
06E9:  GOTO   6DF
....................  
....................    // resetMemory(); 
....................     
....................    // data_avail = FALSE; 
....................    // int pass [4] = {1,2,3,4}; 
....................    // int id [2] = {12,12}; 
....................    // saveUser(id, pass, 1); 
....................    // int id1 [2] = {14,0}; 
....................    // saveUser(id1, pass, 0); 
....................    // int id2 [2] = {5,5}; 
....................    // saveUser(id2, pass, 1); 
....................    // int id3 [2] = {70,00}; 
....................    // saveUser(id3, pass, 1); 
....................    // int id4 [2] = {254,254}; 
....................    // saveUser(id4, pass, 3);//admin 
....................  
....................    int * admins; 
....................  
....................    admins = getAdminID(); 
*
076B:  MOVF   79,W
076C:  MOVWF  4C
076D:  MOVF   78,W
076E:  MOVWF  4B
....................    for (int16 i=0; i < sizeof(admins); i+=2){ 
076F:  CLRF   4E
0770:  CLRF   4D
0771:  MOVF   4E,F
0772:  BTFSS  03.2
0773:  GOTO   7BB
0774:  MOVF   4D,W
0775:  SUBLW  01
0776:  BTFSS  03.0
0777:  GOTO   7BB
....................       printf(lcd_escreve, "\fid:%u%u",admins[i], admins[i+1]); 
0778:  MOVF   4B,W
0779:  ADDWF  4D,W
077A:  MOVWF  04
077B:  BCF    03.7
077C:  BTFSC  4C.0
077D:  BSF    03.7
077E:  MOVF   00,W
077F:  MOVWF  4F
0780:  MOVLW  01
0781:  ADDWF  4D,W
0782:  MOVWF  50
0783:  MOVF   4E,W
0784:  MOVWF  51
0785:  BTFSC  03.0
0786:  INCF   51,F
0787:  MOVF   4B,W
0788:  ADDWF  50,W
0789:  MOVWF  04
078A:  BCF    03.7
078B:  BTFSC  4C.0
078C:  BSF    03.7
078D:  MOVF   00,W
078E:  MOVWF  52
078F:  MOVLW  10
0790:  BSF    03.6
0791:  MOVWF  0D
0792:  MOVLW  05
0793:  MOVWF  0F
0794:  BCF    03.0
0795:  BCF    03.6
0796:  CLRF   2B
0797:  BTFSC  0B.7
0798:  BSF    2B.7
0799:  BCF    0B.7
079A:  MOVLW  04
079B:  MOVWF  63
079C:  CALL   25F
079D:  BTFSC  2B.7
079E:  BSF    0B.7
079F:  MOVF   4F,W
07A0:  MOVWF  54
07A1:  MOVLW  1B
07A2:  MOVWF  55
07A3:  CALL   5FF
07A4:  MOVF   52,W
07A5:  MOVWF  54
07A6:  MOVLW  1B
07A7:  MOVWF  55
07A8:  CALL   5FF
....................       delay_ms(1000); 
07A9:  MOVLW  04
07AA:  MOVWF  4F
07AB:  CLRF   2B
07AC:  BTFSC  0B.7
07AD:  BSF    2B.7
07AE:  BCF    0B.7
07AF:  MOVLW  FA
07B0:  MOVWF  68
07B1:  CALL   060
07B2:  BTFSC  2B.7
07B3:  BSF    0B.7
07B4:  DECFSZ 4F,F
07B5:  GOTO   7AB
07B6:  MOVLW  02
07B7:  ADDWF  4D,F
07B8:  BTFSC  03.0
07B9:  INCF   4E,F
07BA:  GOTO   771
07BB:  CLRF   2B
07BC:  BTFSC  0B.7
07BD:  BSF    2B.7
07BE:  BCF    0B.7
....................    }  
....................     
....................     
....................    // isIdAvailable(254); 
....................    // isIdAvailable(200); 
....................  
....................   
....................   // address_data_delete = getAddressByID(6); 
....................   // printf(lcd_escreve, "\f Address ID = %d", address_data_delete); 
....................  //  deleteBlock(address_data_delete); 
....................    delay_ms(50); 
07BF:  MOVLW  32
07C0:  MOVWF  68
07C1:  CALL   060
07C2:  BTFSC  2B.7
07C3:  BSF    0B.7
....................    // printUser(); 
....................    delay_ms(1000); 
07C4:  MOVLW  04
07C5:  MOVWF  4F
07C6:  CLRF   2B
07C7:  BTFSC  0B.7
07C8:  BSF    2B.7
07C9:  BCF    0B.7
07CA:  MOVLW  FA
07CB:  MOVWF  68
07CC:  CALL   060
07CD:  BTFSC  2B.7
07CE:  BSF    0B.7
07CF:  DECFSZ 4F,F
07D0:  GOTO   7C6
....................     
....................    while(TRUE) 
....................    { 
07D1:  GOTO   7D1
....................     
....................    } 
....................  
.................... } 
.................... /* 
07D2:  SLEEP
.................... int incrementID(){ 
....................    int greatest_id = 0 ,address = 0;    
....................     
....................    erase_program_eeprom(0);  
....................    int id_temp = read_ext_eeprom(address);    
....................  
....................    while( id_temp  != -1){ 
....................        
....................       if(id_temp > greatest_id ){ 
....................          greatest_id = id_temp; 
....................       }      
....................       
....................       address += BLOCK_SIZE; 
....................       id_temp = read_ext_eeprom(address); 
....................        
....................    } 
....................    
....................     
....................    return ++greatest_id; 
....................      
.................... } 
.................... */ 
.................... void saveUser(int * id, int * pass, int status){ 
....................  
....................    if( id[0] < 256 && id[1] < 256 && getAddressByID(id) > -1 ){ 
....................       int address = lastNewUserPosition(); 
....................       //recebe os parÃ¢metros do usuÃ¡rio 
....................       User user; 
....................       user.id[0] = id[0]; 
....................       user.id[1] = id[1]; 
....................       user.pass[0] = pass[0]; 
....................       user.pass[1] = pass[1]; 
....................       user.pass[2] = pass[2]; 
....................       user.pass[3] = pass[3]; 
....................       user.status = status; 
....................        
....................  
....................       //Corrigir isso, o endereÃ§o tem que ser "dinÃ¢mico" 
....................        
....................       write_ext_eeprom(address, user.id[0]); 
....................       write_ext_eeprom(address+1, user.id[1]); 
....................       write_ext_eeprom(address+2, user.pass[0]); 
....................       write_ext_eeprom(address+3, user.pass[1]); 
....................       write_ext_eeprom(address+4, user.pass[2]); 
....................       write_ext_eeprom(address+5, user.pass[3]);        
....................       write_ext_eeprom(address+6, user.status); 
....................     
....................  
....................       printf (lcd_escreve,"\fUsuario Cadastrado"); 
....................       delay_ms(500); 
....................  
....................    }else{ 
....................       printf (lcd_escreve,"\fID incompativel"); 
....................       printf (lcd_escreve,"\r\nTente novamente"); 
....................       delay_ms(1000); 
....................  
....................    } 
.................... } 
....................  
.................... void printUser(){ 
....................    //delay_ms(50); 
....................    int tmp_result = read_ext_eeprom(0);   
....................     
....................    delay_ms(50);   
....................     
....................    printf (lcd_escreve,"\f Button: %d", tmp_result); 
....................    printf(lcd_escreve, "\r\nPw:%d%d%d%d St:%d %d", read_ext_eeprom(1), read_ext_eeprom(2), read_ext_eeprom(3), read_ext_eeprom(4), read_ext_eeprom(5), read_ext_eeprom(6)); 
....................     
....................    //printf(lcd_escreve, "\f Client () elseÂ´{}{} 
....................    // printf(lcd_escreve, "\r\nPw:%c%c%c%c St:%c %c", U1.pass[0], U1.pass[1], U1.pass[2], U1.pass[3], U1.status, U1.type_usr); 
.................... } 
....................  
.................... int getAddressByID(int * id){ 
....................    int id_temp[2]; 
....................    int address = 0; 
....................     
....................    while( read_ext_eeprom(address) != -1){ 
....................       id_temp[0] = read_ext_eeprom(address); 
....................       id_temp[1] = read_ext_eeprom(address+1); 
....................        
....................       if (id_temp[0] == id[0] && id_temp[1] == id[1]){ 
....................          printf (lcd_escreve,"\fID Encontrado:%u%u", id_temp[0],id_temp[1]); 
....................          delay_ms(1000); 
....................          return address; 
....................       } 
....................  
....................       address += BLOCK_SIZE;  
....................    } 
....................    printf (lcd_escreve,"\f ID N Encontrado"); 
....................    return -1; 
....................     
.................... } 
....................  
.................... void erase_program_eeprom(int addrr){ 
....................    for(int i=0; i < BLOCK_SIZE; i++){ 
....................          write_ext_eeprom(addrr + i, -1); 
....................    }   
....................    printf (lcd_escreve,"\f User erased "); 
....................    delay_ms(500); 
.................... } 
....................  
.................... int deleteUser(int8 address){ 
....................     
....................    int data_temp; 
....................    int previous_block = address; 
....................    int next_block = address + BLOCK_SIZE; 
....................  
....................    //Case 1: without next block 
....................    if (read_ext_eeprom(next_block) == -1){ 
....................       erase_program_eeprom(previous_block);       
....................       return 1; 
....................    } 
....................  
....................    //Case 2: Check whether the data in the address is empty 
....................    while(read_ext_eeprom(next_block) != -1){ 
....................       //data_temp[index] = read_ext_eeprom(address); 
....................       for(int i=0; i < BLOCK_SIZE; i++){ 
....................          data_temp = read_ext_eeprom(next_block + i);            
....................          write_ext_eeprom(previous_block + i, data_temp);    //overwrite delete block 
....................       }   
....................  
....................       previous_block = next_block; 
....................       next_block += BLOCK_SIZE; 
....................    } 
....................     
....................    next_block -= BLOCK_SIZE; 
....................     
....................    //Erase last block   
....................    erase_program_eeprom(next_block); 
....................     
....................    return 1; 
....................  
.................... } 
....................  
.................... int lastNewUserPosition(){ 
....................    int address = 0; 
....................    int id_temp; 
....................  
....................    while( read_ext_eeprom(address) != -1){ 
....................       address += BLOCK_SIZE;  
....................    } 
....................    printf (lcd_escreve,"\fAddress: %d", address); 
....................    delay_ms(1000); 
....................     
....................    return address; 
....................  
.................... } 
....................  
.................... int isIdAvailable(int id){ 
....................    unsigned int address = 0; 
....................    int id_temp; 
....................    while( read_ext_eeprom(address) != -1){ 
....................       id_temp = read_ext_eeprom(address); 
....................       if (id_temp == id){ 
....................           printf (lcd_escreve,"\fID:%u, Existe", id_temp); 
....................           delay_ms(1000); 
....................          return 0;//Sucessful 
....................       } 
....................  
....................       address += BLOCK_SIZE;  
....................    } 
....................    printf (lcd_escreve,"\fID:%u, N Existe", id_temp); 
....................    delay_ms(1000); 
....................    return -1; 
.................... } 
....................  
.................... void resetMemory(){ 
....................    int address = 0; 
....................    for(; read_ext_eeprom(address) != -1; 
....................     erase_program_eeprom(address), address += BLOCK_SIZE); 
.................... } 
....................  
.................... // void adminMenu(){ 
....................  
.................... //    option = readKeyboard(); 
....................  
.................... //    switch (option) 
.................... //    { 
.................... //    case 1: 
.................... //       /* code */ 
.................... //       break; 
....................     
.................... //    default: 
.................... //       break; 
.................... //    } 
....................     
....................  
....................     
.................... // } 
....................  
.................... unsigned char readKeyboard(){ 
....................    unsigned char tmp; 
....................    unsigned char tmp_result; 
....................  
....................    tmp = tc_tecla(1500); // ms 
*
030C:  MOVLW  DC
030D:  MOVWF  63
*
0433:  MOVF   78,W
0434:  MOVWF  61
....................    if(tmp != 255){ 
0435:  INCFSZ 61,W
0436:  GOTO   438
0437:  GOTO   4E6
....................       write_ext_eeprom(0, tmp); 
0438:  CLRF   63
0439:  MOVF   61,W
043A:  MOVWF  64
....................       delay_ms(50); 
*
04CD:  MOVLW  32
04CE:  BCF    03.5
04CF:  MOVWF  68
04D0:  CALL   060
....................       tmp_result = read_ext_eeprom(0); 
04D1:  CLRF   63
04D2:  CALL   0D0
04D3:  MOVF   78,W
04D4:  MOVWF  62
....................       delay_ms(50); 
04D5:  MOVLW  32
04D6:  MOVWF  68
04D7:  CALL   060
....................       // tmp_result = tmp; 
....................       printf(lcd_escreve,"\f Button: %c", tmp_result); 
04D8:  MOVLW  77
04D9:  BSF    03.6
04DA:  MOVWF  0D
04DB:  MOVLW  05
04DC:  MOVWF  0F
04DD:  BCF    03.0
04DE:  MOVLW  0A
04DF:  BCF    03.6
04E0:  MOVWF  63
04E1:  CALL   25F
04E2:  MOVF   62,W
04E3:  MOVWF  67
04E4:  CALL   228
....................    }else{  
04E5:  GOTO   4ED
....................       printf(lcd_escreve,"\f   TECLADO  "); 
04E6:  MOVLW  7E
04E7:  BSF    03.6
04E8:  MOVWF  0D
04E9:  MOVLW  05
04EA:  MOVWF  0F
04EB:  BCF    03.6
04EC:  CALL   2B6
....................    } 
....................    return tmp; 
04ED:  MOVF   61,W
04EE:  MOVWF  78
.................... } 
....................  
....................  
.................... int * getAdminID(){ 
*
06EA:  CLRF   4F
06EB:  CLRF   51
....................  
....................    int address = 0; 
....................    int temp_status; 
....................    int index= 0; 
....................    static int admins[BLOCK_SIZE]; 
*
067D:  BCF    03.5
067E:  CLRF   3F
067F:  CLRF   40
0680:  CLRF   41
0681:  CLRF   42
0682:  CLRF   43
0683:  CLRF   44
0684:  CLRF   45
....................    admins[0] = 0; 
*
06EC:  CLRF   3F
06ED:  CLRF   2B
06EE:  BTFSC  0B.7
06EF:  BSF    2B.7
06F0:  BCF    0B.7
....................    while( read_ext_eeprom(address) != -1){ 
06F1:  MOVF   4F,W
06F2:  MOVWF  63
06F3:  CALL   0D0
06F4:  BTFSC  2B.7
06F5:  BSF    0B.7
06F6:  MOVF   78,W
06F7:  SUBLW  FF
06F8:  BTFSC  03.2
06F9:  GOTO   767
....................       temp_status = read_ext_eeprom(address + (BLOCK_SIZE - 1));//status of the user 
06FA:  MOVLW  06
06FB:  ADDWF  4F,W
06FC:  MOVWF  54
06FD:  CLRF   2B
06FE:  BTFSC  0B.7
06FF:  BSF    2B.7
0700:  BCF    0B.7
0701:  MOVF   54,W
0702:  MOVWF  63
0703:  CALL   0D0
0704:  BTFSC  2B.7
0705:  BSF    0B.7
0706:  MOVF   78,W
0707:  MOVWF  50
....................       printf (lcd_escreve,"\ftemp_status: %u", temp_status); 
0708:  MOVLW  85
0709:  BSF    03.6
070A:  MOVWF  0D
070B:  MOVLW  05
070C:  MOVWF  0F
070D:  BCF    03.0
070E:  BCF    03.6
070F:  CLRF   2B
0710:  BTFSC  0B.7
0711:  BSF    2B.7
0712:  BCF    0B.7
0713:  MOVLW  0E
0714:  MOVWF  63
0715:  CALL   25F
0716:  BTFSC  2B.7
0717:  BSF    0B.7
0718:  MOVF   50,W
0719:  MOVWF  54
071A:  MOVLW  1B
071B:  MOVWF  55
071C:  CALL   5FF
....................       delay_ms(1000); 
071D:  MOVLW  04
071E:  MOVWF  54
071F:  CLRF   2B
0720:  BTFSC  0B.7
0721:  BSF    2B.7
0722:  BCF    0B.7
0723:  MOVLW  FA
0724:  MOVWF  68
0725:  CALL   060
0726:  BTFSC  2B.7
0727:  BSF    0B.7
0728:  DECFSZ 54,F
0729:  GOTO   71F
....................       if (temp_status == 3){ 
072A:  MOVF   50,W
072B:  SUBLW  03
072C:  BTFSS  03.2
072D:  GOTO   764
....................          printf (lcd_escreve,"\fAdmin Encontrado"); 
072E:  MOVLW  8E
072F:  BSF    03.6
0730:  MOVWF  0D
0731:  MOVLW  05
0732:  MOVWF  0F
0733:  BCF    03.6
0734:  CLRF   2B
0735:  BTFSC  0B.7
0736:  BSF    2B.7
0737:  BCF    0B.7
0738:  CALL   2B6
0739:  BTFSC  2B.7
073A:  BSF    0B.7
....................          delay_ms(1000); 
073B:  MOVLW  04
073C:  MOVWF  54
073D:  CLRF   2B
073E:  BTFSC  0B.7
073F:  BSF    2B.7
0740:  BCF    0B.7
0741:  MOVLW  FA
0742:  MOVWF  68
0743:  CALL   060
0744:  BTFSC  2B.7
0745:  BSF    0B.7
0746:  DECFSZ 54,F
0747:  GOTO   73D
....................          for(int i=0; i < 2; i++){ 
0748:  CLRF   52
0749:  MOVF   52,W
074A:  SUBLW  01
074B:  BTFSS  03.0
074C:  GOTO   764
....................             int id = read_ext_eeprom(address+i);    
074D:  MOVF   52,W
074E:  ADDWF  4F,W
074F:  MOVWF  54
0750:  CLRF   2B
0751:  BTFSC  0B.7
0752:  BSF    2B.7
0753:  BCF    0B.7
0754:  MOVF   54,W
0755:  MOVWF  63
0756:  CALL   0D0
0757:  BTFSC  2B.7
0758:  BSF    0B.7
0759:  MOVF   78,W
075A:  MOVWF  53
....................             admins[index] = id; 
075B:  MOVLW  3F
075C:  ADDWF  51,W
075D:  MOVWF  04
075E:  BCF    03.7
075F:  MOVF   53,W
0760:  MOVWF  00
....................             index++; 
0761:  INCF   51,F
0762:  INCF   52,F
0763:  GOTO   749
....................          } 
....................  
....................       } 
....................  
....................       address += BLOCK_SIZE;  
0764:  MOVLW  07
0765:  ADDWF  4F,F
0766:  GOTO   6ED
....................    } 
....................  
....................    return admins; 
0767:  MOVLW  3F
0768:  MOVWF  78
0769:  MOVLW  00
076A:  MOVWF  79
....................  
.................... } 

Configuration Fuses:
   Word  1: 3F32   HS NOWDT PUT NOBROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT

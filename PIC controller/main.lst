CCS PCM C Compiler, Version 5.025, 7201               20-Nov-21 17:49

               Filename:   E:\University\Microcontrollers\PCW Projects\eletronic-lock-system\PIC controller\main.lst

               ROM used:   3645 words (44%)
                           Largest free fragment is 2048
               RAM used:   59 (16%) at main() level
                           160 (43%) worst case
               Stack used: 6 locations (5 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  0D
0001:  MOVWF  0A
0002:  GOTO   5E4
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  BTFSS  0B.5
0028:  GOTO   02B
0029:  BTFSC  0B.2
002A:  GOTO   052
002B:  MOVLW  8C
002C:  MOVWF  04
002D:  BTFSS  00.0
002E:  GOTO   031
002F:  BTFSC  0C.0
0030:  GOTO   055
0031:  MOVF   22,W
0032:  MOVWF  04
0033:  MOVF   23,W
0034:  MOVWF  77
0035:  MOVF   24,W
0036:  MOVWF  78
0037:  MOVF   25,W
0038:  MOVWF  79
0039:  MOVF   26,W
003A:  MOVWF  7A
003B:  MOVF   27,W
003C:  BSF    03.6
003D:  MOVWF  0D
003E:  BCF    03.6
003F:  MOVF   28,W
0040:  BSF    03.6
0041:  MOVWF  0F
0042:  BCF    03.6
0043:  MOVF   29,W
0044:  BSF    03.6
0045:  MOVWF  0C
0046:  BCF    03.6
0047:  MOVF   2A,W
0048:  BSF    03.6
0049:  MOVWF  0E
004A:  BCF    03.6
004B:  MOVF   20,W
004C:  MOVWF  0A
004D:  SWAPF  21,W
004E:  MOVWF  03
004F:  SWAPF  7F,F
0050:  SWAPF  7F,W
0051:  RETFIE
0052:  BCF    0A.3
0053:  BCF    0A.4
0054:  GOTO   13A
0055:  BCF    0A.3
0056:  BCF    0A.4
0057:  GOTO   136
....................  
.................... #include <16F877A.h> 
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
0058:  BCF    0A.0
0059:  BCF    0A.1
005A:  BCF    0A.2
005B:  ADDWF  02,F
005C:  RETLW  28
005D:  RETLW  0F
005E:  RETLW  01
005F:  RETLW  06
0060:  DATA 0D,05
0061:  DATA 69,32
0062:  DATA 5B,18
0063:  DATA 5D,1D
0064:  DATA A5,3A
0065:  DATA 00,00
0066:  DATA 8C,2A
0067:  DATA F3,3A
0068:  DATA 61,39
0069:  DATA E9,37
006A:  DATA A0,21
006B:  DATA 61,32
006C:  DATA E1,39
006D:  DATA 74,39
006E:  DATA 61,32
006F:  DATA 6F,00
0070:  DATA 8C,24
0071:  DATA 44,10
0072:  DATA 69,37
0073:  DATA E3,37
0074:  DATA 6D,38
0075:  DATA 61,3A
0076:  DATA 69,3B
0077:  DATA 65,36
0078:  DATA 00,01
0079:  DATA 0D,05
007A:  DATA D4,32
007B:  DATA 6E,3A
007C:  DATA 65,10
007D:  DATA EE,37
007E:  DATA F6,30
007F:  DATA ED,32
0080:  DATA 6E,3A
0081:  DATA 65,00
0082:  DATA 0C,10
0083:  DATA C2,3A
0084:  DATA 74,3A
0085:  DATA 6F,37
0086:  DATA 3A,10
0087:  DATA 25,32
0088:  DATA 00,10
0089:  DATA 0D,05
008A:  DATA D0,3B
008B:  DATA BA,12
008C:  DATA E4,12
008D:  DATA E4,12
008E:  DATA E4,12
008F:  DATA 64,10
0090:  DATA 53,3A
0091:  DATA BA,12
0092:  DATA 64,10
0093:  DATA 25,32
0094:  DATA 00,00
0095:  DATA 8C,24
0096:  DATA 44,10
0097:  DATA 45,37
0098:  DATA E3,37
0099:  DATA 6E,3A
009A:  DATA F2,30
009B:  DATA E4,37
009C:  DATA BA,12
009D:  DATA F5,12
009E:  DATA 75,00
009F:  DATA 0C,10
00A0:  DATA 49,22
00A1:  DATA 20,27
00A2:  DATA A0,22
00A3:  DATA EE,31
00A4:  DATA 6F,37
00A5:  DATA 74,39
00A6:  DATA 61,32
00A7:  DATA 6F,00
00A8:  DATA 0C,10
00A9:  DATA D5,39
00AA:  DATA 65,39
00AB:  DATA A0,32
00AC:  DATA F2,30
00AD:  DATA F3,32
00AE:  DATA 64,10
00AF:  DATA 00,00
00B0:  DATA 8C,20
00B1:  DATA 64,32
00B2:  DATA F2,32
00B3:  DATA F3,39
00B4:  DATA 3A,10
00B5:  DATA 25,32
00B6:  DATA 00,00
00B7:  DATA 8C,24
00B8:  DATA 44,1D
00B9:  DATA A5,3A
00BA:  DATA 2C,10
00BB:  DATA 45,3C
00BC:  DATA E9,39
00BD:  DATA F4,32
00BE:  DATA 00,01
00BF:  DATA 8C,24
00C0:  DATA 44,1D
00C1:  DATA A5,3A
00C2:  DATA 2C,10
00C3:  DATA 4E,10
00C4:  DATA 45,3C
00C5:  DATA E9,39
00C6:  DATA F4,32
00C7:  DATA 00,00
00C8:  DATA 0C,10
00C9:  DATA 4F,38
00CA:  DATA F4,34
00CB:  DATA 6F,37
00CC:  DATA 3A,10
00CD:  DATA A5,31
00CE:  DATA 00,01
00CF:  DATA 0C,22
00D0:  DATA E9,33
00D1:  DATA 69,3A
00D2:  DATA 65,10
00D3:  DATA 6F,10
00D4:  DATA 49,22
00D5:  DATA 00,01
00D6:  DATA 0C,2A
00D7:  DATA 79,38
00D8:  DATA 65,32
00D9:  DATA A0,24
00DA:  DATA 44,1D
00DB:  DATA A5,31
00DC:  DATA 00,01
00DD:  DATA 8C,34
00DE:  DATA 64,1D
00DF:  DATA A0,12
00E0:  DATA F5,12
00E1:  DATA 75,00
00E2:  DATA 0C,22
00E3:  DATA E9,33
00E4:  DATA 69,3A
00E5:  DATA 65,10
00E6:  DATA 61,10
00E7:  DATA F3,32
00E8:  DATA 6E,34
00E9:  DATA 61,00
00EA:  DATA 0C,2A
00EB:  DATA 79,38
00EC:  DATA 65,32
00ED:  DATA 20,28
00EE:  DATA E1,39
00EF:  DATA 73,1D
00F0:  DATA A5,31
00F1:  DATA 00,01
00F2:  DATA 0C,28
00F3:  DATA C1,29
00F4:  DATA 53,14
00F5:  DATA B4,14
00F6:  DATA 3A,10
00F7:  DATA A5,3A
00F8:  DATA A5,3A
00F9:  DATA A5,3A
00FA:  DATA A5,3A
00FB:  DATA 00,01
00FC:  DATA 8C,29
00FD:  DATA F4,30
00FE:  DATA F4,3A
00FF:  DATA 73,14
0100:  DATA 30,16
0101:  DATA 31,16
0102:  DATA B3,14
0103:  DATA 3A,00
0104:  DATA 0C,2A
0105:  DATA 79,38
0106:  DATA 65,32
0107:  DATA A0,29
0108:  DATA F4,30
0109:  DATA F4,3A
010A:  DATA 73,1D
010B:  DATA A5,31
010C:  DATA 00,01
010D:  DATA 8C,29
010E:  DATA D4,20
010F:  DATA D4,2A
0110:  DATA 53,1D
0111:  DATA A0,12
0112:  DATA 75,00
0113:  DATA 0C,10
0114:  DATA 20,10
0115:  DATA D4,22
0116:  DATA 43,26
0117:  DATA 41,22
0118:  DATA 4F,10
0119:  DATA 20,00
011A:  DATA 8C,20
011B:  DATA E4,36
011C:  DATA 69,37
011D:  DATA A0,22
011E:  DATA EE,31
011F:  DATA 6F,37
0120:  DATA 74,39
0121:  DATA 61,32
0122:  DATA 6F,00
0123:  DATA 0C,10
0124:  DATA 61,32
0125:  DATA ED,34
0126:  DATA EE,39
0127:  DATA 5B,18
0128:  DATA 5D,1D
0129:  DATA A0,12
012A:  DATA 64,00
012B:  DATA 8C,34
012C:  DATA 64,3F
012D:  DATA BA,12
012E:  DATA F5,12
012F:  DATA 75,00
0130:  DATA 0C,28
0131:  DATA 61,39
0132:  DATA F3,34
0133:  DATA EE,33
0134:  DATA BA,12
0135:  DATA 73,00
*
013E:  DATA 0C,10
013F:  DATA A0,34
0140:  DATA EE,34
0141:  DATA E3,34
0142:  DATA 61,37
0143:  DATA E4,37
0144:  DATA 2E,17
0145:  DATA 2E,10
0146:  DATA 00,00
*
024E:  MOVF   0B,W
024F:  BSF    03.5
0250:  MOVWF  2C
0251:  BCF    03.5
0252:  BCF    0B.7
0253:  BSF    03.5
0254:  BSF    03.6
0255:  BSF    0C.7
0256:  BSF    0C.0
0257:  NOP
0258:  NOP
0259:  BCF    03.6
025A:  BTFSS  2C.7
025B:  GOTO   25F
025C:  BCF    03.5
025D:  BSF    0B.7
025E:  BSF    03.5
025F:  BCF    03.5
0260:  BSF    03.6
0261:  MOVF   0C,W
0262:  ANDLW  7F
0263:  BTFSC  03.2
0264:  GOTO   2C0
0265:  BSF    03.5
0266:  BCF    03.6
0267:  MOVWF  2C
0268:  BCF    03.5
0269:  BSF    03.6
026A:  MOVF   0D,W
026B:  BSF    03.5
026C:  BCF    03.6
026D:  MOVWF  2D
026E:  BCF    03.5
026F:  BSF    03.6
0270:  MOVF   0F,W
0271:  BSF    03.5
0272:  BCF    03.6
0273:  MOVWF  2E
0274:  MOVF   2C,W
0275:  MOVWF  30
0276:  BCF    03.5
0277:  CALL   20B
0278:  BSF    03.5
0279:  MOVF   2D,W
027A:  BCF    03.5
027B:  BSF    03.6
027C:  MOVWF  0D
027D:  BSF    03.5
027E:  BCF    03.6
027F:  MOVF   2E,W
0280:  BCF    03.5
0281:  BSF    03.6
0282:  MOVWF  0F
0283:  BCF    03.6
0284:  MOVF   0B,W
0285:  BSF    03.5
0286:  MOVWF  2F
0287:  BCF    03.5
0288:  BCF    0B.7
0289:  BSF    03.5
028A:  BSF    03.6
028B:  BSF    0C.7
028C:  BSF    0C.0
028D:  NOP
028E:  NOP
028F:  BCF    03.6
0290:  BTFSS  2F.7
0291:  GOTO   295
0292:  BCF    03.5
0293:  BSF    0B.7
0294:  BSF    03.5
0295:  BCF    03.5
0296:  BSF    03.6
0297:  RLF    0C,W
0298:  RLF    0E,W
0299:  ANDLW  7F
029A:  BTFSC  03.2
029B:  GOTO   2C0
029C:  BSF    03.5
029D:  BCF    03.6
029E:  MOVWF  2C
029F:  BCF    03.5
02A0:  BSF    03.6
02A1:  MOVF   0D,W
02A2:  BSF    03.5
02A3:  BCF    03.6
02A4:  MOVWF  2D
02A5:  BCF    03.5
02A6:  BSF    03.6
02A7:  MOVF   0F,W
02A8:  BSF    03.5
02A9:  BCF    03.6
02AA:  MOVWF  2E
02AB:  MOVF   2C,W
02AC:  MOVWF  30
02AD:  BCF    03.5
02AE:  CALL   20B
02AF:  BSF    03.5
02B0:  MOVF   2D,W
02B1:  BCF    03.5
02B2:  BSF    03.6
02B3:  MOVWF  0D
02B4:  BSF    03.5
02B5:  BCF    03.6
02B6:  MOVF   2E,W
02B7:  BCF    03.5
02B8:  BSF    03.6
02B9:  MOVWF  0F
02BA:  INCF   0D,F
02BB:  BTFSC  03.2
02BC:  INCF   0F,F
02BD:  BCF    03.6
02BE:  GOTO   24E
02BF:  BSF    03.6
02C0:  BCF    03.6
02C1:  RETURN
*
05FD:  MOVF   0B,W
05FE:  BSF    03.5
05FF:  MOVWF  2D
0600:  BCF    03.5
0601:  BCF    0B.7
0602:  BSF    03.5
0603:  BSF    03.6
0604:  BSF    0C.7
0605:  BSF    0C.0
0606:  NOP
0607:  NOP
0608:  BCF    03.6
0609:  BTFSS  2D.7
060A:  GOTO   60E
060B:  BCF    03.5
060C:  BSF    0B.7
060D:  BSF    03.5
060E:  BTFSC  03.0
060F:  GOTO   647
0610:  BCF    03.5
0611:  BSF    03.6
0612:  MOVF   0C,W
0613:  ANDLW  7F
0614:  BSF    03.5
0615:  BCF    03.6
0616:  MOVWF  2D
0617:  BCF    03.5
0618:  BSF    03.6
0619:  MOVF   0D,W
061A:  BSF    03.5
061B:  BCF    03.6
061C:  MOVWF  2E
061D:  BCF    03.5
061E:  BSF    03.6
061F:  MOVF   0F,W
0620:  BSF    03.5
0621:  BCF    03.6
0622:  MOVWF  2F
0623:  MOVF   2D,W
0624:  MOVWF  30
0625:  BCF    03.5
0626:  CALL   20B
0627:  BSF    03.5
0628:  MOVF   2E,W
0629:  BCF    03.5
062A:  BSF    03.6
062B:  MOVWF  0D
062C:  BSF    03.5
062D:  BCF    03.6
062E:  MOVF   2F,W
062F:  BCF    03.5
0630:  BSF    03.6
0631:  MOVWF  0F
0632:  BCF    03.6
0633:  MOVF   0B,W
0634:  BSF    03.5
0635:  MOVWF  30
0636:  BCF    03.5
0637:  BCF    0B.7
0638:  BSF    03.5
0639:  BSF    03.6
063A:  BSF    0C.7
063B:  BSF    0C.0
063C:  NOP
063D:  NOP
063E:  BCF    03.6
063F:  BTFSS  30.7
0640:  GOTO   644
0641:  BCF    03.5
0642:  BSF    0B.7
0643:  BSF    03.5
0644:  DECFSZ 2C,F
0645:  GOTO   647
0646:  GOTO   675
0647:  BCF    03.5
0648:  BSF    03.6
0649:  RLF    0C,W
064A:  RLF    0E,W
064B:  ANDLW  7F
064C:  BSF    03.5
064D:  BCF    03.6
064E:  MOVWF  2D
064F:  BCF    03.5
0650:  BSF    03.6
0651:  MOVF   0D,W
0652:  BSF    03.5
0653:  BCF    03.6
0654:  MOVWF  2E
0655:  BCF    03.5
0656:  BSF    03.6
0657:  MOVF   0F,W
0658:  BSF    03.5
0659:  BCF    03.6
065A:  MOVWF  2F
065B:  MOVF   2D,W
065C:  MOVWF  30
065D:  BCF    03.5
065E:  CALL   20B
065F:  BSF    03.5
0660:  MOVF   2E,W
0661:  BCF    03.5
0662:  BSF    03.6
0663:  MOVWF  0D
0664:  BSF    03.5
0665:  BCF    03.6
0666:  MOVF   2F,W
0667:  BCF    03.5
0668:  BSF    03.6
0669:  MOVWF  0F
066A:  INCF   0D,F
066B:  BTFSC  03.2
066C:  INCF   0F,F
066D:  BCF    03.0
066E:  BSF    03.5
066F:  BCF    03.6
0670:  DECFSZ 2C,F
0671:  GOTO   673
0672:  GOTO   675
0673:  BCF    03.5
0674:  GOTO   5FD
0675:  BCF    03.5
0676:  RETURN
*
06B7:  MOVF   00,F
06B8:  BTFSC  03.2
06B9:  GOTO   6D3
06BA:  BSF    03.5
06BB:  CLRF   22
06BC:  MOVF   04,W
06BD:  MOVWF  21
06BE:  BCF    22.0
06BF:  BTFSC  03.7
06C0:  BSF    22.0
06C1:  MOVF   00,W
06C2:  MOVWF  30
06C3:  BCF    03.5
06C4:  CALL   20B
06C5:  BSF    03.5
06C6:  MOVF   21,W
06C7:  MOVWF  04
06C8:  BCF    03.7
06C9:  BTFSC  22.0
06CA:  BSF    03.7
06CB:  INCF   04,F
06CC:  BTFSS  03.2
06CD:  GOTO   6D1
06CE:  BCF    03.5
06CF:  INCF   05,F
06D0:  BSF    03.5
06D1:  BCF    03.5
06D2:  GOTO   6B7
*
0703:  CLRF   29
0704:  MOVF   04,W
0705:  MOVWF  28
0706:  BCF    29.0
0707:  BTFSC  03.7
0708:  BSF    29.0
0709:  SWAPF  22,W
070A:  IORLW  F0
070B:  MOVWF  24
070C:  ADDWF  24,F
070D:  ADDLW  E2
070E:  MOVWF  25
070F:  ADDLW  32
0710:  MOVWF  27
0711:  MOVF   22,W
0712:  ANDLW  0F
0713:  ADDWF  25,F
0714:  ADDWF  25,F
0715:  ADDWF  27,F
0716:  ADDLW  E9
0717:  MOVWF  26
0718:  ADDWF  26,F
0719:  ADDWF  26,F
071A:  SWAPF  21,W
071B:  ANDLW  0F
071C:  ADDWF  26,F
071D:  ADDWF  27,F
071E:  RLF    26,F
071F:  RLF    27,F
0720:  COMF   27,F
0721:  RLF    27,F
0722:  MOVF   21,W
0723:  ANDLW  0F
0724:  ADDWF  27,F
0725:  RLF    24,F
0726:  MOVLW  07
0727:  MOVWF  23
0728:  MOVLW  0A
0729:  ADDWF  27,F
072A:  DECF   26,F
072B:  BTFSS  03.0
072C:  GOTO   729
072D:  ADDWF  26,F
072E:  DECF   25,F
072F:  BTFSS  03.0
0730:  GOTO   72D
0731:  ADDWF  25,F
0732:  DECF   24,F
0733:  BTFSS  03.0
0734:  GOTO   731
0735:  ADDWF  24,F
0736:  DECF   23,F
0737:  BTFSS  03.0
0738:  GOTO   735
0739:  MOVLW  A3
073A:  MOVWF  04
073B:  BCF    03.7
073C:  MOVLW  07
073D:  ANDWF  28,W
073E:  BCF    28.6
073F:  ADDWF  04,F
0740:  MOVLW  A7
0741:  SUBWF  04,W
0742:  BTFSC  03.2
0743:  BSF    28.6
0744:  MOVF   00,W
0745:  MOVWF  77
0746:  BTFSS  03.2
0747:  GOTO   750
0748:  BTFSC  28.6
0749:  GOTO   750
074A:  BTFSC  28.4
074B:  GOTO   764
074C:  BTFSC  28.3
074D:  GOTO   750
074E:  MOVLW  20
074F:  GOTO   753
0750:  BSF    28.3
0751:  BCF    28.4
0752:  MOVLW  30
0753:  ADDWF  77,F
0754:  CLRF   22
0755:  MOVF   04,W
0756:  MOVWF  21
0757:  BCF    22.0
0758:  BTFSC  03.7
0759:  BSF    22.0
075A:  MOVF   77,W
075B:  MOVWF  30
075C:  BCF    03.5
075D:  CALL   20B
075E:  BSF    03.5
075F:  MOVF   21,W
0760:  MOVWF  04
0761:  BCF    03.7
0762:  BTFSC  22.0
0763:  BSF    03.7
0764:  INCF   04,F
0765:  BTFSS  28.6
0766:  GOTO   740
*
0792:  BSF    03.5
0793:  MOVF   30,W
0794:  CLRF   78
0795:  SUBWF  2F,W
0796:  BTFSC  03.0
0797:  GOTO   79B
0798:  MOVF   2F,W
0799:  MOVWF  77
079A:  GOTO   7A7
079B:  CLRF   77
079C:  MOVLW  08
079D:  MOVWF  31
079E:  RLF    2F,F
079F:  RLF    77,F
07A0:  MOVF   30,W
07A1:  SUBWF  77,W
07A2:  BTFSC  03.0
07A3:  MOVWF  77
07A4:  RLF    78,F
07A5:  DECFSZ 31,F
07A6:  GOTO   79E
07A7:  BCF    03.5
07A8:  RETURN
07A9:  MOVF   78,W
07AA:  BSF    03.5
07AB:  MOVF   2C,W
07AC:  MOVWF  2F
07AD:  MOVLW  64
07AE:  MOVWF  30
07AF:  BCF    03.5
07B0:  CALL   792
07B1:  MOVF   77,W
07B2:  BSF    03.5
07B3:  MOVWF  2C
07B4:  MOVF   78,W
07B5:  MOVLW  30
07B6:  BTFSS  03.2
07B7:  GOTO   7BF
07B8:  BTFSS  2D.1
07B9:  GOTO   7C8
07BA:  BTFSC  2D.3
07BB:  GOTO   7C8
07BC:  BTFSC  2D.4
07BD:  MOVLW  20
07BE:  GOTO   7C2
07BF:  BCF    2D.3
07C0:  BCF    2D.4
07C1:  BSF    2D.0
07C2:  ADDWF  78,F
07C3:  MOVF   78,W
07C4:  MOVWF  30
07C5:  BCF    03.5
07C6:  CALL   20B
07C7:  BSF    03.5
07C8:  MOVF   2C,W
07C9:  MOVWF  2F
07CA:  MOVLW  0A
07CB:  MOVWF  30
07CC:  BCF    03.5
07CD:  CALL   792
07CE:  MOVF   77,W
07CF:  BSF    03.5
07D0:  MOVWF  2C
07D1:  MOVF   78,W
07D2:  MOVLW  30
07D3:  BTFSS  03.2
07D4:  GOTO   7DB
07D5:  BTFSC  2D.3
07D6:  GOTO   7E1
07D7:  BTFSS  2D.0
07D8:  GOTO   7E1
07D9:  BTFSC  2D.4
07DA:  MOVLW  20
07DB:  ADDWF  78,F
07DC:  MOVF   78,W
07DD:  MOVWF  30
07DE:  BCF    03.5
07DF:  CALL   20B
07E0:  BSF    03.5
07E1:  MOVLW  30
07E2:  ADDWF  2C,F
07E3:  MOVF   2C,W
07E4:  MOVWF  30
07E5:  BCF    03.5
07E6:  CALL   20B
07E7:  RETURN
*
0977:  MOVF   56,W
0978:  XORWF  58,W
0979:  ANDLW  80
097A:  MOVWF  5A
097B:  BTFSS  56.7
097C:  GOTO   182
097D:  COMF   55,F
097E:  COMF   56,F
097F:  INCF   55,F
0980:  BTFSC  03.2
0981:  INCF   56,F
0982:  BTFSS  58.7
0983:  GOTO   189
0984:  COMF   57,F
0985:  COMF   58,F
0986:  INCF   57,F
0987:  BTFSC  03.2
0988:  INCF   58,F
0989:  MOVLW  10
098A:  MOVWF  59
098B:  CLRF   77
098C:  CLRF   7A
098D:  RRF    56,F
098E:  RRF    55,F
098F:  BTFSS  03.0
0990:  GOTO   197
0991:  MOVF   57,W
0992:  ADDWF  77,F
0993:  BTFSC  03.0
0994:  INCF   7A,F
0995:  MOVF   58,W
0996:  ADDWF  7A,F
0997:  RRF    7A,F
0998:  RRF    77,F
0999:  RRF    79,F
099A:  RRF    78,F
099B:  DECFSZ 59,F
099C:  GOTO   18D
099D:  BTFSS  5A.7
099E:  GOTO   1A4
099F:  COMF   78,F
09A0:  COMF   79,F
09A1:  INCF   78,F
09A2:  BTFSC  03.2
09A3:  INCF   79,F
*
0CCE:  MOVLW  20
0CCF:  BTFSS  2A.4
0CD0:  MOVLW  30
0CD1:  MOVWF  2B
0CD2:  MOVF   29,W
0CD3:  MOVWF  77
0CD4:  BTFSS  29.7
0CD5:  GOTO   4DE
0CD6:  COMF   77,F
0CD7:  INCF   77,F
0CD8:  MOVF   77,W
0CD9:  MOVWF  29
0CDA:  MOVLW  2D
0CDB:  MOVWF  2B
0CDC:  BSF    2A.7
0CDD:  BSF    2A.0
0CDE:  MOVF   29,W
0CDF:  MOVWF  2F
0CE0:  MOVLW  64
0CE1:  MOVWF  30
0CE2:  BCF    0A.3
0CE3:  BCF    03.5
0CE4:  CALL   792
0CE5:  BSF    0A.3
0CE6:  MOVF   77,W
0CE7:  BSF    03.5
0CE8:  MOVWF  29
0CE9:  MOVLW  30
0CEA:  ADDWF  78,W
0CEB:  MOVWF  2C
0CEC:  MOVF   29,W
0CED:  MOVWF  2F
0CEE:  MOVLW  0A
0CEF:  MOVWF  30
0CF0:  BCF    0A.3
0CF1:  BCF    03.5
0CF2:  CALL   792
0CF3:  BSF    0A.3
0CF4:  MOVLW  30
0CF5:  ADDWF  77,W
0CF6:  BSF    03.5
0CF7:  MOVWF  2E
0CF8:  MOVLW  30
0CF9:  ADDWF  78,W
0CFA:  MOVWF  2D
0CFB:  MOVF   2B,W
0CFC:  MOVWF  77
0CFD:  MOVLW  30
0CFE:  SUBWF  2C,W
0CFF:  BTFSC  03.2
0D00:  GOTO   505
0D01:  BSF    2A.1
0D02:  BTFSC  2A.7
0D03:  BSF    2A.2
0D04:  GOTO   519
0D05:  MOVF   2B,W
0D06:  MOVWF  2C
0D07:  MOVLW  20
0D08:  MOVWF  2B
0D09:  MOVLW  30
0D0A:  SUBWF  2D,W
0D0B:  BTFSC  03.2
0D0C:  GOTO   511
0D0D:  BSF    2A.0
0D0E:  BTFSC  2A.7
0D0F:  BSF    2A.1
0D10:  GOTO   519
0D11:  BTFSS  03.2
0D12:  BSF    2A.0
0D13:  BTFSS  03.2
0D14:  GOTO   519
0D15:  MOVF   2C,W
0D16:  MOVWF  2D
0D17:  MOVLW  20
0D18:  MOVWF  2C
0D19:  BTFSC  2A.2
0D1A:  GOTO   520
0D1B:  BTFSC  2A.1
0D1C:  GOTO   527
0D1D:  BTFSC  2A.0
0D1E:  GOTO   52E
0D1F:  GOTO   535
0D20:  MOVF   2B,W
0D21:  MOVWF  30
0D22:  BCF    0A.3
0D23:  BCF    03.5
0D24:  CALL   20B
0D25:  BSF    0A.3
0D26:  BSF    03.5
0D27:  MOVF   2C,W
0D28:  MOVWF  30
0D29:  BCF    0A.3
0D2A:  BCF    03.5
0D2B:  CALL   20B
0D2C:  BSF    0A.3
0D2D:  BSF    03.5
0D2E:  MOVF   2D,W
0D2F:  MOVWF  30
0D30:  BCF    0A.3
0D31:  BCF    03.5
0D32:  CALL   20B
0D33:  BSF    0A.3
0D34:  BSF    03.5
0D35:  MOVF   2E,W
0D36:  MOVWF  30
0D37:  BCF    0A.3
0D38:  BCF    03.5
0D39:  CALL   20B
0D3A:  BSF    0A.3
....................  
.................... #list 
....................  
.................... #device ADC=8 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES HS  
....................  
.................... #use delay(crystal=20000000) 
*
0154:  MOVLW  B1
0155:  MOVWF  04
0156:  BCF    03.7
0157:  MOVF   00,W
0158:  BTFSC  03.2
0159:  GOTO   167
015A:  MOVLW  06
015B:  MOVWF  78
015C:  CLRF   77
015D:  DECFSZ 77,F
015E:  GOTO   15D
015F:  DECFSZ 78,F
0160:  GOTO   15C
0161:  MOVLW  7B
0162:  MOVWF  77
0163:  DECFSZ 77,F
0164:  GOTO   163
0165:  DECFSZ 00,F
0166:  GOTO   15A
0167:  RETURN
.................... //#use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=PORT1) 
....................  
....................  
.................... // -------Variables' Declaration 
.................... #define RX_BUFFER_SIZE 10 
.................... #define BLOCK_SIZE sizeof(User)  
.................... signed int8 address_data_delete; 
.................... int8 rx_wr_index = 0; 
.................... int8 lock_pos = 0, rxd, read, valid_data_count; 
.................... int data_avail = FALSE, got_id = FALSE; 
.................... unsigned int8 rx_buffer[RX_BUFFER_SIZE]; 
.................... #include "functions.c" 
.................... #include "functions.h" 
....................  
.................... //Define the default pins before calling the LCD driver 
.................... #ifndef lcd_enable  
....................    #define lcd_enable     pin_e1 
....................    #define lcd_rs         pin_e2 
....................    //#define lcd_rw       pin_e2   
....................    #define lcd_d4         pin_d4 
....................    #define lcd_d5         pin_d5 
....................    #define lcd_d6         pin_d6 
....................    #define lcd_d7         pin_d7 
.................... #endif 
....................  
.................... #include "mod_lcd.c" 
.................... /************************************************************************/ 
.................... /*  MOD_LCD.C - Biblioteca de manipulaï¿½ï¿½o de mï¿½dulo LCD                 */ 
.................... /*                                                                      */ 
.................... /*  Autor: Fï¿½bio Pereira                                                */ 
.................... /*                                                                      */ 
.................... /************************************************************************/ 
....................  
.................... // As definiï¿½ï¿½es a seguir sï¿½o utilizadas para acesso aos pinos do display 
.................... // caso o pino RW nï¿½o seja utilizado, comente a definiï¿½ï¿½o lcd_rw 
.................... #ifndef lcd_enable 
.................... 	#define lcd_enable 		pin_e1		// pino enable do LCD 
.................... 	#define lcd_rs			pin_e0		// pino rs do LCD 
.................... 	//#define lcd_rw		pin_e2		// pino rw do LCD 
.................... 	#define lcd_d4			pin_d4		// pino de dados d4 do LCD 
.................... 	#define lcd_d5			pin_d5		// pino de dados d5 do LCD 
.................... 	#define lcd_d6			pin_d6		// pino de dados d6 do LCD 
.................... 	#define lcd_d7			pin_d7		// pino de dados d7 do LCD 
.................... #endif 
....................  
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 linhas 
.................... #define lcd_seg_lin 0x40    // Endereï¿½o da segunda linha na RAM do LCD 
....................  
.................... // a constante abaixo define a seqï¿½ï¿½ncia de inicializaï¿½ï¿½o do mï¿½dulo LCD 
.................... byte CONST INI_LCD[4] = {0x20 | (lcd_type << 2), 0xf, 1, 6}; 
....................  
.................... byte lcd_le_byte() 
.................... // lï¿½ um byte do LCD (somente com pino RW) 
.................... { 
.................... 	byte dado; 
.................... 	// configura os pinos de dados como entradas 
.................... 	input(lcd_d4); 
.................... 	input(lcd_d5); 
.................... 	input(lcd_d6); 
.................... 	input(lcd_d7); 
.................... 	// se o pino rw for utilizado, coloca em 1 
.................... 	#ifdef lcd_rw 
.................... 		output_high(lcd_rw); 
.................... 	#endif 
....................    output_high(lcd_enable); // habilita display 
.................... 	dado = 0;	// zera a variï¿½vel de leitura 
.................... 	// lï¿½ os quatro bits mais significativos 
.................... 	if (input(lcd_d7)) bit_set(dado,7); 
.................... 	if (input(lcd_d6)) bit_set(dado,6); 
.................... 	if (input(lcd_d5)) bit_set(dado,5); 
.................... 	if (input(lcd_d4)) bit_set(dado,4); 
.................... 	// dï¿½ um pulso na linha enable 
.................... 	output_low(lcd_enable); 
.................... 	output_high(lcd_enable); 
.................... 	// lï¿½ os quatro bits menos significativos 
.................... 	if (input(lcd_d7)) bit_set(dado,3); 
.................... 	if (input(lcd_d6)) bit_set(dado,2); 
.................... 	if (input(lcd_d5)) bit_set(dado,1); 
.................... 	if (input(lcd_d4)) bit_set(dado,0); 
.................... 	output_low(lcd_enable);	// desabilita o display 
.................... 	return dado;	// retorna o byte lido 
.................... } 
....................  
.................... void lcd_envia_nibble( byte dado ) 
.................... // envia um dado de quatro bits para o display 
.................... { 
.................... 	// coloca os quatro bits nas saidas 
.................... 	output_bit(lcd_d4,bit_test(dado,0)); 
0168:  BSF    03.5
0169:  BTFSC  38.0
016A:  GOTO   16F
016B:  BCF    03.5
016C:  BCF    08.4
016D:  GOTO   171
016E:  BSF    03.5
016F:  BCF    03.5
0170:  BSF    08.4
0171:  BSF    03.5
0172:  BCF    08.4
.................... 	output_bit(lcd_d5,bit_test(dado,1)); 
0173:  BTFSC  38.1
0174:  GOTO   179
0175:  BCF    03.5
0176:  BCF    08.5
0177:  GOTO   17B
0178:  BSF    03.5
0179:  BCF    03.5
017A:  BSF    08.5
017B:  BSF    03.5
017C:  BCF    08.5
.................... 	output_bit(lcd_d6,bit_test(dado,2)); 
017D:  BTFSC  38.2
017E:  GOTO   183
017F:  BCF    03.5
0180:  BCF    08.6
0181:  GOTO   185
0182:  BSF    03.5
0183:  BCF    03.5
0184:  BSF    08.6
0185:  BSF    03.5
0186:  BCF    08.6
.................... 	output_bit(lcd_d7,bit_test(dado,3)); 
0187:  BTFSC  38.3
0188:  GOTO   18D
0189:  BCF    03.5
018A:  BCF    08.7
018B:  GOTO   18F
018C:  BSF    03.5
018D:  BCF    03.5
018E:  BSF    08.7
018F:  BSF    03.5
0190:  BCF    08.7
.................... 	// dï¿½ um pulso na linha enable 
.................... 	output_high(lcd_enable); 
0191:  BCF    09.1
0192:  BCF    03.5
0193:  BSF    09.1
.................... 	output_low(lcd_enable); 
0194:  BSF    03.5
0195:  BCF    09.1
0196:  BCF    03.5
0197:  BCF    09.1
0198:  RETURN
.................... } 
....................  
....................  
.................... void lcd_envia_byte( boolean endereco, byte dado ) 
.................... { 
.................... 	// coloca a linha rs em 0 
.................... 	output_low(lcd_rs); 
0199:  BSF    03.5
019A:  BCF    09.2
019B:  BCF    03.5
019C:  BCF    09.2
.................... 	// aguarda o display ficar desocupado 
.................... 	//while ( bit_test(lcd_le_byte(),7) ) ; 
.................... 	// configura a linha rs dependendo do modo selecionado 
.................... 	output_bit(lcd_rs,endereco); 
019D:  BSF    03.5
019E:  MOVF   35,F
019F:  BTFSS  03.2
01A0:  GOTO   1A5
01A1:  BCF    03.5
01A2:  BCF    09.2
01A3:  GOTO   1A7
01A4:  BSF    03.5
01A5:  BCF    03.5
01A6:  BSF    09.2
01A7:  BSF    03.5
01A8:  BCF    09.2
.................... 	delay_us(100);	// aguarda 100 us 
01A9:  MOVLW  A6
01AA:  MOVWF  77
01AB:  DECFSZ 77,F
01AC:  GOTO   1AB
01AD:  NOP
.................... 	// caso a linha rw esteja definida, coloca em 0 
.................... 	#ifdef lcd_rw 
.................... 		output_low(lcd_rw); 
.................... 	#endif 
.................... 	// desativa linha enable 
.................... 	output_low(lcd_enable); 
01AE:  BCF    09.1
01AF:  BCF    03.5
01B0:  BCF    09.1
.................... 	// envia a primeira parte do byte 
.................... 	lcd_envia_nibble(dado >> 4); 
01B1:  BSF    03.5
01B2:  SWAPF  36,W
01B3:  MOVWF  37
01B4:  MOVLW  0F
01B5:  ANDWF  37,F
01B6:  MOVF   37,W
01B7:  MOVWF  38
01B8:  BCF    03.5
01B9:  CALL   168
.................... 	// envia a segunda parte do byte 
.................... 	lcd_envia_nibble(dado & 0x0f); 
01BA:  BSF    03.5
01BB:  MOVF   36,W
01BC:  ANDLW  0F
01BD:  MOVWF  37
01BE:  MOVWF  38
01BF:  BCF    03.5
01C0:  CALL   168
01C1:  RETURN
.................... } 
....................  
....................  
.................... void lcd_ini() 
.................... // rotina de inicializaï¿½ï¿½o do display 
.................... { 
.................... 	byte conta; 
.................... 	output_low(lcd_d4); 
01C2:  BSF    03.5
01C3:  BCF    08.4
01C4:  BCF    03.5
01C5:  BCF    08.4
.................... 	output_low(lcd_d5); 
01C6:  BSF    03.5
01C7:  BCF    08.5
01C8:  BCF    03.5
01C9:  BCF    08.5
.................... 	output_low(lcd_d6); 
01CA:  BSF    03.5
01CB:  BCF    08.6
01CC:  BCF    03.5
01CD:  BCF    08.6
.................... 	output_low(lcd_d7); 
01CE:  BSF    03.5
01CF:  BCF    08.7
01D0:  BCF    03.5
01D1:  BCF    08.7
.................... 	output_low(lcd_rs); 
01D2:  BSF    03.5
01D3:  BCF    09.2
01D4:  BCF    03.5
01D5:  BCF    09.2
.................... 	#ifdef lcd_rw 
.................... 		output_high(lcd_rw); 
.................... 	#endif 
.................... 	output_low(lcd_enable); 
01D6:  BSF    03.5
01D7:  BCF    09.1
01D8:  BCF    03.5
01D9:  BCF    09.1
.................... 	delay_ms(15); 
01DA:  MOVLW  0F
01DB:  BSF    03.5
01DC:  MOVWF  31
01DD:  BCF    03.5
01DE:  CALL   154
.................... 	// envia uma seqï¿½ï¿½ncia de 3 vezes 0x03 
.................... 	// e depois 0x02 para configurar o mï¿½dulo 
.................... 	// para modo de 4 bits 
.................... 	for(conta=1;conta<=3;++conta) 
01DF:  MOVLW  01
01E0:  MOVWF  55
01E1:  MOVF   55,W
01E2:  SUBLW  03
01E3:  BTFSS  03.0
01E4:  GOTO   1F1
.................... 	{ 
.................... 		lcd_envia_nibble(3); 
01E5:  MOVLW  03
01E6:  BSF    03.5
01E7:  MOVWF  38
01E8:  BCF    03.5
01E9:  CALL   168
.................... 		delay_ms(5); 
01EA:  MOVLW  05
01EB:  BSF    03.5
01EC:  MOVWF  31
01ED:  BCF    03.5
01EE:  CALL   154
01EF:  INCF   55,F
01F0:  GOTO   1E1
.................... 	} 
.................... 	lcd_envia_nibble(2); 
01F1:  MOVLW  02
01F2:  BSF    03.5
01F3:  MOVWF  38
01F4:  BCF    03.5
01F5:  CALL   168
.................... 	// envia string de inicializaï¿½ï¿½o do display 
.................... 	for(conta=0;conta<=3;++conta) lcd_envia_byte(0,INI_LCD[conta]); 
01F6:  CLRF   55
01F7:  MOVF   55,W
01F8:  SUBLW  03
01F9:  BTFSS  03.0
01FA:  GOTO   208
01FB:  MOVF   55,W
01FC:  CALL   058
01FD:  MOVWF  56
01FE:  BSF    03.5
01FF:  CLRF   35
0200:  BCF    03.5
0201:  MOVF   56,W
0202:  BSF    03.5
0203:  MOVWF  36
0204:  BCF    03.5
0205:  CALL   199
0206:  INCF   55,F
0207:  GOTO   1F7
0208:  BSF    0A.3
0209:  BCF    0A.4
020A:  GOTO   61A (RETURN)
.................... } 
....................  
.................... void lcd_pos_xy( byte x, byte y) 
.................... { 
....................    byte endereco; 
....................    if(y!=1) 
*
022C:  DECFSZ 32,W
022D:  GOTO   22F
022E:  GOTO   232
....................    	endereco = lcd_seg_lin; 
022F:  MOVLW  40
0230:  MOVWF  33
0231:  GOTO   233
....................    else 
....................    	endereco = 0; 
0232:  CLRF   33
....................    endereco += x-1; 
0233:  MOVLW  01
0234:  SUBWF  31,W
0235:  ADDWF  33,F
....................    lcd_envia_byte(0,0x80|endereco); 
0236:  MOVF   33,W
0237:  IORLW  80
0238:  MOVWF  34
0239:  CLRF   35
023A:  MOVF   34,W
023B:  MOVWF  36
023C:  BCF    03.5
023D:  CALL   199
.................... } 
....................  
.................... void lcd_escreve( char c) 
.................... // envia caractere para o display 
.................... { 
....................    switch (c) 
*
020B:  BSF    03.5
020C:  MOVF   30,W
020D:  XORLW  0C
020E:  BCF    03.5
020F:  BTFSC  03.2
0210:  GOTO   21B
0211:  XORLW  06
0212:  BTFSC  03.2
0213:  GOTO   227
0214:  XORLW  07
0215:  BTFSC  03.2
0216:  GOTO   227
0217:  XORLW  05
0218:  BTFSC  03.2
0219:  GOTO   23F
021A:  GOTO   246
.................... 	{ 
....................      case '\f' 	:	lcd_envia_byte(0,1); 
021B:  BSF    03.5
021C:  CLRF   35
021D:  MOVLW  01
021E:  MOVWF  36
021F:  BCF    03.5
0220:  CALL   199
.................... 	  			delay_ms(2); 
0221:  MOVLW  02
0222:  BSF    03.5
0223:  MOVWF  31
0224:  BCF    03.5
0225:  CALL   154
.................... 				break; 
0226:  GOTO   24D
....................      case '\n'	: 
.................... 	   case '\r' 	:	lcd_pos_xy(1,2); 
0227:  MOVLW  01
0228:  BSF    03.5
0229:  MOVWF  31
022A:  MOVLW  02
022B:  MOVWF  32
.................... 	  			break; 
*
023E:  GOTO   24D
....................      case '\b' 	:	lcd_envia_byte(0,0x10); 
023F:  BSF    03.5
0240:  CLRF   35
0241:  MOVLW  10
0242:  MOVWF  36
0243:  BCF    03.5
0244:  CALL   199
.................... 	  			break; 
0245:  GOTO   24D
....................      default	:	lcd_envia_byte(1,c); 
0246:  MOVLW  01
0247:  BSF    03.5
0248:  MOVWF  35
0249:  MOVF   30,W
024A:  MOVWF  36
024B:  BCF    03.5
024C:  CALL   199
.................... 	  			break; 
....................    } 
024D:  RETURN
.................... } 
....................  
.................... char lcd_le( byte x, byte y) 
.................... // le caractere do display 
.................... { 
.................... 	char valor; 
.................... 	// seleciona a posiï¿½ï¿½o do caractere 
.................... 	lcd_pos_xy(x,y); 
.................... 	// ativa rs 
.................... 	output_high(lcd_rs); 
.................... 	// lï¿½ o caractere 
.................... 	valor = lcd_le_byte(); 
.................... 	// desativa rs 
.................... 	output_low(lcd_rs); 
.................... 	// retorna o valor do caractere 
.................... 	return valor; 
.................... } 
....................  
....................  
.................... #include "2401.c" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a MicroChip 24LC01B configured for a x8 org         //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);  Read the byte d from the address a     //// 
.................... ////                                                                   //// 
.................... ////   b = ext_eeprom_ready();  Returns TRUE if the eeprom is ready    //// 
.................... ////                            to receive opcodes                     //// 
.................... ////                                                                   //// 
.................... ////   The main program may define EEPROM_SDA                          //// 
.................... ////   and EEPROM_SCL to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... ////                            Pin Layout                             //// 
.................... ////   -----------------------------------------------------------     //// 
.................... ////   |                                                         |     //// 
.................... ////   | 1: NC   Not Connected | 8: VCC   +5V                    |     //// 
.................... ////   |                       |                                 |     //// 
.................... ////   | 2: NC   Not Connected | 7: WP    GND                    |     //// 
.................... ////   |                       |                                 |     //// 
.................... ////   | 3: NC   Not Connected | 6: SCL   EEPROM_SCL and Pull-Up |     //// 
.................... ////   |                       |                                 |     //// 
.................... ////   | 4: VSS  GND           | 5: SDA   EEPROM_SDA and Pull-Up |     //// 
.................... ////   -----------------------------------------------------------     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2003 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef EEPROM_SDA 
....................  
.................... #define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C3 
....................  
.................... #endif 
....................  
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
02C2:  MOVLW  08
02C3:  MOVWF  78
02C4:  MOVLW  04
02C5:  MOVWF  77
02C6:  DECFSZ 77,F
02C7:  GOTO   2C6
02C8:  BCF    07.3
02C9:  BCF    3D.3
02CA:  MOVF   3D,W
02CB:  BSF    03.5
02CC:  MOVWF  07
02CD:  MOVLW  03
02CE:  MOVWF  77
02CF:  DECFSZ 77,F
02D0:  GOTO   2CF
02D1:  RLF    30,F
02D2:  BCF    03.5
02D3:  BCF    07.4
02D4:  BTFSS  03.0
02D5:  GOTO   2DC
02D6:  BSF    3D.4
02D7:  MOVF   3D,W
02D8:  BSF    03.5
02D9:  MOVWF  07
02DA:  GOTO   2E0
02DB:  BCF    03.5
02DC:  BCF    3D.4
02DD:  MOVF   3D,W
02DE:  BSF    03.5
02DF:  MOVWF  07
02E0:  NOP
02E1:  BCF    03.5
02E2:  BSF    3D.3
02E3:  MOVF   3D,W
02E4:  BSF    03.5
02E5:  MOVWF  07
02E6:  BCF    03.5
02E7:  BTFSS  07.3
02E8:  GOTO   2E7
02E9:  DECFSZ 78,F
02EA:  GOTO   2C4
02EB:  MOVLW  04
02EC:  MOVWF  77
02ED:  DECFSZ 77,F
02EE:  GOTO   2ED
02EF:  BCF    07.3
02F0:  BCF    3D.3
02F1:  MOVF   3D,W
02F2:  BSF    03.5
02F3:  MOVWF  07
02F4:  NOP
02F5:  BCF    03.5
02F6:  BSF    3D.4
02F7:  MOVF   3D,W
02F8:  BSF    03.5
02F9:  MOVWF  07
02FA:  MOVLW  03
02FB:  MOVWF  77
02FC:  DECFSZ 77,F
02FD:  GOTO   2FC
02FE:  MOVLW  03
02FF:  MOVWF  77
0300:  DECFSZ 77,F
0301:  GOTO   300
0302:  BCF    03.5
0303:  BSF    3D.3
0304:  MOVF   3D,W
0305:  BSF    03.5
0306:  MOVWF  07
0307:  BCF    03.5
0308:  BTFSS  07.3
0309:  GOTO   308
030A:  CLRF   78
030B:  MOVLW  03
030C:  MOVWF  77
030D:  DECFSZ 77,F
030E:  GOTO   30D
030F:  BTFSC  07.4
0310:  BSF    78.0
0311:  BCF    07.3
0312:  BCF    3D.3
0313:  MOVF   3D,W
0314:  BSF    03.5
0315:  MOVWF  07
0316:  BCF    03.5
0317:  BCF    07.4
0318:  BCF    3D.4
0319:  MOVF   3D,W
031A:  BSF    03.5
031B:  MOVWF  07
031C:  BCF    03.5
031D:  RETURN
*
03C0:  MOVLW  08
03C1:  BSF    03.5
03C2:  MOVWF  30
03C3:  MOVF   77,W
03C4:  MOVWF  31
03C5:  BCF    03.5
03C6:  BSF    3D.4
03C7:  MOVF   3D,W
03C8:  BSF    03.5
03C9:  MOVWF  07
03CA:  MOVLW  03
03CB:  MOVWF  77
03CC:  DECFSZ 77,F
03CD:  GOTO   3CC
03CE:  BCF    03.5
03CF:  BSF    3D.3
03D0:  MOVF   3D,W
03D1:  BSF    03.5
03D2:  MOVWF  07
03D3:  BCF    03.5
03D4:  BTFSS  07.3
03D5:  GOTO   3D4
03D6:  BTFSC  07.4
03D7:  BSF    03.0
03D8:  BTFSS  07.4
03D9:  BCF    03.0
03DA:  RLF    78,F
03DB:  MOVLW  04
03DC:  MOVWF  77
03DD:  DECFSZ 77,F
03DE:  GOTO   3DD
03DF:  BCF    3D.3
03E0:  MOVF   3D,W
03E1:  BSF    03.5
03E2:  MOVWF  07
03E3:  BCF    03.5
03E4:  BCF    07.3
03E5:  BSF    03.5
03E6:  DECFSZ 30,F
03E7:  GOTO   3C5
03E8:  BCF    03.5
03E9:  BSF    3D.4
03EA:  MOVF   3D,W
03EB:  BSF    03.5
03EC:  MOVWF  07
03ED:  MOVLW  03
03EE:  MOVWF  77
03EF:  DECFSZ 77,F
03F0:  GOTO   3EF
03F1:  BCF    03.5
03F2:  BCF    07.4
03F3:  BSF    03.5
03F4:  MOVF   31,W
03F5:  BTFSC  03.2
03F6:  GOTO   3FC
03F7:  BCF    03.5
03F8:  BCF    3D.4
03F9:  MOVF   3D,W
03FA:  BSF    03.5
03FB:  MOVWF  07
03FC:  NOP
03FD:  BCF    03.5
03FE:  BSF    3D.3
03FF:  MOVF   3D,W
0400:  BSF    03.5
0401:  MOVWF  07
0402:  BCF    03.5
0403:  BTFSS  07.3
0404:  GOTO   403
0405:  MOVLW  04
0406:  MOVWF  77
0407:  DECFSZ 77,F
0408:  GOTO   407
0409:  BCF    07.3
040A:  BCF    3D.3
040B:  MOVF   3D,W
040C:  BSF    03.5
040D:  MOVWF  07
040E:  MOVLW  03
040F:  MOVWF  77
0410:  DECFSZ 77,F
0411:  GOTO   410
0412:  BCF    03.5
0413:  BCF    07.4
0414:  BCF    3D.4
0415:  MOVF   3D,W
0416:  BSF    03.5
0417:  MOVWF  07
....................  
.................... #define EEPROM_ADDRESS BYTE 
.................... #define EEPROM_SIZE    128 
....................  
.................... void init_ext_eeprom() { 
....................    output_float(EEPROM_SCL); 
*
0147:  BSF    3D.3
0148:  MOVF   3D,W
0149:  BSF    03.5
014A:  MOVWF  07
....................    output_float(EEPROM_SDA); 
014B:  BCF    03.5
014C:  BSF    3D.4
014D:  MOVF   3D,W
014E:  BSF    03.5
014F:  MOVWF  07
0150:  BCF    03.5
0151:  BSF    0A.3
0152:  BCF    0A.4
0153:  GOTO   611 (RETURN)
.................... } 
....................  
.................... BOOLEAN ext_eeprom_ready() { 
....................    int1 ack; 
....................    i2c_start();            // If the write command is acknowledged, 
*
031E:  BSF    3D.4
031F:  MOVF   3D,W
0320:  BSF    03.5
0321:  MOVWF  07
0322:  MOVLW  04
0323:  MOVWF  77
0324:  DECFSZ 77,F
0325:  GOTO   324
0326:  BCF    03.5
0327:  BSF    3D.3
0328:  MOVF   3D,W
0329:  BSF    03.5
032A:  MOVWF  07
032B:  MOVLW  03
032C:  MOVWF  77
032D:  DECFSZ 77,F
032E:  GOTO   32D
032F:  BCF    03.5
0330:  BCF    07.4
0331:  BCF    3D.4
0332:  MOVF   3D,W
0333:  BSF    03.5
0334:  MOVWF  07
0335:  MOVLW  04
0336:  MOVWF  77
0337:  DECFSZ 77,F
0338:  GOTO   337
0339:  BCF    03.5
033A:  BCF    07.3
033B:  BCF    3D.3
033C:  MOVF   3D,W
033D:  BSF    03.5
033E:  MOVWF  07
....................    ack = i2c_write(0xa0);  // then the device is ready. 
033F:  MOVLW  A0
0340:  MOVWF  30
0341:  BCF    03.5
0342:  CALL   2C2
0343:  MOVF   78,W
0344:  BSF    03.5
0345:  BCF    2F.0
0346:  BTFSC  78.0
0347:  BSF    2F.0
....................    i2c_stop(); 
0348:  BCF    03.5
0349:  BCF    3D.4
034A:  MOVF   3D,W
034B:  BSF    03.5
034C:  MOVWF  07
034D:  NOP
034E:  BCF    03.5
034F:  BSF    3D.3
0350:  MOVF   3D,W
0351:  BSF    03.5
0352:  MOVWF  07
0353:  BCF    03.5
0354:  BTFSS  07.3
0355:  GOTO   354
0356:  MOVLW  04
0357:  MOVWF  77
0358:  DECFSZ 77,F
0359:  GOTO   358
035A:  GOTO   35B
035B:  NOP
035C:  BSF    3D.4
035D:  MOVF   3D,W
035E:  BSF    03.5
035F:  MOVWF  07
0360:  MOVLW  04
0361:  MOVWF  77
0362:  DECFSZ 77,F
0363:  GOTO   362
....................    return !ack; 
0364:  MOVLW  00
0365:  BTFSS  2F.0
0366:  MOVLW  01
0367:  MOVWF  78
0368:  BCF    03.5
0369:  RETURN
.................... } 
....................  
.................... void write_ext_eeprom(BYTE address, BYTE data) { 
....................    while(!ext_eeprom_ready()); 
*
043A:  CALL   31E
043B:  MOVF   78,F
043C:  BTFSC  03.2
043D:  GOTO   43A
....................    i2c_start(); 
043E:  BSF    3D.4
043F:  MOVF   3D,W
0440:  BSF    03.5
0441:  MOVWF  07
0442:  MOVLW  04
0443:  MOVWF  77
0444:  DECFSZ 77,F
0445:  GOTO   444
0446:  BCF    03.5
0447:  BSF    3D.3
0448:  MOVF   3D,W
0449:  BSF    03.5
044A:  MOVWF  07
044B:  MOVLW  03
044C:  MOVWF  77
044D:  DECFSZ 77,F
044E:  GOTO   44D
044F:  BCF    03.5
0450:  BCF    07.4
0451:  BCF    3D.4
0452:  MOVF   3D,W
0453:  BSF    03.5
0454:  MOVWF  07
0455:  MOVLW  04
0456:  MOVWF  77
0457:  DECFSZ 77,F
0458:  GOTO   457
0459:  BCF    03.5
045A:  BCF    07.3
045B:  BCF    3D.3
045C:  MOVF   3D,W
045D:  BSF    03.5
045E:  MOVWF  07
....................    i2c_write(0xa0); 
045F:  MOVLW  A0
0460:  MOVWF  30
0461:  BCF    03.5
0462:  CALL   2C2
....................    i2c_write(address); 
0463:  BSF    03.5
0464:  MOVF   28,W
0465:  MOVWF  30
0466:  BCF    03.5
0467:  CALL   2C2
....................    i2c_write(data); 
0468:  BSF    03.5
0469:  MOVF   29,W
046A:  MOVWF  30
046B:  BCF    03.5
046C:  CALL   2C2
....................    i2c_stop(); 
046D:  BCF    3D.4
046E:  MOVF   3D,W
046F:  BSF    03.5
0470:  MOVWF  07
0471:  NOP
0472:  BCF    03.5
0473:  BSF    3D.3
0474:  MOVF   3D,W
0475:  BSF    03.5
0476:  MOVWF  07
0477:  BCF    03.5
0478:  BTFSS  07.3
0479:  GOTO   478
047A:  MOVLW  04
047B:  MOVWF  77
047C:  DECFSZ 77,F
047D:  GOTO   47C
047E:  GOTO   47F
047F:  NOP
0480:  BSF    3D.4
0481:  MOVF   3D,W
0482:  BSF    03.5
0483:  MOVWF  07
0484:  MOVLW  04
0485:  MOVWF  77
0486:  DECFSZ 77,F
0487:  GOTO   486
0488:  BCF    03.5
0489:  RETURN
.................... } 
....................  
....................  
.................... BYTE read_ext_eeprom(BYTE address) { 
....................    BYTE data; 
....................  
....................    while(!ext_eeprom_ready()); 
*
036A:  CALL   31E
036B:  MOVF   78,F
036C:  BTFSC  03.2
036D:  GOTO   36A
....................    i2c_start(); 
036E:  BSF    3D.4
036F:  MOVF   3D,W
0370:  BSF    03.5
0371:  MOVWF  07
0372:  MOVLW  04
0373:  MOVWF  77
0374:  DECFSZ 77,F
0375:  GOTO   374
0376:  BCF    03.5
0377:  BSF    3D.3
0378:  MOVF   3D,W
0379:  BSF    03.5
037A:  MOVWF  07
037B:  MOVLW  03
037C:  MOVWF  77
037D:  DECFSZ 77,F
037E:  GOTO   37D
037F:  BCF    03.5
0380:  BCF    07.4
0381:  BCF    3D.4
0382:  MOVF   3D,W
0383:  BSF    03.5
0384:  MOVWF  07
0385:  MOVLW  04
0386:  MOVWF  77
0387:  DECFSZ 77,F
0388:  GOTO   387
0389:  BCF    03.5
038A:  BCF    07.3
038B:  BCF    3D.3
038C:  MOVF   3D,W
038D:  BSF    03.5
038E:  MOVWF  07
....................    i2c_write(0xa0); 
038F:  MOVLW  A0
0390:  MOVWF  30
0391:  BCF    03.5
0392:  CALL   2C2
....................    i2c_write(address); 
0393:  BSF    03.5
0394:  MOVF   2D,W
0395:  MOVWF  30
0396:  BCF    03.5
0397:  CALL   2C2
....................    i2c_start(); 
0398:  BSF    3D.4
0399:  MOVF   3D,W
039A:  BSF    03.5
039B:  MOVWF  07
039C:  MOVLW  04
039D:  MOVWF  77
039E:  DECFSZ 77,F
039F:  GOTO   39E
03A0:  BCF    03.5
03A1:  BSF    3D.3
03A2:  MOVF   3D,W
03A3:  BSF    03.5
03A4:  MOVWF  07
03A5:  MOVLW  03
03A6:  MOVWF  77
03A7:  DECFSZ 77,F
03A8:  GOTO   3A7
03A9:  BCF    03.5
03AA:  BTFSS  07.3
03AB:  GOTO   3AA
03AC:  BCF    07.4
03AD:  BCF    3D.4
03AE:  MOVF   3D,W
03AF:  BSF    03.5
03B0:  MOVWF  07
03B1:  MOVLW  04
03B2:  MOVWF  77
03B3:  DECFSZ 77,F
03B4:  GOTO   3B3
03B5:  BCF    03.5
03B6:  BCF    07.3
03B7:  BCF    3D.3
03B8:  MOVF   3D,W
03B9:  BSF    03.5
03BA:  MOVWF  07
....................    i2c_write(0xa1); 
03BB:  MOVLW  A1
03BC:  MOVWF  30
03BD:  BCF    03.5
03BE:  CALL   2C2
....................    data=i2c_read(0); 
03BF:  CLRF   77
*
0418:  MOVF   78,W
0419:  MOVWF  2E
....................    i2c_stop(); 
041A:  BCF    03.5
041B:  BCF    3D.4
041C:  MOVF   3D,W
041D:  BSF    03.5
041E:  MOVWF  07
041F:  NOP
0420:  BCF    03.5
0421:  BSF    3D.3
0422:  MOVF   3D,W
0423:  BSF    03.5
0424:  MOVWF  07
0425:  BCF    03.5
0426:  BTFSS  07.3
0427:  GOTO   426
0428:  MOVLW  04
0429:  MOVWF  77
042A:  DECFSZ 77,F
042B:  GOTO   42A
042C:  GOTO   42D
042D:  NOP
042E:  BSF    3D.4
042F:  MOVF   3D,W
0430:  BSF    03.5
0431:  MOVWF  07
0432:  MOVLW  04
0433:  MOVWF  77
0434:  DECFSZ 77,F
0435:  GOTO   434
....................    return(data); 
0436:  MOVF   2E,W
0437:  MOVWF  78
0438:  BCF    03.5
0439:  RETURN
.................... } 
....................  
.................... #include "kbd_board4.c" 
.................... /*######################################################################  
....................    Rotina utilização do teclado da placa PicSim board4 
....................    Adaptada para o compilador CCS 
....................    Autor: Alberto Willia Mascarenhas (adaptou para o compilador) 
....................    For e-mail suggestions :  awmascarenhas@gmail.com 
.................... ######################################################################## */ 
.................... unsigned char tc_tecla(unsigned int timeout) 
*
04BE:  CLRF   75
04BF:  CLRF   76
.................... { 
....................   unsigned int to=0; 
....................   unsigned char k = 0;   
....................   while(((to < timeout)||(!timeout))&&(!k)){ 
04C0:  MOVF   74,W
04C1:  SUBWF  75,W
04C2:  BTFSS  03.0
04C3:  GOTO   4C7
04C4:  MOVF   74,F
04C5:  BTFSS  03.2
04C6:  GOTO   5E6
04C7:  MOVF   76,F
04C8:  BTFSS  03.2
04C9:  GOTO   5E6
....................       
....................        
....................       //------------------------------------------------------------------------- 
....................       //inicio do programa de varredura do teclado matricial 
....................       //-------------------------------------------------------------------------- 
....................       //habilita primeira coluna do teclado 
....................       output_low(PIN_B0);output_high(PIN_B1);output_high(PIN_B2);output_high(PIN_B3); 
04CA:  BSF    03.5
04CB:  BCF    06.0
04CC:  BCF    03.5
04CD:  BCF    06.0
04CE:  BSF    03.5
04CF:  BCF    06.1
04D0:  BCF    03.5
04D1:  BSF    06.1
04D2:  BSF    03.5
04D3:  BCF    06.2
04D4:  BCF    03.5
04D5:  BSF    06.2
04D6:  BSF    03.5
04D7:  BCF    06.3
04D8:  BCF    03.5
04D9:  BSF    06.3
....................       delay_ms(20); 
04DA:  MOVLW  14
04DB:  BSF    03.5
04DC:  MOVWF  31
04DD:  BCF    03.5
04DE:  CALL   154
....................       if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='1';}; 
04DF:  BSF    03.5
04E0:  BSF    08.0
04E1:  BCF    03.5
04E2:  BTFSC  08.0
04E3:  GOTO   4EB
04E4:  BSF    03.5
04E5:  BSF    08.0
04E6:  BCF    03.5
04E7:  BTFSS  08.0
04E8:  GOTO   4E4
04E9:  MOVLW  31
04EA:  MOVWF  76
....................       if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='4';}; 
04EB:  BSF    03.5
04EC:  BSF    08.1
04ED:  BCF    03.5
04EE:  BTFSC  08.1
04EF:  GOTO   4F7
04F0:  BSF    03.5
04F1:  BSF    08.1
04F2:  BCF    03.5
04F3:  BTFSS  08.1
04F4:  GOTO   4F0
04F5:  MOVLW  34
04F6:  MOVWF  76
....................       if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='7';}; 
04F7:  BSF    03.5
04F8:  BSF    08.2
04F9:  BCF    03.5
04FA:  BTFSC  08.2
04FB:  GOTO   503
04FC:  BSF    03.5
04FD:  BSF    08.2
04FE:  BCF    03.5
04FF:  BTFSS  08.2
0500:  GOTO   4FC
0501:  MOVLW  37
0502:  MOVWF  76
....................       if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='*';}; 
0503:  BSF    03.5
0504:  BSF    08.3
0505:  BCF    03.5
0506:  BTFSC  08.3
0507:  GOTO   50F
0508:  BSF    03.5
0509:  BSF    08.3
050A:  BCF    03.5
050B:  BTFSS  08.3
050C:  GOTO   508
050D:  MOVLW  2A
050E:  MOVWF  76
....................       //habilita segunda coluna do teclado 
....................       output_high(PIN_B0);output_low(PIN_B1);output_high(PIN_B2);output_high(PIN_B3); 
050F:  BSF    03.5
0510:  BCF    06.0
0511:  BCF    03.5
0512:  BSF    06.0
0513:  BSF    03.5
0514:  BCF    06.1
0515:  BCF    03.5
0516:  BCF    06.1
0517:  BSF    03.5
0518:  BCF    06.2
0519:  BCF    03.5
051A:  BSF    06.2
051B:  BSF    03.5
051C:  BCF    06.3
051D:  BCF    03.5
051E:  BSF    06.3
....................       delay_ms(20);       
051F:  MOVLW  14
0520:  BSF    03.5
0521:  MOVWF  31
0522:  BCF    03.5
0523:  CALL   154
....................       if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='2';}; 
0524:  BSF    03.5
0525:  BSF    08.0
0526:  BCF    03.5
0527:  BTFSC  08.0
0528:  GOTO   530
0529:  BSF    03.5
052A:  BSF    08.0
052B:  BCF    03.5
052C:  BTFSS  08.0
052D:  GOTO   529
052E:  MOVLW  32
052F:  MOVWF  76
....................       if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='5';}; 
0530:  BSF    03.5
0531:  BSF    08.1
0532:  BCF    03.5
0533:  BTFSC  08.1
0534:  GOTO   53C
0535:  BSF    03.5
0536:  BSF    08.1
0537:  BCF    03.5
0538:  BTFSS  08.1
0539:  GOTO   535
053A:  MOVLW  35
053B:  MOVWF  76
....................       if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='8';}; 
053C:  BSF    03.5
053D:  BSF    08.2
053E:  BCF    03.5
053F:  BTFSC  08.2
0540:  GOTO   548
0541:  BSF    03.5
0542:  BSF    08.2
0543:  BCF    03.5
0544:  BTFSS  08.2
0545:  GOTO   541
0546:  MOVLW  38
0547:  MOVWF  76
....................       if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='0';}; 
0548:  BSF    03.5
0549:  BSF    08.3
054A:  BCF    03.5
054B:  BTFSC  08.3
054C:  GOTO   554
054D:  BSF    03.5
054E:  BSF    08.3
054F:  BCF    03.5
0550:  BTFSS  08.3
0551:  GOTO   54D
0552:  MOVLW  30
0553:  MOVWF  76
....................        
....................       //habilita terceira coluna do teclado 
....................       output_high(PIN_B0);output_high(PIN_B1);output_low(PIN_B2);output_high(PIN_B3); 
0554:  BSF    03.5
0555:  BCF    06.0
0556:  BCF    03.5
0557:  BSF    06.0
0558:  BSF    03.5
0559:  BCF    06.1
055A:  BCF    03.5
055B:  BSF    06.1
055C:  BSF    03.5
055D:  BCF    06.2
055E:  BCF    03.5
055F:  BCF    06.2
0560:  BSF    03.5
0561:  BCF    06.3
0562:  BCF    03.5
0563:  BSF    06.3
....................       delay_ms(20);       
0564:  MOVLW  14
0565:  BSF    03.5
0566:  MOVWF  31
0567:  BCF    03.5
0568:  CALL   154
....................       if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='3';}; 
0569:  BSF    03.5
056A:  BSF    08.0
056B:  BCF    03.5
056C:  BTFSC  08.0
056D:  GOTO   575
056E:  BSF    03.5
056F:  BSF    08.0
0570:  BCF    03.5
0571:  BTFSS  08.0
0572:  GOTO   56E
0573:  MOVLW  33
0574:  MOVWF  76
....................       if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='6';}; 
0575:  BSF    03.5
0576:  BSF    08.1
0577:  BCF    03.5
0578:  BTFSC  08.1
0579:  GOTO   581
057A:  BSF    03.5
057B:  BSF    08.1
057C:  BCF    03.5
057D:  BTFSS  08.1
057E:  GOTO   57A
057F:  MOVLW  36
0580:  MOVWF  76
....................       if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='9';}; 
0581:  BSF    03.5
0582:  BSF    08.2
0583:  BCF    03.5
0584:  BTFSC  08.2
0585:  GOTO   58D
0586:  BSF    03.5
0587:  BSF    08.2
0588:  BCF    03.5
0589:  BTFSS  08.2
058A:  GOTO   586
058B:  MOVLW  39
058C:  MOVWF  76
....................       if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='#';}; 
058D:  BSF    03.5
058E:  BSF    08.3
058F:  BCF    03.5
0590:  BTFSC  08.3
0591:  GOTO   599
0592:  BSF    03.5
0593:  BSF    08.3
0594:  BCF    03.5
0595:  BTFSS  08.3
0596:  GOTO   592
0597:  MOVLW  23
0598:  MOVWF  76
....................   
....................        //habilita quarta coluna do teclado 
....................       output_high(PIN_B0);output_high(PIN_B1);output_high(PIN_B2);output_low(PIN_B3); 
0599:  BSF    03.5
059A:  BCF    06.0
059B:  BCF    03.5
059C:  BSF    06.0
059D:  BSF    03.5
059E:  BCF    06.1
059F:  BCF    03.5
05A0:  BSF    06.1
05A1:  BSF    03.5
05A2:  BCF    06.2
05A3:  BCF    03.5
05A4:  BSF    06.2
05A5:  BSF    03.5
05A6:  BCF    06.3
05A7:  BCF    03.5
05A8:  BCF    06.3
....................       delay_ms(20);       
05A9:  MOVLW  14
05AA:  BSF    03.5
05AB:  MOVWF  31
05AC:  BCF    03.5
05AD:  CALL   154
....................       if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='A';}; 
05AE:  BSF    03.5
05AF:  BSF    08.0
05B0:  BCF    03.5
05B1:  BTFSC  08.0
05B2:  GOTO   5BA
05B3:  BSF    03.5
05B4:  BSF    08.0
05B5:  BCF    03.5
05B6:  BTFSS  08.0
05B7:  GOTO   5B3
05B8:  MOVLW  41
05B9:  MOVWF  76
....................       if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='B';}; 
05BA:  BSF    03.5
05BB:  BSF    08.1
05BC:  BCF    03.5
05BD:  BTFSC  08.1
05BE:  GOTO   5C6
05BF:  BSF    03.5
05C0:  BSF    08.1
05C1:  BCF    03.5
05C2:  BTFSS  08.1
05C3:  GOTO   5BF
05C4:  MOVLW  42
05C5:  MOVWF  76
....................       if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='C';}; 
05C6:  BSF    03.5
05C7:  BSF    08.2
05C8:  BCF    03.5
05C9:  BTFSC  08.2
05CA:  GOTO   5D2
05CB:  BSF    03.5
05CC:  BSF    08.2
05CD:  BCF    03.5
05CE:  BTFSS  08.2
05CF:  GOTO   5CB
05D0:  MOVLW  43
05D1:  MOVWF  76
....................       if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='D';}; 
05D2:  BSF    03.5
05D3:  BSF    08.3
05D4:  BCF    03.5
05D5:  BTFSC  08.3
05D6:  GOTO   5DE
05D7:  BSF    03.5
05D8:  BSF    08.3
05D9:  BCF    03.5
05DA:  BTFSS  08.3
05DB:  GOTO   5D7
05DC:  MOVLW  44
05DD:  MOVWF  76
....................   
....................       //printf (lcd_escreve,"\f saiu geral %u",k); 
....................       //delay_ms(1000); 
....................       delay_ms(5); 
05DE:  MOVLW  05
05DF:  BSF    03.5
05E0:  MOVWF  31
05E1:  BCF    03.5
05E2:  CALL   154
....................       to+=5; 
05E3:  MOVLW  05
05E4:  ADDWF  75,F
05E5:  GOTO   4C0
....................   } 
....................    if(!k)k=255; 
05E6:  MOVF   76,F
05E7:  BTFSS  03.2
05E8:  GOTO   5EB
05E9:  MOVLW  FF
05EA:  MOVWF  76
....................   return k;   
05EB:  MOVF   76,W
05EC:  MOVWF  78
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... // -----------------Functions 
.................... void saveUser(int * id, int * pass, int status); 
.................... int getAddressByID(int * id);    
.................... int deleteUser(int address); 
....................  
.................... int isIdAvailable(int id);     
.................... void printUser(); 
.................... void erase_program_eeprom(int addrr); 
.................... int incrementID(); 
.................... int lastNewUserPosition(); 
.................... void resetMemory(); 
.................... void adminMenu(); 
.................... unsigned char readKeyboard();  
.................... int * getAdminsID(); 
.................... void listAdmins(); 
.................... int * strToInt(char * str); 
....................  
.................... char * strfromchar(char destination[], char source); 
....................  
....................  
.................... typedef struct {  
....................    int id[2]; 
....................    int pass[4]; //password 
....................    int status; //0 - Unpaid, 1 - Paid, 3 - Admin 
.................... }User; 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
*
0677:  BSF    03.5
0678:  MOVF   56,W
0679:  MOVWF  59
....................    for(su=s;0<n;++su,--n) 
067A:  MOVF   55,W
067B:  MOVWF  5B
067C:  MOVF   54,W
067D:  MOVWF  5A
067E:  MOVF   58,F
067F:  BTFSS  03.2
0680:  GOTO   685
0681:  MOVF   57,W
0682:  SUBLW  00
0683:  BTFSC  03.0
0684:  GOTO   69D
....................       if(*su==uc) 
0685:  MOVF   5B,W
0686:  MOVWF  7A
0687:  MOVF   5A,W
0688:  MOVWF  04
0689:  BCF    03.7
068A:  BTFSC  7A.0
068B:  BSF    03.7
068C:  MOVF   59,W
068D:  SUBWF  00,W
068E:  BTFSS  03.2
068F:  GOTO   695
....................       return su; 
0690:  MOVF   5A,W
0691:  MOVWF  78
0692:  MOVF   5B,W
0693:  MOVWF  79
0694:  GOTO   6A0
0695:  INCF   5A,F
0696:  BTFSC  03.2
0697:  INCF   5B,F
0698:  MOVF   57,W
0699:  BTFSC  03.2
069A:  DECF   58,F
069B:  DECF   57,F
069C:  GOTO   67E
....................    return NULL; 
069D:  MOVLW  00
069E:  MOVWF  78
069F:  MOVWF  79
06A0:  BCF    03.5
06A1:  RETURN
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
0DF5:  BCF    03.5
0DF6:  CLRF   3E
0DF7:  CLRF   3F
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
*
0800:  BSF    03.5
0801:  CLRF   2D
0802:  CLRF   2C
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
0803:  MOVLW  30
0804:  MOVWF  2F
0805:  MOVLW  31
0806:  MOVWF  30
0807:  MOVLW  32
0808:  MOVWF  31
0809:  MOVLW  33
080A:  MOVWF  32
080B:  MOVLW  34
080C:  MOVWF  33
080D:  MOVLW  35
080E:  MOVWF  34
080F:  MOVLW  36
0810:  MOVWF  35
0811:  MOVLW  37
0812:  MOVWF  36
0813:  MOVLW  38
0814:  MOVWF  37
0815:  MOVLW  39
0816:  MOVWF  38
0817:  MOVLW  61
0818:  MOVWF  39
0819:  MOVLW  62
081A:  MOVWF  3A
081B:  MOVLW  63
081C:  MOVWF  3B
081D:  MOVLW  64
081E:  MOVWF  3C
081F:  MOVLW  65
0820:  MOVWF  3D
0821:  MOVLW  66
0822:  MOVWF  3E
0823:  MOVLW  67
0824:  MOVWF  3F
0825:  MOVLW  68
0826:  MOVWF  40
0827:  MOVLW  69
0828:  MOVWF  41
0829:  MOVLW  6A
082A:  MOVWF  42
082B:  MOVLW  6B
082C:  MOVWF  43
082D:  MOVLW  6C
082E:  MOVWF  44
082F:  MOVLW  6D
0830:  MOVWF  45
0831:  MOVLW  6E
0832:  MOVWF  46
0833:  MOVLW  6F
0834:  MOVWF  47
0835:  MOVLW  70
0836:  MOVWF  48
0837:  MOVLW  71
0838:  MOVWF  49
0839:  MOVLW  73
083A:  MOVWF  4A
083B:  MOVLW  74
083C:  MOVWF  4B
083D:  MOVLW  75
083E:  MOVWF  4C
083F:  MOVLW  76
0840:  MOVWF  4D
0841:  MOVLW  77
0842:  MOVWF  4E
0843:  MOVLW  78
0844:  MOVWF  4F
0845:  MOVLW  79
0846:  MOVWF  50
0847:  MOVLW  7A
0848:  MOVWF  51
0849:  CLRF   52
....................    for(sc=s;isspace(*sc);++sc); 
084A:  MOVF   22,W
084B:  MOVWF  27
084C:  MOVF   21,W
084D:  MOVWF  26
084E:  MOVF   27,W
084F:  MOVWF  7A
0850:  MOVF   26,W
0851:  MOVWF  04
0852:  BCF    03.7
0853:  BTFSC  7A.0
0854:  BSF    03.7
0855:  MOVF   00,W
0856:  SUBLW  20
0857:  BTFSS  03.2
0858:  GOTO   05D
0859:  INCF   26,F
085A:  BTFSC  03.2
085B:  INCF   27,F
085C:  GOTO   04E
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
085D:  MOVF   27,W
085E:  MOVWF  7A
085F:  MOVF   26,W
0860:  MOVWF  04
0861:  BCF    03.7
0862:  BTFSC  27.0
0863:  BSF    03.7
0864:  MOVF   00,W
0865:  SUBLW  2D
0866:  BTFSC  03.2
0867:  GOTO   073
0868:  MOVF   27,W
0869:  MOVWF  7A
086A:  MOVF   26,W
086B:  MOVWF  04
086C:  BCF    03.7
086D:  BTFSC  27.0
086E:  BSF    03.7
086F:  MOVF   00,W
0870:  SUBLW  2B
0871:  BTFSS  03.2
0872:  GOTO   07F
0873:  MOVF   27,W
0874:  MOVWF  7A
0875:  MOVF   26,W
0876:  INCF   26,F
0877:  BTFSC  03.2
0878:  INCF   27,F
0879:  MOVWF  04
087A:  BCF    03.7
087B:  BTFSC  7A.0
087C:  BSF    03.7
087D:  MOVF   00,W
087E:  GOTO   080
087F:  MOVLW  2B
0880:  MOVWF  2E
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
0881:  MOVF   2E,W
0882:  SUBLW  2D
0883:  BTFSC  03.2
0884:  GOTO   090
0885:  BTFSC  25.7
0886:  GOTO   090
0887:  DECFSZ 25,W
0888:  GOTO   08A
0889:  GOTO   090
088A:  BTFSC  25.7
088B:  GOTO   092
088C:  MOVF   25,W
088D:  SUBLW  24
088E:  BTFSC  03.0
088F:  GOTO   092
....................    goto StrtoulGO; 
0890:  GOTO   1EC
0891:  GOTO   128
....................  
....................    else if (base) 
0892:  MOVF   25,F
0893:  BTFSC  03.2
0894:  GOTO   0ED
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
0895:  MOVF   25,W
0896:  SUBLW  10
0897:  BTFSS  03.2
0898:  GOTO   0BC
0899:  MOVF   27,W
089A:  MOVWF  7A
089B:  MOVF   26,W
089C:  MOVWF  04
089D:  BCF    03.7
089E:  BTFSC  7A.0
089F:  BSF    03.7
08A0:  MOVF   00,W
08A1:  SUBLW  30
08A2:  BTFSS  03.2
08A3:  GOTO   0BC
08A4:  MOVLW  01
08A5:  ADDWF  26,W
08A6:  MOVWF  04
08A7:  BCF    03.7
08A8:  BTFSC  27.0
08A9:  BSF    03.7
08AA:  MOVF   00,W
08AB:  SUBLW  78
08AC:  BTFSC  03.2
08AD:  GOTO   0B8
08AE:  MOVLW  01
08AF:  ADDWF  26,W
08B0:  MOVWF  04
08B1:  BCF    03.7
08B2:  BTFSC  27.0
08B3:  BSF    03.7
08B4:  MOVF   00,W
08B5:  SUBLW  58
08B6:  BTFSS  03.2
08B7:  GOTO   0BC
....................          sc+=2; 
08B8:  MOVLW  02
08B9:  ADDWF  26,F
08BA:  BTFSC  03.0
08BB:  INCF   27,F
....................       if(base==8 && *sc =='0') 
08BC:  MOVF   25,W
08BD:  SUBLW  08
08BE:  BTFSS  03.2
08BF:  GOTO   0CF
08C0:  MOVF   27,W
08C1:  MOVWF  7A
08C2:  MOVF   26,W
08C3:  MOVWF  04
08C4:  BCF    03.7
08C5:  BTFSC  7A.0
08C6:  BSF    03.7
08C7:  MOVF   00,W
08C8:  SUBLW  30
08C9:  BTFSS  03.2
08CA:  GOTO   0CF
....................          sc+=1; 
08CB:  MOVLW  01
08CC:  ADDWF  26,F
08CD:  BTFSC  03.0
08CE:  INCF   27,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
08CF:  MOVF   25,W
08D0:  SUBLW  02
08D1:  BTFSS  03.2
08D2:  GOTO   0EC
08D3:  MOVF   27,W
08D4:  MOVWF  7A
08D5:  MOVF   26,W
08D6:  MOVWF  04
08D7:  BCF    03.7
08D8:  BTFSC  7A.0
08D9:  BSF    03.7
08DA:  MOVF   00,W
08DB:  SUBLW  30
08DC:  BTFSS  03.2
08DD:  GOTO   0EC
08DE:  MOVLW  01
08DF:  ADDWF  26,W
08E0:  MOVWF  04
08E1:  BCF    03.7
08E2:  BTFSC  27.0
08E3:  BSF    03.7
08E4:  MOVF   00,W
08E5:  SUBLW  62
08E6:  BTFSS  03.2
08E7:  GOTO   0EC
....................          sc+=2; 
08E8:  MOVLW  02
08E9:  ADDWF  26,F
08EA:  BTFSC  03.0
08EB:  INCF   27,F
....................  
....................    } 
08EC:  GOTO   128
....................    else if(*sc!='0') // base is 0, find base 
08ED:  MOVF   27,W
08EE:  MOVWF  7A
08EF:  MOVF   26,W
08F0:  MOVWF  04
08F1:  BCF    03.7
08F2:  BTFSC  7A.0
08F3:  BSF    03.7
08F4:  MOVF   00,W
08F5:  SUBLW  30
08F6:  BTFSC  03.2
08F7:  GOTO   0FB
....................       base=10; 
08F8:  MOVLW  0A
08F9:  MOVWF  25
08FA:  GOTO   128
....................    else if (sc[1]=='x' || sc[1]=='X') 
08FB:  MOVLW  01
08FC:  ADDWF  26,W
08FD:  MOVWF  04
08FE:  BCF    03.7
08FF:  BTFSC  27.0
0900:  BSF    03.7
0901:  MOVF   00,W
0902:  SUBLW  78
0903:  BTFSC  03.2
0904:  GOTO   10F
0905:  MOVLW  01
0906:  ADDWF  26,W
0907:  MOVWF  04
0908:  BCF    03.7
0909:  BTFSC  27.0
090A:  BSF    03.7
090B:  MOVF   00,W
090C:  SUBLW  58
090D:  BTFSS  03.2
090E:  GOTO   116
....................       base =16,sc+=2; 
090F:  MOVLW  10
0910:  MOVWF  25
0911:  MOVLW  02
0912:  ADDWF  26,F
0913:  BTFSC  03.0
0914:  INCF   27,F
0915:  GOTO   128
....................    else if(sc[1]=='b') 
0916:  MOVLW  01
0917:  ADDWF  26,W
0918:  MOVWF  04
0919:  BCF    03.7
091A:  BTFSC  27.0
091B:  BSF    03.7
091C:  MOVF   00,W
091D:  SUBLW  62
091E:  BTFSS  03.2
091F:  GOTO   126
....................       base=2,sc+=2; 
0920:  MOVLW  02
0921:  MOVWF  25
0922:  ADDWF  26,F
0923:  BTFSC  03.0
0924:  INCF   27,F
0925:  GOTO   128
....................    else 
....................       base=8; 
0926:  MOVLW  08
0927:  MOVWF  25
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
0928:  MOVF   27,W
0929:  MOVWF  29
092A:  MOVF   26,W
092B:  MOVWF  28
092C:  MOVF   27,W
092D:  MOVWF  7A
092E:  MOVF   26,W
092F:  MOVWF  04
0930:  BCF    03.7
0931:  BTFSC  7A.0
0932:  BSF    03.7
0933:  MOVF   00,W
0934:  SUBLW  30
0935:  BTFSS  03.2
0936:  GOTO   13B
0937:  INCF   26,F
0938:  BTFSC  03.2
0939:  INCF   27,F
093A:  GOTO   12C
....................    sd=memchr(digits,tolower(*sc),base); 
093B:  MOVF   27,W
093C:  MOVWF  7A
093D:  MOVF   26,W
093E:  MOVWF  04
093F:  BCF    03.7
0940:  BTFSC  27.0
0941:  BSF    03.7
0942:  MOVF   00,W
0943:  MOVWF  53
0944:  SUBLW  40
0945:  BTFSC  03.0
0946:  GOTO   14E
0947:  MOVF   53,W
0948:  SUBLW  5A
0949:  BTFSS  03.0
094A:  GOTO   14E
094B:  MOVF   53,W
094C:  IORLW  20
094D:  GOTO   14F
094E:  MOVF   53,W
094F:  MOVWF  53
0950:  CLRF   55
0951:  MOVLW  AF
0952:  MOVWF  54
0953:  MOVF   53,W
0954:  MOVWF  56
0955:  CLRF   58
0956:  MOVF   25,W
0957:  MOVWF  57
0958:  BCF    0A.3
0959:  BCF    03.5
095A:  CALL   677
095B:  BSF    0A.3
095C:  MOVF   79,W
095D:  BSF    03.5
095E:  MOVWF  2B
095F:  MOVF   78,W
0960:  MOVWF  2A
....................    for(; sd!=0; ) 
0961:  MOVF   2A,F
0962:  BTFSS  03.2
0963:  GOTO   167
0964:  MOVF   2B,F
0965:  BTFSC  03.2
0966:  GOTO   1E4
....................    { 
....................       x=x*base+(int16)(sd-digits); 
0967:  CLRF   7A
0968:  MOVF   25,W
0969:  MOVWF  77
096A:  BTFSC  77.7
096B:  DECF   7A,F
096C:  MOVWF  53
096D:  MOVF   7A,W
096E:  MOVWF  54
096F:  MOVF   2D,W
0970:  MOVWF  56
0971:  MOVF   2C,W
0972:  MOVWF  55
0973:  MOVF   54,W
0974:  MOVWF  58
0975:  MOVF   53,W
0976:  MOVWF  57
*
09A4:  MOVF   79,W
09A5:  MOVWF  54
09A6:  MOVF   78,W
09A7:  MOVWF  53
09A8:  MOVLW  AF
09A9:  SUBWF  2A,W
09AA:  MOVWF  77
09AB:  MOVF   2B,W
09AC:  MOVWF  7A
09AD:  MOVLW  00
09AE:  BTFSS  03.0
09AF:  MOVLW  01
09B0:  SUBWF  7A,F
09B1:  MOVF   77,W
09B2:  ADDWF  53,W
09B3:  MOVWF  2C
09B4:  MOVF   54,W
09B5:  MOVWF  2D
09B6:  MOVF   7A,W
09B7:  BTFSC  03.0
09B8:  INCFSZ 7A,W
09B9:  ADDWF  2D,F
....................       ++sc; 
09BA:  INCF   26,F
09BB:  BTFSC  03.2
09BC:  INCF   27,F
....................       sd=memchr(digits,tolower(*sc),base); 
09BD:  MOVF   27,W
09BE:  MOVWF  7A
09BF:  MOVF   26,W
09C0:  MOVWF  04
09C1:  BCF    03.7
09C2:  BTFSC  27.0
09C3:  BSF    03.7
09C4:  MOVF   00,W
09C5:  MOVWF  53
09C6:  SUBLW  40
09C7:  BTFSC  03.0
09C8:  GOTO   1D0
09C9:  MOVF   53,W
09CA:  SUBLW  5A
09CB:  BTFSS  03.0
09CC:  GOTO   1D0
09CD:  MOVF   53,W
09CE:  IORLW  20
09CF:  GOTO   1D1
09D0:  MOVF   53,W
09D1:  MOVWF  53
09D2:  CLRF   55
09D3:  MOVLW  AF
09D4:  MOVWF  54
09D5:  MOVF   53,W
09D6:  MOVWF  56
09D7:  CLRF   58
09D8:  MOVF   25,W
09D9:  MOVWF  57
09DA:  BCF    0A.3
09DB:  BCF    03.5
09DC:  CALL   677
09DD:  BSF    0A.3
09DE:  MOVF   79,W
09DF:  BSF    03.5
09E0:  MOVWF  2B
09E1:  MOVF   78,W
09E2:  MOVWF  2A
09E3:  GOTO   161
....................    } 
....................    if(s1==sc) 
09E4:  MOVF   26,W
09E5:  SUBWF  28,W
09E6:  BTFSS  03.2
09E7:  GOTO   1FF
09E8:  MOVF   27,W
09E9:  SUBWF  29,W
09EA:  BTFSS  03.2
09EB:  GOTO   1FF
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
09EC:  MOVF   23,W
09ED:  IORWF  24,W
09EE:  BTFSC  03.2
09EF:  GOTO   1FB
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
09F0:  MOVF   23,W
09F1:  MOVWF  04
09F2:  BCF    03.7
09F3:  BTFSC  24.0
09F4:  BSF    03.7
09F5:  INCF   04,F
09F6:  MOVF   22,W
09F7:  MOVWF  00
09F8:  DECF   04,F
09F9:  MOVF   21,W
09FA:  MOVWF  00
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
09FB:  MOVLW  00
09FC:  MOVWF  78
09FD:  MOVWF  79
09FE:  GOTO   212
....................    } 
....................    if (endptr) 
09FF:  MOVF   23,W
0A00:  IORWF  24,W
0A01:  BTFSC  03.2
0A02:  GOTO   20E
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
0A03:  MOVF   23,W
0A04:  MOVWF  04
0A05:  BCF    03.7
0A06:  BTFSC  24.0
0A07:  BSF    03.7
0A08:  INCF   04,F
0A09:  MOVF   27,W
0A0A:  MOVWF  00
0A0B:  DECF   04,F
0A0C:  MOVF   26,W
0A0D:  MOVWF  00
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
0A0E:  MOVF   2C,W
0A0F:  MOVWF  78
0A10:  MOVF   2D,W
0A11:  MOVWF  79
0A12:  BCF    03.5
0A13:  RETURN
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... void saveUser(int * id, int * pass, int status){ 
....................    printf (lcd_escreve,"\r\nid[0]:%u",id[0]); 
*
0BFF:  MOVF   72,W
0C00:  MOVWF  04
0C01:  BCF    03.7
0C02:  BTFSC  73.0
0C03:  BSF    03.7
0C04:  MOVF   00,W
0C05:  MOVWF  7C
0C06:  MOVLW  60
0C07:  BSF    03.6
0C08:  MOVWF  0D
0C09:  MOVLW  00
0C0A:  MOVWF  0F
0C0B:  BCF    03.0
0C0C:  MOVLW  08
0C0D:  BSF    03.5
0C0E:  BCF    03.6
0C0F:  MOVWF  2C
0C10:  BCF    0A.3
0C11:  BCF    03.5
0C12:  CALL   5FD
0C13:  BSF    0A.3
0C14:  MOVF   7C,W
0C15:  BSF    03.5
0C16:  MOVWF  2C
0C17:  MOVLW  1B
0C18:  MOVWF  2D
0C19:  BCF    0A.3
0C1A:  BCF    03.5
0C1B:  CALL   7A9
0C1C:  BSF    0A.3
....................    delay_ms(1000); 
0C1D:  MOVLW  04
0C1E:  MOVWF  7C
0C1F:  MOVLW  FA
0C20:  BSF    03.5
0C21:  MOVWF  31
0C22:  BCF    0A.3
0C23:  BCF    03.5
0C24:  CALL   154
0C25:  BSF    0A.3
0C26:  DECFSZ 7C,F
0C27:  GOTO   41F
....................    if( id[0] < 256 && id[1] < 256 && getAddressByID(id) > -1 ){ 
0C28:  MOVF   72,W
0C29:  MOVWF  04
0C2A:  BCF    03.7
0C2B:  BTFSC  73.0
0C2C:  BSF    03.7
0C2D:  MOVLW  01
0C2E:  ADDWF  72,W
0C2F:  MOVWF  04
0C30:  BCF    03.7
0C31:  BTFSC  73.0
0C32:  BSF    03.7
0C33:  MOVF   73,W
0C34:  BSF    03.5
0C35:  MOVWF  28
0C36:  MOVF   72,W
0C37:  MOVWF  27
....................       int address = lastNewUserPosition(); 
....................       //recebe os parÃ¢metros do usuÃ¡rio 
....................       User user; 
*
0D49:  MOVF   78,W
0D4A:  MOVWF  7B
....................       user.id[0] = id[0]; 
0D4B:  MOVF   72,W
0D4C:  MOVWF  04
0D4D:  BCF    03.7
0D4E:  BTFSC  73.0
0D4F:  BSF    03.7
0D50:  MOVF   00,W
0D51:  MOVWF  20
....................       user.id[1] = id[1]; 
0D52:  MOVLW  01
0D53:  ADDWF  72,W
0D54:  MOVWF  04
0D55:  BCF    03.7
0D56:  BTFSC  73.0
0D57:  BSF    03.7
0D58:  MOVF   00,W
0D59:  MOVWF  21
....................       user.pass[0] = pass[0]; 
0D5A:  MOVF   74,W
0D5B:  MOVWF  04
0D5C:  BCF    03.7
0D5D:  BTFSC  75.0
0D5E:  BSF    03.7
0D5F:  MOVF   00,W
0D60:  MOVWF  22
....................       user.pass[1] = pass[1]; 
0D61:  MOVLW  01
0D62:  ADDWF  74,W
0D63:  MOVWF  04
0D64:  BCF    03.7
0D65:  BTFSC  75.0
0D66:  BSF    03.7
0D67:  MOVF   00,W
0D68:  MOVWF  23
....................       user.pass[2] = pass[2]; 
0D69:  MOVLW  02
0D6A:  ADDWF  74,W
0D6B:  MOVWF  04
0D6C:  BCF    03.7
0D6D:  BTFSC  75.0
0D6E:  BSF    03.7
0D6F:  MOVF   00,W
0D70:  MOVWF  24
....................       user.pass[3] = pass[3]; 
0D71:  MOVLW  03
0D72:  ADDWF  74,W
0D73:  MOVWF  04
0D74:  BCF    03.7
0D75:  BTFSC  75.0
0D76:  BSF    03.7
0D77:  MOVF   00,W
0D78:  MOVWF  25
....................       user.status = status; 
0D79:  MOVF   76,W
0D7A:  MOVWF  26
....................        
....................  
....................       //Corrigir isso, o endereÃ§o tem que ser "dinÃ¢mico" 
....................        
....................       write_ext_eeprom(address, user.id[0]); 
0D7B:  MOVF   7B,W
0D7C:  MOVWF  28
0D7D:  MOVF   20,W
0D7E:  MOVWF  29
0D7F:  BCF    0A.3
0D80:  BCF    03.5
0D81:  CALL   43A
0D82:  BSF    0A.3
....................       write_ext_eeprom(address+1, user.id[1]); 
0D83:  MOVLW  01
0D84:  ADDWF  7B,W
0D85:  MOVWF  7C
0D86:  BSF    03.5
0D87:  MOVWF  28
0D88:  MOVF   21,W
0D89:  MOVWF  29
0D8A:  BCF    0A.3
0D8B:  BCF    03.5
0D8C:  CALL   43A
0D8D:  BSF    0A.3
....................       write_ext_eeprom(address+2, user.pass[0]); 
0D8E:  MOVLW  02
0D8F:  ADDWF  7B,W
0D90:  MOVWF  7C
0D91:  BSF    03.5
0D92:  MOVWF  28
0D93:  MOVF   22,W
0D94:  MOVWF  29
0D95:  BCF    0A.3
0D96:  BCF    03.5
0D97:  CALL   43A
0D98:  BSF    0A.3
....................       write_ext_eeprom(address+3, user.pass[1]); 
0D99:  MOVLW  03
0D9A:  ADDWF  7B,W
0D9B:  MOVWF  7C
0D9C:  BSF    03.5
0D9D:  MOVWF  28
0D9E:  MOVF   23,W
0D9F:  MOVWF  29
0DA0:  BCF    0A.3
0DA1:  BCF    03.5
0DA2:  CALL   43A
0DA3:  BSF    0A.3
....................       write_ext_eeprom(address+4, user.pass[2]); 
0DA4:  MOVLW  04
0DA5:  ADDWF  7B,W
0DA6:  MOVWF  7C
0DA7:  BSF    03.5
0DA8:  MOVWF  28
0DA9:  MOVF   24,W
0DAA:  MOVWF  29
0DAB:  BCF    0A.3
0DAC:  BCF    03.5
0DAD:  CALL   43A
0DAE:  BSF    0A.3
....................       write_ext_eeprom(address+5, user.pass[3]);        
0DAF:  MOVLW  05
0DB0:  ADDWF  7B,W
0DB1:  MOVWF  7C
0DB2:  BSF    03.5
0DB3:  MOVWF  28
0DB4:  MOVF   25,W
0DB5:  MOVWF  29
0DB6:  BCF    0A.3
0DB7:  BCF    03.5
0DB8:  CALL   43A
0DB9:  BSF    0A.3
....................       write_ext_eeprom(address+6, user.status); 
0DBA:  MOVLW  06
0DBB:  ADDWF  7B,W
0DBC:  MOVWF  7C
0DBD:  BSF    03.5
0DBE:  MOVWF  28
0DBF:  MOVF   26,W
0DC0:  MOVWF  29
0DC1:  BCF    0A.3
0DC2:  BCF    03.5
0DC3:  CALL   43A
0DC4:  BSF    0A.3
....................     
....................  
....................       printf (lcd_escreve,"\fUsuario Cadastrado"); 
0DC5:  MOVLW  66
0DC6:  BSF    03.6
0DC7:  MOVWF  0D
0DC8:  MOVLW  00
0DC9:  MOVWF  0F
0DCA:  BCF    0A.3
0DCB:  BCF    03.6
0DCC:  CALL   24E
0DCD:  BSF    0A.3
....................       delay_ms(500); 
0DCE:  MOVLW  02
0DCF:  MOVWF  7C
0DD0:  MOVLW  FA
0DD1:  BSF    03.5
0DD2:  MOVWF  31
0DD3:  BCF    0A.3
0DD4:  BCF    03.5
0DD5:  CALL   154
0DD6:  BSF    0A.3
0DD7:  DECFSZ 7C,F
0DD8:  GOTO   5D0
....................  
....................    }else{ 
....................       printf (lcd_escreve,"\fID incompativel"); 
....................       printf (lcd_escreve,"\r\nTente novamente"); 
....................       delay_ms(1000); 
....................  
....................    } 
.................... } 
....................  
.................... void printUser(){ 
....................    //delay_ms(50); 
....................    int tmp_result = read_ext_eeprom(0);   
....................     
....................    delay_ms(50);   
....................     
....................    printf (lcd_escreve,"\f Button: %d", tmp_result); 
....................    printf(lcd_escreve, "\r\nPw:%d%d%d%d St:%d %d", read_ext_eeprom(1), read_ext_eeprom(2), read_ext_eeprom(3), read_ext_eeprom(4), read_ext_eeprom(5), read_ext_eeprom(6)); 
....................     
....................    //printf(lcd_escreve, "\f Client () elseÂ´{}{} 
....................    // printf(lcd_escreve, "\r\nPw:%c%c%c%c St:%c %c", U1.pass[0], U1.pass[1], U1.pass[2], U1.pass[3], U1.status, U1.type_usr); 
.................... } 
....................  
.................... int getAddressByID(int * id){ 
*
0C38:  CLRF   2B
....................    int id_temp[2]; 
....................    int address = 0; 
....................     
....................    while( read_ext_eeprom(address) != -1){ 
0C39:  MOVF   2B,W
0C3A:  MOVWF  2D
0C3B:  BCF    0A.3
0C3C:  BCF    03.5
0C3D:  CALL   36A
0C3E:  BSF    0A.3
0C3F:  MOVF   78,W
0C40:  SUBLW  FF
0C41:  BTFSC  03.2
0C42:  GOTO   49F
....................       id_temp[0] = read_ext_eeprom(address); 
0C43:  BSF    03.5
0C44:  MOVF   2B,W
0C45:  MOVWF  2D
0C46:  BCF    0A.3
0C47:  BCF    03.5
0C48:  CALL   36A
0C49:  BSF    0A.3
0C4A:  MOVF   78,W
0C4B:  BSF    03.5
0C4C:  MOVWF  29
....................       id_temp[1] = read_ext_eeprom(address+1); 
0C4D:  MOVLW  01
0C4E:  ADDWF  2B,W
0C4F:  MOVWF  2C
0C50:  MOVWF  2D
0C51:  BCF    0A.3
0C52:  BCF    03.5
0C53:  CALL   36A
0C54:  BSF    0A.3
0C55:  MOVF   78,W
0C56:  BSF    03.5
0C57:  MOVWF  2A
....................        
....................       if (id_temp[0] == id[0] && id_temp[1] == id[1]){ 
0C58:  MOVF   27,W
0C59:  MOVWF  04
0C5A:  BCF    03.7
0C5B:  BTFSC  28.0
0C5C:  BSF    03.7
0C5D:  MOVF   00,W
0C5E:  SUBWF  29,W
0C5F:  BTFSS  03.2
0C60:  GOTO   49B
0C61:  MOVLW  01
0C62:  ADDWF  27,W
0C63:  MOVWF  04
0C64:  BCF    03.7
0C65:  BTFSC  28.0
0C66:  BSF    03.7
0C67:  MOVF   00,W
0C68:  SUBWF  2A,W
0C69:  BTFSS  03.2
0C6A:  GOTO   49B
....................          printf (lcd_escreve,"\fID Encontrado:%u%u", id_temp[0],id_temp[1]); 
0C6B:  MOVLW  95
0C6C:  BCF    03.5
0C6D:  BSF    03.6
0C6E:  MOVWF  0D
0C6F:  MOVLW  00
0C70:  MOVWF  0F
0C71:  BCF    03.0
0C72:  MOVLW  0F
0C73:  BSF    03.5
0C74:  BCF    03.6
0C75:  MOVWF  2C
0C76:  BCF    0A.3
0C77:  BCF    03.5
0C78:  CALL   5FD
0C79:  BSF    0A.3
0C7A:  BSF    03.5
0C7B:  MOVF   29,W
0C7C:  MOVWF  2C
0C7D:  MOVLW  1B
0C7E:  MOVWF  2D
0C7F:  BCF    0A.3
0C80:  BCF    03.5
0C81:  CALL   7A9
0C82:  BSF    0A.3
0C83:  BSF    03.5
0C84:  MOVF   2A,W
0C85:  MOVWF  2C
0C86:  MOVLW  1B
0C87:  MOVWF  2D
0C88:  BCF    0A.3
0C89:  BCF    03.5
0C8A:  CALL   7A9
0C8B:  BSF    0A.3
....................          delay_ms(1000); 
0C8C:  MOVLW  04
0C8D:  BSF    03.5
0C8E:  MOVWF  2C
0C8F:  MOVLW  FA
0C90:  MOVWF  31
0C91:  BCF    0A.3
0C92:  BCF    03.5
0C93:  CALL   154
0C94:  BSF    0A.3
0C95:  BSF    03.5
0C96:  DECFSZ 2C,F
0C97:  GOTO   48F
....................          return address; 
0C98:  MOVF   2B,W
0C99:  MOVWF  78
0C9A:  GOTO   4AB
....................       } 
....................  
....................       address += BLOCK_SIZE;  
0C9B:  MOVLW  07
0C9C:  ADDWF  2B,F
0C9D:  GOTO   439
0C9E:  BCF    03.5
....................    } 
....................    printf (lcd_escreve,"\f ID N Encontrado"); 
0C9F:  MOVLW  9F
0CA0:  BSF    03.6
0CA1:  MOVWF  0D
0CA2:  MOVLW  00
0CA3:  MOVWF  0F
0CA4:  BCF    0A.3
0CA5:  BCF    03.6
0CA6:  CALL   24E
0CA7:  BSF    0A.3
....................    return -1; 
0CA8:  MOVLW  FF
0CA9:  MOVWF  78
0CAA:  BSF    03.5
....................     
.................... } 
....................  
.................... void erase_program_eeprom(int addrr){ 
....................    for(int i=0; i < BLOCK_SIZE; i++){ 
*
0496:  CLRF   57
0497:  MOVF   57,W
0498:  SUBLW  06
0499:  BTFSS  03.0
049A:  GOTO   4A6
....................          write_ext_eeprom(addrr + i, -1); 
049B:  MOVF   57,W
049C:  ADDWF  56,W
049D:  MOVWF  58
049E:  BSF    03.5
049F:  MOVWF  28
04A0:  MOVLW  FF
04A1:  MOVWF  29
04A2:  BCF    03.5
04A3:  CALL   43A
04A4:  INCF   57,F
04A5:  GOTO   497
....................    }   
....................    printf (lcd_escreve,"\f User erased "); 
04A6:  MOVLW  A8
04A7:  BSF    03.6
04A8:  MOVWF  0D
04A9:  MOVLW  00
04AA:  MOVWF  0F
04AB:  BCF    03.6
04AC:  CALL   24E
....................    delay_ms(500); 
04AD:  MOVLW  02
04AE:  MOVWF  58
04AF:  MOVLW  FA
04B0:  BSF    03.5
04B1:  MOVWF  31
04B2:  BCF    03.5
04B3:  CALL   154
04B4:  DECFSZ 58,F
04B5:  GOTO   4AF
.................... } 
....................  
.................... int deleteUser(int8 address){ 
....................     
....................    int data_temp; 
....................    int previous_block = address; 
....................    int next_block = address + BLOCK_SIZE; 
....................  
....................    //Case 1: without next block 
....................    if (read_ext_eeprom(next_block) == -1){ 
....................       erase_program_eeprom(previous_block);       
....................       return 1; 
....................    } 
....................  
....................    //Case 2: Check whether the data in the address is empty 
....................    while(read_ext_eeprom(next_block) != -1){ 
....................       //data_temp[index] = read_ext_eeprom(address); 
....................       for(int i=0; i < BLOCK_SIZE; i++){ 
....................          data_temp = read_ext_eeprom(next_block + i);            
....................          write_ext_eeprom(previous_block + i, data_temp);    //overwrite delete block 
....................       }   
....................  
....................       previous_block = next_block; 
....................       next_block += BLOCK_SIZE; 
....................    } 
....................     
....................    next_block -= BLOCK_SIZE; 
....................     
....................    //Erase last block   
....................    erase_program_eeprom(next_block); 
....................     
....................    return 1; 
....................  
.................... } 
....................  
.................... int lastNewUserPosition(){ 
*
0CAB:  CLRF   27
....................    int address = 0; 
....................    int id_temp; 
....................  
....................    while( read_ext_eeprom(address) != -1){ 
0CAC:  MOVF   27,W
0CAD:  MOVWF  2D
0CAE:  BCF    0A.3
0CAF:  BCF    03.5
0CB0:  CALL   36A
0CB1:  BSF    0A.3
0CB2:  MOVF   78,W
0CB3:  SUBLW  FF
0CB4:  BTFSC  03.2
0CB5:  GOTO   4BB
....................       address += BLOCK_SIZE;  
0CB6:  MOVLW  07
0CB7:  BSF    03.5
0CB8:  ADDWF  27,F
0CB9:  GOTO   4AC
0CBA:  BCF    03.5
....................    } 
....................    printf (lcd_escreve,"\fAddress: %d", address); 
0CBB:  MOVLW  B0
0CBC:  BSF    03.6
0CBD:  MOVWF  0D
0CBE:  MOVLW  00
0CBF:  MOVWF  0F
0CC0:  BCF    03.0
0CC1:  MOVLW  0A
0CC2:  BSF    03.5
0CC3:  BCF    03.6
0CC4:  MOVWF  2C
0CC5:  BCF    0A.3
0CC6:  BCF    03.5
0CC7:  CALL   5FD
0CC8:  BSF    0A.3
0CC9:  BSF    03.5
0CCA:  MOVF   27,W
0CCB:  MOVWF  29
0CCC:  MOVLW  18
0CCD:  MOVWF  2A
....................    delay_ms(1000); 
*
0D3B:  MOVLW  04
0D3C:  BSF    03.5
0D3D:  MOVWF  29
0D3E:  MOVLW  FA
0D3F:  MOVWF  31
0D40:  BCF    0A.3
0D41:  BCF    03.5
0D42:  CALL   154
0D43:  BSF    0A.3
0D44:  BSF    03.5
0D45:  DECFSZ 29,F
0D46:  GOTO   53E
....................     
....................    return address; 
0D47:  MOVF   27,W
0D48:  MOVWF  78
....................  
.................... } 
....................  
.................... int isIdAvailable(int * id){ 
....................    unsigned int address = 0; 
....................    int id_temp; 
....................    while( read_ext_eeprom(address) != -1){ 
....................       id_temp = read_ext_eeprom(address); 
....................       if (id_temp == id){ 
....................           printf (lcd_escreve,"\fID:%u, Existe", id_temp); 
....................           delay_ms(1000); 
....................          return 0;//Sucessful 
....................       } 
....................  
....................       address += BLOCK_SIZE;  
....................    } 
....................    printf (lcd_escreve,"\fID:%u, N Existe", id_temp); 
....................    delay_ms(1000); 
....................    return -1; 
.................... } 
....................  
.................... void resetMemory(){ 
*
048A:  CLRF   55
....................    int address = 0; 
....................    for(; read_ext_eeprom(address) != -1; 
048B:  MOVF   55,W
048C:  BSF    03.5
048D:  MOVWF  2D
048E:  BCF    03.5
048F:  CALL   36A
0490:  MOVF   78,W
0491:  SUBLW  FF
0492:  BTFSC  03.2
0493:  GOTO   4B9
....................     erase_program_eeprom(address), address += BLOCK_SIZE); 
0494:  MOVF   55,W
0495:  MOVWF  56
*
04B6:  MOVLW  07
04B7:  ADDWF  55,F
04B8:  GOTO   48B
04B9:  BSF    0A.3
04BA:  BCF    0A.4
04BB:  GOTO   637 (RETURN)
.................... } 
....................  
.................... void adminMenu(){ 
....................  
....................  
....................   unsigned char keyboard_buffer[BLOCK_SIZE * 2]; 
....................   unsigned char option; 
....................    // printf(lcd_escreve,"\f1: CAD Cliente "); 
....................    // delay_ms(500); 
....................    // printf(lcd_escreve,"\r\n2: DEL Cliente"); 
....................    // delay_ms(500); 
....................    // printf(lcd_escreve,"\f3: Buscar Cliente "); 
....................    // delay_ms(500); 
....................    // printf(lcd_escreve,"\r\n4: Editar Cliente"); 
....................    // delay_ms(500); 
....................    // printf(lcd_escreve,"\f5: SAIR do Menu "); 
....................    // delay_ms(500); 
....................   do{ 
....................      
....................      option = readKeyboard(); 
*
0A14:  BCF    0A.3
0A15:  CALL   4BC
0A16:  BSF    0A.3
0A17:  MOVF   78,W
0A18:  MOVWF  63
....................      printf(lcd_escreve,"\f Option: %c", option); 
0A19:  MOVLW  C8
0A1A:  BSF    03.6
0A1B:  MOVWF  0D
0A1C:  MOVLW  00
0A1D:  MOVWF  0F
0A1E:  BCF    03.0
0A1F:  MOVLW  0A
0A20:  BSF    03.5
0A21:  BCF    03.6
0A22:  MOVWF  2C
0A23:  BCF    0A.3
0A24:  BCF    03.5
0A25:  CALL   5FD
0A26:  BSF    0A.3
0A27:  MOVF   63,W
0A28:  BSF    03.5
0A29:  MOVWF  30
0A2A:  BCF    0A.3
0A2B:  BCF    03.5
0A2C:  CALL   20B
0A2D:  BSF    0A.3
....................      delay_ms(500); 
0A2E:  MOVLW  02
0A2F:  MOVWF  72
0A30:  MOVLW  FA
0A31:  BSF    03.5
0A32:  MOVWF  31
0A33:  BCF    0A.3
0A34:  BCF    03.5
0A35:  CALL   154
0A36:  BSF    0A.3
0A37:  DECFSZ 72,F
0A38:  GOTO   230
....................  
....................  
....................     switch(option){ 
0A39:  MOVF   63,W
0A3A:  XORLW  31
0A3B:  BTFSC  03.2
0A3C:  GOTO   247
0A3D:  XORLW  33
0A3E:  BTFSC  03.2
0A3F:  GOTO   5DA
0A40:  XORLW  01
0A41:  BTFSC  03.2
0A42:  GOTO   5DB
0A43:  XORLW  07
0A44:  BTFSC  03.2
0A45:  GOTO   5DC
0A46:  GOTO   5DD
....................        case '1': 
....................          unsigned int * temp; 
....................          unsigned int pass[4]; 
....................          int * id; 
....................          unsigned int status; 
....................          int i = 0; 
0A47:  CLRF   6D
....................            //The user needs to type 4 digits 
....................            //For example, even if it's just 9 
....................            //He/she will type: 0009 
....................            while(i < 5){ 
0A48:  MOVF   6D,W
0A49:  SUBLW  04
0A4A:  BTFSS  03.0
0A4B:  GOTO   297
....................  
....................             printf(lcd_escreve,"\fDigite o ID"); 
0A4C:  MOVLW  CF
0A4D:  BSF    03.6
0A4E:  MOVWF  0D
0A4F:  MOVLW  00
0A50:  MOVWF  0F
0A51:  BCF    0A.3
0A52:  BCF    03.6
0A53:  CALL   24E
0A54:  BSF    0A.3
....................             delay_ms(50); 
0A55:  MOVLW  32
0A56:  BSF    03.5
0A57:  MOVWF  31
0A58:  BCF    0A.3
0A59:  BCF    03.5
0A5A:  CALL   154
0A5B:  BSF    0A.3
....................             option = readKeyboard(); 
0A5C:  BCF    0A.3
0A5D:  CALL   4BC
0A5E:  BSF    0A.3
0A5F:  MOVF   78,W
0A60:  MOVWF  63
....................             printf(lcd_escreve,"\fTyped ID:%c", option); 
0A61:  MOVLW  D6
0A62:  BSF    03.6
0A63:  MOVWF  0D
0A64:  MOVLW  00
0A65:  MOVWF  0F
0A66:  BCF    03.0
0A67:  MOVLW  0A
0A68:  BSF    03.5
0A69:  BCF    03.6
0A6A:  MOVWF  2C
0A6B:  BCF    0A.3
0A6C:  BCF    03.5
0A6D:  CALL   5FD
0A6E:  BSF    0A.3
0A6F:  MOVF   63,W
0A70:  BSF    03.5
0A71:  MOVWF  30
0A72:  BCF    0A.3
0A73:  BCF    03.5
0A74:  CALL   20B
0A75:  BSF    0A.3
....................             delay_ms(500); 
0A76:  MOVLW  02
0A77:  MOVWF  72
0A78:  MOVLW  FA
0A79:  BSF    03.5
0A7A:  MOVWF  31
0A7B:  BCF    0A.3
0A7C:  BCF    03.5
0A7D:  CALL   154
0A7E:  BSF    0A.3
0A7F:  DECFSZ 72,F
0A80:  GOTO   278
....................             if(option != 255){ 
0A81:  INCFSZ 63,W
0A82:  GOTO   284
0A83:  GOTO   296
....................                if(i == 2){ 
0A84:  MOVF   6D,W
0A85:  SUBLW  02
0A86:  BTFSS  03.2
0A87:  GOTO   28F
....................                   //To convert to int will be easier with space between them 
....................                   keyboard_buffer[i] = ' '; 
0A88:  MOVLW  55
0A89:  ADDWF  6D,W
0A8A:  MOVWF  04
0A8B:  BCF    03.7
0A8C:  MOVLW  20
0A8D:  MOVWF  00
....................                   i++; 
0A8E:  INCF   6D,F
....................                } 
....................                keyboard_buffer[i] = option; 
0A8F:  MOVLW  55
0A90:  ADDWF  6D,W
0A91:  MOVWF  04
0A92:  BCF    03.7
0A93:  MOVF   63,W
0A94:  MOVWF  00
....................                i++; 
0A95:  INCF   6D,F
....................             } 
0A96:  GOTO   248
....................            } 
....................             // unsigned char *id; 
....................             // id = keyboard_buffer; 
....................             id = strToInt(keyboard_buffer); 
0A97:  CLRF   73
0A98:  MOVLW  55
0A99:  MOVWF  72
0A9A:  BCF    0A.3
0A9B:  CALL   6A2
0A9C:  BSF    0A.3
0A9D:  MOVF   79,W
0A9E:  MOVWF  6B
0A9F:  MOVF   78,W
0AA0:  MOVWF  6A
....................             //https://www.tutorialspoint.com/cprogramming/c_pointer_to_an_array.htm 
....................             //*(id+1) == id[1] 
....................             printf(lcd_escreve,"\fid: %u%u",id[0],id[1]); 
0AA1:  MOVF   6A,W
0AA2:  MOVWF  04
0AA3:  BCF    03.7
0AA4:  BTFSC  6B.0
0AA5:  BSF    03.7
0AA6:  MOVF   00,W
0AA7:  MOVWF  72
0AA8:  MOVLW  01
0AA9:  ADDWF  6A,W
0AAA:  MOVWF  04
0AAB:  BCF    03.7
0AAC:  BTFSC  6B.0
0AAD:  BSF    03.7
0AAE:  MOVF   00,W
0AAF:  MOVWF  73
0AB0:  MOVLW  DD
0AB1:  BSF    03.6
0AB2:  MOVWF  0D
0AB3:  MOVLW  00
0AB4:  MOVWF  0F
0AB5:  BCF    03.0
0AB6:  MOVLW  05
0AB7:  BSF    03.5
0AB8:  BCF    03.6
0AB9:  MOVWF  2C
0ABA:  BCF    0A.3
0ABB:  BCF    03.5
0ABC:  CALL   5FD
0ABD:  BSF    0A.3
0ABE:  MOVF   72,W
0ABF:  BSF    03.5
0AC0:  MOVWF  2C
0AC1:  MOVLW  1B
0AC2:  MOVWF  2D
0AC3:  BCF    0A.3
0AC4:  BCF    03.5
0AC5:  CALL   7A9
0AC6:  BSF    0A.3
0AC7:  MOVF   73,W
0AC8:  BSF    03.5
0AC9:  MOVWF  2C
0ACA:  MOVLW  1B
0ACB:  MOVWF  2D
0ACC:  BCF    0A.3
0ACD:  BCF    03.5
0ACE:  CALL   7A9
0ACF:  BSF    0A.3
....................             delay_ms(1000); 
0AD0:  MOVLW  04
0AD1:  MOVWF  72
0AD2:  MOVLW  FA
0AD3:  BSF    03.5
0AD4:  MOVWF  31
0AD5:  BCF    0A.3
0AD6:  BCF    03.5
0AD7:  CALL   154
0AD8:  BSF    0A.3
0AD9:  DECFSZ 72,F
0ADA:  GOTO   2D2
....................        
....................          //password 
....................  
....................          i = 0; 
0ADB:  CLRF   6D
....................            while(i < 4){ 
0ADC:  MOVF   6D,W
0ADD:  SUBLW  03
0ADE:  BTFSS  03.0
0ADF:  GOTO   340
....................  
....................             printf(lcd_escreve,"\fDigite a senha"); 
0AE0:  MOVLW  E2
0AE1:  BSF    03.6
0AE2:  MOVWF  0D
0AE3:  MOVLW  00
0AE4:  MOVWF  0F
0AE5:  BCF    0A.3
0AE6:  BCF    03.6
0AE7:  CALL   24E
0AE8:  BSF    0A.3
....................             delay_ms(50); 
0AE9:  MOVLW  32
0AEA:  BSF    03.5
0AEB:  MOVWF  31
0AEC:  BCF    0A.3
0AED:  BCF    03.5
0AEE:  CALL   154
0AEF:  BSF    0A.3
....................             option = readKeyboard(); 
0AF0:  BCF    0A.3
0AF1:  CALL   4BC
0AF2:  BSF    0A.3
0AF3:  MOVF   78,W
0AF4:  MOVWF  63
....................             printf(lcd_escreve,"\fTyped Pass:%c", option); 
0AF5:  MOVLW  EA
0AF6:  BSF    03.6
0AF7:  MOVWF  0D
0AF8:  MOVLW  00
0AF9:  MOVWF  0F
0AFA:  BCF    03.0
0AFB:  MOVLW  0C
0AFC:  BSF    03.5
0AFD:  BCF    03.6
0AFE:  MOVWF  2C
0AFF:  BCF    0A.3
0B00:  BCF    03.5
0B01:  CALL   5FD
0B02:  BSF    0A.3
0B03:  MOVF   63,W
0B04:  BSF    03.5
0B05:  MOVWF  30
0B06:  BCF    0A.3
0B07:  BCF    03.5
0B08:  CALL   20B
0B09:  BSF    0A.3
....................             delay_ms(500); 
0B0A:  MOVLW  02
0B0B:  MOVWF  72
0B0C:  MOVLW  FA
0B0D:  BSF    03.5
0B0E:  MOVWF  31
0B0F:  BCF    0A.3
0B10:  BCF    03.5
0B11:  CALL   154
0B12:  BSF    0A.3
0B13:  DECFSZ 72,F
0B14:  GOTO   30C
....................             if(option != 255){ 
0B15:  INCFSZ 63,W
0B16:  GOTO   318
0B17:  GOTO   33F
....................                // keyboard_buffer[i] = option; 
....................                unsigned char destination[2]; 
....................                //Convert string from char and return  
....................                //to the left array of char(str_pass) 
....................                strfromchar(destination,option); 
0B18:  CLRF   73
0B19:  MOVLW  6E
0B1A:  MOVWF  72
0B1B:  MOVF   63,W
0B1C:  MOVWF  74
0B1D:  BCF    0A.3
0B1E:  CALL   7E8
0B1F:  BSF    0A.3
....................                temp = strToInt(destination); 
0B20:  CLRF   73
0B21:  MOVLW  6E
0B22:  MOVWF  72
0B23:  BCF    0A.3
0B24:  CALL   6A2
0B25:  BSF    0A.3
0B26:  MOVF   79,W
0B27:  MOVWF  65
0B28:  MOVF   78,W
0B29:  MOVWF  64
....................                pass[i] = temp[0]; 
0B2A:  MOVLW  66
0B2B:  ADDWF  6D,W
0B2C:  MOVWF  72
0B2D:  CLRF   73
0B2E:  BTFSC  03.0
0B2F:  INCF   73,F
0B30:  MOVF   64,W
0B31:  MOVWF  04
0B32:  BCF    03.7
0B33:  BTFSC  65.0
0B34:  BSF    03.7
0B35:  MOVF   00,W
0B36:  MOVWF  74
0B37:  MOVF   72,W
0B38:  MOVWF  04
0B39:  BCF    03.7
0B3A:  BTFSC  73.0
0B3B:  BSF    03.7
0B3C:  MOVF   74,W
0B3D:  MOVWF  00
....................                i++; 
0B3E:  INCF   6D,F
....................             } 
0B3F:  GOTO   2DC
....................            } 
....................             printf(lcd_escreve,"\fPASS(4): %u%u%u%u",pass[0],pass[1],pass[2],pass[3]); 
0B40:  MOVLW  F2
0B41:  BSF    03.6
0B42:  MOVWF  0D
0B43:  MOVLW  00
0B44:  MOVWF  0F
0B45:  BCF    03.0
0B46:  MOVLW  0A
0B47:  BSF    03.5
0B48:  BCF    03.6
0B49:  MOVWF  2C
0B4A:  BCF    0A.3
0B4B:  BCF    03.5
0B4C:  CALL   5FD
0B4D:  BSF    0A.3
0B4E:  MOVF   66,W
0B4F:  BSF    03.5
0B50:  MOVWF  2C
0B51:  MOVLW  1B
0B52:  MOVWF  2D
0B53:  BCF    0A.3
0B54:  BCF    03.5
0B55:  CALL   7A9
0B56:  BSF    0A.3
0B57:  MOVF   67,W
0B58:  BSF    03.5
0B59:  MOVWF  2C
0B5A:  MOVLW  1B
0B5B:  MOVWF  2D
0B5C:  BCF    0A.3
0B5D:  BCF    03.5
0B5E:  CALL   7A9
0B5F:  BSF    0A.3
0B60:  MOVF   68,W
0B61:  BSF    03.5
0B62:  MOVWF  2C
0B63:  MOVLW  1B
0B64:  MOVWF  2D
0B65:  BCF    0A.3
0B66:  BCF    03.5
0B67:  CALL   7A9
0B68:  BSF    0A.3
0B69:  MOVF   69,W
0B6A:  BSF    03.5
0B6B:  MOVWF  2C
0B6C:  MOVLW  1B
0B6D:  MOVWF  2D
0B6E:  BCF    0A.3
0B6F:  BCF    03.5
0B70:  CALL   7A9
0B71:  BSF    0A.3
....................             delay_ms(1000); 
0B72:  MOVLW  04
0B73:  MOVWF  72
0B74:  MOVLW  FA
0B75:  BSF    03.5
0B76:  MOVWF  31
0B77:  BCF    0A.3
0B78:  BCF    03.5
0B79:  CALL   154
0B7A:  BSF    0A.3
0B7B:  DECFSZ 72,F
0B7C:  GOTO   374
....................  
....................  
....................          i = 0; 
0B7D:  CLRF   6D
....................            while(i < 1){ 
0B7E:  MOVF   6D,F
0B7F:  BTFSS  03.2
0B80:  GOTO   3D4
....................  
....................             printf(lcd_escreve,"\fStatus(0,1,3):"); 
0B81:  MOVLW  FC
0B82:  BSF    03.6
0B83:  MOVWF  0D
0B84:  MOVLW  00
0B85:  MOVWF  0F
0B86:  BCF    0A.3
0B87:  BCF    03.6
0B88:  CALL   24E
0B89:  BSF    0A.3
....................             delay_ms(50); 
0B8A:  MOVLW  32
0B8B:  BSF    03.5
0B8C:  MOVWF  31
0B8D:  BCF    0A.3
0B8E:  BCF    03.5
0B8F:  CALL   154
0B90:  BSF    0A.3
....................             option = readKeyboard(); 
0B91:  BCF    0A.3
0B92:  CALL   4BC
0B93:  BSF    0A.3
0B94:  MOVF   78,W
0B95:  MOVWF  63
....................             printf(lcd_escreve,"\fTyped Status:%c", option); 
0B96:  MOVLW  04
0B97:  BSF    03.6
0B98:  MOVWF  0D
0B99:  MOVLW  01
0B9A:  MOVWF  0F
0B9B:  BCF    03.0
0B9C:  MOVLW  0E
0B9D:  BSF    03.5
0B9E:  BCF    03.6
0B9F:  MOVWF  2C
0BA0:  BCF    0A.3
0BA1:  BCF    03.5
0BA2:  CALL   5FD
0BA3:  BSF    0A.3
0BA4:  MOVF   63,W
0BA5:  BSF    03.5
0BA6:  MOVWF  30
0BA7:  BCF    0A.3
0BA8:  BCF    03.5
0BA9:  CALL   20B
0BAA:  BSF    0A.3
....................             delay_ms(500); 
0BAB:  MOVLW  02
0BAC:  MOVWF  72
0BAD:  MOVLW  FA
0BAE:  BSF    03.5
0BAF:  MOVWF  31
0BB0:  BCF    0A.3
0BB1:  BCF    03.5
0BB2:  CALL   154
0BB3:  BSF    0A.3
0BB4:  DECFSZ 72,F
0BB5:  GOTO   3AD
....................             if(option != 255){ 
0BB6:  INCFSZ 63,W
0BB7:  GOTO   3B9
0BB8:  GOTO   3D3
....................                unsigned char destination[2]; 
....................                strfromchar(destination,option); 
0BB9:  CLRF   73
0BBA:  MOVLW  70
0BBB:  MOVWF  72
0BBC:  MOVF   63,W
0BBD:  MOVWF  74
0BBE:  BCF    0A.3
0BBF:  CALL   7E8
0BC0:  BSF    0A.3
....................                temp = strToInt(destination); 
0BC1:  CLRF   73
0BC2:  MOVLW  70
0BC3:  MOVWF  72
0BC4:  BCF    0A.3
0BC5:  CALL   6A2
0BC6:  BSF    0A.3
0BC7:  MOVF   79,W
0BC8:  MOVWF  65
0BC9:  MOVF   78,W
0BCA:  MOVWF  64
....................                status = temp[0];  
0BCB:  MOVF   64,W
0BCC:  MOVWF  04
0BCD:  BCF    03.7
0BCE:  BTFSC  65.0
0BCF:  BSF    03.7
0BD0:  MOVF   00,W
0BD1:  MOVWF  6C
....................                i++; 
0BD2:  INCF   6D,F
....................             } 
0BD3:  GOTO   37E
....................            } 
....................             printf(lcd_escreve,"\fSTATUS: %u",status); 
0BD4:  MOVLW  0D
0BD5:  BSF    03.6
0BD6:  MOVWF  0D
0BD7:  MOVLW  01
0BD8:  MOVWF  0F
0BD9:  BCF    03.0
0BDA:  MOVLW  09
0BDB:  BSF    03.5
0BDC:  BCF    03.6
0BDD:  MOVWF  2C
0BDE:  BCF    0A.3
0BDF:  BCF    03.5
0BE0:  CALL   5FD
0BE1:  BSF    0A.3
0BE2:  MOVF   6C,W
0BE3:  BSF    03.5
0BE4:  MOVWF  2C
0BE5:  MOVLW  1B
0BE6:  MOVWF  2D
0BE7:  BCF    0A.3
0BE8:  BCF    03.5
0BE9:  CALL   7A9
0BEA:  BSF    0A.3
....................             delay_ms(1000); 
0BEB:  MOVLW  04
0BEC:  MOVWF  72
0BED:  MOVLW  FA
0BEE:  BSF    03.5
0BEF:  MOVWF  31
0BF0:  BCF    0A.3
0BF1:  BCF    03.5
0BF2:  CALL   154
0BF3:  BSF    0A.3
0BF4:  DECFSZ 72,F
0BF5:  GOTO   3ED
....................  
....................  
....................             saveUser(id,pass,status); 
0BF6:  MOVF   6B,W
0BF7:  MOVWF  73
0BF8:  MOVF   6A,W
0BF9:  MOVWF  72
0BFA:  CLRF   75
0BFB:  MOVLW  66
0BFC:  MOVWF  74
0BFD:  MOVF   6C,W
0BFE:  MOVWF  76
....................             break; 
*
0DD9:  GOTO   5DD
....................        case 2: 
....................             // listar(); 
....................             break; 
0DDA:  GOTO   5DD
....................        case 3: 
....................             // mostrarMes(); 
....................             break; 
0DDB:  GOTO   5DD
....................        case 4: 
....................             //  printf("\nTENHA UM BOM DIA\n"); 
....................             break; 
0DDC:  GOTO   5DD
....................        default: 
....................             // printf("\nDIGITE UM VALOR VÃLIDO\n"); 
....................             break; 
....................  
....................       } 
....................    }while(option != 4);//sÃ³ termina quando for 4  
0DDD:  MOVF   63,W
0DDE:  SUBLW  04
0DDF:  BTFSS  03.2
0DE0:  GOTO   214
0DE1:  BSF    0A.3
0DE2:  BCF    0A.4
0DE3:  GOTO   639 (RETURN)
....................     
....................   
....................  
....................     
.................... } 
....................  
.................... unsigned char readKeyboard(){ 
....................    unsigned char tmp; 
....................    unsigned char tmp_result; 
....................     
....................    tmp = tc_tecla(1500); // ms 
*
04BC:  MOVLW  DC
04BD:  MOVWF  74
*
05ED:  MOVF   78,W
05EE:  MOVWF  72
....................    if(tmp != 255){ 
05EF:  INCFSZ 72,W
05F0:  GOTO   5F2
05F1:  GOTO   5F3
....................       // write_ext_eeprom(0, tmp); 
....................       // delay_ms(50); 
....................       // tmp_result = read_ext_eeprom(0); 
....................       // delay_ms(50); 
....................       // tmp_result = tmp; 
....................       // printf(lcd_escreve,"\f Button: %c", tmp); 
....................       // delay_ms(50); 
....................    }else{  
05F2:  GOTO   5FA
....................       printf(lcd_escreve,"\f   TECLADO  "); 
05F3:  MOVLW  13
05F4:  BSF    03.6
05F5:  MOVWF  0D
05F6:  MOVLW  01
05F7:  MOVWF  0F
05F8:  BCF    03.6
05F9:  CALL   24E
....................    } 
....................  
....................    return tmp; 
05FA:  MOVF   72,W
05FB:  MOVWF  78
05FC:  RETURN
.................... } 
....................  
....................  
.................... int * getAdminsID(){ 
....................  
....................    int address = 0; 
....................    int temp_status; 
....................    int index= 0; 
....................    static int admins[BLOCK_SIZE]; 
*
0DF8:  CLRF   44
0DF9:  CLRF   45
0DFA:  CLRF   46
0DFB:  CLRF   47
0DFC:  CLRF   48
0DFD:  CLRF   49
0DFE:  CLRF   4A
....................    admins[0] = -1; 
....................    while( read_ext_eeprom(address) != -1){ 
....................       temp_status = read_ext_eeprom(address + (BLOCK_SIZE - 1));//status of the user 
....................       if (temp_status == 3){ 
....................          printf (lcd_escreve,"\fAdmin Encontrado"); 
....................          delay_ms(1000); 
....................          for(int i=0; i < 2; i++){ 
....................             int id = read_ext_eeprom(address+i);    
....................             admins[index] = id; 
....................             index++; 
....................          } 
....................  
....................       } 
....................  
....................       address += BLOCK_SIZE;  
....................    } 
....................  
....................    return admins; 
....................  
.................... } 
....................  
.................... void listAdmins(){ 
....................    int * admins; 
....................  
....................    admins = getAdminsID(); 
....................    printf(lcd_escreve,"\f admins[0]: %d", admins[0]); 
....................    delay_ms(1000); 
....................    if(admins[0] != -1){ 
....................       for (int16 i=0; i < sizeof(admins); i+=2){ 
....................          printf(lcd_escreve, "\fid~:%u%u",admins[i], admins[i+1]); 
....................          delay_ms(1000); 
....................       }  
....................    } 
.................... } 
....................  
....................  
.................... int * strToInt(char * str){ 
*
06A2:  MOVF   73,W
06A3:  MOVWF  75
06A4:  MOVF   72,W
06A5:  MOVWF  74
....................  
....................   char *p = str; 
....................   //https://flaviocopes.com/c-array-length/ 
.................... //   int size = (sizeof str) / (sizeof * str); 
....................   static unsigned int buffer[BLOCK_SIZE];   
*
0DFF:  CLRF   4B
0E00:  CLRF   4C
0E01:  CLRF   4D
0E02:  CLRF   4E
0E03:  CLRF   4F
0E04:  CLRF   50
0E05:  CLRF   51
....................   printf(lcd_escreve,"\fParsing:%s",p ); 
*
06A6:  MOVLW  30
06A7:  BSF    03.6
06A8:  MOVWF  0D
06A9:  MOVLW  01
06AA:  MOVWF  0F
06AB:  BCF    03.0
06AC:  MOVLW  09
06AD:  BSF    03.5
06AE:  BCF    03.6
06AF:  MOVWF  2C
06B0:  BCF    03.5
06B1:  CALL   5FD
06B2:  MOVF   74,W
06B3:  MOVWF  04
06B4:  BCF    03.7
06B5:  BTFSC  75.0
06B6:  BSF    03.7
....................   delay_ms(1000); 
*
06D3:  MOVLW  04
06D4:  BSF    03.5
06D5:  MOVWF  20
06D6:  MOVLW  FA
06D7:  MOVWF  31
06D8:  BCF    03.5
06D9:  CALL   154
06DA:  BSF    03.5
06DB:  DECFSZ 20,F
06DC:  GOTO   6D6
....................   char * end; 
....................   int index = 0; 
06DD:  CLRF   76
....................  
....................   for (unsigned long number = strtoul(p, &end, 10); 
06DE:  MOVF   75,W
06DF:  MOVWF  22
06E0:  MOVF   74,W
06E1:  MOVWF  21
06E2:  CLRF   24
06E3:  MOVLW  7B
06E4:  MOVWF  23
06E5:  MOVLW  0A
06E6:  MOVWF  25
06E7:  BSF    0A.3
06E8:  BCF    03.5
06E9:  CALL   000
06EA:  BCF    0A.3
06EB:  MOVF   79,W
06EC:  MOVWF  7E
06ED:  MOVF   78,W
06EE:  MOVWF  7D
....................         p != end; 
06EF:  MOVF   7B,W
06F0:  SUBWF  74,W
06F1:  BTFSS  03.2
06F2:  GOTO   6F7
06F3:  MOVF   7C,W
06F4:  SUBWF  75,W
06F5:  BTFSC  03.2
06F6:  GOTO   78D
....................         number = strtoul(p, &end, 10)) 
....................   { 
....................     printf(lcd_escreve,"\n%lu",number ); 
06F7:  MOVLW  0A
06F8:  BSF    03.5
06F9:  MOVWF  30
06FA:  BCF    03.5
06FB:  CALL   20B
06FC:  MOVLW  10
06FD:  MOVWF  04
06FE:  MOVF   7E,W
06FF:  BSF    03.5
0700:  MOVWF  22
0701:  MOVF   7D,W
0702:  MOVWF  21
....................     delay_ms(700); 
*
0767:  MOVLW  04
0768:  MOVWF  20
0769:  MOVLW  AF
076A:  MOVWF  31
076B:  BCF    03.5
076C:  CALL   154
076D:  BSF    03.5
076E:  DECFSZ 20,F
076F:  GOTO   769
....................     p = end; 
0770:  MOVF   7C,W
0771:  MOVWF  75
0772:  MOVF   7B,W
0773:  MOVWF  74
....................  
....................     buffer[index] =  (int) number;  
0774:  MOVLW  4B
0775:  ADDWF  76,W
0776:  MOVWF  04
0777:  BCF    03.7
0778:  MOVF   7D,W
0779:  MOVWF  00
....................     index++; 
077A:  INCF   76,F
077B:  MOVF   75,W
077C:  MOVWF  22
077D:  MOVF   74,W
077E:  MOVWF  21
077F:  CLRF   24
0780:  MOVLW  7B
0781:  MOVWF  23
0782:  MOVLW  0A
0783:  MOVWF  25
0784:  BSF    0A.3
0785:  BCF    03.5
0786:  CALL   000
0787:  BCF    0A.3
0788:  MOVF   79,W
0789:  MOVWF  7E
078A:  MOVF   78,W
078B:  MOVWF  7D
078C:  GOTO   6EF
....................   } 
....................  
....................    return buffer; 
078D:  MOVLW  4B
078E:  MOVWF  78
078F:  MOVLW  00
0790:  MOVWF  79
0791:  RETURN
.................... } 
....................  
.................... char * strfromchar(char destination[], char source)  
.................... {  
....................    destination[0] = source;   // copy the character into the string  
*
07E8:  MOVF   72,W
07E9:  MOVWF  04
07EA:  BCF    03.7
07EB:  BTFSC  73.0
07EC:  BSF    03.7
07ED:  MOVF   74,W
07EE:  MOVWF  00
....................    destination[1] = '\0';      // null-terminate the string  
07EF:  MOVLW  01
07F0:  ADDWF  72,W
07F1:  MOVWF  04
07F2:  BCF    03.7
07F3:  BTFSC  73.0
07F4:  BSF    03.7
07F5:  CLRF   00
....................   
....................    return destination;         // common convention for str functions  
07F6:  MOVF   72,W
07F7:  MOVWF  78
07F8:  MOVF   73,W
07F9:  MOVWF  79
07FA:  RETURN
.................... }  
....................  
....................  
.................... /* 
.................... // ---- MSG from serial communication 
.................... #int_RDA 
.................... void RDA_isr(void){ 
....................    rx_buffer[rx_wr_index] = getc(); 
....................    rxd = rx_buffer[rx_wr_index]; 
....................    rx_wr_index++; 
....................  
....................    if(rx_wr_index > RX_BUFFER_SIZE){ 
....................       rx_wr_index = 0; 
....................    } 
....................  
....................    //Look for unique ID: "IFMT" 
....................    if(rxd == 'I' && lock_pos == 0){ 
....................       lock_pos++; 
....................    } 
....................    else if(rxd == 'F' && lock_pos == 1){ 
....................       lock_pos++; 
....................    } 
....................    else if(rxd == 'M' && lock_pos == 2){ 
....................       lock_pos++; 
....................    } 
....................    else if(rxd == 'T' && lock_pos == 3){ 
....................       lock_pos=0; //Reset the "combination lock" 
....................       got_id = TRUE; 
....................       read = rxd; 
....................       //get ready to count the number of data bytes 
....................       valid_data_count = 0xff;  
....................  
....................       //buffer is reset to index 0 
....................       rx_wr_index = 0; 
....................    }else { 
....................       lock_pos = 0; 
....................    } 
....................  
....................    if(got_id && ++valid_data_count >= 6){ 
....................       data_avail = TRUE; 
....................       got_id = FALSE; 
....................    } 
....................     
.................... } 
.................... */ 
....................  
....................  
....................  
....................  
.................... #int_TIMER1 
.................... void TIMER1_isr(void) 
.................... { 
.................... } 
....................  
*
0136:  BCF    0C.0
0137:  BCF    0A.3
0138:  BCF    0A.4
0139:  GOTO   031
.................... #int_RTCC 
.................... void RTCC_isr(void) 
.................... { 
....................  
....................        
013A:  BCF    0B.2
013B:  BCF    0A.3
013C:  BCF    0A.4
013D:  GOTO   031
.................... } 
....................  
.................... void main() 
*
0DE4:  MOVF   03,W
0DE5:  ANDLW  1F
0DE6:  MOVWF  03
0DE7:  CLRF   2C
0DE8:  CLRF   2D
0DE9:  CLRF   31
0DEA:  CLRF   32
0DEB:  MOVLW  FF
0DEC:  MOVWF  3D
0DED:  BSF    03.5
0DEE:  BSF    1F.0
0DEF:  BSF    1F.1
0DF0:  BSF    1F.2
0DF1:  BCF    1F.3
0DF2:  MOVLW  07
0DF3:  MOVWF  1C
0DF4:  BCF    03.7
*
0E06:  CLRF   54
.................... { 
....................    //VARIAVEIS 
....................    byte result; 
....................    unsigned char option; 
....................     
....................    eeprom_address address = 0; 
....................  
....................    // unsigned char tmp_result; 
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_256|RTCC_8_bit);      //13.1ms overflow 
0E07:  BSF    03.5
0E08:  MOVF   01,W
0E09:  ANDLW  C0
0E0A:  IORLW  07
0E0B:  MOVWF  01
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); //Overflow in 104ms | Resolution 1.6 us 
0E0C:  MOVLW  B5
0E0D:  BCF    03.5
0E0E:  MOVWF  10
....................  
....................    init_ext_eeprom(); 
0E0F:  BCF    0A.3
0E10:  GOTO   147
0E11:  BSF    0A.3
....................  
....................    enable_interrupts(INT_TIMER0); 
0E12:  BSF    0B.5
....................    enable_interrupts(INT_TIMER1); 
0E13:  BSF    03.5
0E14:  BSF    0C.0
....................  
....................    enable_interrupts(GLOBAL); 
0E15:  MOVLW  C0
0E16:  BCF    03.5
0E17:  IORWF  0B,F
....................  
....................  
....................    lcd_ini(); 
0E18:  BCF    0A.3
0E19:  GOTO   1C2
0E1A:  BSF    0A.3
....................    delay_us(50); 
0E1B:  MOVLW  52
0E1C:  MOVWF  77
0E1D:  DECFSZ 77,F
0E1E:  GOTO   61D
0E1F:  GOTO   620
0E20:  NOP
....................    printf(lcd_escreve, "\f  iniciando... "); 
0E21:  MOVLW  3E
0E22:  BSF    03.6
0E23:  MOVWF  0D
0E24:  MOVLW  01
0E25:  MOVWF  0F
0E26:  BCF    0A.3
0E27:  BCF    03.6
0E28:  CALL   24E
0E29:  BSF    0A.3
....................    delay_ms(500); 
0E2A:  MOVLW  02
0E2B:  MOVWF  55
0E2C:  MOVLW  FA
0E2D:  BSF    03.5
0E2E:  MOVWF  31
0E2F:  BCF    0A.3
0E30:  BCF    03.5
0E31:  CALL   154
0E32:  BSF    0A.3
0E33:  DECFSZ 55,F
0E34:  GOTO   62C
....................  
....................    // printf(lcd_escreve, "\fIFMT - Serial"); 
....................    // delay_ms(50); 
....................  
....................    // int size = BLOCK_SIZE; 
....................    // printf(lcd_escreve, "\fBlock_Size:%u", size); 
....................    // delay_ms(500); 
....................  
....................    resetMemory(); 
0E35:  BCF    0A.3
0E36:  GOTO   48A
0E37:  BSF    0A.3
....................  
....................    // data_avail = FALSE; 
....................    // int id [2] = {12,34}; 
....................    // int pass [4] = {1,2,3,4}; 
....................    // saveUser(id, pass, 1); 
....................    // int id1 [2] = {14,0}; 
....................    // saveuser(id1, pass, 0); 
....................    // int id2 [2] = {5,5}; 
....................    // saveuser(id2, pass, 1); 
....................    // int id3 [2] = {70,00}; 
....................    // saveuser(id3, pass, 1); 
....................    // int id4 [2] = {254,254}; 
....................    // saveuser(id4, pass, 3);//admin 
....................    // adminMenu(); 
....................     
....................    //// listAdmins(); 
....................    adminMenu(); 
0E38:  GOTO   214
....................  
....................  
....................  
....................  
....................    // char keyboard_buffer[]= '6'; 
....................    // char n = '9'; 
....................    // unsigned char temp_pass[2]; 
....................    // unsigned int * buffer; 
....................    // unsigned int pass[4]; 
....................    // strfromchar(temp_pass,n); 
....................    // buffer = strToInt(temp_pass); 
....................    // pass[0] = buffer[0]; 
....................  
....................    // printf(lcd_escreve,"\foutside:%u", pass[0]); 
....................    // delay_ms(800); 
....................  
....................  
....................    // int index = 2; 
....................    // if(index>0){//for testing purposes 
....................    //    for(int i=0; i < index; i++){ 
....................    //       printf(lcd_escreve,"\foutside:%u", buffer[i]); 
....................    //       delay_ms(800); 
....................    //    } 
....................    // } 
....................   
....................   
....................   // address_data_delete = getAddressByID(6); 
....................   // printf(lcd_escreve, "\f Address ID = %d", address_data_delete); 
....................  //  deleteBlock(address_data_delete); 
....................    delay_ms(50); 
0E39:  MOVLW  32
0E3A:  BSF    03.5
0E3B:  MOVWF  31
0E3C:  BCF    0A.3
0E3D:  BCF    03.5
0E3E:  CALL   154
0E3F:  BSF    0A.3
....................     
....................    while(TRUE) 
....................    { 
0E40:  GOTO   640
....................    } 
....................  
.................... } 
....................  
0E41:  SLEEP

Configuration Fuses:
   Word  1: 3F32   HS NOWDT PUT NOBROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT

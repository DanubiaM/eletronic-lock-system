CCS PCM C Compiler, Version 5.025, 7201               20-Nov-21 22:28

               Filename:   E:\University\Microcontrollers\PCW Projects\eletronic-lock-system\PIC controller\main.lst

               ROM used:   3742 words (46%)
                           Largest free fragment is 2048
               RAM used:   58 (16%) at main() level
                           222 (60%) worst case
               Stack used: 7 locations (6 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  0E
0001:  MOVWF  0A
0002:  GOTO   650
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  BTFSS  0B.5
0028:  GOTO   02B
0029:  BTFSC  0B.2
002A:  GOTO   052
002B:  MOVLW  8C
002C:  MOVWF  04
002D:  BTFSS  00.0
002E:  GOTO   031
002F:  BTFSC  0C.0
0030:  GOTO   055
0031:  MOVF   22,W
0032:  MOVWF  04
0033:  MOVF   23,W
0034:  MOVWF  77
0035:  MOVF   24,W
0036:  MOVWF  78
0037:  MOVF   25,W
0038:  MOVWF  79
0039:  MOVF   26,W
003A:  MOVWF  7A
003B:  MOVF   27,W
003C:  BSF    03.6
003D:  MOVWF  0D
003E:  BCF    03.6
003F:  MOVF   28,W
0040:  BSF    03.6
0041:  MOVWF  0F
0042:  BCF    03.6
0043:  MOVF   29,W
0044:  BSF    03.6
0045:  MOVWF  0C
0046:  BCF    03.6
0047:  MOVF   2A,W
0048:  BSF    03.6
0049:  MOVWF  0E
004A:  BCF    03.6
004B:  MOVF   20,W
004C:  MOVWF  0A
004D:  SWAPF  21,W
004E:  MOVWF  03
004F:  SWAPF  7F,F
0050:  SWAPF  7F,W
0051:  RETFIE
0052:  BCF    0A.3
0053:  BCF    0A.4
0054:  GOTO   135
0055:  BCF    0A.3
0056:  BCF    0A.4
0057:  GOTO   131
....................  
.................... #include <16F877A.h> 
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
0058:  BCF    0A.0
0059:  BCF    0A.1
005A:  BCF    0A.2
005B:  ADDWF  02,F
005C:  RETLW  28
005D:  RETLW  0F
005E:  RETLW  01
005F:  RETLW  06
0060:  BCF    0A.0
0061:  BCF    0A.1
0062:  BCF    0A.2
0063:  ADDWF  02,F
0064:  RETLW  4E
0065:  RETLW  41
0066:  RETLW  4F
0067:  RETLW  20
0068:  RETLW  50
0069:  RETLW  41
006A:  RETLW  47
006B:  RETLW  4F
006C:  RETLW  00
006D:  BCF    0A.0
006E:  BCF    0A.1
006F:  BCF    0A.2
0070:  ADDWF  02,F
0071:  RETLW  50
0072:  RETLW  41
0073:  RETLW  47
0074:  RETLW  4F
0075:  RETLW  00
0076:  DATA 8C,2A
0077:  DATA F3,3A
0078:  DATA 61,39
0079:  DATA E9,37
007A:  DATA A0,21
007B:  DATA 61,32
007C:  DATA E1,39
007D:  DATA 74,39
007E:  DATA 61,32
007F:  DATA 6F,00
0080:  DATA 8C,24
0081:  DATA 44,10
0082:  DATA 69,37
0083:  DATA E3,37
0084:  DATA 6D,38
0085:  DATA 61,3A
0086:  DATA 69,3B
0087:  DATA 65,36
0088:  DATA 00,01
0089:  DATA 0D,05
008A:  DATA D4,32
008B:  DATA 6E,3A
008C:  DATA 65,10
008D:  DATA EE,37
008E:  DATA F6,30
008F:  DATA ED,32
0090:  DATA 6E,3A
0091:  DATA 65,00
0092:  DATA 0C,10
0093:  DATA C2,3A
0094:  DATA 74,3A
0095:  DATA 6F,37
0096:  DATA 3A,10
0097:  DATA 25,32
0098:  DATA 00,00
0099:  DATA 0D,05
009A:  DATA D0,3B
009B:  DATA BA,12
009C:  DATA E4,12
009D:  DATA E4,12
009E:  DATA E4,12
009F:  DATA 64,10
00A0:  DATA 53,3A
00A1:  DATA BA,12
00A2:  DATA 64,10
00A3:  DATA 25,32
00A4:  DATA 00,00
00A5:  DATA 8C,24
00A6:  DATA 44,10
00A7:  DATA 45,3C
00A8:  DATA E9,39
00A9:  DATA F4,32
00AA:  DATA BA,12
00AB:  DATA F5,12
00AC:  DATA 75,00
00AD:  DATA 8C,24
00AE:  DATA 44,1D
00AF:  DATA A5,3A
00B0:  DATA A5,3A
00B1:  DATA A0,06
00B2:  DATA 0A,22
00B3:  DATA E9,39
00B4:  DATA F0,37
00B5:  DATA EE,34
00B6:  DATA F6,32
00B7:  DATA 6C,00
00B8:  DATA 8C,24
00B9:  DATA 44,1D
00BA:  DATA A5,3A
00BB:  DATA A5,3A
00BC:  DATA 00,01
00BD:  DATA 0D,05
00BE:  DATA 53,3A
00BF:  DATA 61,3A
00C0:  DATA F5,39
00C1:  DATA BA,12
00C2:  DATA 73,00
00C3:  DATA 8C,2A
00C4:  DATA F3,3A
00C5:  DATA 61,39
00C6:  DATA E9,37
00C7:  DATA 20,27
00C8:  DATA A0,22
00C9:  DATA F8,34
00CA:  DATA 73,3A
00CB:  DATA 65,00
00CC:  DATA 0C,10
00CD:  DATA D5,39
00CE:  DATA 65,39
00CF:  DATA A0,32
00D0:  DATA F2,30
00D1:  DATA F3,32
00D2:  DATA 64,10
00D3:  DATA 00,00
00D4:  DATA 8C,18
00D5:  DATA 3A,10
00D6:  DATA C3,20
00D7:  DATA 44,10
00D8:  DATA 43,36
00D9:  DATA E9,32
00DA:  DATA 6E,3A
00DB:  DATA 65,10
00DC:  DATA 00,01
00DD:  DATA 0D,05
00DE:  DATA 32,1D
00DF:  DATA 20,21
00E0:  DATA F5,39
00E1:  DATA E3,30
00E2:  DATA 72,10
00E3:  DATA 43,36
00E4:  DATA E9,32
00E5:  DATA 6E,3A
00E6:  DATA 65,00
00E7:  DATA 0C,10
00E8:  DATA 4F,38
00E9:  DATA F4,34
00EA:  DATA 6F,37
00EB:  DATA 3A,10
00EC:  DATA A5,31
00ED:  DATA 00,00
00EE:  DATA 0C,10
00EF:  DATA 20,10
00F0:  DATA D4,22
00F1:  DATA 43,26
00F2:  DATA 41,22
00F3:  DATA 4F,10
00F4:  DATA 20,00
00F5:  DATA 8C,20
00F6:  DATA E4,36
00F7:  DATA 69,37
00F8:  DATA A0,22
00F9:  DATA EE,31
00FA:  DATA 6F,37
00FB:  DATA 74,39
00FC:  DATA 61,32
00FD:  DATA 6F,00
00FE:  DATA 0C,10
00FF:  DATA 61,32
0100:  DATA ED,34
0101:  DATA EE,39
0102:  DATA 5B,18
0103:  DATA 5D,1D
0104:  DATA A0,12
0105:  DATA 64,00
0106:  DATA 8C,34
0107:  DATA 64,3F
0108:  DATA BA,12
0109:  DATA F5,12
010A:  DATA 75,00
010B:  DATA 0C,22
010C:  DATA E9,33
010D:  DATA 69,3A
010E:  DATA 65,10
010F:  DATA 6F,10
0110:  DATA 49,22
0111:  DATA 00,01
0112:  DATA 0C,2A
0113:  DATA 79,38
0114:  DATA 65,32
0115:  DATA BA,12
0116:  DATA 63,00
0117:  DATA 0C,2A
0118:  DATA 79,38
0119:  DATA 65,32
011A:  DATA BA,12
011B:  DATA 63,00
011C:  DATA 8C,34
011D:  DATA 64,1D
011E:  DATA A0,12
011F:  DATA F5,12
0120:  DATA 75,00
0121:  DATA 0C,28
0122:  DATA C1,29
0123:  DATA 53,14
0124:  DATA B4,14
0125:  DATA 3A,10
0126:  DATA A5,3A
0127:  DATA A5,3A
0128:  DATA A5,3A
0129:  DATA A5,3A
012A:  DATA 00,01
012B:  DATA 8C,29
012C:  DATA D4,20
012D:  DATA D4,2A
012E:  DATA 53,1D
012F:  DATA A0,12
0130:  DATA 75,00
*
0139:  DATA 0C,10
013A:  DATA A0,34
013B:  DATA EE,34
013C:  DATA E3,34
013D:  DATA 61,37
013E:  DATA E4,37
013F:  DATA 2E,17
0140:  DATA 2E,10
0141:  DATA 00,00
*
0249:  MOVF   0B,W
024A:  BSF    03.5
024B:  MOVWF  55
024C:  BCF    03.5
024D:  BCF    0B.7
024E:  BSF    03.5
024F:  BSF    03.6
0250:  BSF    0C.7
0251:  BSF    0C.0
0252:  NOP
0253:  NOP
0254:  BCF    03.6
0255:  BTFSS  55.7
0256:  GOTO   25A
0257:  BCF    03.5
0258:  BSF    0B.7
0259:  BSF    03.5
025A:  BCF    03.5
025B:  BSF    03.6
025C:  MOVF   0C,W
025D:  ANDLW  7F
025E:  BTFSC  03.2
025F:  GOTO   2BB
0260:  BSF    03.5
0261:  BCF    03.6
0262:  MOVWF  55
0263:  BCF    03.5
0264:  BSF    03.6
0265:  MOVF   0D,W
0266:  BSF    03.5
0267:  BCF    03.6
0268:  MOVWF  56
0269:  BCF    03.5
026A:  BSF    03.6
026B:  MOVF   0F,W
026C:  BSF    03.5
026D:  BCF    03.6
026E:  MOVWF  57
026F:  MOVF   55,W
0270:  MOVWF  59
0271:  BCF    03.5
0272:  CALL   206
0273:  BSF    03.5
0274:  MOVF   56,W
0275:  BCF    03.5
0276:  BSF    03.6
0277:  MOVWF  0D
0278:  BSF    03.5
0279:  BCF    03.6
027A:  MOVF   57,W
027B:  BCF    03.5
027C:  BSF    03.6
027D:  MOVWF  0F
027E:  BCF    03.6
027F:  MOVF   0B,W
0280:  BSF    03.5
0281:  MOVWF  58
0282:  BCF    03.5
0283:  BCF    0B.7
0284:  BSF    03.5
0285:  BSF    03.6
0286:  BSF    0C.7
0287:  BSF    0C.0
0288:  NOP
0289:  NOP
028A:  BCF    03.6
028B:  BTFSS  58.7
028C:  GOTO   290
028D:  BCF    03.5
028E:  BSF    0B.7
028F:  BSF    03.5
0290:  BCF    03.5
0291:  BSF    03.6
0292:  RLF    0C,W
0293:  RLF    0E,W
0294:  ANDLW  7F
0295:  BTFSC  03.2
0296:  GOTO   2BB
0297:  BSF    03.5
0298:  BCF    03.6
0299:  MOVWF  55
029A:  BCF    03.5
029B:  BSF    03.6
029C:  MOVF   0D,W
029D:  BSF    03.5
029E:  BCF    03.6
029F:  MOVWF  56
02A0:  BCF    03.5
02A1:  BSF    03.6
02A2:  MOVF   0F,W
02A3:  BSF    03.5
02A4:  BCF    03.6
02A5:  MOVWF  57
02A6:  MOVF   55,W
02A7:  MOVWF  59
02A8:  BCF    03.5
02A9:  CALL   206
02AA:  BSF    03.5
02AB:  MOVF   56,W
02AC:  BCF    03.5
02AD:  BSF    03.6
02AE:  MOVWF  0D
02AF:  BSF    03.5
02B0:  BCF    03.6
02B1:  MOVF   57,W
02B2:  BCF    03.5
02B3:  BSF    03.6
02B4:  MOVWF  0F
02B5:  INCF   0D,F
02B6:  BTFSC  03.2
02B7:  INCF   0F,F
02B8:  BCF    03.6
02B9:  GOTO   249
02BA:  BSF    03.6
02BB:  BCF    03.6
02BC:  RETURN
*
0422:  MOVF   0B,W
0423:  BSF    03.5
0424:  MOVWF  56
0425:  BCF    03.5
0426:  BCF    0B.7
0427:  BSF    03.5
0428:  BSF    03.6
0429:  BSF    0C.7
042A:  BSF    0C.0
042B:  NOP
042C:  NOP
042D:  BCF    03.6
042E:  BTFSS  56.7
042F:  GOTO   433
0430:  BCF    03.5
0431:  BSF    0B.7
0432:  BSF    03.5
0433:  BTFSC  03.0
0434:  GOTO   46C
0435:  BCF    03.5
0436:  BSF    03.6
0437:  MOVF   0C,W
0438:  ANDLW  7F
0439:  BSF    03.5
043A:  BCF    03.6
043B:  MOVWF  56
043C:  BCF    03.5
043D:  BSF    03.6
043E:  MOVF   0D,W
043F:  BSF    03.5
0440:  BCF    03.6
0441:  MOVWF  57
0442:  BCF    03.5
0443:  BSF    03.6
0444:  MOVF   0F,W
0445:  BSF    03.5
0446:  BCF    03.6
0447:  MOVWF  58
0448:  MOVF   56,W
0449:  MOVWF  59
044A:  BCF    03.5
044B:  CALL   206
044C:  BSF    03.5
044D:  MOVF   57,W
044E:  BCF    03.5
044F:  BSF    03.6
0450:  MOVWF  0D
0451:  BSF    03.5
0452:  BCF    03.6
0453:  MOVF   58,W
0454:  BCF    03.5
0455:  BSF    03.6
0456:  MOVWF  0F
0457:  BCF    03.6
0458:  MOVF   0B,W
0459:  BSF    03.5
045A:  MOVWF  59
045B:  BCF    03.5
045C:  BCF    0B.7
045D:  BSF    03.5
045E:  BSF    03.6
045F:  BSF    0C.7
0460:  BSF    0C.0
0461:  NOP
0462:  NOP
0463:  BCF    03.6
0464:  BTFSS  59.7
0465:  GOTO   469
0466:  BCF    03.5
0467:  BSF    0B.7
0468:  BSF    03.5
0469:  DECFSZ 55,F
046A:  GOTO   46C
046B:  GOTO   49A
046C:  BCF    03.5
046D:  BSF    03.6
046E:  RLF    0C,W
046F:  RLF    0E,W
0470:  ANDLW  7F
0471:  BSF    03.5
0472:  BCF    03.6
0473:  MOVWF  56
0474:  BCF    03.5
0475:  BSF    03.6
0476:  MOVF   0D,W
0477:  BSF    03.5
0478:  BCF    03.6
0479:  MOVWF  57
047A:  BCF    03.5
047B:  BSF    03.6
047C:  MOVF   0F,W
047D:  BSF    03.5
047E:  BCF    03.6
047F:  MOVWF  58
0480:  MOVF   56,W
0481:  MOVWF  59
0482:  BCF    03.5
0483:  CALL   206
0484:  BSF    03.5
0485:  MOVF   57,W
0486:  BCF    03.5
0487:  BSF    03.6
0488:  MOVWF  0D
0489:  BSF    03.5
048A:  BCF    03.6
048B:  MOVF   58,W
048C:  BCF    03.5
048D:  BSF    03.6
048E:  MOVWF  0F
048F:  INCF   0D,F
0490:  BTFSC  03.2
0491:  INCF   0F,F
0492:  BCF    03.0
0493:  BSF    03.5
0494:  BCF    03.6
0495:  DECFSZ 55,F
0496:  GOTO   498
0497:  GOTO   49A
0498:  BCF    03.5
0499:  GOTO   422
049A:  BCF    03.5
049B:  RETURN
*
0659:  MOVF   37,W
065A:  XORWF  39,W
065B:  ANDLW  80
065C:  MOVWF  3B
065D:  BTFSS  37.7
065E:  GOTO   664
065F:  COMF   36,F
0660:  COMF   37,F
0661:  INCF   36,F
0662:  BTFSC  03.2
0663:  INCF   37,F
0664:  BTFSS  39.7
0665:  GOTO   66B
0666:  COMF   38,F
0667:  COMF   39,F
0668:  INCF   38,F
0669:  BTFSC  03.2
066A:  INCF   39,F
066B:  MOVLW  10
066C:  MOVWF  3A
066D:  CLRF   77
066E:  CLRF   7A
066F:  RRF    37,F
0670:  RRF    36,F
0671:  BTFSS  03.0
0672:  GOTO   679
0673:  MOVF   38,W
0674:  ADDWF  77,F
0675:  BTFSC  03.0
0676:  INCF   7A,F
0677:  MOVF   39,W
0678:  ADDWF  7A,F
0679:  RRF    7A,F
067A:  RRF    77,F
067B:  RRF    79,F
067C:  RRF    78,F
067D:  DECFSZ 3A,F
067E:  GOTO   66F
067F:  BTFSS  3B.7
0680:  GOTO   686
0681:  COMF   78,F
0682:  COMF   79,F
0683:  INCF   78,F
0684:  BTFSC  03.2
0685:  INCF   79,F
*
0798:  BSF    03.5
0799:  MOVF   58,W
079A:  CLRF   78
079B:  SUBWF  57,W
079C:  BTFSC  03.0
079D:  GOTO   7A1
079E:  MOVF   57,W
079F:  MOVWF  77
07A0:  GOTO   7AD
07A1:  CLRF   77
07A2:  MOVLW  08
07A3:  MOVWF  59
07A4:  RLF    57,F
07A5:  RLF    77,F
07A6:  MOVF   58,W
07A7:  SUBWF  77,W
07A8:  BTFSC  03.0
07A9:  MOVWF  77
07AA:  RLF    78,F
07AB:  DECFSZ 59,F
07AC:  GOTO   7A4
07AD:  BCF    03.5
07AE:  RETURN
07AF:  MOVF   78,W
07B0:  BSF    03.5
07B1:  MOVF   55,W
07B2:  MOVWF  57
07B3:  MOVLW  64
07B4:  MOVWF  58
07B5:  BCF    03.5
07B6:  CALL   798
07B7:  MOVF   77,W
07B8:  BSF    03.5
07B9:  MOVWF  55
07BA:  MOVF   78,W
07BB:  MOVLW  30
07BC:  BTFSS  03.2
07BD:  GOTO   7C5
07BE:  BTFSS  56.1
07BF:  GOTO   7CE
07C0:  BTFSC  56.3
07C1:  GOTO   7CE
07C2:  BTFSC  56.4
07C3:  MOVLW  20
07C4:  GOTO   7C8
07C5:  BCF    56.3
07C6:  BCF    56.4
07C7:  BSF    56.0
07C8:  ADDWF  78,F
07C9:  MOVF   78,W
07CA:  MOVWF  59
07CB:  BCF    03.5
07CC:  CALL   206
07CD:  BSF    03.5
07CE:  MOVF   55,W
07CF:  MOVWF  57
07D0:  MOVLW  0A
07D1:  MOVWF  58
07D2:  BCF    03.5
07D3:  CALL   798
07D4:  MOVF   77,W
07D5:  BSF    03.5
07D6:  MOVWF  55
07D7:  MOVF   78,W
07D8:  MOVLW  30
07D9:  BTFSS  03.2
07DA:  GOTO   7E1
07DB:  BTFSC  56.3
07DC:  GOTO   7E7
07DD:  BTFSS  56.0
07DE:  GOTO   7E7
07DF:  BTFSC  56.4
07E0:  MOVLW  20
07E1:  ADDWF  78,F
07E2:  MOVF   78,W
07E3:  MOVWF  59
07E4:  BCF    03.5
07E5:  CALL   206
07E6:  BSF    03.5
07E7:  MOVLW  30
07E8:  ADDWF  55,F
07E9:  MOVF   55,W
07EA:  MOVWF  59
07EB:  BCF    03.5
07EC:  CALL   206
07ED:  RETURN
*
0800:  MOVF   00,F
0801:  BTFSC  03.2
0802:  GOTO   01E
0803:  BSF    03.5
0804:  CLRF   52
0805:  MOVF   04,W
0806:  MOVWF  51
0807:  BCF    52.0
0808:  BTFSC  03.7
0809:  BSF    52.0
080A:  MOVF   00,W
080B:  MOVWF  59
080C:  BCF    0A.3
080D:  BCF    03.5
080E:  CALL   206
080F:  BSF    0A.3
0810:  BSF    03.5
0811:  MOVF   51,W
0812:  MOVWF  04
0813:  BCF    03.7
0814:  BTFSC  52.0
0815:  BSF    03.7
0816:  INCF   04,F
0817:  BTFSS  03.2
0818:  GOTO   01C
0819:  BCF    03.5
081A:  INCF   05,F
081B:  BSF    03.5
081C:  BCF    03.5
081D:  GOTO   000
081E:  RETURN
....................  
.................... #list 
....................  
.................... #device ADC=8 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES HS  
....................  
.................... #use delay(crystal=20000000) 
*
014F:  MOVLW  DA
0150:  MOVWF  04
0151:  BCF    03.7
0152:  MOVF   00,W
0153:  BTFSC  03.2
0154:  GOTO   162
0155:  MOVLW  06
0156:  MOVWF  78
0157:  CLRF   77
0158:  DECFSZ 77,F
0159:  GOTO   158
015A:  DECFSZ 78,F
015B:  GOTO   157
015C:  MOVLW  7B
015D:  MOVWF  77
015E:  DECFSZ 77,F
015F:  GOTO   15E
0160:  DECFSZ 00,F
0161:  GOTO   155
0162:  RETURN
.................... //#use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=PORT1) 
....................  
....................  
.................... // -------Variables' Declaration 
.................... #define RX_BUFFER_SIZE 10 
.................... #define BLOCK_SIZE sizeof(User)  
.................... signed int8 address_data_delete; 
.................... int8 rx_wr_index = 0; 
.................... int8 lock_pos = 0, rxd, read, valid_data_count; 
.................... int data_avail = FALSE, got_id = FALSE; 
.................... unsigned int8 rx_buffer[RX_BUFFER_SIZE]; 
.................... #include "functions.c" 
.................... #include "functions.h" 
....................  
.................... //Define the default pins before calling the LCD driver 
.................... #ifndef lcd_enable  
....................    #define lcd_enable     pin_e1 
....................    #define lcd_rs         pin_e2 
....................    //#define lcd_rw       pin_e2   
....................    #define lcd_d4         pin_d4 
....................    #define lcd_d5         pin_d5 
....................    #define lcd_d6         pin_d6 
....................    #define lcd_d7         pin_d7 
.................... #endif 
....................  
.................... #include "mod_lcd.c" 
.................... /************************************************************************/ 
.................... /*  MOD_LCD.C - Biblioteca de manipulaï¿½ï¿½o de mï¿½dulo LCD                 */ 
.................... /*                                                                      */ 
.................... /*  Autor: Fï¿½bio Pereira                                                */ 
.................... /*                                                                      */ 
.................... /************************************************************************/ 
....................  
.................... // As definiï¿½ï¿½es a seguir sï¿½o utilizadas para acesso aos pinos do display 
.................... // caso o pino RW nï¿½o seja utilizado, comente a definiï¿½ï¿½o lcd_rw 
.................... #ifndef lcd_enable 
.................... 	#define lcd_enable 		pin_e1		// pino enable do LCD 
.................... 	#define lcd_rs			pin_e0		// pino rs do LCD 
.................... 	//#define lcd_rw		pin_e2		// pino rw do LCD 
.................... 	#define lcd_d4			pin_d4		// pino de dados d4 do LCD 
.................... 	#define lcd_d5			pin_d5		// pino de dados d5 do LCD 
.................... 	#define lcd_d6			pin_d6		// pino de dados d6 do LCD 
.................... 	#define lcd_d7			pin_d7		// pino de dados d7 do LCD 
.................... #endif 
....................  
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 linhas 
.................... #define lcd_seg_lin 0x40    // Endereï¿½o da segunda linha na RAM do LCD 
....................  
.................... // a constante abaixo define a seqï¿½ï¿½ncia de inicializaï¿½ï¿½o do mï¿½dulo LCD 
.................... byte CONST INI_LCD[4] = {0x20 | (lcd_type << 2), 0xf, 1, 6}; 
....................  
.................... byte lcd_le_byte() 
.................... // lï¿½ um byte do LCD (somente com pino RW) 
.................... { 
.................... 	byte dado; 
.................... 	// configura os pinos de dados como entradas 
.................... 	input(lcd_d4); 
.................... 	input(lcd_d5); 
.................... 	input(lcd_d6); 
.................... 	input(lcd_d7); 
.................... 	// se o pino rw for utilizado, coloca em 1 
.................... 	#ifdef lcd_rw 
.................... 		output_high(lcd_rw); 
.................... 	#endif 
....................    output_high(lcd_enable); // habilita display 
.................... 	dado = 0;	// zera a variï¿½vel de leitura 
.................... 	// lï¿½ os quatro bits mais significativos 
.................... 	if (input(lcd_d7)) bit_set(dado,7); 
.................... 	if (input(lcd_d6)) bit_set(dado,6); 
.................... 	if (input(lcd_d5)) bit_set(dado,5); 
.................... 	if (input(lcd_d4)) bit_set(dado,4); 
.................... 	// dï¿½ um pulso na linha enable 
.................... 	output_low(lcd_enable); 
.................... 	output_high(lcd_enable); 
.................... 	// lï¿½ os quatro bits menos significativos 
.................... 	if (input(lcd_d7)) bit_set(dado,3); 
.................... 	if (input(lcd_d6)) bit_set(dado,2); 
.................... 	if (input(lcd_d5)) bit_set(dado,1); 
.................... 	if (input(lcd_d4)) bit_set(dado,0); 
.................... 	output_low(lcd_enable);	// desabilita o display 
.................... 	return dado;	// retorna o byte lido 
.................... } 
....................  
.................... void lcd_envia_nibble( byte dado ) 
.................... // envia um dado de quatro bits para o display 
.................... { 
.................... 	// coloca os quatro bits nas saidas 
.................... 	output_bit(lcd_d4,bit_test(dado,0)); 
0163:  BSF    03.5
0164:  BTFSC  61.0
0165:  GOTO   16A
0166:  BCF    03.5
0167:  BCF    08.4
0168:  GOTO   16C
0169:  BSF    03.5
016A:  BCF    03.5
016B:  BSF    08.4
016C:  BSF    03.5
016D:  BCF    08.4
.................... 	output_bit(lcd_d5,bit_test(dado,1)); 
016E:  BTFSC  61.1
016F:  GOTO   174
0170:  BCF    03.5
0171:  BCF    08.5
0172:  GOTO   176
0173:  BSF    03.5
0174:  BCF    03.5
0175:  BSF    08.5
0176:  BSF    03.5
0177:  BCF    08.5
.................... 	output_bit(lcd_d6,bit_test(dado,2)); 
0178:  BTFSC  61.2
0179:  GOTO   17E
017A:  BCF    03.5
017B:  BCF    08.6
017C:  GOTO   180
017D:  BSF    03.5
017E:  BCF    03.5
017F:  BSF    08.6
0180:  BSF    03.5
0181:  BCF    08.6
.................... 	output_bit(lcd_d7,bit_test(dado,3)); 
0182:  BTFSC  61.3
0183:  GOTO   188
0184:  BCF    03.5
0185:  BCF    08.7
0186:  GOTO   18A
0187:  BSF    03.5
0188:  BCF    03.5
0189:  BSF    08.7
018A:  BSF    03.5
018B:  BCF    08.7
.................... 	// dï¿½ um pulso na linha enable 
.................... 	output_high(lcd_enable); 
018C:  BCF    09.1
018D:  BCF    03.5
018E:  BSF    09.1
.................... 	output_low(lcd_enable); 
018F:  BSF    03.5
0190:  BCF    09.1
0191:  BCF    03.5
0192:  BCF    09.1
0193:  RETURN
.................... } 
....................  
....................  
.................... void lcd_envia_byte( boolean endereco, byte dado ) 
.................... { 
.................... 	// coloca a linha rs em 0 
.................... 	output_low(lcd_rs); 
0194:  BSF    03.5
0195:  BCF    09.2
0196:  BCF    03.5
0197:  BCF    09.2
.................... 	// aguarda o display ficar desocupado 
.................... 	//while ( bit_test(lcd_le_byte(),7) ) ; 
.................... 	// configura a linha rs dependendo do modo selecionado 
.................... 	output_bit(lcd_rs,endereco); 
0198:  BSF    03.5
0199:  MOVF   5E,F
019A:  BTFSS  03.2
019B:  GOTO   1A0
019C:  BCF    03.5
019D:  BCF    09.2
019E:  GOTO   1A2
019F:  BSF    03.5
01A0:  BCF    03.5
01A1:  BSF    09.2
01A2:  BSF    03.5
01A3:  BCF    09.2
.................... 	delay_us(100);	// aguarda 100 us 
01A4:  MOVLW  A6
01A5:  MOVWF  77
01A6:  DECFSZ 77,F
01A7:  GOTO   1A6
01A8:  NOP
.................... 	// caso a linha rw esteja definida, coloca em 0 
.................... 	#ifdef lcd_rw 
.................... 		output_low(lcd_rw); 
.................... 	#endif 
.................... 	// desativa linha enable 
.................... 	output_low(lcd_enable); 
01A9:  BCF    09.1
01AA:  BCF    03.5
01AB:  BCF    09.1
.................... 	// envia a primeira parte do byte 
.................... 	lcd_envia_nibble(dado >> 4); 
01AC:  BSF    03.5
01AD:  SWAPF  5F,W
01AE:  MOVWF  60
01AF:  MOVLW  0F
01B0:  ANDWF  60,F
01B1:  MOVF   60,W
01B2:  MOVWF  61
01B3:  BCF    03.5
01B4:  CALL   163
.................... 	// envia a segunda parte do byte 
.................... 	lcd_envia_nibble(dado & 0x0f); 
01B5:  BSF    03.5
01B6:  MOVF   5F,W
01B7:  ANDLW  0F
01B8:  MOVWF  60
01B9:  MOVWF  61
01BA:  BCF    03.5
01BB:  CALL   163
01BC:  RETURN
.................... } 
....................  
....................  
.................... void lcd_ini() 
.................... // rotina de inicializaï¿½ï¿½o do display 
.................... { 
.................... 	byte conta; 
.................... 	output_low(lcd_d4); 
01BD:  BSF    03.5
01BE:  BCF    08.4
01BF:  BCF    03.5
01C0:  BCF    08.4
.................... 	output_low(lcd_d5); 
01C1:  BSF    03.5
01C2:  BCF    08.5
01C3:  BCF    03.5
01C4:  BCF    08.5
.................... 	output_low(lcd_d6); 
01C5:  BSF    03.5
01C6:  BCF    08.6
01C7:  BCF    03.5
01C8:  BCF    08.6
.................... 	output_low(lcd_d7); 
01C9:  BSF    03.5
01CA:  BCF    08.7
01CB:  BCF    03.5
01CC:  BCF    08.7
.................... 	output_low(lcd_rs); 
01CD:  BSF    03.5
01CE:  BCF    09.2
01CF:  BCF    03.5
01D0:  BCF    09.2
.................... 	#ifdef lcd_rw 
.................... 		output_high(lcd_rw); 
.................... 	#endif 
.................... 	output_low(lcd_enable); 
01D1:  BSF    03.5
01D2:  BCF    09.1
01D3:  BCF    03.5
01D4:  BCF    09.1
.................... 	delay_ms(15); 
01D5:  MOVLW  0F
01D6:  BSF    03.5
01D7:  MOVWF  5A
01D8:  BCF    03.5
01D9:  CALL   14F
.................... 	// envia uma seqï¿½ï¿½ncia de 3 vezes 0x03 
.................... 	// e depois 0x02 para configurar o mï¿½dulo 
.................... 	// para modo de 4 bits 
.................... 	for(conta=1;conta<=3;++conta) 
01DA:  MOVLW  01
01DB:  MOVWF  5B
01DC:  MOVF   5B,W
01DD:  SUBLW  03
01DE:  BTFSS  03.0
01DF:  GOTO   1EC
.................... 	{ 
.................... 		lcd_envia_nibble(3); 
01E0:  MOVLW  03
01E1:  BSF    03.5
01E2:  MOVWF  61
01E3:  BCF    03.5
01E4:  CALL   163
.................... 		delay_ms(5); 
01E5:  MOVLW  05
01E6:  BSF    03.5
01E7:  MOVWF  5A
01E8:  BCF    03.5
01E9:  CALL   14F
01EA:  INCF   5B,F
01EB:  GOTO   1DC
.................... 	} 
.................... 	lcd_envia_nibble(2); 
01EC:  MOVLW  02
01ED:  BSF    03.5
01EE:  MOVWF  61
01EF:  BCF    03.5
01F0:  CALL   163
.................... 	// envia string de inicializaï¿½ï¿½o do display 
.................... 	for(conta=0;conta<=3;++conta) lcd_envia_byte(0,INI_LCD[conta]); 
01F1:  CLRF   5B
01F2:  MOVF   5B,W
01F3:  SUBLW  03
01F4:  BTFSS  03.0
01F5:  GOTO   203
01F6:  MOVF   5B,W
01F7:  CALL   058
01F8:  MOVWF  5C
01F9:  BSF    03.5
01FA:  CLRF   5E
01FB:  BCF    03.5
01FC:  MOVF   5C,W
01FD:  BSF    03.5
01FE:  MOVWF  5F
01FF:  BCF    03.5
0200:  CALL   194
0201:  INCF   5B,F
0202:  GOTO   1F2
0203:  BSF    0A.3
0204:  BCF    0A.4
0205:  GOTO   686 (RETURN)
.................... } 
....................  
.................... void lcd_pos_xy( byte x, byte y) 
.................... { 
....................    byte endereco; 
....................    if(y!=1) 
*
0227:  DECFSZ 5B,W
0228:  GOTO   22A
0229:  GOTO   22D
....................    	endereco = lcd_seg_lin; 
022A:  MOVLW  40
022B:  MOVWF  5C
022C:  GOTO   22E
....................    else 
....................    	endereco = 0; 
022D:  CLRF   5C
....................    endereco += x-1; 
022E:  MOVLW  01
022F:  SUBWF  5A,W
0230:  ADDWF  5C,F
....................    lcd_envia_byte(0,0x80|endereco); 
0231:  MOVF   5C,W
0232:  IORLW  80
0233:  MOVWF  5D
0234:  CLRF   5E
0235:  MOVF   5D,W
0236:  MOVWF  5F
0237:  BCF    03.5
0238:  CALL   194
.................... } 
....................  
.................... void lcd_escreve( char c) 
.................... // envia caractere para o display 
.................... { 
....................    switch (c) 
*
0206:  BSF    03.5
0207:  MOVF   59,W
0208:  XORLW  0C
0209:  BCF    03.5
020A:  BTFSC  03.2
020B:  GOTO   216
020C:  XORLW  06
020D:  BTFSC  03.2
020E:  GOTO   222
020F:  XORLW  07
0210:  BTFSC  03.2
0211:  GOTO   222
0212:  XORLW  05
0213:  BTFSC  03.2
0214:  GOTO   23A
0215:  GOTO   241
.................... 	{ 
....................      case '\f' 	:	lcd_envia_byte(0,1); 
0216:  BSF    03.5
0217:  CLRF   5E
0218:  MOVLW  01
0219:  MOVWF  5F
021A:  BCF    03.5
021B:  CALL   194
.................... 	  			delay_ms(2); 
021C:  MOVLW  02
021D:  BSF    03.5
021E:  MOVWF  5A
021F:  BCF    03.5
0220:  CALL   14F
.................... 				break; 
0221:  GOTO   248
....................      case '\n'	: 
.................... 	   case '\r' 	:	lcd_pos_xy(1,2); 
0222:  MOVLW  01
0223:  BSF    03.5
0224:  MOVWF  5A
0225:  MOVLW  02
0226:  MOVWF  5B
.................... 	  			break; 
*
0239:  GOTO   248
....................      case '\b' 	:	lcd_envia_byte(0,0x10); 
023A:  BSF    03.5
023B:  CLRF   5E
023C:  MOVLW  10
023D:  MOVWF  5F
023E:  BCF    03.5
023F:  CALL   194
.................... 	  			break; 
0240:  GOTO   248
....................      default	:	lcd_envia_byte(1,c); 
0241:  MOVLW  01
0242:  BSF    03.5
0243:  MOVWF  5E
0244:  MOVF   59,W
0245:  MOVWF  5F
0246:  BCF    03.5
0247:  CALL   194
.................... 	  			break; 
....................    } 
0248:  RETURN
.................... } 
....................  
.................... char lcd_le( byte x, byte y) 
.................... // le caractere do display 
.................... { 
.................... 	char valor; 
.................... 	// seleciona a posiï¿½ï¿½o do caractere 
.................... 	lcd_pos_xy(x,y); 
.................... 	// ativa rs 
.................... 	output_high(lcd_rs); 
.................... 	// lï¿½ o caractere 
.................... 	valor = lcd_le_byte(); 
.................... 	// desativa rs 
.................... 	output_low(lcd_rs); 
.................... 	// retorna o valor do caractere 
.................... 	return valor; 
.................... } 
....................  
....................  
.................... #include "2401.c" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a MicroChip 24LC01B configured for a x8 org         //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);  Read the byte d from the address a     //// 
.................... ////                                                                   //// 
.................... ////   b = ext_eeprom_ready();  Returns TRUE if the eeprom is ready    //// 
.................... ////                            to receive opcodes                     //// 
.................... ////                                                                   //// 
.................... ////   The main program may define EEPROM_SDA                          //// 
.................... ////   and EEPROM_SCL to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... ////                            Pin Layout                             //// 
.................... ////   -----------------------------------------------------------     //// 
.................... ////   |                                                         |     //// 
.................... ////   | 1: NC   Not Connected | 8: VCC   +5V                    |     //// 
.................... ////   |                       |                                 |     //// 
.................... ////   | 2: NC   Not Connected | 7: WP    GND                    |     //// 
.................... ////   |                       |                                 |     //// 
.................... ////   | 3: NC   Not Connected | 6: SCL   EEPROM_SCL and Pull-Up |     //// 
.................... ////   |                       |                                 |     //// 
.................... ////   | 4: VSS  GND           | 5: SDA   EEPROM_SDA and Pull-Up |     //// 
.................... ////   -----------------------------------------------------------     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2003 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef EEPROM_SDA 
....................  
.................... #define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C3 
....................  
.................... #endif 
....................  
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
08AB:  MOVLW  08
08AC:  MOVWF  78
08AD:  MOVLW  04
08AE:  MOVWF  77
08AF:  DECFSZ 77,F
08B0:  GOTO   0AF
08B1:  BCF    07.3
08B2:  BCF    3D.3
08B3:  MOVF   3D,W
08B4:  BSF    03.5
08B5:  MOVWF  07
08B6:  MOVLW  03
08B7:  MOVWF  77
08B8:  DECFSZ 77,F
08B9:  GOTO   0B8
08BA:  RLF    57,F
08BB:  BCF    03.5
08BC:  BCF    07.4
08BD:  BTFSS  03.0
08BE:  GOTO   0C5
08BF:  BSF    3D.4
08C0:  MOVF   3D,W
08C1:  BSF    03.5
08C2:  MOVWF  07
08C3:  GOTO   0C9
08C4:  BCF    03.5
08C5:  BCF    3D.4
08C6:  MOVF   3D,W
08C7:  BSF    03.5
08C8:  MOVWF  07
08C9:  NOP
08CA:  BCF    03.5
08CB:  BSF    3D.3
08CC:  MOVF   3D,W
08CD:  BSF    03.5
08CE:  MOVWF  07
08CF:  BCF    03.5
08D0:  BTFSS  07.3
08D1:  GOTO   0D0
08D2:  DECFSZ 78,F
08D3:  GOTO   0AD
08D4:  MOVLW  04
08D5:  MOVWF  77
08D6:  DECFSZ 77,F
08D7:  GOTO   0D6
08D8:  BCF    07.3
08D9:  BCF    3D.3
08DA:  MOVF   3D,W
08DB:  BSF    03.5
08DC:  MOVWF  07
08DD:  NOP
08DE:  BCF    03.5
08DF:  BSF    3D.4
08E0:  MOVF   3D,W
08E1:  BSF    03.5
08E2:  MOVWF  07
08E3:  MOVLW  03
08E4:  MOVWF  77
08E5:  DECFSZ 77,F
08E6:  GOTO   0E5
08E7:  MOVLW  03
08E8:  MOVWF  77
08E9:  DECFSZ 77,F
08EA:  GOTO   0E9
08EB:  BCF    03.5
08EC:  BSF    3D.3
08ED:  MOVF   3D,W
08EE:  BSF    03.5
08EF:  MOVWF  07
08F0:  BCF    03.5
08F1:  BTFSS  07.3
08F2:  GOTO   0F1
08F3:  CLRF   78
08F4:  MOVLW  03
08F5:  MOVWF  77
08F6:  DECFSZ 77,F
08F7:  GOTO   0F6
08F8:  BTFSC  07.4
08F9:  BSF    78.0
08FA:  BCF    07.3
08FB:  BCF    3D.3
08FC:  MOVF   3D,W
08FD:  BSF    03.5
08FE:  MOVWF  07
08FF:  BCF    03.5
0900:  BCF    07.4
0901:  BCF    3D.4
0902:  MOVF   3D,W
0903:  BSF    03.5
0904:  MOVWF  07
0905:  BCF    03.5
0906:  RETURN
*
09A9:  MOVLW  08
09AA:  BSF    03.5
09AB:  MOVWF  57
09AC:  MOVF   77,W
09AD:  MOVWF  58
09AE:  BCF    03.5
09AF:  BSF    3D.4
09B0:  MOVF   3D,W
09B1:  BSF    03.5
09B2:  MOVWF  07
09B3:  MOVLW  03
09B4:  MOVWF  77
09B5:  DECFSZ 77,F
09B6:  GOTO   1B5
09B7:  BCF    03.5
09B8:  BSF    3D.3
09B9:  MOVF   3D,W
09BA:  BSF    03.5
09BB:  MOVWF  07
09BC:  BCF    03.5
09BD:  BTFSS  07.3
09BE:  GOTO   1BD
09BF:  BTFSC  07.4
09C0:  BSF    03.0
09C1:  BTFSS  07.4
09C2:  BCF    03.0
09C3:  RLF    78,F
09C4:  MOVLW  04
09C5:  MOVWF  77
09C6:  DECFSZ 77,F
09C7:  GOTO   1C6
09C8:  BCF    3D.3
09C9:  MOVF   3D,W
09CA:  BSF    03.5
09CB:  MOVWF  07
09CC:  BCF    03.5
09CD:  BCF    07.3
09CE:  BSF    03.5
09CF:  DECFSZ 57,F
09D0:  GOTO   1AE
09D1:  BCF    03.5
09D2:  BSF    3D.4
09D3:  MOVF   3D,W
09D4:  BSF    03.5
09D5:  MOVWF  07
09D6:  MOVLW  03
09D7:  MOVWF  77
09D8:  DECFSZ 77,F
09D9:  GOTO   1D8
09DA:  BCF    03.5
09DB:  BCF    07.4
09DC:  BSF    03.5
09DD:  MOVF   58,W
09DE:  BTFSC  03.2
09DF:  GOTO   1E5
09E0:  BCF    03.5
09E1:  BCF    3D.4
09E2:  MOVF   3D,W
09E3:  BSF    03.5
09E4:  MOVWF  07
09E5:  NOP
09E6:  BCF    03.5
09E7:  BSF    3D.3
09E8:  MOVF   3D,W
09E9:  BSF    03.5
09EA:  MOVWF  07
09EB:  BCF    03.5
09EC:  BTFSS  07.3
09ED:  GOTO   1EC
09EE:  MOVLW  04
09EF:  MOVWF  77
09F0:  DECFSZ 77,F
09F1:  GOTO   1F0
09F2:  BCF    07.3
09F3:  BCF    3D.3
09F4:  MOVF   3D,W
09F5:  BSF    03.5
09F6:  MOVWF  07
09F7:  MOVLW  03
09F8:  MOVWF  77
09F9:  DECFSZ 77,F
09FA:  GOTO   1F9
09FB:  BCF    03.5
09FC:  BCF    07.4
09FD:  BCF    3D.4
09FE:  MOVF   3D,W
09FF:  BSF    03.5
0A00:  MOVWF  07
....................  
.................... #define EEPROM_ADDRESS BYTE 
.................... #define EEPROM_SIZE    128 
....................  
.................... void init_ext_eeprom() { 
....................    output_float(EEPROM_SCL); 
*
0142:  BSF    3D.3
0143:  MOVF   3D,W
0144:  BSF    03.5
0145:  MOVWF  07
....................    output_float(EEPROM_SDA); 
0146:  BCF    03.5
0147:  BSF    3D.4
0148:  MOVF   3D,W
0149:  BSF    03.5
014A:  MOVWF  07
014B:  BCF    03.5
014C:  BSF    0A.3
014D:  BCF    0A.4
014E:  GOTO   67D (RETURN)
.................... } 
....................  
.................... BOOLEAN ext_eeprom_ready() { 
....................    int1 ack; 
....................    i2c_start();            // If the write command is acknowledged, 
*
0907:  BSF    3D.4
0908:  MOVF   3D,W
0909:  BSF    03.5
090A:  MOVWF  07
090B:  MOVLW  04
090C:  MOVWF  77
090D:  DECFSZ 77,F
090E:  GOTO   10D
090F:  BCF    03.5
0910:  BSF    3D.3
0911:  MOVF   3D,W
0912:  BSF    03.5
0913:  MOVWF  07
0914:  MOVLW  03
0915:  MOVWF  77
0916:  DECFSZ 77,F
0917:  GOTO   116
0918:  BCF    03.5
0919:  BCF    07.4
091A:  BCF    3D.4
091B:  MOVF   3D,W
091C:  BSF    03.5
091D:  MOVWF  07
091E:  MOVLW  04
091F:  MOVWF  77
0920:  DECFSZ 77,F
0921:  GOTO   120
0922:  BCF    03.5
0923:  BCF    07.3
0924:  BCF    3D.3
0925:  MOVF   3D,W
0926:  BSF    03.5
0927:  MOVWF  07
....................    ack = i2c_write(0xa0);  // then the device is ready. 
0928:  MOVLW  A0
0929:  MOVWF  57
092A:  BCF    03.5
092B:  CALL   0AB
092C:  MOVF   78,W
092D:  BSF    03.5
092E:  BCF    56.0
092F:  BTFSC  78.0
0930:  BSF    56.0
....................    i2c_stop(); 
0931:  BCF    03.5
0932:  BCF    3D.4
0933:  MOVF   3D,W
0934:  BSF    03.5
0935:  MOVWF  07
0936:  NOP
0937:  BCF    03.5
0938:  BSF    3D.3
0939:  MOVF   3D,W
093A:  BSF    03.5
093B:  MOVWF  07
093C:  BCF    03.5
093D:  BTFSS  07.3
093E:  GOTO   13D
093F:  MOVLW  04
0940:  MOVWF  77
0941:  DECFSZ 77,F
0942:  GOTO   141
0943:  GOTO   144
0944:  NOP
0945:  BSF    3D.4
0946:  MOVF   3D,W
0947:  BSF    03.5
0948:  MOVWF  07
0949:  MOVLW  04
094A:  MOVWF  77
094B:  DECFSZ 77,F
094C:  GOTO   14B
....................    return !ack; 
094D:  MOVLW  00
094E:  BTFSS  56.0
094F:  MOVLW  01
0950:  MOVWF  78
0951:  BCF    03.5
0952:  RETURN
.................... } 
....................  
.................... void write_ext_eeprom(BYTE address, BYTE data) { 
....................    while(!ext_eeprom_ready()); 
*
0AD4:  CALL   107
0AD5:  MOVF   78,F
0AD6:  BTFSC  03.2
0AD7:  GOTO   2D4
....................    i2c_start(); 
0AD8:  BSF    3D.4
0AD9:  MOVF   3D,W
0ADA:  BSF    03.5
0ADB:  MOVWF  07
0ADC:  MOVLW  04
0ADD:  MOVWF  77
0ADE:  DECFSZ 77,F
0ADF:  GOTO   2DE
0AE0:  BCF    03.5
0AE1:  BSF    3D.3
0AE2:  MOVF   3D,W
0AE3:  BSF    03.5
0AE4:  MOVWF  07
0AE5:  MOVLW  03
0AE6:  MOVWF  77
0AE7:  DECFSZ 77,F
0AE8:  GOTO   2E7
0AE9:  BCF    03.5
0AEA:  BCF    07.4
0AEB:  BCF    3D.4
0AEC:  MOVF   3D,W
0AED:  BSF    03.5
0AEE:  MOVWF  07
0AEF:  MOVLW  04
0AF0:  MOVWF  77
0AF1:  DECFSZ 77,F
0AF2:  GOTO   2F1
0AF3:  BCF    03.5
0AF4:  BCF    07.3
0AF5:  BCF    3D.3
0AF6:  MOVF   3D,W
0AF7:  BSF    03.5
0AF8:  MOVWF  07
....................    i2c_write(0xa0); 
0AF9:  MOVLW  A0
0AFA:  MOVWF  57
0AFB:  BCF    03.5
0AFC:  CALL   0AB
....................    i2c_write(address); 
0AFD:  BSF    03.5
0AFE:  MOVF   4F,W
0AFF:  MOVWF  57
0B00:  BCF    03.5
0B01:  CALL   0AB
....................    i2c_write(data); 
0B02:  BSF    03.5
0B03:  MOVF   50,W
0B04:  MOVWF  57
0B05:  BCF    03.5
0B06:  CALL   0AB
....................    i2c_stop(); 
0B07:  BCF    3D.4
0B08:  MOVF   3D,W
0B09:  BSF    03.5
0B0A:  MOVWF  07
0B0B:  NOP
0B0C:  BCF    03.5
0B0D:  BSF    3D.3
0B0E:  MOVF   3D,W
0B0F:  BSF    03.5
0B10:  MOVWF  07
0B11:  BCF    03.5
0B12:  BTFSS  07.3
0B13:  GOTO   312
0B14:  MOVLW  04
0B15:  MOVWF  77
0B16:  DECFSZ 77,F
0B17:  GOTO   316
0B18:  GOTO   319
0B19:  NOP
0B1A:  BSF    3D.4
0B1B:  MOVF   3D,W
0B1C:  BSF    03.5
0B1D:  MOVWF  07
0B1E:  MOVLW  04
0B1F:  MOVWF  77
0B20:  DECFSZ 77,F
0B21:  GOTO   320
0B22:  BCF    03.5
0B23:  RETURN
.................... } 
....................  
....................  
.................... BYTE read_ext_eeprom(BYTE address) { 
....................    BYTE data; 
....................  
....................    while(!ext_eeprom_ready()); 
*
0953:  CALL   107
0954:  MOVF   78,F
0955:  BTFSC  03.2
0956:  GOTO   153
....................    i2c_start(); 
0957:  BSF    3D.4
0958:  MOVF   3D,W
0959:  BSF    03.5
095A:  MOVWF  07
095B:  MOVLW  04
095C:  MOVWF  77
095D:  DECFSZ 77,F
095E:  GOTO   15D
095F:  BCF    03.5
0960:  BSF    3D.3
0961:  MOVF   3D,W
0962:  BSF    03.5
0963:  MOVWF  07
0964:  MOVLW  03
0965:  MOVWF  77
0966:  DECFSZ 77,F
0967:  GOTO   166
0968:  BCF    03.5
0969:  BCF    07.4
096A:  BCF    3D.4
096B:  MOVF   3D,W
096C:  BSF    03.5
096D:  MOVWF  07
096E:  MOVLW  04
096F:  MOVWF  77
0970:  DECFSZ 77,F
0971:  GOTO   170
0972:  BCF    03.5
0973:  BCF    07.3
0974:  BCF    3D.3
0975:  MOVF   3D,W
0976:  BSF    03.5
0977:  MOVWF  07
....................    i2c_write(0xa0); 
0978:  MOVLW  A0
0979:  MOVWF  57
097A:  BCF    03.5
097B:  CALL   0AB
....................    i2c_write(address); 
097C:  BSF    03.5
097D:  MOVF   54,W
097E:  MOVWF  57
097F:  BCF    03.5
0980:  CALL   0AB
....................    i2c_start(); 
0981:  BSF    3D.4
0982:  MOVF   3D,W
0983:  BSF    03.5
0984:  MOVWF  07
0985:  MOVLW  04
0986:  MOVWF  77
0987:  DECFSZ 77,F
0988:  GOTO   187
0989:  BCF    03.5
098A:  BSF    3D.3
098B:  MOVF   3D,W
098C:  BSF    03.5
098D:  MOVWF  07
098E:  MOVLW  03
098F:  MOVWF  77
0990:  DECFSZ 77,F
0991:  GOTO   190
0992:  BCF    03.5
0993:  BTFSS  07.3
0994:  GOTO   193
0995:  BCF    07.4
0996:  BCF    3D.4
0997:  MOVF   3D,W
0998:  BSF    03.5
0999:  MOVWF  07
099A:  MOVLW  04
099B:  MOVWF  77
099C:  DECFSZ 77,F
099D:  GOTO   19C
099E:  BCF    03.5
099F:  BCF    07.3
09A0:  BCF    3D.3
09A1:  MOVF   3D,W
09A2:  BSF    03.5
09A3:  MOVWF  07
....................    i2c_write(0xa1); 
09A4:  MOVLW  A1
09A5:  MOVWF  57
09A6:  BCF    03.5
09A7:  CALL   0AB
....................    data=i2c_read(0); 
09A8:  CLRF   77
*
0A01:  MOVF   78,W
0A02:  MOVWF  55
....................    i2c_stop(); 
0A03:  BCF    03.5
0A04:  BCF    3D.4
0A05:  MOVF   3D,W
0A06:  BSF    03.5
0A07:  MOVWF  07
0A08:  NOP
0A09:  BCF    03.5
0A0A:  BSF    3D.3
0A0B:  MOVF   3D,W
0A0C:  BSF    03.5
0A0D:  MOVWF  07
0A0E:  BCF    03.5
0A0F:  BTFSS  07.3
0A10:  GOTO   20F
0A11:  MOVLW  04
0A12:  MOVWF  77
0A13:  DECFSZ 77,F
0A14:  GOTO   213
0A15:  GOTO   216
0A16:  NOP
0A17:  BSF    3D.4
0A18:  MOVF   3D,W
0A19:  BSF    03.5
0A1A:  MOVWF  07
0A1B:  MOVLW  04
0A1C:  MOVWF  77
0A1D:  DECFSZ 77,F
0A1E:  GOTO   21D
....................    return(data); 
0A1F:  MOVF   55,W
0A20:  MOVWF  78
0A21:  BCF    03.5
0A22:  RETURN
.................... } 
....................  
.................... #include "kbd_board4.c" 
.................... /*######################################################################  
....................    Rotina utilização do teclado da placa PicSim board4 
....................    Adaptada para o compilador CCS 
....................    Autor: Alberto Willia Mascarenhas (adaptou para o compilador) 
....................    For e-mail suggestions :  awmascarenhas@gmail.com 
.................... ######################################################################## */ 
.................... unsigned char tc_tecla(unsigned int timeout) 
*
02C0:  CLRF   56
02C1:  CLRF   57
.................... { 
....................   unsigned int to=0; 
....................   unsigned char k = 0;   
....................   while(((to < timeout)||(!timeout))&&(!k)){ 
02C2:  MOVF   55,W
02C3:  SUBWF  56,W
02C4:  BTFSS  03.0
02C5:  GOTO   2C9
02C6:  MOVF   55,F
02C7:  BTFSS  03.2
02C8:  GOTO   408
02C9:  MOVF   57,F
02CA:  BTFSS  03.2
02CB:  GOTO   408
....................       
....................        
....................       //------------------------------------------------------------------------- 
....................       //inicio do programa de varredura do teclado matricial 
....................       //-------------------------------------------------------------------------- 
....................       //habilita primeira coluna do teclado 
....................       output_low(PIN_B0);output_high(PIN_B1);output_high(PIN_B2);output_high(PIN_B3); 
02CC:  BCF    06.0
02CD:  BCF    03.5
02CE:  BCF    06.0
02CF:  BSF    03.5
02D0:  BCF    06.1
02D1:  BCF    03.5
02D2:  BSF    06.1
02D3:  BSF    03.5
02D4:  BCF    06.2
02D5:  BCF    03.5
02D6:  BSF    06.2
02D7:  BSF    03.5
02D8:  BCF    06.3
02D9:  BCF    03.5
02DA:  BSF    06.3
....................       delay_ms(20); 
02DB:  MOVLW  14
02DC:  BSF    03.5
02DD:  MOVWF  5A
02DE:  BCF    03.5
02DF:  CALL   14F
....................       if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='1';}; 
02E0:  BSF    03.5
02E1:  BSF    08.0
02E2:  BCF    03.5
02E3:  BTFSC  08.0
02E4:  GOTO   2EE
02E5:  BSF    03.5
02E6:  BSF    08.0
02E7:  BCF    03.5
02E8:  BTFSS  08.0
02E9:  GOTO   2E5
02EA:  MOVLW  31
02EB:  BSF    03.5
02EC:  MOVWF  57
02ED:  BCF    03.5
....................       if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='4';}; 
02EE:  BSF    03.5
02EF:  BSF    08.1
02F0:  BCF    03.5
02F1:  BTFSC  08.1
02F2:  GOTO   2FC
02F3:  BSF    03.5
02F4:  BSF    08.1
02F5:  BCF    03.5
02F6:  BTFSS  08.1
02F7:  GOTO   2F3
02F8:  MOVLW  34
02F9:  BSF    03.5
02FA:  MOVWF  57
02FB:  BCF    03.5
....................       if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='7';}; 
02FC:  BSF    03.5
02FD:  BSF    08.2
02FE:  BCF    03.5
02FF:  BTFSC  08.2
0300:  GOTO   30A
0301:  BSF    03.5
0302:  BSF    08.2
0303:  BCF    03.5
0304:  BTFSS  08.2
0305:  GOTO   301
0306:  MOVLW  37
0307:  BSF    03.5
0308:  MOVWF  57
0309:  BCF    03.5
....................       if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='*';}; 
030A:  BSF    03.5
030B:  BSF    08.3
030C:  BCF    03.5
030D:  BTFSC  08.3
030E:  GOTO   318
030F:  BSF    03.5
0310:  BSF    08.3
0311:  BCF    03.5
0312:  BTFSS  08.3
0313:  GOTO   30F
0314:  MOVLW  2A
0315:  BSF    03.5
0316:  MOVWF  57
0317:  BCF    03.5
....................       //habilita segunda coluna do teclado 
....................       output_high(PIN_B0);output_low(PIN_B1);output_high(PIN_B2);output_high(PIN_B3); 
0318:  BSF    03.5
0319:  BCF    06.0
031A:  BCF    03.5
031B:  BSF    06.0
031C:  BSF    03.5
031D:  BCF    06.1
031E:  BCF    03.5
031F:  BCF    06.1
0320:  BSF    03.5
0321:  BCF    06.2
0322:  BCF    03.5
0323:  BSF    06.2
0324:  BSF    03.5
0325:  BCF    06.3
0326:  BCF    03.5
0327:  BSF    06.3
....................       delay_ms(20);       
0328:  MOVLW  14
0329:  BSF    03.5
032A:  MOVWF  5A
032B:  BCF    03.5
032C:  CALL   14F
....................       if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='2';}; 
032D:  BSF    03.5
032E:  BSF    08.0
032F:  BCF    03.5
0330:  BTFSC  08.0
0331:  GOTO   33B
0332:  BSF    03.5
0333:  BSF    08.0
0334:  BCF    03.5
0335:  BTFSS  08.0
0336:  GOTO   332
0337:  MOVLW  32
0338:  BSF    03.5
0339:  MOVWF  57
033A:  BCF    03.5
....................       if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='5';}; 
033B:  BSF    03.5
033C:  BSF    08.1
033D:  BCF    03.5
033E:  BTFSC  08.1
033F:  GOTO   349
0340:  BSF    03.5
0341:  BSF    08.1
0342:  BCF    03.5
0343:  BTFSS  08.1
0344:  GOTO   340
0345:  MOVLW  35
0346:  BSF    03.5
0347:  MOVWF  57
0348:  BCF    03.5
....................       if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='8';}; 
0349:  BSF    03.5
034A:  BSF    08.2
034B:  BCF    03.5
034C:  BTFSC  08.2
034D:  GOTO   357
034E:  BSF    03.5
034F:  BSF    08.2
0350:  BCF    03.5
0351:  BTFSS  08.2
0352:  GOTO   34E
0353:  MOVLW  38
0354:  BSF    03.5
0355:  MOVWF  57
0356:  BCF    03.5
....................       if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='0';}; 
0357:  BSF    03.5
0358:  BSF    08.3
0359:  BCF    03.5
035A:  BTFSC  08.3
035B:  GOTO   365
035C:  BSF    03.5
035D:  BSF    08.3
035E:  BCF    03.5
035F:  BTFSS  08.3
0360:  GOTO   35C
0361:  MOVLW  30
0362:  BSF    03.5
0363:  MOVWF  57
0364:  BCF    03.5
....................        
....................       //habilita terceira coluna do teclado 
....................       output_high(PIN_B0);output_high(PIN_B1);output_low(PIN_B2);output_high(PIN_B3); 
0365:  BSF    03.5
0366:  BCF    06.0
0367:  BCF    03.5
0368:  BSF    06.0
0369:  BSF    03.5
036A:  BCF    06.1
036B:  BCF    03.5
036C:  BSF    06.1
036D:  BSF    03.5
036E:  BCF    06.2
036F:  BCF    03.5
0370:  BCF    06.2
0371:  BSF    03.5
0372:  BCF    06.3
0373:  BCF    03.5
0374:  BSF    06.3
....................       delay_ms(20);       
0375:  MOVLW  14
0376:  BSF    03.5
0377:  MOVWF  5A
0378:  BCF    03.5
0379:  CALL   14F
....................       if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='3';}; 
037A:  BSF    03.5
037B:  BSF    08.0
037C:  BCF    03.5
037D:  BTFSC  08.0
037E:  GOTO   388
037F:  BSF    03.5
0380:  BSF    08.0
0381:  BCF    03.5
0382:  BTFSS  08.0
0383:  GOTO   37F
0384:  MOVLW  33
0385:  BSF    03.5
0386:  MOVWF  57
0387:  BCF    03.5
....................       if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='6';}; 
0388:  BSF    03.5
0389:  BSF    08.1
038A:  BCF    03.5
038B:  BTFSC  08.1
038C:  GOTO   396
038D:  BSF    03.5
038E:  BSF    08.1
038F:  BCF    03.5
0390:  BTFSS  08.1
0391:  GOTO   38D
0392:  MOVLW  36
0393:  BSF    03.5
0394:  MOVWF  57
0395:  BCF    03.5
....................       if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='9';}; 
0396:  BSF    03.5
0397:  BSF    08.2
0398:  BCF    03.5
0399:  BTFSC  08.2
039A:  GOTO   3A4
039B:  BSF    03.5
039C:  BSF    08.2
039D:  BCF    03.5
039E:  BTFSS  08.2
039F:  GOTO   39B
03A0:  MOVLW  39
03A1:  BSF    03.5
03A2:  MOVWF  57
03A3:  BCF    03.5
....................       if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='#';}; 
03A4:  BSF    03.5
03A5:  BSF    08.3
03A6:  BCF    03.5
03A7:  BTFSC  08.3
03A8:  GOTO   3B2
03A9:  BSF    03.5
03AA:  BSF    08.3
03AB:  BCF    03.5
03AC:  BTFSS  08.3
03AD:  GOTO   3A9
03AE:  MOVLW  23
03AF:  BSF    03.5
03B0:  MOVWF  57
03B1:  BCF    03.5
....................   
....................        //habilita quarta coluna do teclado 
....................       output_high(PIN_B0);output_high(PIN_B1);output_high(PIN_B2);output_low(PIN_B3); 
03B2:  BSF    03.5
03B3:  BCF    06.0
03B4:  BCF    03.5
03B5:  BSF    06.0
03B6:  BSF    03.5
03B7:  BCF    06.1
03B8:  BCF    03.5
03B9:  BSF    06.1
03BA:  BSF    03.5
03BB:  BCF    06.2
03BC:  BCF    03.5
03BD:  BSF    06.2
03BE:  BSF    03.5
03BF:  BCF    06.3
03C0:  BCF    03.5
03C1:  BCF    06.3
....................       delay_ms(20);       
03C2:  MOVLW  14
03C3:  BSF    03.5
03C4:  MOVWF  5A
03C5:  BCF    03.5
03C6:  CALL   14F
....................       if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='A';}; 
03C7:  BSF    03.5
03C8:  BSF    08.0
03C9:  BCF    03.5
03CA:  BTFSC  08.0
03CB:  GOTO   3D5
03CC:  BSF    03.5
03CD:  BSF    08.0
03CE:  BCF    03.5
03CF:  BTFSS  08.0
03D0:  GOTO   3CC
03D1:  MOVLW  41
03D2:  BSF    03.5
03D3:  MOVWF  57
03D4:  BCF    03.5
....................       if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='B';}; 
03D5:  BSF    03.5
03D6:  BSF    08.1
03D7:  BCF    03.5
03D8:  BTFSC  08.1
03D9:  GOTO   3E3
03DA:  BSF    03.5
03DB:  BSF    08.1
03DC:  BCF    03.5
03DD:  BTFSS  08.1
03DE:  GOTO   3DA
03DF:  MOVLW  42
03E0:  BSF    03.5
03E1:  MOVWF  57
03E2:  BCF    03.5
....................       if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='C';}; 
03E3:  BSF    03.5
03E4:  BSF    08.2
03E5:  BCF    03.5
03E6:  BTFSC  08.2
03E7:  GOTO   3F1
03E8:  BSF    03.5
03E9:  BSF    08.2
03EA:  BCF    03.5
03EB:  BTFSS  08.2
03EC:  GOTO   3E8
03ED:  MOVLW  43
03EE:  BSF    03.5
03EF:  MOVWF  57
03F0:  BCF    03.5
....................       if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='D';}; 
03F1:  BSF    03.5
03F2:  BSF    08.3
03F3:  BCF    03.5
03F4:  BTFSC  08.3
03F5:  GOTO   3FF
03F6:  BSF    03.5
03F7:  BSF    08.3
03F8:  BCF    03.5
03F9:  BTFSS  08.3
03FA:  GOTO   3F6
03FB:  MOVLW  44
03FC:  BSF    03.5
03FD:  MOVWF  57
03FE:  BCF    03.5
....................   
....................       //printf (lcd_escreve,"\f saiu geral %u",k); 
....................       //delay_ms(1000); 
....................       delay_ms(5); 
03FF:  MOVLW  05
0400:  BSF    03.5
0401:  MOVWF  5A
0402:  BCF    03.5
0403:  CALL   14F
....................       to+=5; 
0404:  MOVLW  05
0405:  BSF    03.5
0406:  ADDWF  56,F
0407:  GOTO   2C2
....................   } 
....................    if(!k)k=255; 
0408:  MOVF   57,F
0409:  BTFSS  03.2
040A:  GOTO   40D
040B:  MOVLW  FF
040C:  MOVWF  57
....................   return k;   
040D:  MOVF   57,W
040E:  MOVWF  78
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... // -----------------Functions 
.................... void saveUser(int * id, int * pass, int status); 
.................... int getAddressByID(int * id);    
.................... void searchUser(int * id); 
.................... int deleteUser(int address); 
....................  
.................... // int isIdAvailable(int id);     
.................... void printUser(); 
.................... void erase_program_eeprom(int addrr); 
.................... int incrementID(); 
.................... int lastNewUserPosition(); 
.................... void resetMemory(); 
.................... void adminMenu(); 
.................... unsigned char readKeyboard();  
.................... int * getAdminsID(); 
.................... void listAdmins(); 
.................... int * strToInt(char * str); 
.................... char * strfromchar(char destination[], char source); 
.................... int * inputId(); 
.................... int * inputToKeyboard(char * msg, int max); 
.................... void inputKeyboardUser(); 
....................  
....................  
.................... typedef struct {  
....................    int id[2];   
....................    int pass[4]; //password 
....................    int status; //0 - Unpaid, 1 - Paid, 3 - Admin 
.................... }User; 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
*
049C:  BSF    03.6
049D:  MOVF   37,W
049E:  MOVWF  3A
....................    for(su=s;0<n;++su,--n) 
049F:  MOVF   36,W
04A0:  MOVWF  3C
04A1:  MOVF   35,W
04A2:  MOVWF  3B
04A3:  MOVF   39,F
04A4:  BTFSS  03.2
04A5:  GOTO   4AA
04A6:  MOVF   38,W
04A7:  SUBLW  00
04A8:  BTFSC  03.0
04A9:  GOTO   4C2
....................       if(*su==uc) 
04AA:  MOVF   3C,W
04AB:  MOVWF  7A
04AC:  MOVF   3B,W
04AD:  MOVWF  04
04AE:  BCF    03.7
04AF:  BTFSC  7A.0
04B0:  BSF    03.7
04B1:  MOVF   3A,W
04B2:  SUBWF  00,W
04B3:  BTFSS  03.2
04B4:  GOTO   4BA
....................       return su; 
04B5:  MOVF   3B,W
04B6:  MOVWF  78
04B7:  MOVF   3C,W
04B8:  MOVWF  79
04B9:  GOTO   4C5
04BA:  INCF   3B,F
04BB:  BTFSC  03.2
04BC:  INCF   3C,F
04BD:  MOVF   38,W
04BE:  BTFSC  03.2
04BF:  DECF   39,F
04C0:  DECF   38,F
04C1:  GOTO   4A3
....................    return NULL; 
04C2:  MOVLW  00
04C3:  MOVWF  78
04C4:  MOVWF  79
04C5:  BCF    03.6
04C6:  RETURN
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
0E61:  BCF    03.5
0E62:  CLRF   3E
0E63:  CLRF   3F
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
*
04C7:  BSF    03.5
04C8:  CLRF   67
04C9:  CLRF   66
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
04CA:  MOVLW  30
04CB:  BCF    03.5
04CC:  BSF    03.6
04CD:  MOVWF  10
04CE:  MOVLW  31
04CF:  MOVWF  11
04D0:  MOVLW  32
04D1:  MOVWF  12
04D2:  MOVLW  33
04D3:  MOVWF  13
04D4:  MOVLW  34
04D5:  MOVWF  14
04D6:  MOVLW  35
04D7:  MOVWF  15
04D8:  MOVLW  36
04D9:  MOVWF  16
04DA:  MOVLW  37
04DB:  MOVWF  17
04DC:  MOVLW  38
04DD:  MOVWF  18
04DE:  MOVLW  39
04DF:  MOVWF  19
04E0:  MOVLW  61
04E1:  MOVWF  1A
04E2:  MOVLW  62
04E3:  MOVWF  1B
04E4:  MOVLW  63
04E5:  MOVWF  1C
04E6:  MOVLW  64
04E7:  MOVWF  1D
04E8:  MOVLW  65
04E9:  MOVWF  1E
04EA:  MOVLW  66
04EB:  MOVWF  1F
04EC:  MOVLW  67
04ED:  MOVWF  20
04EE:  MOVLW  68
04EF:  MOVWF  21
04F0:  MOVLW  69
04F1:  MOVWF  22
04F2:  MOVLW  6A
04F3:  MOVWF  23
04F4:  MOVLW  6B
04F5:  MOVWF  24
04F6:  MOVLW  6C
04F7:  MOVWF  25
04F8:  MOVLW  6D
04F9:  MOVWF  26
04FA:  MOVLW  6E
04FB:  MOVWF  27
04FC:  MOVLW  6F
04FD:  MOVWF  28
04FE:  MOVLW  70
04FF:  MOVWF  29
0500:  MOVLW  71
0501:  MOVWF  2A
0502:  MOVLW  73
0503:  MOVWF  2B
0504:  MOVLW  74
0505:  MOVWF  2C
0506:  MOVLW  75
0507:  MOVWF  2D
0508:  MOVLW  76
0509:  MOVWF  2E
050A:  MOVLW  77
050B:  MOVWF  2F
050C:  MOVLW  78
050D:  MOVWF  30
050E:  MOVLW  79
050F:  MOVWF  31
0510:  MOVLW  7A
0511:  MOVWF  32
0512:  CLRF   33
....................    for(sc=s;isspace(*sc);++sc); 
0513:  BSF    03.5
0514:  BCF    03.6
0515:  MOVF   5C,W
0516:  MOVWF  61
0517:  MOVF   5B,W
0518:  MOVWF  60
0519:  MOVF   61,W
051A:  MOVWF  7A
051B:  MOVF   60,W
051C:  MOVWF  04
051D:  BCF    03.7
051E:  BTFSC  7A.0
051F:  BSF    03.7
0520:  MOVF   00,W
0521:  SUBLW  20
0522:  BTFSS  03.2
0523:  GOTO   528
0524:  INCF   60,F
0525:  BTFSC  03.2
0526:  INCF   61,F
0527:  GOTO   519
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
0528:  MOVF   61,W
0529:  MOVWF  7A
052A:  MOVF   60,W
052B:  MOVWF  04
052C:  BCF    03.7
052D:  BTFSC  61.0
052E:  BSF    03.7
052F:  MOVF   00,W
0530:  SUBLW  2D
0531:  BTFSC  03.2
0532:  GOTO   53E
0533:  MOVF   61,W
0534:  MOVWF  7A
0535:  MOVF   60,W
0536:  MOVWF  04
0537:  BCF    03.7
0538:  BTFSC  61.0
0539:  BSF    03.7
053A:  MOVF   00,W
053B:  SUBLW  2B
053C:  BTFSS  03.2
053D:  GOTO   54A
053E:  MOVF   61,W
053F:  MOVWF  7A
0540:  MOVF   60,W
0541:  INCF   60,F
0542:  BTFSC  03.2
0543:  INCF   61,F
0544:  MOVWF  04
0545:  BCF    03.7
0546:  BTFSC  7A.0
0547:  BSF    03.7
0548:  MOVF   00,W
0549:  GOTO   54B
054A:  MOVLW  2B
054B:  MOVWF  68
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
054C:  MOVF   68,W
054D:  SUBLW  2D
054E:  BTFSC  03.2
054F:  GOTO   55B
0550:  BTFSC  5F.7
0551:  GOTO   55B
0552:  DECFSZ 5F,W
0553:  GOTO   555
0554:  GOTO   55B
0555:  BTFSC  5F.7
0556:  GOTO   55D
0557:  MOVF   5F,W
0558:  SUBLW  24
0559:  BTFSC  03.0
055A:  GOTO   55D
....................    goto StrtoulGO; 
055B:  GOTO   6DB
055C:  GOTO   5F3
....................  
....................    else if (base) 
055D:  MOVF   5F,F
055E:  BTFSC  03.2
055F:  GOTO   5B8
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
0560:  MOVF   5F,W
0561:  SUBLW  10
0562:  BTFSS  03.2
0563:  GOTO   587
0564:  MOVF   61,W
0565:  MOVWF  7A
0566:  MOVF   60,W
0567:  MOVWF  04
0568:  BCF    03.7
0569:  BTFSC  7A.0
056A:  BSF    03.7
056B:  MOVF   00,W
056C:  SUBLW  30
056D:  BTFSS  03.2
056E:  GOTO   587
056F:  MOVLW  01
0570:  ADDWF  60,W
0571:  MOVWF  04
0572:  BCF    03.7
0573:  BTFSC  61.0
0574:  BSF    03.7
0575:  MOVF   00,W
0576:  SUBLW  78
0577:  BTFSC  03.2
0578:  GOTO   583
0579:  MOVLW  01
057A:  ADDWF  60,W
057B:  MOVWF  04
057C:  BCF    03.7
057D:  BTFSC  61.0
057E:  BSF    03.7
057F:  MOVF   00,W
0580:  SUBLW  58
0581:  BTFSS  03.2
0582:  GOTO   587
....................          sc+=2; 
0583:  MOVLW  02
0584:  ADDWF  60,F
0585:  BTFSC  03.0
0586:  INCF   61,F
....................       if(base==8 && *sc =='0') 
0587:  MOVF   5F,W
0588:  SUBLW  08
0589:  BTFSS  03.2
058A:  GOTO   59A
058B:  MOVF   61,W
058C:  MOVWF  7A
058D:  MOVF   60,W
058E:  MOVWF  04
058F:  BCF    03.7
0590:  BTFSC  7A.0
0591:  BSF    03.7
0592:  MOVF   00,W
0593:  SUBLW  30
0594:  BTFSS  03.2
0595:  GOTO   59A
....................          sc+=1; 
0596:  MOVLW  01
0597:  ADDWF  60,F
0598:  BTFSC  03.0
0599:  INCF   61,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
059A:  MOVF   5F,W
059B:  SUBLW  02
059C:  BTFSS  03.2
059D:  GOTO   5B7
059E:  MOVF   61,W
059F:  MOVWF  7A
05A0:  MOVF   60,W
05A1:  MOVWF  04
05A2:  BCF    03.7
05A3:  BTFSC  7A.0
05A4:  BSF    03.7
05A5:  MOVF   00,W
05A6:  SUBLW  30
05A7:  BTFSS  03.2
05A8:  GOTO   5B7
05A9:  MOVLW  01
05AA:  ADDWF  60,W
05AB:  MOVWF  04
05AC:  BCF    03.7
05AD:  BTFSC  61.0
05AE:  BSF    03.7
05AF:  MOVF   00,W
05B0:  SUBLW  62
05B1:  BTFSS  03.2
05B2:  GOTO   5B7
....................          sc+=2; 
05B3:  MOVLW  02
05B4:  ADDWF  60,F
05B5:  BTFSC  03.0
05B6:  INCF   61,F
....................  
....................    } 
05B7:  GOTO   5F3
....................    else if(*sc!='0') // base is 0, find base 
05B8:  MOVF   61,W
05B9:  MOVWF  7A
05BA:  MOVF   60,W
05BB:  MOVWF  04
05BC:  BCF    03.7
05BD:  BTFSC  7A.0
05BE:  BSF    03.7
05BF:  MOVF   00,W
05C0:  SUBLW  30
05C1:  BTFSC  03.2
05C2:  GOTO   5C6
....................       base=10; 
05C3:  MOVLW  0A
05C4:  MOVWF  5F
05C5:  GOTO   5F3
....................    else if (sc[1]=='x' || sc[1]=='X') 
05C6:  MOVLW  01
05C7:  ADDWF  60,W
05C8:  MOVWF  04
05C9:  BCF    03.7
05CA:  BTFSC  61.0
05CB:  BSF    03.7
05CC:  MOVF   00,W
05CD:  SUBLW  78
05CE:  BTFSC  03.2
05CF:  GOTO   5DA
05D0:  MOVLW  01
05D1:  ADDWF  60,W
05D2:  MOVWF  04
05D3:  BCF    03.7
05D4:  BTFSC  61.0
05D5:  BSF    03.7
05D6:  MOVF   00,W
05D7:  SUBLW  58
05D8:  BTFSS  03.2
05D9:  GOTO   5E1
....................       base =16,sc+=2; 
05DA:  MOVLW  10
05DB:  MOVWF  5F
05DC:  MOVLW  02
05DD:  ADDWF  60,F
05DE:  BTFSC  03.0
05DF:  INCF   61,F
05E0:  GOTO   5F3
....................    else if(sc[1]=='b') 
05E1:  MOVLW  01
05E2:  ADDWF  60,W
05E3:  MOVWF  04
05E4:  BCF    03.7
05E5:  BTFSC  61.0
05E6:  BSF    03.7
05E7:  MOVF   00,W
05E8:  SUBLW  62
05E9:  BTFSS  03.2
05EA:  GOTO   5F1
....................       base=2,sc+=2; 
05EB:  MOVLW  02
05EC:  MOVWF  5F
05ED:  ADDWF  60,F
05EE:  BTFSC  03.0
05EF:  INCF   61,F
05F0:  GOTO   5F3
....................    else 
....................       base=8; 
05F1:  MOVLW  08
05F2:  MOVWF  5F
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
05F3:  MOVF   61,W
05F4:  MOVWF  63
05F5:  MOVF   60,W
05F6:  MOVWF  62
05F7:  MOVF   61,W
05F8:  MOVWF  7A
05F9:  MOVF   60,W
05FA:  MOVWF  04
05FB:  BCF    03.7
05FC:  BTFSC  7A.0
05FD:  BSF    03.7
05FE:  MOVF   00,W
05FF:  SUBLW  30
0600:  BTFSS  03.2
0601:  GOTO   606
0602:  INCF   60,F
0603:  BTFSC  03.2
0604:  INCF   61,F
0605:  GOTO   5F7
....................    sd=memchr(digits,tolower(*sc),base); 
0606:  MOVF   61,W
0607:  MOVWF  7A
0608:  MOVF   60,W
0609:  MOVWF  04
060A:  BCF    03.7
060B:  BTFSC  61.0
060C:  BSF    03.7
060D:  MOVF   00,W
060E:  MOVWF  69
060F:  SUBLW  40
0610:  BTFSC  03.0
0611:  GOTO   619
0612:  MOVF   69,W
0613:  SUBLW  5A
0614:  BTFSS  03.0
0615:  GOTO   619
0616:  MOVF   69,W
0617:  IORLW  20
0618:  GOTO   61A
0619:  MOVF   69,W
061A:  MOVWF  69
061B:  MOVLW  01
061C:  BCF    03.5
061D:  BSF    03.6
061E:  MOVWF  36
061F:  MOVLW  10
0620:  MOVWF  35
0621:  BSF    03.5
0622:  BCF    03.6
0623:  MOVF   69,W
0624:  BCF    03.5
0625:  BSF    03.6
0626:  MOVWF  37
0627:  CLRF   39
0628:  BSF    03.5
0629:  BCF    03.6
062A:  MOVF   5F,W
062B:  BCF    03.5
062C:  BSF    03.6
062D:  MOVWF  38
062E:  BCF    03.6
062F:  CALL   49C
0630:  MOVF   79,W
0631:  BSF    03.5
0632:  MOVWF  65
0633:  MOVF   78,W
0634:  MOVWF  64
....................    for(; sd!=0; ) 
0635:  MOVF   64,F
0636:  BTFSS  03.2
0637:  GOTO   63B
0638:  MOVF   65,F
0639:  BTFSC  03.2
063A:  GOTO   6D3
....................    { 
....................       x=x*base+(int16)(sd-digits); 
063B:  CLRF   7A
063C:  MOVF   5F,W
063D:  MOVWF  77
063E:  BTFSC  77.7
063F:  DECF   7A,F
0640:  MOVWF  69
0641:  MOVF   7A,W
0642:  MOVWF  6A
0643:  MOVF   67,W
0644:  BCF    03.5
0645:  BSF    03.6
0646:  MOVWF  37
0647:  BSF    03.5
0648:  BCF    03.6
0649:  MOVF   66,W
064A:  BCF    03.5
064B:  BSF    03.6
064C:  MOVWF  36
064D:  BSF    03.5
064E:  BCF    03.6
064F:  MOVF   6A,W
0650:  BCF    03.5
0651:  BSF    03.6
0652:  MOVWF  39
0653:  BSF    03.5
0654:  BCF    03.6
0655:  MOVF   69,W
0656:  BCF    03.5
0657:  BSF    03.6
0658:  MOVWF  38
*
0686:  MOVF   79,W
0687:  BSF    03.5
0688:  BCF    03.6
0689:  MOVWF  6A
068A:  MOVF   78,W
068B:  MOVWF  69
068C:  MOVLW  10
068D:  SUBWF  64,W
068E:  MOVWF  77
068F:  MOVF   65,W
0690:  MOVWF  7A
0691:  MOVLW  01
0692:  BTFSS  03.0
0693:  MOVLW  02
0694:  SUBWF  7A,F
0695:  MOVF   77,W
0696:  ADDWF  69,W
0697:  MOVWF  78
0698:  MOVF   6A,W
0699:  BTFSC  03.0
069A:  INCFSZ 6A,W
069B:  ADDWF  7A,F
069C:  MOVF   78,W
069D:  MOVWF  66
069E:  MOVF   7A,W
069F:  MOVWF  67
....................       ++sc; 
06A0:  INCF   60,F
06A1:  BTFSC  03.2
06A2:  INCF   61,F
....................       sd=memchr(digits,tolower(*sc),base); 
06A3:  MOVF   61,W
06A4:  MOVWF  7A
06A5:  MOVF   60,W
06A6:  MOVWF  04
06A7:  BCF    03.7
06A8:  BTFSC  61.0
06A9:  BSF    03.7
06AA:  MOVF   00,W
06AB:  MOVWF  69
06AC:  SUBLW  40
06AD:  BTFSC  03.0
06AE:  GOTO   6B6
06AF:  MOVF   69,W
06B0:  SUBLW  5A
06B1:  BTFSS  03.0
06B2:  GOTO   6B6
06B3:  MOVF   69,W
06B4:  IORLW  20
06B5:  GOTO   6B7
06B6:  MOVF   69,W
06B7:  MOVWF  69
06B8:  MOVLW  01
06B9:  BCF    03.5
06BA:  BSF    03.6
06BB:  MOVWF  36
06BC:  MOVLW  10
06BD:  MOVWF  35
06BE:  BSF    03.5
06BF:  BCF    03.6
06C0:  MOVF   69,W
06C1:  BCF    03.5
06C2:  BSF    03.6
06C3:  MOVWF  37
06C4:  CLRF   39
06C5:  BSF    03.5
06C6:  BCF    03.6
06C7:  MOVF   5F,W
06C8:  BCF    03.5
06C9:  BSF    03.6
06CA:  MOVWF  38
06CB:  BCF    03.6
06CC:  CALL   49C
06CD:  MOVF   79,W
06CE:  BSF    03.5
06CF:  MOVWF  65
06D0:  MOVF   78,W
06D1:  MOVWF  64
06D2:  GOTO   635
....................    } 
....................    if(s1==sc) 
06D3:  MOVF   60,W
06D4:  SUBWF  62,W
06D5:  BTFSS  03.2
06D6:  GOTO   6EE
06D7:  MOVF   61,W
06D8:  SUBWF  63,W
06D9:  BTFSS  03.2
06DA:  GOTO   6EE
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
06DB:  MOVF   5D,W
06DC:  IORWF  5E,W
06DD:  BTFSC  03.2
06DE:  GOTO   6EA
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
06DF:  MOVF   5D,W
06E0:  MOVWF  04
06E1:  BCF    03.7
06E2:  BTFSC  5E.0
06E3:  BSF    03.7
06E4:  INCF   04,F
06E5:  MOVF   5C,W
06E6:  MOVWF  00
06E7:  DECF   04,F
06E8:  MOVF   5B,W
06E9:  MOVWF  00
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
06EA:  MOVLW  00
06EB:  MOVWF  78
06EC:  MOVWF  79
06ED:  GOTO   701
....................    } 
....................    if (endptr) 
06EE:  MOVF   5D,W
06EF:  IORWF  5E,W
06F0:  BTFSC  03.2
06F1:  GOTO   6FD
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
06F2:  MOVF   5D,W
06F3:  MOVWF  04
06F4:  BCF    03.7
06F5:  BTFSC  5E.0
06F6:  BSF    03.7
06F7:  INCF   04,F
06F8:  MOVF   61,W
06F9:  MOVWF  00
06FA:  DECF   04,F
06FB:  MOVF   60,W
06FC:  MOVWF  00
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
06FD:  MOVF   66,W
06FE:  MOVWF  78
06FF:  MOVF   67,W
0700:  MOVWF  79
0701:  BCF    03.5
0702:  RETURN
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... void saveUser(int * id, int * pass, int status){ 
....................    if( id[0] <= 99 && id[1] <= 99 && getAddressByID(id) == -1 ){ 
*
0CB2:  MOVF   41,W
0CB3:  MOVWF  04
0CB4:  BCF    03.7
0CB5:  BTFSC  42.0
0CB6:  BSF    03.7
0CB7:  MOVF   00,W
0CB8:  SUBLW  63
0CB9:  BTFSS  03.0
0CBA:  GOTO   567
0CBB:  MOVLW  01
0CBC:  ADDWF  41,W
0CBD:  MOVWF  04
0CBE:  BCF    03.7
0CBF:  BTFSC  42.0
0CC0:  BSF    03.7
0CC1:  MOVF   00,W
0CC2:  SUBLW  63
0CC3:  BTFSS  03.0
0CC4:  GOTO   567
0CC5:  MOVF   42,W
0CC6:  MOVWF  4F
0CC7:  MOVF   41,W
0CC8:  MOVWF  4E
0CC9:  BCF    03.5
0CCA:  CALL   223
0CCB:  MOVF   78,W
0CCC:  SUBLW  FF
0CCD:  BTFSC  03.2
0CCE:  GOTO   4D1
0CCF:  BSF    03.5
0CD0:  GOTO   567
....................       int address = lastNewUserPosition(); 
....................       //recebe os parÃ¢metros do usuÃ¡rio 
....................       User user; 
*
0CE3:  MOVF   78,W
0CE4:  MOVWF  46
....................       user.id[0] = id[0]; 
0CE5:  MOVF   41,W
0CE6:  MOVWF  04
0CE7:  BCF    03.7
0CE8:  BTFSC  42.0
0CE9:  BSF    03.7
0CEA:  MOVF   00,W
0CEB:  MOVWF  47
....................       user.id[1] = id[1]; 
0CEC:  MOVLW  01
0CED:  ADDWF  41,W
0CEE:  MOVWF  04
0CEF:  BCF    03.7
0CF0:  BTFSC  42.0
0CF1:  BSF    03.7
0CF2:  MOVF   00,W
0CF3:  MOVWF  48
....................       user.pass[0] = pass[0]; 
0CF4:  MOVF   43,W
0CF5:  MOVWF  04
0CF6:  BCF    03.7
0CF7:  BTFSC  44.0
0CF8:  BSF    03.7
0CF9:  MOVF   00,W
0CFA:  MOVWF  49
....................       user.pass[1] = pass[1]; 
0CFB:  MOVLW  01
0CFC:  ADDWF  43,W
0CFD:  MOVWF  04
0CFE:  BCF    03.7
0CFF:  BTFSC  44.0
0D00:  BSF    03.7
0D01:  MOVF   00,W
0D02:  MOVWF  4A
....................       user.pass[2] = pass[2]; 
0D03:  MOVLW  02
0D04:  ADDWF  43,W
0D05:  MOVWF  04
0D06:  BCF    03.7
0D07:  BTFSC  44.0
0D08:  BSF    03.7
0D09:  MOVF   00,W
0D0A:  MOVWF  4B
....................       user.pass[3] = pass[3]; 
0D0B:  MOVLW  03
0D0C:  ADDWF  43,W
0D0D:  MOVWF  04
0D0E:  BCF    03.7
0D0F:  BTFSC  44.0
0D10:  BSF    03.7
0D11:  MOVF   00,W
0D12:  MOVWF  4C
....................       user.status = status; 
0D13:  MOVF   45,W
0D14:  MOVWF  4D
....................        
....................       write_ext_eeprom(address, user.id[0]); 
0D15:  MOVF   46,W
0D16:  MOVWF  4F
0D17:  MOVF   47,W
0D18:  MOVWF  50
0D19:  BCF    03.5
0D1A:  CALL   2D4
....................       write_ext_eeprom(address+1, user.id[1]); 
0D1B:  MOVLW  01
0D1C:  BSF    03.5
0D1D:  ADDWF  46,W
0D1E:  MOVWF  4E
0D1F:  MOVWF  4F
0D20:  MOVF   48,W
0D21:  MOVWF  50
0D22:  BCF    03.5
0D23:  CALL   2D4
....................       write_ext_eeprom(address+2, user.pass[0]); 
0D24:  MOVLW  02
0D25:  BSF    03.5
0D26:  ADDWF  46,W
0D27:  MOVWF  4E
0D28:  MOVWF  4F
0D29:  MOVF   49,W
0D2A:  MOVWF  50
0D2B:  BCF    03.5
0D2C:  CALL   2D4
....................       write_ext_eeprom(address+3, user.pass[1]); 
0D2D:  MOVLW  03
0D2E:  BSF    03.5
0D2F:  ADDWF  46,W
0D30:  MOVWF  4E
0D31:  MOVWF  4F
0D32:  MOVF   4A,W
0D33:  MOVWF  50
0D34:  BCF    03.5
0D35:  CALL   2D4
....................       write_ext_eeprom(address+4, user.pass[2]); 
0D36:  MOVLW  04
0D37:  BSF    03.5
0D38:  ADDWF  46,W
0D39:  MOVWF  4E
0D3A:  MOVWF  4F
0D3B:  MOVF   4B,W
0D3C:  MOVWF  50
0D3D:  BCF    03.5
0D3E:  CALL   2D4
....................       write_ext_eeprom(address+5, user.pass[3]);        
0D3F:  MOVLW  05
0D40:  BSF    03.5
0D41:  ADDWF  46,W
0D42:  MOVWF  4E
0D43:  MOVWF  4F
0D44:  MOVF   4C,W
0D45:  MOVWF  50
0D46:  BCF    03.5
0D47:  CALL   2D4
....................       write_ext_eeprom(address+6, user.status); 
0D48:  MOVLW  06
0D49:  BSF    03.5
0D4A:  ADDWF  46,W
0D4B:  MOVWF  4E
0D4C:  MOVWF  4F
0D4D:  MOVF   4D,W
0D4E:  MOVWF  50
0D4F:  BCF    03.5
0D50:  CALL   2D4
....................  
....................       printf (lcd_escreve,"\fUsuario Cadastrado"); 
0D51:  MOVLW  76
0D52:  BSF    03.6
0D53:  MOVWF  0D
0D54:  MOVLW  00
0D55:  MOVWF  0F
0D56:  BCF    0A.3
0D57:  BCF    03.6
0D58:  CALL   249
0D59:  BSF    0A.3
....................       delay_ms(500); 
0D5A:  MOVLW  02
0D5B:  BSF    03.5
0D5C:  MOVWF  4E
0D5D:  MOVLW  FA
0D5E:  MOVWF  5A
0D5F:  BCF    0A.3
0D60:  BCF    03.5
0D61:  CALL   14F
0D62:  BSF    0A.3
0D63:  BSF    03.5
0D64:  DECFSZ 4E,F
0D65:  GOTO   55D
....................  
....................    }else{ 
0D66:  GOTO   586
....................       printf (lcd_escreve,"\fID incompativel"); 
0D67:  MOVLW  80
0D68:  BCF    03.5
0D69:  BSF    03.6
0D6A:  MOVWF  0D
0D6B:  MOVLW  00
0D6C:  MOVWF  0F
0D6D:  BCF    0A.3
0D6E:  BCF    03.6
0D6F:  CALL   249
0D70:  BSF    0A.3
....................       printf (lcd_escreve,"\r\nTente novamente"); 
0D71:  MOVLW  89
0D72:  BSF    03.6
0D73:  MOVWF  0D
0D74:  MOVLW  00
0D75:  MOVWF  0F
0D76:  BCF    0A.3
0D77:  BCF    03.6
0D78:  CALL   249
0D79:  BSF    0A.3
....................       delay_ms(1000); 
0D7A:  MOVLW  04
0D7B:  BSF    03.5
0D7C:  MOVWF  4E
0D7D:  MOVLW  FA
0D7E:  MOVWF  5A
0D7F:  BCF    0A.3
0D80:  BCF    03.5
0D81:  CALL   14F
0D82:  BSF    0A.3
0D83:  BSF    03.5
0D84:  DECFSZ 4E,F
0D85:  GOTO   57D
....................  
....................    } 
.................... } 
....................  
.................... void printUser(){ 
....................    //delay_ms(50); 
....................    int tmp_result = read_ext_eeprom(0);   
....................  
....................    delay_ms(50);   
....................     
....................    printf (lcd_escreve,"\f Button: %d", tmp_result); 
....................    printf(lcd_escreve, "\r\nPw:%d%d%d%d St:%d %d", read_ext_eeprom(1), read_ext_eeprom(2), read_ext_eeprom(3), read_ext_eeprom(4), read_ext_eeprom(5), read_ext_eeprom(6)); 
....................     
....................    //printf(lcd_escreve, "\f Client () elseÂ´{}{} 
....................    // printf(lcd_escreve, "\r\nPw:%c%c%c%c St:%c %c", U1.pass[0], U1.pass[1], U1.pass[2], U1.pass[3], U1.status, U1.type_usr); 
.................... } 
....................  
.................... int getAddressByID(int * id){ 
*
0A23:  BSF    03.5
0A24:  CLRF   52
....................    int id_temp[2]; 
....................    int address = 0; 
....................     
....................    while( read_ext_eeprom(address) != -1){ 
0A25:  MOVF   52,W
0A26:  MOVWF  54
0A27:  BCF    03.5
0A28:  CALL   153
0A29:  MOVF   78,W
0A2A:  SUBLW  FF
0A2B:  BTFSC  03.2
0A2C:  GOTO   285
....................       id_temp[0] = read_ext_eeprom(address); 
0A2D:  BSF    03.5
0A2E:  MOVF   52,W
0A2F:  MOVWF  54
0A30:  BCF    03.5
0A31:  CALL   153
0A32:  MOVF   78,W
0A33:  BSF    03.5
0A34:  MOVWF  50
....................       id_temp[1] = read_ext_eeprom(address+1); 
0A35:  MOVLW  01
0A36:  ADDWF  52,W
0A37:  MOVWF  53
0A38:  MOVWF  54
0A39:  BCF    03.5
0A3A:  CALL   153
0A3B:  MOVF   78,W
0A3C:  BSF    03.5
0A3D:  MOVWF  51
....................        
....................       if (id_temp[0] == id[0] && id_temp[1] == id[1]){ 
0A3E:  MOVF   4E,W
0A3F:  MOVWF  04
0A40:  BCF    03.7
0A41:  BTFSC  4F.0
0A42:  BSF    03.7
0A43:  MOVF   00,W
0A44:  SUBWF  50,W
0A45:  BTFSS  03.2
0A46:  GOTO   281
0A47:  MOVLW  01
0A48:  ADDWF  4E,W
0A49:  MOVWF  04
0A4A:  BCF    03.7
0A4B:  BTFSC  4F.0
0A4C:  BSF    03.7
0A4D:  MOVF   00,W
0A4E:  SUBWF  51,W
0A4F:  BTFSS  03.2
0A50:  GOTO   281
....................          printf (lcd_escreve,"\fID Existe:%u%u", id_temp[0],id_temp[1]); 
0A51:  MOVLW  A5
0A52:  BCF    03.5
0A53:  BSF    03.6
0A54:  MOVWF  0D
0A55:  MOVLW  00
0A56:  MOVWF  0F
0A57:  BCF    03.0
0A58:  MOVLW  0B
0A59:  BSF    03.5
0A5A:  BCF    03.6
0A5B:  MOVWF  55
0A5C:  BCF    0A.3
0A5D:  BCF    03.5
0A5E:  CALL   422
0A5F:  BSF    0A.3
0A60:  BSF    03.5
0A61:  MOVF   50,W
0A62:  MOVWF  55
0A63:  MOVLW  1B
0A64:  MOVWF  56
0A65:  BCF    0A.3
0A66:  BCF    03.5
0A67:  CALL   7AF
0A68:  BSF    0A.3
0A69:  BSF    03.5
0A6A:  MOVF   51,W
0A6B:  MOVWF  55
0A6C:  MOVLW  1B
0A6D:  MOVWF  56
0A6E:  BCF    0A.3
0A6F:  BCF    03.5
0A70:  CALL   7AF
0A71:  BSF    0A.3
....................          delay_ms(1000); 
0A72:  MOVLW  04
0A73:  BSF    03.5
0A74:  MOVWF  53
0A75:  MOVLW  FA
0A76:  MOVWF  5A
0A77:  BCF    0A.3
0A78:  BCF    03.5
0A79:  CALL   14F
0A7A:  BSF    0A.3
0A7B:  BSF    03.5
0A7C:  DECFSZ 53,F
0A7D:  GOTO   275
....................          return address; 
0A7E:  MOVF   52,W
0A7F:  MOVWF  78
0A80:  GOTO   2D2
....................       } 
....................  
....................       address += BLOCK_SIZE;  
0A81:  MOVLW  07
0A82:  ADDWF  52,F
0A83:  GOTO   225
0A84:  BCF    03.5
....................    } 
....................    printf (lcd_escreve,"\fID:%u%u \r\nDisponivel",id[0],id[1]); 
0A85:  BSF    03.5
0A86:  MOVF   4E,W
0A87:  MOVWF  04
0A88:  BCF    03.7
0A89:  BTFSC  4F.0
0A8A:  BSF    03.7
0A8B:  MOVF   00,W
0A8C:  MOVWF  53
0A8D:  MOVLW  01
0A8E:  ADDWF  4E,W
0A8F:  MOVWF  04
0A90:  BCF    03.7
0A91:  BTFSC  4F.0
0A92:  BSF    03.7
0A93:  MOVF   00,W
0A94:  MOVWF  54
0A95:  MOVLW  AD
0A96:  BCF    03.5
0A97:  BSF    03.6
0A98:  MOVWF  0D
0A99:  MOVLW  00
0A9A:  MOVWF  0F
0A9B:  BCF    03.0
0A9C:  MOVLW  04
0A9D:  BSF    03.5
0A9E:  BCF    03.6
0A9F:  MOVWF  55
0AA0:  BCF    0A.3
0AA1:  BCF    03.5
0AA2:  CALL   422
0AA3:  BSF    0A.3
0AA4:  BSF    03.5
0AA5:  MOVF   53,W
0AA6:  MOVWF  55
0AA7:  MOVLW  1B
0AA8:  MOVWF  56
0AA9:  BCF    0A.3
0AAA:  BCF    03.5
0AAB:  CALL   7AF
0AAC:  BSF    0A.3
0AAD:  BSF    03.5
0AAE:  MOVF   54,W
0AAF:  MOVWF  55
0AB0:  MOVLW  1B
0AB1:  MOVWF  56
0AB2:  BCF    0A.3
0AB3:  BCF    03.5
0AB4:  CALL   7AF
0AB5:  BSF    0A.3
0AB6:  MOVLW  B1
0AB7:  BSF    03.6
0AB8:  MOVWF  0D
0AB9:  MOVLW  00
0ABA:  MOVWF  0F
0ABB:  BCF    03.0
0ABC:  MOVLW  0D
0ABD:  BSF    03.5
0ABE:  BCF    03.6
0ABF:  MOVWF  55
0AC0:  BCF    0A.3
0AC1:  BCF    03.5
0AC2:  CALL   422
0AC3:  BSF    0A.3
....................    delay_ms(1000); 
0AC4:  MOVLW  04
0AC5:  BSF    03.5
0AC6:  MOVWF  53
0AC7:  MOVLW  FA
0AC8:  MOVWF  5A
0AC9:  BCF    0A.3
0ACA:  BCF    03.5
0ACB:  CALL   14F
0ACC:  BSF    0A.3
0ACD:  BSF    03.5
0ACE:  DECFSZ 53,F
0ACF:  GOTO   2C7
....................    return -1; 
0AD0:  MOVLW  FF
0AD1:  MOVWF  78
0AD2:  BCF    03.5
0AD3:  RETURN
.................... } 
....................  
.................... void searchUser(int * id){ 
*
0DA0:  MOVF   61,W
0DA1:  BSF    03.5
0DA2:  MOVWF  4F
0DA3:  BCF    03.5
0DA4:  MOVF   60,W
0DA5:  BSF    03.5
0DA6:  MOVWF  4E
0DA7:  BCF    03.5
0DA8:  CALL   223
0DA9:  MOVF   78,W
0DAA:  MOVWF  62
....................  
....................    int address = getAddressByID(id); 
....................    if(address != -1){ 
0DAB:  MOVF   62,W
0DAC:  SUBLW  FF
0DAD:  BTFSC  03.2
0DAE:  GOTO   62C
....................       printf (lcd_escreve,"\fID:%u%u",id[0],id[1]); 
0DAF:  MOVF   60,W
0DB0:  MOVWF  04
0DB1:  BCF    03.7
0DB2:  BTFSC  61.0
0DB3:  BSF    03.7
0DB4:  MOVF   00,W
0DB5:  MOVWF  6D
0DB6:  MOVLW  01
0DB7:  ADDWF  60,W
0DB8:  MOVWF  04
0DB9:  BCF    03.7
0DBA:  BTFSC  61.0
0DBB:  BSF    03.7
0DBC:  MOVF   00,W
0DBD:  MOVWF  6E
0DBE:  MOVLW  B8
0DBF:  BSF    03.6
0DC0:  MOVWF  0D
0DC1:  MOVLW  00
0DC2:  MOVWF  0F
0DC3:  BCF    03.0
0DC4:  MOVLW  04
0DC5:  BSF    03.5
0DC6:  BCF    03.6
0DC7:  MOVWF  55
0DC8:  BCF    0A.3
0DC9:  BCF    03.5
0DCA:  CALL   422
0DCB:  BSF    0A.3
0DCC:  MOVF   6D,W
0DCD:  BSF    03.5
0DCE:  MOVWF  55
0DCF:  MOVLW  1B
0DD0:  MOVWF  56
0DD1:  BCF    0A.3
0DD2:  BCF    03.5
0DD3:  CALL   7AF
0DD4:  BSF    0A.3
0DD5:  MOVF   6E,W
0DD6:  BSF    03.5
0DD7:  MOVWF  55
0DD8:  MOVLW  1B
0DD9:  MOVWF  56
0DDA:  BCF    0A.3
0DDB:  BCF    03.5
0DDC:  CALL   7AF
0DDD:  BSF    0A.3
....................        
....................  
....................       char msg_status[10]; 
....................       if(read_ext_eeprom(address+BLOCK_SIZE - 1) == 0){ 
0DDE:  MOVLW  07
0DDF:  ADDWF  62,W
0DE0:  ADDLW  FF
0DE1:  MOVWF  6D
0DE2:  BSF    03.5
0DE3:  MOVWF  54
0DE4:  BCF    03.5
0DE5:  CALL   153
0DE6:  MOVF   78,F
0DE7:  BTFSS  03.2
0DE8:  GOTO   5FC
....................          strcpy(msg_status,"NAO PAGO"); 
0DE9:  CLRF   6D
0DEA:  CLRF   6E
0DEB:  MOVLW  63
0DEC:  MOVWF  04
0DED:  BCF    03.7
0DEE:  MOVF   6D,W
0DEF:  ADDWF  04,F
0DF0:  MOVF   6E,W
0DF1:  BCF    0A.3
0DF2:  CALL   060
0DF3:  BSF    0A.3
0DF4:  MOVWF  00
0DF5:  IORLW  00
0DF6:  BTFSC  03.2
0DF7:  GOTO   5FB
0DF8:  INCF   6E,F
0DF9:  INCF   6D,F
0DFA:  GOTO   5EB
....................       }else{ 
0DFB:  GOTO   60E
....................          strcpy(msg_status,"PAGO"); 
0DFC:  CLRF   6D
0DFD:  CLRF   6E
0DFE:  MOVLW  63
0DFF:  MOVWF  04
0E00:  BCF    03.7
0E01:  MOVF   6D,W
0E02:  ADDWF  04,F
0E03:  MOVF   6E,W
0E04:  BCF    0A.3
0E05:  CALL   06D
0E06:  BSF    0A.3
0E07:  MOVWF  00
0E08:  IORLW  00
0E09:  BTFSC  03.2
0E0A:  GOTO   60E
0E0B:  INCF   6E,F
0E0C:  INCF   6D,F
0E0D:  GOTO   5FE
....................       } 
....................       printf (lcd_escreve,"\r\nStatus:%s",msg_status); 
0E0E:  MOVLW  BD
0E0F:  BSF    03.6
0E10:  MOVWF  0D
0E11:  MOVLW  00
0E12:  MOVWF  0F
0E13:  BCF    03.0
0E14:  MOVLW  09
0E15:  BSF    03.5
0E16:  BCF    03.6
0E17:  MOVWF  55
0E18:  BCF    0A.3
0E19:  BCF    03.5
0E1A:  CALL   422
0E1B:  BSF    0A.3
0E1C:  MOVLW  63
0E1D:  MOVWF  04
0E1E:  BCF    03.7
0E1F:  CALL   000
....................       delay_ms(1000); 
0E20:  MOVLW  04
0E21:  MOVWF  6D
0E22:  MOVLW  FA
0E23:  BSF    03.5
0E24:  MOVWF  5A
0E25:  BCF    0A.3
0E26:  BCF    03.5
0E27:  CALL   14F
0E28:  BSF    0A.3
0E29:  DECFSZ 6D,F
0E2A:  GOTO   622
....................    }else{ 
0E2B:  GOTO   640
....................       printf(lcd_escreve,"\fUsuario N Existe"); 
0E2C:  MOVLW  C3
0E2D:  BSF    03.6
0E2E:  MOVWF  0D
0E2F:  MOVLW  00
0E30:  MOVWF  0F
0E31:  BCF    0A.3
0E32:  BCF    03.6
0E33:  CALL   249
0E34:  BSF    0A.3
....................       delay_ms(1000); 
0E35:  MOVLW  04
0E36:  MOVWF  6D
0E37:  MOVLW  FA
0E38:  BSF    03.5
0E39:  MOVWF  5A
0E3A:  BCF    0A.3
0E3B:  BCF    03.5
0E3C:  CALL   14F
0E3D:  BSF    0A.3
0E3E:  DECFSZ 6D,F
0E3F:  GOTO   637
....................    } 
.................... } 
....................  
.................... void erase_program_eeprom(int addrr){ 
....................    for(int i=0; i < BLOCK_SIZE; i++){ 
....................          write_ext_eeprom(addrr + i, -1); 
....................    }   
....................    printf (lcd_escreve,"\f User erased "); 
....................    delay_ms(200); 
.................... } 
....................  
.................... int deleteUser(int8 address){ 
....................     
....................    int data_temp; 
....................    int previous_block = address; 
....................    int next_block = address + BLOCK_SIZE; 
....................  
....................    //Case 1: without next block 
....................    if (read_ext_eeprom(next_block) == -1){ 
....................       erase_program_eeprom(previous_block);       
....................       return 1; 
....................    } 
....................  
....................    //Case 2: Check whether the data in the address is empty 
....................    while(read_ext_eeprom(next_block) != -1){ 
....................       //data_temp[index] = read_ext_eeprom(address); 
....................       for(int i=0; i < BLOCK_SIZE; i++){ 
....................          data_temp = read_ext_eeprom(next_block + i);            
....................          write_ext_eeprom(previous_block + i, data_temp);    //overwrite delete block 
....................       }   
....................  
....................       previous_block = next_block; 
....................       next_block += BLOCK_SIZE; 
....................    } 
....................     
....................    next_block -= BLOCK_SIZE; 
....................     
....................    //Erase last block   
....................    erase_program_eeprom(next_block); 
....................     
....................    return 1; 
....................  
.................... } 
....................  
.................... int lastNewUserPosition(){ 
*
0CD1:  BSF    03.5
0CD2:  CLRF   4E
....................    int address = 0; 
....................    int id_temp; 
....................  
....................    while( read_ext_eeprom(address) != -1){ 
0CD3:  MOVF   4E,W
0CD4:  MOVWF  54
0CD5:  BCF    03.5
0CD6:  CALL   153
0CD7:  MOVF   78,W
0CD8:  SUBLW  FF
0CD9:  BTFSC  03.2
0CDA:  GOTO   4E0
....................       address += BLOCK_SIZE;  
0CDB:  MOVLW  07
0CDC:  BSF    03.5
0CDD:  ADDWF  4E,F
0CDE:  GOTO   4D3
0CDF:  BCF    03.5
....................    } 
....................    // printf (lcd_escreve,"\fAddress: %u", address); 
....................    // delay_ms(500); 
....................     
....................    return address; 
0CE0:  BSF    03.5
0CE1:  MOVF   4E,W
0CE2:  MOVWF  78
....................  
.................... } 
....................  
.................... // int isIdAvailable(int * id){ 
.................... //    unsigned int address = 0; 
.................... //    int id_temp[2]; 
.................... //    while( read_ext_eeprom(address) != -1){ 
.................... //       id_temp[0] = read_ext_eeprom(address); 
.................... //       id_temp[1] = read_ext_eeprom(address+1); 
.................... //       if (id_temp[0] == id[0] && id_temp[1] == id[1]){ 
.................... //          printf (lcd_escreve,"\fID:%u, Existe", id_temp); 
.................... //          delay_ms(1000); 
.................... //          return address;//Sucessful 
.................... //       } 
.................... //       address += BLOCK_SIZE;  
.................... //    } 
.................... //    printf (lcd_escreve,"\fID:%u, N Existe", id_temp); 
.................... //    delay_ms(1000); 
.................... //    return -1; 
.................... // } 
....................  
.................... void resetMemory(){ 
....................    int address = 0; 
....................    for(; read_ext_eeprom(address) != -1; 
....................     erase_program_eeprom(address), address += BLOCK_SIZE); 
.................... } 
....................  
.................... void adminMenu(){ 
....................  
....................  
....................   unsigned char option; 
....................    printf(lcd_escreve,"\f1: CAD Cliente "); 
*
0B24:  MOVLW  D4
0B25:  BSF    03.6
0B26:  MOVWF  0D
0B27:  MOVLW  00
0B28:  MOVWF  0F
0B29:  BCF    0A.3
0B2A:  BCF    03.6
0B2B:  CALL   249
0B2C:  BSF    0A.3
....................    delay_ms(500); 
0B2D:  MOVLW  02
0B2E:  MOVWF  60
0B2F:  MOVLW  FA
0B30:  BSF    03.5
0B31:  MOVWF  5A
0B32:  BCF    0A.3
0B33:  BCF    03.5
0B34:  CALL   14F
0B35:  BSF    0A.3
0B36:  DECFSZ 60,F
0B37:  GOTO   32F
....................    printf(lcd_escreve,"\r\n2: Buscar Cliente"); 
0B38:  MOVLW  DD
0B39:  BSF    03.6
0B3A:  MOVWF  0D
0B3B:  MOVLW  00
0B3C:  MOVWF  0F
0B3D:  BCF    0A.3
0B3E:  BCF    03.6
0B3F:  CALL   249
0B40:  BSF    0A.3
....................    delay_ms(500); 
0B41:  MOVLW  02
0B42:  MOVWF  60
0B43:  MOVLW  FA
0B44:  BSF    03.5
0B45:  MOVWF  5A
0B46:  BCF    0A.3
0B47:  BCF    03.5
0B48:  CALL   14F
0B49:  BSF    0A.3
0B4A:  DECFSZ 60,F
0B4B:  GOTO   343
....................    // printf(lcd_escreve,"\f3: DEL Cliente "); 
....................    // delay_ms(500); 
....................    // printf(lcd_escreve,"\r\n4: Editar Cliente"); 
....................    // delay_ms(500); 
....................    // printf(lcd_escreve,"\f5: SAIR do Menu "); 
....................    // delay_ms(500); 
....................   do{ 
....................      
....................    option = readKeyboard(); 
0B4C:  BCF    0A.3
0B4D:  CALL   2BD
0B4E:  BSF    0A.3
0B4F:  MOVF   78,W
0B50:  MOVWF  5B
....................    printf(lcd_escreve,"\f Option: %c", option); 
0B51:  MOVLW  E7
0B52:  BSF    03.6
0B53:  MOVWF  0D
0B54:  MOVLW  00
0B55:  MOVWF  0F
0B56:  BCF    03.0
0B57:  MOVLW  0A
0B58:  BSF    03.5
0B59:  BCF    03.6
0B5A:  MOVWF  55
0B5B:  BCF    0A.3
0B5C:  BCF    03.5
0B5D:  CALL   422
0B5E:  BSF    0A.3
0B5F:  MOVF   5B,W
0B60:  BSF    03.5
0B61:  MOVWF  59
0B62:  BCF    0A.3
0B63:  BCF    03.5
0B64:  CALL   206
0B65:  BSF    0A.3
....................    delay_ms(500); 
0B66:  MOVLW  02
0B67:  MOVWF  60
0B68:  MOVLW  FA
0B69:  BSF    03.5
0B6A:  MOVWF  5A
0B6B:  BCF    0A.3
0B6C:  BCF    03.5
0B6D:  CALL   14F
0B6E:  BSF    0A.3
0B6F:  DECFSZ 60,F
0B70:  GOTO   368
....................  
....................  
....................    switch(option){ 
0B71:  MOVF   5B,W
0B72:  XORLW  31
0B73:  BTFSC  03.2
0B74:  GOTO   37F
0B75:  XORLW  03
0B76:  BTFSC  03.2
0B77:  GOTO   587
0B78:  XORLW  31
0B79:  BTFSC  03.2
0B7A:  GOTO   642
0B7B:  XORLW  07
0B7C:  BTFSC  03.2
0B7D:  GOTO   644
0B7E:  GOTO   647
....................       case '1': 
....................          inputKeyboardUser(); 
....................          break; 
*
0D86:  GOTO   648
....................       case '2': 
....................          unsigned int * temp; 
....................          unsigned int id [2]; 
....................  
....................          temp = inputId(); 
0D87:  BCF    0A.3
0D88:  CALL   73F
0D89:  BSF    0A.3
0D8A:  MOVF   79,W
0D8B:  MOVWF  5D
0D8C:  MOVF   78,W
0D8D:  MOVWF  5C
....................          id[0] = temp[0]; 
0D8E:  MOVF   5C,W
0D8F:  MOVWF  04
0D90:  BCF    03.7
0D91:  BTFSC  5D.0
0D92:  BSF    03.7
0D93:  MOVF   00,W
0D94:  MOVWF  5E
....................          id[1] = temp[1]; 
0D95:  MOVLW  01
0D96:  ADDWF  5C,W
0D97:  MOVWF  04
0D98:  BCF    03.7
0D99:  BTFSC  5D.0
0D9A:  BSF    03.7
0D9B:  MOVF   00,W
0D9C:  MOVWF  5F
....................          searchUser(id); 
0D9D:  CLRF   61
0D9E:  MOVLW  5E
0D9F:  MOVWF  60
....................          break; 
*
0E40:  BSF    03.5
0E41:  GOTO   648
....................       case 3: 
....................          // mostrarMes(); 
....................          break; 
0E42:  BSF    03.5
0E43:  GOTO   648
....................       case 4: 
....................          //  printf("\nTENHA UM BOM DIA\n"); 
....................          break; 
0E44:  BSF    03.5
0E45:  GOTO   648
0E46:  BCF    03.5
....................       default: 
....................          // printf("\nDIGITE UM VALOR VÃLIDO\n"); 
....................          break; 
0E47:  BSF    03.5
....................  
....................    } 
....................    }while(option != 5);//sÃ³ termina quando for 4  
0E48:  BCF    03.5
0E49:  MOVF   5B,W
0E4A:  SUBLW  05
0E4B:  BTFSS  03.2
0E4C:  GOTO   34C
0E4D:  BSF    0A.3
0E4E:  BCF    0A.4
0E4F:  GOTO   6A7 (RETURN)
....................     
....................   
....................  
....................     
.................... } 
....................  
.................... unsigned char readKeyboard(){ 
....................    unsigned char tmp; 
....................    unsigned char tmp_result; 
....................     
....................    tmp = tc_tecla(1500); // ms 
*
02BD:  MOVLW  DC
02BE:  BSF    03.5
02BF:  MOVWF  55
*
040F:  MOVF   78,W
0410:  MOVWF  53
....................    if(tmp != 255){ 
0411:  INCFSZ 53,W
0412:  GOTO   414
0413:  GOTO   415
....................       // write_ext_eeprom(0, tmp); 
....................       // delay_ms(50); 
....................       // tmp_result = read_ext_eeprom(0); 
....................       // delay_ms(50); 
....................       // tmp_result = tmp; 
....................       // printf(lcd_escreve,"\f Button: %c", tmp); 
....................       // delay_ms(50); 
....................    }else{  
0414:  GOTO   41E
....................       printf(lcd_escreve,"\f   TECLADO  "); 
0415:  MOVLW  EE
0416:  BCF    03.5
0417:  BSF    03.6
0418:  MOVWF  0D
0419:  MOVLW  00
041A:  MOVWF  0F
041B:  BCF    03.6
041C:  CALL   249
041D:  BSF    03.5
....................    } 
....................  
....................    return tmp; 
041E:  MOVF   53,W
041F:  MOVWF  78
0420:  BCF    03.5
0421:  RETURN
.................... } 
....................  
....................  
.................... int * getAdminsID(){ 
....................  
....................    int address = 0; 
....................    int temp_status; 
....................    int index= 0; 
....................    static int admins[BLOCK_SIZE]; 
*
0E64:  CLRF   44
0E65:  CLRF   45
0E66:  CLRF   46
0E67:  CLRF   47
0E68:  CLRF   48
0E69:  CLRF   49
0E6A:  CLRF   4A
....................    admins[0] = -1; 
....................    while( read_ext_eeprom(address) != -1){ 
....................       temp_status = read_ext_eeprom(address + (BLOCK_SIZE - 1));//status of the user 
....................       if (temp_status == 3){ 
....................          printf (lcd_escreve,"\fAdmin Encontrado"); 
....................          delay_ms(1000); 
....................          for(int i=0; i < 2; i++){ 
....................             int id = read_ext_eeprom(address+i);    
....................             admins[index] = id; 
....................             index++; 
....................          } 
....................  
....................       } 
....................  
....................       address += BLOCK_SIZE;  
....................    } 
....................  
....................    return admins; 
....................  
.................... } 
....................  
.................... void listAdmins(){ 
....................    int * admins; 
....................  
....................    admins = getAdminsID(); 
....................    printf(lcd_escreve,"\f admins[0]: %d", admins[0]); 
....................    delay_ms(1000); 
....................    if(admins[0] != -1){ 
....................       for (int16 i=0; i < sizeof(admins); i+=2){ 
....................          printf(lcd_escreve, "\fid~:%u%u",admins[i], admins[i+1]); 
....................          delay_ms(1000); 
....................       }  
....................    } 
.................... } 
....................  
....................  
.................... int * strToInt(char * str){ 
*
0703:  BSF    03.5
0704:  MOVF   54,W
0705:  MOVWF  56
0706:  MOVF   53,W
0707:  MOVWF  55
0708:  CLRF   59
....................  
....................   char *p = str; 
....................   //https://flaviocopes.com/c-array-length/ 
.................... //   int size = (sizeof str) / (sizeof * str); 
....................   static unsigned int buffer[BLOCK_SIZE];   
*
0E6B:  CLRF   4B
0E6C:  CLRF   4C
0E6D:  CLRF   4D
0E6E:  CLRF   4E
0E6F:  CLRF   4F
0E70:  CLRF   50
0E71:  CLRF   51
.................... //   printf(lcd_escreve,"\fParsing: %s",p); 
.................... //   delay_ms(1000); 
....................   char * end; 
....................   int index = 0; 
....................  
....................   for (unsigned int number = strtoul(p, &end, 10); 
*
0709:  MOVF   56,W
070A:  MOVWF  5C
070B:  MOVF   55,W
070C:  MOVWF  5B
070D:  CLRF   5E
070E:  MOVLW  D7
070F:  MOVWF  5D
0710:  MOVLW  0A
0711:  MOVWF  5F
0712:  BCF    03.5
0713:  CALL   4C7
0714:  MOVF   78,W
0715:  BSF    03.5
0716:  MOVWF  5A
....................         p != end; 
0717:  MOVF   57,W
0718:  SUBWF  55,W
0719:  BTFSS  03.2
071A:  GOTO   71F
071B:  MOVF   58,W
071C:  SUBWF  56,W
071D:  BTFSC  03.2
071E:  GOTO   739
....................         number = strtoul(p, &end, 10)) 
....................   { 
....................    //  printf(lcd_escreve,"\n%u",number ); 
....................    //  delay_ms(50); 
....................     p = end; 
071F:  MOVF   58,W
0720:  MOVWF  56
0721:  MOVF   57,W
0722:  MOVWF  55
....................  
....................     buffer[index] = number;  
0723:  MOVLW  4B
0724:  ADDWF  59,W
0725:  MOVWF  04
0726:  BCF    03.7
0727:  MOVF   5A,W
0728:  MOVWF  00
....................     index++; 
0729:  INCF   59,F
072A:  MOVF   56,W
072B:  MOVWF  5C
072C:  MOVF   55,W
072D:  MOVWF  5B
072E:  CLRF   5E
072F:  MOVLW  D7
0730:  MOVWF  5D
0731:  MOVLW  0A
0732:  MOVWF  5F
0733:  BCF    03.5
0734:  CALL   4C7
0735:  MOVF   78,W
0736:  BSF    03.5
0737:  MOVWF  5A
0738:  GOTO   717
....................   } 
....................  
....................    return buffer; 
0739:  MOVLW  4B
073A:  MOVWF  78
073B:  MOVLW  00
073C:  MOVWF  79
073D:  BCF    03.5
073E:  RETURN
.................... } 
....................  
.................... char * strfromchar(char destination[], char source)  
.................... {  
....................    destination[0] = source;   // copy the character into the string  
*
086A:  MOVF   51,W
086B:  MOVWF  04
086C:  BCF    03.7
086D:  BTFSC  52.0
086E:  BSF    03.7
086F:  MOVF   53,W
0870:  MOVWF  00
....................    destination[1] = '\0';      // null-terminate the string  
0871:  MOVLW  01
0872:  ADDWF  51,W
0873:  MOVWF  04
0874:  BCF    03.7
0875:  BTFSC  52.0
0876:  BSF    03.7
0877:  CLRF   00
....................   
....................    return destination;         // common convention for str functions  
0878:  MOVF   51,W
0879:  MOVWF  78
087A:  MOVF   52,W
087B:  MOVWF  79
.................... }  
....................  
....................  
.................... int * inputId(){ 
*
073F:  BSF    03.5
0740:  CLRF   52
....................    unsigned char keyboard_buffer[BLOCK_SIZE * 2]; 
....................    unsigned char option; 
....................  
....................    int * temp; 
....................    int i = 0; 
....................    //The user needs to type 4 digits 
....................    //For example, even if it's just 9 
....................    //He/she will type: 0009 
....................    while(i < 5){ 
0741:  MOVF   52,W
0742:  SUBLW  04
0743:  BTFSS  03.0
0744:  GOTO   788
....................       printf(lcd_escreve,"\fDigite o ID"); 
0745:  MOVLW  0B
0746:  BCF    03.5
0747:  BSF    03.6
0748:  MOVWF  0D
0749:  MOVLW  01
074A:  MOVWF  0F
074B:  BCF    03.6
074C:  CALL   249
....................       delay_ms(50); 
074D:  MOVLW  32
074E:  BSF    03.5
074F:  MOVWF  5A
0750:  BCF    03.5
0751:  CALL   14F
....................       option = readKeyboard(); 
0752:  CALL   2BD
0753:  MOVF   78,W
0754:  BSF    03.5
0755:  MOVWF  4F
....................       printf(lcd_escreve,"\fTyped:%c", option); 
0756:  MOVLW  12
0757:  BCF    03.5
0758:  BSF    03.6
0759:  MOVWF  0D
075A:  MOVLW  01
075B:  MOVWF  0F
075C:  BCF    03.0
075D:  MOVLW  07
075E:  BSF    03.5
075F:  BCF    03.6
0760:  MOVWF  55
0761:  BCF    03.5
0762:  CALL   422
0763:  BSF    03.5
0764:  MOVF   4F,W
0765:  MOVWF  59
0766:  BCF    03.5
0767:  CALL   206
....................       delay_ms(500); 
0768:  MOVLW  02
0769:  BSF    03.5
076A:  MOVWF  53
076B:  MOVLW  FA
076C:  MOVWF  5A
076D:  BCF    03.5
076E:  CALL   14F
076F:  BSF    03.5
0770:  DECFSZ 53,F
0771:  GOTO   76B
....................       if(option != 255){ 
0772:  INCFSZ 4F,W
0773:  GOTO   775
0774:  GOTO   787
....................          if(i == 2){ 
0775:  MOVF   52,W
0776:  SUBLW  02
0777:  BTFSS  03.2
0778:  GOTO   780
....................             //To convert to int will be easier with space between them 
....................             keyboard_buffer[i] = ' '; 
0779:  MOVLW  C1
077A:  ADDWF  52,W
077B:  MOVWF  04
077C:  BCF    03.7
077D:  MOVLW  20
077E:  MOVWF  00
....................             i++; 
077F:  INCF   52,F
....................          } 
....................          keyboard_buffer[i] = option; 
0780:  MOVLW  C1
0781:  ADDWF  52,W
0782:  MOVWF  04
0783:  BCF    03.7
0784:  MOVF   4F,W
0785:  MOVWF  00
....................          i++; 
0786:  INCF   52,F
....................       } 
0787:  GOTO   741
....................    } 
....................    // unsigned char *id; 
....................    // id = keyboard_buffer; 
....................    temp = strToInt(keyboard_buffer); 
0788:  CLRF   54
0789:  MOVLW  C1
078A:  MOVWF  53
078B:  BCF    03.5
078C:  CALL   703
078D:  MOVF   79,W
078E:  BSF    03.5
078F:  MOVWF  51
0790:  MOVF   78,W
0791:  MOVWF  50
....................    return temp; 
0792:  MOVF   50,W
0793:  MOVWF  78
0794:  MOVF   51,W
0795:  MOVWF  79
0796:  BCF    03.5
0797:  RETURN
....................    // id[0] = temp[0]; 
....................    // id[1] = temp[1]; 
....................    // //https://www.tutorialspoint.com/cprogramming/c_pointer_to_an_array.htm 
....................    // //*(id+1) == id[1] 
....................    // printf(lcd_escreve,"\fid: %u%u",id[0],id[1]); 
....................    // delay_ms(1000); 
.................... } 
....................  
.................... int * inputToKeyboard(char * msg, int max){ 
*
081F:  BSF    03.5
0820:  CLRF   4E
....................    unsigned char option; 
....................    int data[BLOCK_SIZE]; 
....................    int * temp; 
....................    int i = 0; 
....................  
....................    while(i < max){ 
0821:  MOVF   43,W
0822:  SUBWF  4E,W
0823:  BTFSC  03.0
0824:  GOTO   0A2
....................  
....................       printf(lcd_escreve,"\f%s", msg); 
0825:  MOVLW  0C
0826:  MOVWF  59
0827:  BCF    0A.3
0828:  BCF    03.5
0829:  CALL   206
082A:  BSF    0A.3
082B:  BSF    03.5
082C:  MOVF   41,W
082D:  MOVWF  04
082E:  BCF    03.7
082F:  BTFSC  42.0
0830:  BSF    03.7
0831:  BCF    03.5
0832:  CALL   000
....................       delay_ms(50); 
0833:  MOVLW  32
0834:  BSF    03.5
0835:  MOVWF  5A
0836:  BCF    0A.3
0837:  BCF    03.5
0838:  CALL   14F
0839:  BSF    0A.3
....................       option = readKeyboard(); 
083A:  BCF    0A.3
083B:  CALL   2BD
083C:  BSF    0A.3
083D:  MOVF   78,W
083E:  BSF    03.5
083F:  MOVWF  44
....................       printf(lcd_escreve,"\fTyped:%c", option); 
0840:  MOVLW  17
0841:  BCF    03.5
0842:  BSF    03.6
0843:  MOVWF  0D
0844:  MOVLW  01
0845:  MOVWF  0F
0846:  BCF    03.0
0847:  MOVLW  07
0848:  BSF    03.5
0849:  BCF    03.6
084A:  MOVWF  55
084B:  BCF    0A.3
084C:  BCF    03.5
084D:  CALL   422
084E:  BSF    0A.3
084F:  BSF    03.5
0850:  MOVF   44,W
0851:  MOVWF  59
0852:  BCF    0A.3
0853:  BCF    03.5
0854:  CALL   206
0855:  BSF    0A.3
....................       delay_ms(400); 
0856:  MOVLW  02
0857:  BSF    03.5
0858:  MOVWF  51
0859:  MOVLW  C8
085A:  MOVWF  5A
085B:  BCF    0A.3
085C:  BCF    03.5
085D:  CALL   14F
085E:  BSF    0A.3
085F:  BSF    03.5
0860:  DECFSZ 51,F
0861:  GOTO   059
....................       if(option != 255){ 
0862:  INCFSZ 44,W
0863:  GOTO   065
0864:  GOTO   0A1
....................          unsigned char destination[2]; 
....................          //Convert string from char and return  
....................          //to the left array of char(str_pass) 
....................          strfromchar(destination,option); 
0865:  CLRF   52
0866:  MOVLW  CF
0867:  MOVWF  51
0868:  MOVF   44,W
0869:  MOVWF  53
....................          temp = strToInt(destination); 
*
087C:  CLRF   54
087D:  MOVLW  CF
087E:  MOVWF  53
087F:  BCF    0A.3
0880:  BCF    03.5
0881:  CALL   703
0882:  BSF    0A.3
0883:  MOVF   79,W
0884:  BSF    03.5
0885:  MOVWF  4D
0886:  MOVF   78,W
0887:  MOVWF  4C
....................          data[i] = temp[0]; 
0888:  MOVLW  C5
0889:  ADDWF  4E,W
088A:  MOVWF  78
088B:  CLRF   7A
088C:  BTFSC  03.0
088D:  INCF   7A,F
088E:  MOVF   78,W
088F:  MOVWF  51
0890:  MOVF   7A,W
0891:  MOVWF  52
0892:  MOVF   4C,W
0893:  MOVWF  04
0894:  BCF    03.7
0895:  BTFSC  4D.0
0896:  BSF    03.7
0897:  MOVF   00,W
0898:  MOVWF  53
0899:  MOVF   51,W
089A:  MOVWF  04
089B:  BCF    03.7
089C:  BTFSC  52.0
089D:  BSF    03.7
089E:  MOVF   53,W
089F:  MOVWF  00
....................          i++; 
08A0:  INCF   4E,F
....................       } 
08A1:  GOTO   021
....................    } 
....................  
....................    temp = data; 
08A2:  CLRF   4D
08A3:  MOVLW  C5
08A4:  MOVWF  4C
....................    return temp; 
08A5:  MOVF   4C,W
08A6:  MOVWF  78
08A7:  MOVF   4D,W
08A8:  MOVWF  79
08A9:  BCF    03.5
08AA:  RETURN
....................    // printf(lcd_escreve,"\fPASS(4): %u%u%u%u",pass[0],pass[1],pass[2],pass[3]); 
....................    // delay_ms(1000); 
....................  
.................... } 
.................... void inputKeyboardUser(){ 
....................  
....................    unsigned int * temp; 
....................    unsigned int id [2]; 
....................    unsigned int pass[4]; 
....................    unsigned int status; 
....................  
....................    temp = inputId(); 
*
0B7F:  BCF    0A.3
0B80:  CALL   73F
0B81:  BSF    0A.3
0B82:  MOVF   79,W
0B83:  MOVWF  61
0B84:  MOVF   78,W
0B85:  MOVWF  60
....................    id[0] = temp[0]; 
0B86:  MOVF   60,W
0B87:  MOVWF  04
0B88:  BCF    03.7
0B89:  BTFSC  61.0
0B8A:  BSF    03.7
0B8B:  MOVF   00,W
0B8C:  MOVWF  62
....................    id[1] = temp[1]; 
0B8D:  MOVLW  01
0B8E:  ADDWF  60,W
0B8F:  MOVWF  04
0B90:  BCF    03.7
0B91:  BTFSC  61.0
0B92:  BSF    03.7
0B93:  MOVF   00,W
0B94:  MOVWF  63
....................    printf(lcd_escreve,"\fid: %u%u",id[0],id[1]); 
0B95:  MOVLW  1C
0B96:  BSF    03.6
0B97:  MOVWF  0D
0B98:  MOVLW  01
0B99:  MOVWF  0F
0B9A:  BCF    03.0
0B9B:  MOVLW  05
0B9C:  BSF    03.5
0B9D:  BCF    03.6
0B9E:  MOVWF  55
0B9F:  BCF    0A.3
0BA0:  BCF    03.5
0BA1:  CALL   422
0BA2:  BSF    0A.3
0BA3:  MOVF   62,W
0BA4:  BSF    03.5
0BA5:  MOVWF  55
0BA6:  MOVLW  1B
0BA7:  MOVWF  56
0BA8:  BCF    0A.3
0BA9:  BCF    03.5
0BAA:  CALL   7AF
0BAB:  BSF    0A.3
0BAC:  MOVF   63,W
0BAD:  BSF    03.5
0BAE:  MOVWF  55
0BAF:  MOVLW  1B
0BB0:  MOVWF  56
0BB1:  BCF    0A.3
0BB2:  BCF    03.5
0BB3:  CALL   7AF
0BB4:  BSF    0A.3
....................    delay_ms(800); 
0BB5:  MOVLW  04
0BB6:  MOVWF  6A
0BB7:  MOVLW  C8
0BB8:  BSF    03.5
0BB9:  MOVWF  5A
0BBA:  BCF    0A.3
0BBB:  BCF    03.5
0BBC:  CALL   14F
0BBD:  BSF    0A.3
0BBE:  DECFSZ 6A,F
0BBF:  GOTO   3B7
....................  
....................    char msg [] = "Digite a senha"; 
0BC0:  MOVLW  44
0BC1:  BSF    03.5
0BC2:  MOVWF  20
0BC3:  MOVLW  69
0BC4:  MOVWF  21
0BC5:  MOVLW  67
0BC6:  MOVWF  22
0BC7:  MOVLW  69
0BC8:  MOVWF  23
0BC9:  MOVLW  74
0BCA:  MOVWF  24
0BCB:  MOVLW  65
0BCC:  MOVWF  25
0BCD:  MOVLW  20
0BCE:  MOVWF  26
0BCF:  MOVLW  61
0BD0:  MOVWF  27
0BD1:  MOVLW  20
0BD2:  MOVWF  28
0BD3:  MOVLW  73
0BD4:  MOVWF  29
0BD5:  MOVLW  65
0BD6:  MOVWF  2A
0BD7:  MOVLW  6E
0BD8:  MOVWF  2B
0BD9:  MOVLW  68
0BDA:  MOVWF  2C
0BDB:  MOVLW  61
0BDC:  MOVWF  2D
0BDD:  CLRF   2E
....................    int max = 4; 
0BDE:  MOVLW  04
0BDF:  BCF    03.5
0BE0:  MOVWF  69
....................    temp = inputToKeyboard(msg, max); 
0BE1:  BSF    03.5
0BE2:  CLRF   42
0BE3:  MOVLW  A0
0BE4:  MOVWF  41
0BE5:  BCF    03.5
0BE6:  MOVF   69,W
0BE7:  BSF    03.5
0BE8:  MOVWF  43
0BE9:  BCF    03.5
0BEA:  CALL   01F
0BEB:  MOVF   79,W
0BEC:  MOVWF  61
0BED:  MOVF   78,W
0BEE:  MOVWF  60
....................    pass[0] = temp[0]; 
0BEF:  MOVF   60,W
0BF0:  MOVWF  04
0BF1:  BCF    03.7
0BF2:  BTFSC  61.0
0BF3:  BSF    03.7
0BF4:  MOVF   00,W
0BF5:  MOVWF  64
....................    pass[1] = temp[1]; 
0BF6:  MOVLW  01
0BF7:  ADDWF  60,W
0BF8:  MOVWF  04
0BF9:  BCF    03.7
0BFA:  BTFSC  61.0
0BFB:  BSF    03.7
0BFC:  MOVF   00,W
0BFD:  MOVWF  65
....................    pass[2] = temp[2]; 
0BFE:  MOVLW  02
0BFF:  ADDWF  60,W
0C00:  MOVWF  04
0C01:  BCF    03.7
0C02:  BTFSC  61.0
0C03:  BSF    03.7
0C04:  MOVF   00,W
0C05:  MOVWF  66
....................    pass[3] = temp[3]; 
0C06:  MOVLW  03
0C07:  ADDWF  60,W
0C08:  MOVWF  04
0C09:  BCF    03.7
0C0A:  BTFSC  61.0
0C0B:  BSF    03.7
0C0C:  MOVF   00,W
0C0D:  MOVWF  67
....................    printf(lcd_escreve,"\fPASS(4): %u%u%u%u",pass[0],pass[1],pass[2],pass[3]); 
0C0E:  MOVLW  21
0C0F:  BSF    03.6
0C10:  MOVWF  0D
0C11:  MOVLW  01
0C12:  MOVWF  0F
0C13:  BCF    03.0
0C14:  MOVLW  0A
0C15:  BSF    03.5
0C16:  BCF    03.6
0C17:  MOVWF  55
0C18:  BCF    0A.3
0C19:  BCF    03.5
0C1A:  CALL   422
0C1B:  BSF    0A.3
0C1C:  MOVF   64,W
0C1D:  BSF    03.5
0C1E:  MOVWF  55
0C1F:  MOVLW  1B
0C20:  MOVWF  56
0C21:  BCF    0A.3
0C22:  BCF    03.5
0C23:  CALL   7AF
0C24:  BSF    0A.3
0C25:  MOVF   65,W
0C26:  BSF    03.5
0C27:  MOVWF  55
0C28:  MOVLW  1B
0C29:  MOVWF  56
0C2A:  BCF    0A.3
0C2B:  BCF    03.5
0C2C:  CALL   7AF
0C2D:  BSF    0A.3
0C2E:  MOVF   66,W
0C2F:  BSF    03.5
0C30:  MOVWF  55
0C31:  MOVLW  1B
0C32:  MOVWF  56
0C33:  BCF    0A.3
0C34:  BCF    03.5
0C35:  CALL   7AF
0C36:  BSF    0A.3
0C37:  MOVF   67,W
0C38:  BSF    03.5
0C39:  MOVWF  55
0C3A:  MOVLW  1B
0C3B:  MOVWF  56
0C3C:  BCF    0A.3
0C3D:  BCF    03.5
0C3E:  CALL   7AF
0C3F:  BSF    0A.3
....................    delay_ms(800); 
0C40:  MOVLW  04
0C41:  MOVWF  6A
0C42:  MOVLW  C8
0C43:  BSF    03.5
0C44:  MOVWF  5A
0C45:  BCF    0A.3
0C46:  BCF    03.5
0C47:  CALL   14F
0C48:  BSF    0A.3
0C49:  DECFSZ 6A,F
0C4A:  GOTO   442
....................  
....................    char msg2 [] = "Status (0,1,3): "; 
0C4B:  MOVLW  53
0C4C:  BSF    03.5
0C4D:  MOVWF  2F
0C4E:  MOVLW  74
0C4F:  MOVWF  30
0C50:  MOVLW  61
0C51:  MOVWF  31
0C52:  MOVLW  74
0C53:  MOVWF  32
0C54:  MOVLW  75
0C55:  MOVWF  33
0C56:  MOVLW  73
0C57:  MOVWF  34
0C58:  MOVLW  20
0C59:  MOVWF  35
0C5A:  MOVLW  28
0C5B:  MOVWF  36
0C5C:  MOVLW  30
0C5D:  MOVWF  37
0C5E:  MOVLW  2C
0C5F:  MOVWF  38
0C60:  MOVLW  31
0C61:  MOVWF  39
0C62:  MOVLW  2C
0C63:  MOVWF  3A
0C64:  MOVLW  33
0C65:  MOVWF  3B
0C66:  MOVLW  29
0C67:  MOVWF  3C
0C68:  MOVLW  3A
0C69:  MOVWF  3D
0C6A:  MOVLW  20
0C6B:  MOVWF  3E
0C6C:  CLRF   3F
....................    max = 1; 
0C6D:  MOVLW  01
0C6E:  BCF    03.5
0C6F:  MOVWF  69
....................    temp = inputToKeyboard(msg2, max); 
0C70:  BSF    03.5
0C71:  CLRF   42
0C72:  MOVLW  AF
0C73:  MOVWF  41
0C74:  BCF    03.5
0C75:  MOVF   69,W
0C76:  BSF    03.5
0C77:  MOVWF  43
0C78:  BCF    03.5
0C79:  CALL   01F
0C7A:  MOVF   79,W
0C7B:  MOVWF  61
0C7C:  MOVF   78,W
0C7D:  MOVWF  60
....................    status = temp[0]; 
0C7E:  MOVF   60,W
0C7F:  MOVWF  04
0C80:  BCF    03.7
0C81:  BTFSC  61.0
0C82:  BSF    03.7
0C83:  MOVF   00,W
0C84:  MOVWF  68
....................    printf(lcd_escreve,"\fSTATUS: %u",status); 
0C85:  MOVLW  2B
0C86:  BSF    03.6
0C87:  MOVWF  0D
0C88:  MOVLW  01
0C89:  MOVWF  0F
0C8A:  BCF    03.0
0C8B:  MOVLW  09
0C8C:  BSF    03.5
0C8D:  BCF    03.6
0C8E:  MOVWF  55
0C8F:  BCF    0A.3
0C90:  BCF    03.5
0C91:  CALL   422
0C92:  BSF    0A.3
0C93:  MOVF   68,W
0C94:  BSF    03.5
0C95:  MOVWF  55
0C96:  MOVLW  1B
0C97:  MOVWF  56
0C98:  BCF    0A.3
0C99:  BCF    03.5
0C9A:  CALL   7AF
0C9B:  BSF    0A.3
....................    delay_ms(800); 
0C9C:  MOVLW  04
0C9D:  MOVWF  6A
0C9E:  MOVLW  C8
0C9F:  BSF    03.5
0CA0:  MOVWF  5A
0CA1:  BCF    0A.3
0CA2:  BCF    03.5
0CA3:  CALL   14F
0CA4:  BSF    0A.3
0CA5:  DECFSZ 6A,F
0CA6:  GOTO   49E
....................  
....................     
....................    saveUser(id,pass,status); 
0CA7:  BSF    03.5
0CA8:  CLRF   42
0CA9:  MOVLW  62
0CAA:  MOVWF  41
0CAB:  CLRF   44
0CAC:  MOVLW  64
0CAD:  MOVWF  43
0CAE:  BCF    03.5
0CAF:  MOVF   68,W
0CB0:  BSF    03.5
0CB1:  MOVWF  45
.................... } 
....................  
....................  
.................... /* 
.................... // ---- MSG from serial communication 
.................... #int_RDA 
.................... void RDA_isr(void){ 
....................    rx_buffer[rx_wr_index] = getc(); 
....................    rxd = rx_buffer[rx_wr_index]; 
....................    rx_wr_index++; 
....................  
....................    if(rx_wr_index > RX_BUFFER_SIZE){ 
....................       rx_wr_index = 0; 
....................    } 
....................  
....................    //Look for unique ID: "IFMT" 
....................    if(rxd == 'I' && lock_pos == 0){ 
....................       lock_pos++; 
....................    } 
....................    else if(rxd == 'F' && lock_pos == 1){ 
....................       lock_pos++; 
....................    } 
....................    else if(rxd == 'M' && lock_pos == 2){ 
....................       lock_pos++; 
....................    } 
....................    else if(rxd == 'T' && lock_pos == 3){ 
....................       lock_pos=0; //Reset the "combination lock" 
....................       got_id = TRUE; 
....................       read = rxd; 
....................       //get ready to count the number of data bytes 
....................       valid_data_count = 0xff;  
....................  
....................       //buffer is reset to index 0 
....................       rx_wr_index = 0; 
....................    }else { 
....................       lock_pos = 0; 
....................    } 
....................  
....................    if(got_id && ++valid_data_count >= 6){ 
....................       data_avail = TRUE; 
....................       got_id = FALSE; 
....................    } 
....................     
.................... } 
.................... */ 
....................  
....................  
....................  
....................  
.................... #int_TIMER1 
.................... void TIMER1_isr(void) 
.................... { 
.................... } 
....................  
*
0131:  BCF    0C.0
0132:  BCF    0A.3
0133:  BCF    0A.4
0134:  GOTO   031
.................... #int_RTCC 
.................... void RTCC_isr(void) 
.................... { 
....................  
....................        
0135:  BCF    0B.2
0136:  BCF    0A.3
0137:  BCF    0A.4
0138:  GOTO   031
.................... } 
....................  
.................... void main() 
*
0E50:  MOVF   03,W
0E51:  ANDLW  1F
0E52:  MOVWF  03
0E53:  CLRF   2C
0E54:  CLRF   2D
0E55:  CLRF   31
0E56:  CLRF   32
0E57:  MOVLW  FF
0E58:  MOVWF  3D
0E59:  BSF    03.5
0E5A:  BSF    1F.0
0E5B:  BSF    1F.1
0E5C:  BSF    1F.2
0E5D:  BCF    1F.3
0E5E:  MOVLW  07
0E5F:  MOVWF  1C
0E60:  BCF    03.7
*
0E72:  CLRF   54
.................... { 
....................    //VARIAVEIS 
....................    byte result; 
....................    unsigned char option; 
....................     
....................    eeprom_address address = 0; 
....................  
....................    // unsigned char tmp_result; 
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_256|RTCC_8_bit);      //13.1ms overflow 
0E73:  BSF    03.5
0E74:  MOVF   01,W
0E75:  ANDLW  C0
0E76:  IORLW  07
0E77:  MOVWF  01
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); //Overflow in 104ms | Resolution 1.6 us 
0E78:  MOVLW  B5
0E79:  BCF    03.5
0E7A:  MOVWF  10
....................  
....................    init_ext_eeprom(); 
0E7B:  BCF    0A.3
0E7C:  GOTO   142
0E7D:  BSF    0A.3
....................  
....................    enable_interrupts(INT_TIMER0); 
0E7E:  BSF    0B.5
....................    enable_interrupts(INT_TIMER1); 
0E7F:  BSF    03.5
0E80:  BSF    0C.0
....................  
....................    enable_interrupts(GLOBAL); 
0E81:  MOVLW  C0
0E82:  BCF    03.5
0E83:  IORWF  0B,F
....................  
....................  
....................    lcd_ini(); 
0E84:  BCF    0A.3
0E85:  GOTO   1BD
0E86:  BSF    0A.3
....................    delay_us(50); 
0E87:  MOVLW  52
0E88:  MOVWF  77
0E89:  DECFSZ 77,F
0E8A:  GOTO   689
0E8B:  GOTO   68C
0E8C:  NOP
....................    printf(lcd_escreve, "\f  iniciando... "); 
0E8D:  MOVLW  39
0E8E:  BSF    03.6
0E8F:  MOVWF  0D
0E90:  MOVLW  01
0E91:  MOVWF  0F
0E92:  BCF    0A.3
0E93:  BCF    03.6
0E94:  CALL   249
0E95:  BSF    0A.3
....................    delay_ms(200); 
0E96:  MOVLW  C8
0E97:  BSF    03.5
0E98:  MOVWF  5A
0E99:  BCF    0A.3
0E9A:  BCF    03.5
0E9B:  CALL   14F
0E9C:  BSF    0A.3
....................  
....................    // printf(lcd_escreve, "\fIFMT - Serial"); 
....................    // delay_ms(50); 
....................  
....................    // int size = BLOCK_SIZE; 
....................    // printf(lcd_escreve, "\fBlock_Size:%u", size); 
....................    // delay_ms(500); 
....................  
....................    // resetmemory(); 
....................  
....................    // data_avail = false; 
....................    // int id [2] = {12,34}; 
....................    // int pass [4] = {1,2,3,4}; 
....................    // saveuser(id, pass, 1); 
....................    int id1 [2] = {14,0}; 
0E9D:  MOVLW  0E
0E9E:  MOVWF  55
0E9F:  CLRF   56
....................    // saveuser(id1, pass, 0); 
....................    int id2 [2] = {70,10}; 
0EA0:  MOVLW  46
0EA1:  MOVWF  57
0EA2:  MOVLW  0A
0EA3:  MOVWF  58
....................    // saveuser(id2, pass, 1); 
....................    int id3 [2] = {0,10}; 
0EA4:  CLRF   59
0EA5:  MOVWF  5A
....................    // saveuser(id3, pass, 1); 
....................    // int id4 [2] = {99,99}; 
....................    // saveuser(id4, pass, 3);//admin 
....................     
....................     
....................    // getAddressByID(id2); 
....................    adminMenu(); 
0EA6:  GOTO   324
....................  
....................  
....................  
....................    // char keyboard_buffer[]= '6'; 
....................    // char n = '9'; 
....................    // unsigned char temp_pass[2]; 
....................    // unsigned int * buffer; 
....................    // unsigned int pass[4]; 
....................    // strfromchar(temp_pass,n); 
....................    // buffer = strToInt(temp_pass); 
....................    // pass[0] = buffer[0]; 
....................  
....................    // printf(lcd_escreve,"\foutside:%u", pass[0]); 
....................    // delay_ms(800); 
....................  
....................  
....................    // int index = 2; 
....................    // if(index>0){//for testing purposes 
....................    //    for(int i=0; i < index; i++){ 
....................    //       printf(lcd_escreve,"\foutside:%u", buffer[i]); 
....................    //       delay_ms(800); 
....................    //    } 
....................    // } 
....................   
....................   
....................   // address_data_delete = getAddressByID(6); 
....................   // printf(lcd_escreve, "\f Address ID = %d", address_data_delete); 
....................  //  deleteBlock(address_data_delete); 
....................    delay_ms(50); 
0EA7:  MOVLW  32
0EA8:  BSF    03.5
0EA9:  MOVWF  5A
0EAA:  BCF    0A.3
0EAB:  BCF    03.5
0EAC:  CALL   14F
0EAD:  BSF    0A.3
....................     
....................    while(TRUE) 
....................    { 
0EAE:  GOTO   6AE
....................    } 
....................  
.................... } 
....................  
0EAF:  SLEEP

Configuration Fuses:
   Word  1: 3F32   HS NOWDT PUT NOBROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT

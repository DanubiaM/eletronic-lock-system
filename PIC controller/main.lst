CCS PCM C Compiler, Version 5.025, 7201               22-Nov-21 19:41

               Filename:   E:\University\Microcontrollers\PCW Projects\eletronic-lock-system-ONLINE\PIC controller\main.lst

               ROM used:   5140 words (63%)
                           Largest free fragment is 2048
               RAM used:   45 (12%) at main() level
                           222 (60%) worst case
               Stack used: 7 locations
               Stack size: 8

*
0000:  MOVLW  0C
0001:  MOVWF  0A
0002:  GOTO   46A
0003:  NOP
....................  
.................... #include <16F877A.h> 
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
0004:  BCF    0A.0
0005:  BCF    0A.1
0006:  BCF    0A.2
0007:  ADDWF  02,F
0008:  RETLW  28
0009:  RETLW  0F
000A:  RETLW  01
000B:  RETLW  06
000C:  BCF    0A.0
000D:  BCF    0A.1
000E:  BCF    0A.2
000F:  ADDWF  02,F
0010:  RETLW  4E
0011:  RETLW  41
0012:  RETLW  4F
0013:  RETLW  20
0014:  RETLW  50
0015:  RETLW  41
0016:  RETLW  47
0017:  RETLW  4F
0018:  RETLW  00
0019:  BCF    0A.0
001A:  BCF    0A.1
001B:  BCF    0A.2
001C:  ADDWF  02,F
001D:  RETLW  50
001E:  RETLW  41
001F:  RETLW  47
0020:  RETLW  4F
0021:  RETLW  00
0022:  DATA 8C,2A
0023:  DATA F3,3A
0024:  DATA 61,39
0025:  DATA E9,37
0026:  DATA A0,21
0027:  DATA 61,32
0028:  DATA E1,39
0029:  DATA 74,39
002A:  DATA 61,32
002B:  DATA 6F,00
002C:  DATA 8C,24
002D:  DATA 44,10
002E:  DATA 69,37
002F:  DATA E3,37
0030:  DATA 6D,38
0031:  DATA 61,3A
0032:  DATA 69,3B
0033:  DATA 65,36
0034:  DATA 00,01
0035:  DATA 0D,05
0036:  DATA D4,32
0037:  DATA 6E,3A
0038:  DATA 65,10
0039:  DATA EE,37
003A:  DATA F6,30
003B:  DATA ED,32
003C:  DATA 6E,3A
003D:  DATA 65,00
003E:  DATA 8C,2A
003F:  DATA F3,3A
0040:  DATA 61,39
0041:  DATA E9,37
0042:  DATA A0,20
0043:  DATA F4,3A
0044:  DATA 61,36
0045:  DATA 69,3D
0046:  DATA 61,32
0047:  DATA 6F,00
0048:  DATA 8C,24
0049:  DATA 44,10
004A:  DATA 69,37
004B:  DATA E3,37
004C:  DATA 6D,38
004D:  DATA 61,3A
004E:  DATA 69,3B
004F:  DATA 65,36
0050:  DATA 00,01
0051:  DATA 0D,05
0052:  DATA D4,32
0053:  DATA 6E,3A
0054:  DATA 65,10
0055:  DATA EE,37
0056:  DATA F6,30
0057:  DATA ED,32
0058:  DATA 6E,3A
0059:  DATA 65,00
005A:  DATA 0C,10
005B:  DATA C2,3A
005C:  DATA 74,3A
005D:  DATA 6F,37
005E:  DATA 3A,10
005F:  DATA 25,32
0060:  DATA 00,00
0061:  DATA 0D,05
0062:  DATA D0,3B
0063:  DATA BA,12
0064:  DATA E4,12
0065:  DATA E4,12
0066:  DATA E4,12
0067:  DATA 64,10
0068:  DATA 53,3A
0069:  DATA BA,12
006A:  DATA 64,10
006B:  DATA 25,32
006C:  DATA 00,00
006D:  DATA 8C,24
006E:  DATA 44,1D
006F:  DATA A5,3A
0070:  DATA A5,3A
0071:  DATA 00,01
0072:  DATA 8C,2A
0073:  DATA F3,3A
0074:  DATA 61,39
0075:  DATA E9,37
0076:  DATA 20,27
0077:  DATA A0,22
0078:  DATA F8,34
0079:  DATA 73,3A
007A:  DATA 65,00
007B:  DATA 0C,10
007C:  DATA D5,39
007D:  DATA 65,39
007E:  DATA A0,32
007F:  DATA F2,30
0080:  DATA F3,32
0081:  DATA 64,10
0082:  DATA 00,00
0083:  DATA 0D,05
0084:  DATA 53,3A
0085:  DATA 61,3A
0086:  DATA F5,39
0087:  DATA BA,12
0088:  DATA 73,00
0089:  DATA 8C,18
008A:  DATA BA,21
008B:  DATA 41,22
008C:  DATA 7C,19
008D:  DATA 3A,21
008E:  DATA D5,29
008F:  DATA C3,20
0090:  DATA 52,00
0091:  DATA 0D,05
0092:  DATA 33,1D
0093:  DATA C4,22
0094:  DATA 4C,3E
0095:  DATA 34,1D
0096:  DATA 45,22
0097:  DATA 49,2A
0098:  DATA 41,29
0099:  DATA 00,01
009A:  DATA 8C,1A
009B:  DATA 3A,10
009C:  DATA D3,20
009D:  DATA 49,29
009E:  DATA 20,32
009F:  DATA 6F,10
00A0:  DATA CD,32
00A1:  DATA EE,3A
00A2:  DATA 20,00
00A3:  DATA 0C,10
00A4:  DATA 4F,38
00A5:  DATA F4,34
00A6:  DATA 6F,37
00A7:  DATA 3A,10
00A8:  DATA A5,31
00A9:  DATA 00,01
00AA:  DATA 8C,29
00AB:  DATA F5,31
00AC:  DATA E3,32
00AD:  DATA F3,39
00AE:  DATA A0,16
00AF:  DATA 3E,10
00B0:  DATA 25,32
00B1:  DATA 00,01
00B2:  DATA 8C,3A
00B3:  DATA F3,3A
00B4:  DATA 61,39
00B5:  DATA E9,37
00B6:  DATA 20,32
00B7:  DATA 65,36
00B8:  DATA 65,3A
00B9:  DATA 61,32
00BA:  DATA 6F,00
00BB:  DATA 8C,3A
00BC:  DATA F3,3A
00BD:  DATA 61,39
00BE:  DATA E9,37
00BF:  DATA 20,27
00C0:  DATA A0,22
00C1:  DATA F8,34
00C2:  DATA 73,3A
00C3:  DATA 65,00
00C4:  DATA 0C,22
00C5:  DATA E9,33
00C6:  DATA 69,3A
00C7:  DATA 65,10
00C8:  DATA F5,36
00C9:  DATA 20,3B
00CA:  DATA 61,36
00CB:  DATA 6F,39
00CC:  DATA 00,01
00CD:  DATA 0D,05
00CE:  DATA D6,30
00CF:  DATA EC,34
00D0:  DATA E4,37
00D1:  DATA 21,00
00D2:  DATA 8C,24
00D3:  DATA 44,10
00D4:  DATA 4E,10
00D5:  DATA 45,3C
00D6:  DATA E9,39
00D7:  DATA F4,32
00D8:  DATA 00,01
00D9:  DATA 0D,05
00DA:  DATA D4,32
00DB:  DATA 6E,3A
00DC:  DATA 65,10
00DD:  DATA E4,32
00DE:  DATA 20,37
00DF:  DATA 6F,3B
00E0:  DATA 6F,00
00E1:  DATA 0C,28
00E2:  DATA F2,37
00E3:  DATA E3,3A
00E4:  DATA F2,32
00E5:  DATA A0,30
00E6:  DATA A0,39
00E7:  DATA E5,31
00E8:  DATA F2,32
00E9:  DATA F4,30
00EA:  DATA F2,34
00EB:  DATA 61,00
00EC:  DATA 0D,05
00ED:  DATA D0,17
00EE:  DATA 20,39
00EF:  DATA E5,39
00F0:  DATA 6F,36
00F1:  DATA F6,32
00F2:  DATA 72,00
00F3:  DATA 0C,27
00F4:  DATA 41,22
00F5:  DATA 41,10
00F6:  DATA 65,34
00F7:  DATA 20,26
00F8:  DATA E9,33
00F9:  DATA 61,32
00FA:  DATA EF,10
00FB:  DATA 00,00
00FC:  DATA 0C,10
00FD:  DATA C4,34
00FE:  DATA E7,34
00FF:  DATA F4,32
0100:  DATA 00,00
0101:  DATA 8C,20
0102:  DATA E4,36
0103:  DATA 69,37
0104:  DATA A0,22
0105:  DATA EE,31
0106:  DATA 6F,37
0107:  DATA 74,39
0108:  DATA 61,32
0109:  DATA 6F,00
010A:  DATA 0C,10
010B:  DATA 61,32
010C:  DATA ED,34
010D:  DATA EE,39
010E:  DATA 5B,18
010F:  DATA 5D,1D
0110:  DATA A0,12
0111:  DATA 64,00
0112:  DATA 8C,34
0113:  DATA 64,1D
0114:  DATA A5,3A
0115:  DATA A5,3A
0116:  DATA 00,00
0117:  DATA 0C,22
0118:  DATA E9,33
0119:  DATA 69,3A
011A:  DATA 65,10
011B:  DATA 6F,10
011C:  DATA 49,22
011D:  DATA 3A,10
011E:  DATA 00,01
011F:  DATA 8A,06
0120:  DATA D4,3C
0121:  DATA F0,32
0122:  DATA 64,1D
0123:  DATA A5,31
0124:  DATA 00,00
0125:  DATA 8A,06
0126:  DATA D4,3C
0127:  DATA F0,32
0128:  DATA 64,1D
0129:  DATA A5,31
012A:  DATA 00,00
012B:  DATA 8C,34
012C:  DATA 64,1D
012D:  DATA A0,12
012E:  DATA F5,12
012F:  DATA 75,00
0130:  DATA 8C,24
0131:  DATA 44,10
0132:  DATA CA,30
0133:  DATA 68,10
0134:  DATA 45,3C
0135:  DATA E9,39
0136:  DATA F4,32
0137:  DATA 00,00
0138:  DATA 0C,28
0139:  DATA C1,29
013A:  DATA 53,14
013B:  DATA B4,14
013C:  DATA 3A,10
013D:  DATA A5,3A
013E:  DATA A5,3A
013F:  DATA A5,3A
0140:  DATA A5,3A
0141:  DATA 00,01
0142:  DATA 8C,29
0143:  DATA D4,20
0144:  DATA D4,2A
0145:  DATA 53,1D
0146:  DATA A0,12
0147:  DATA 75,00
0148:  DATA 8C,24
0149:  DATA 44,10
014A:  DATA 4E,10
014B:  DATA 45,3C
014C:  DATA E9,39
014D:  DATA F4,32
014E:  DATA 00,00
014F:  DATA 0C,10
0150:  DATA A0,34
0151:  DATA EE,34
0152:  DATA E3,34
0153:  DATA 61,37
0154:  DATA E4,37
0155:  DATA 2E,17
0156:  DATA 2E,10
0157:  DATA 00,01
0158:  DATA 8C,18
0159:  DATA 3A,26
015A:  DATA EF,33
015B:  DATA 69,37
015C:  DATA 7C,19
015D:  DATA BA,20
015E:  DATA E4,36
015F:  DATA 69,37
0160:  DATA 00,01
0161:  DATA 0D,05
0162:  DATA A0,27
0163:  DATA 70,3A
0164:  DATA E9,37
0165:  DATA 6E,1D
0166:  DATA A0,12
0167:  DATA 63,00
0168:  DATA 0C,21
0169:  DATA E5,36
016A:  DATA 20,2B
016B:  DATA 69,37
016C:  DATA E4,37
016D:  DATA A8,30
016E:  DATA A9,10
016F:  DATA 00,01
0170:  DATA 0C,26
0171:  DATA E9,33
0172:  DATA 61,10
0173:  DATA CC,32
0174:  DATA 64,10
0175:  DATA 65,10
0176:  DATA D2,32
0177:  DATA EC,32
0178:  DATA 00,01
0179:  DATA 8C,21
017A:  DATA 6F,37
017B:  DATA F4,30
017C:  DATA A0,22
017D:  DATA F8,34
017E:  DATA 73,3A
017F:  DATA 65,00
0180:  DATA 8D,06
0181:  DATA AC,26
0182:  DATA E1,39
0183:  DATA 20,23
0184:  DATA 61,36
0185:  DATA F4,30
0186:  DATA 20,28
0187:  DATA E1,33
0188:  DATA 61,39
0189:  DATA 21,00
018A:  DATA 0C,27
018B:  DATA 20,28
018C:  DATA 65,39
018D:  DATA ED,34
018E:  DATA F4,34
018F:  DATA E4,37
0190:  DATA 00,01
0191:  DATA 0C,22
0192:  DATA E9,33
0193:  DATA 69,3A
0194:  DATA 65,10
0195:  DATA F5,36
0196:  DATA 20,3B
0197:  DATA 61,36
0198:  DATA 6F,39
0199:  DATA 00,01
019A:  DATA 0D,05
019B:  DATA D6,30
019C:  DATA EC,34
019D:  DATA E4,37
019E:  DATA 21,00
*
02A6:  MOVF   0B,W
02A7:  BSF    03.5
02A8:  MOVWF  4B
02A9:  BCF    03.5
02AA:  BCF    0B.7
02AB:  BSF    03.5
02AC:  BSF    03.6
02AD:  BSF    0C.7
02AE:  BSF    0C.0
02AF:  NOP
02B0:  NOP
02B1:  BCF    03.6
02B2:  BTFSS  4B.7
02B3:  GOTO   2B7
02B4:  BCF    03.5
02B5:  BSF    0B.7
02B6:  BSF    03.5
02B7:  BCF    03.5
02B8:  BSF    03.6
02B9:  MOVF   0C,W
02BA:  ANDLW  7F
02BB:  BTFSC  03.2
02BC:  GOTO   318
02BD:  BSF    03.5
02BE:  BCF    03.6
02BF:  MOVWF  4B
02C0:  BCF    03.5
02C1:  BSF    03.6
02C2:  MOVF   0D,W
02C3:  BSF    03.5
02C4:  BCF    03.6
02C5:  MOVWF  4C
02C6:  BCF    03.5
02C7:  BSF    03.6
02C8:  MOVF   0F,W
02C9:  BSF    03.5
02CA:  BCF    03.6
02CB:  MOVWF  4D
02CC:  MOVF   4B,W
02CD:  MOVWF  4E
02CE:  BCF    03.5
02CF:  CALL   263
02D0:  BSF    03.5
02D1:  MOVF   4C,W
02D2:  BCF    03.5
02D3:  BSF    03.6
02D4:  MOVWF  0D
02D5:  BSF    03.5
02D6:  BCF    03.6
02D7:  MOVF   4D,W
02D8:  BCF    03.5
02D9:  BSF    03.6
02DA:  MOVWF  0F
02DB:  BCF    03.6
02DC:  MOVF   0B,W
02DD:  BSF    03.5
02DE:  MOVWF  4E
02DF:  BCF    03.5
02E0:  BCF    0B.7
02E1:  BSF    03.5
02E2:  BSF    03.6
02E3:  BSF    0C.7
02E4:  BSF    0C.0
02E5:  NOP
02E6:  NOP
02E7:  BCF    03.6
02E8:  BTFSS  4E.7
02E9:  GOTO   2ED
02EA:  BCF    03.5
02EB:  BSF    0B.7
02EC:  BSF    03.5
02ED:  BCF    03.5
02EE:  BSF    03.6
02EF:  RLF    0C,W
02F0:  RLF    0E,W
02F1:  ANDLW  7F
02F2:  BTFSC  03.2
02F3:  GOTO   318
02F4:  BSF    03.5
02F5:  BCF    03.6
02F6:  MOVWF  4B
02F7:  BCF    03.5
02F8:  BSF    03.6
02F9:  MOVF   0D,W
02FA:  BSF    03.5
02FB:  BCF    03.6
02FC:  MOVWF  4C
02FD:  BCF    03.5
02FE:  BSF    03.6
02FF:  MOVF   0F,W
0300:  BSF    03.5
0301:  BCF    03.6
0302:  MOVWF  4D
0303:  MOVF   4B,W
0304:  MOVWF  4E
0305:  BCF    03.5
0306:  CALL   263
0307:  BSF    03.5
0308:  MOVF   4C,W
0309:  BCF    03.5
030A:  BSF    03.6
030B:  MOVWF  0D
030C:  BSF    03.5
030D:  BCF    03.6
030E:  MOVF   4D,W
030F:  BCF    03.5
0310:  BSF    03.6
0311:  MOVWF  0F
0312:  INCF   0D,F
0313:  BTFSC  03.2
0314:  INCF   0F,F
0315:  BCF    03.6
0316:  GOTO   2A6
0317:  BSF    03.6
0318:  BCF    03.6
0319:  RETURN
*
047F:  MOVF   0B,W
0480:  BSF    03.5
0481:  MOVWF  4A
0482:  BCF    03.5
0483:  BCF    0B.7
0484:  BSF    03.5
0485:  BSF    03.6
0486:  BSF    0C.7
0487:  BSF    0C.0
0488:  NOP
0489:  NOP
048A:  BCF    03.6
048B:  BTFSS  4A.7
048C:  GOTO   490
048D:  BCF    03.5
048E:  BSF    0B.7
048F:  BSF    03.5
0490:  BTFSC  03.0
0491:  GOTO   4C9
0492:  BCF    03.5
0493:  BSF    03.6
0494:  MOVF   0C,W
0495:  ANDLW  7F
0496:  BSF    03.5
0497:  BCF    03.6
0498:  MOVWF  4A
0499:  BCF    03.5
049A:  BSF    03.6
049B:  MOVF   0D,W
049C:  BSF    03.5
049D:  BCF    03.6
049E:  MOVWF  4B
049F:  BCF    03.5
04A0:  BSF    03.6
04A1:  MOVF   0F,W
04A2:  BSF    03.5
04A3:  BCF    03.6
04A4:  MOVWF  4C
04A5:  MOVF   4A,W
04A6:  MOVWF  4E
04A7:  BCF    03.5
04A8:  CALL   263
04A9:  BSF    03.5
04AA:  MOVF   4B,W
04AB:  BCF    03.5
04AC:  BSF    03.6
04AD:  MOVWF  0D
04AE:  BSF    03.5
04AF:  BCF    03.6
04B0:  MOVF   4C,W
04B1:  BCF    03.5
04B2:  BSF    03.6
04B3:  MOVWF  0F
04B4:  BCF    03.6
04B5:  MOVF   0B,W
04B6:  BSF    03.5
04B7:  MOVWF  4D
04B8:  BCF    03.5
04B9:  BCF    0B.7
04BA:  BSF    03.5
04BB:  BSF    03.6
04BC:  BSF    0C.7
04BD:  BSF    0C.0
04BE:  NOP
04BF:  NOP
04C0:  BCF    03.6
04C1:  BTFSS  4D.7
04C2:  GOTO   4C6
04C3:  BCF    03.5
04C4:  BSF    0B.7
04C5:  BSF    03.5
04C6:  DECFSZ 49,F
04C7:  GOTO   4C9
04C8:  GOTO   4F7
04C9:  BCF    03.5
04CA:  BSF    03.6
04CB:  RLF    0C,W
04CC:  RLF    0E,W
04CD:  ANDLW  7F
04CE:  BSF    03.5
04CF:  BCF    03.6
04D0:  MOVWF  4A
04D1:  BCF    03.5
04D2:  BSF    03.6
04D3:  MOVF   0D,W
04D4:  BSF    03.5
04D5:  BCF    03.6
04D6:  MOVWF  4B
04D7:  BCF    03.5
04D8:  BSF    03.6
04D9:  MOVF   0F,W
04DA:  BSF    03.5
04DB:  BCF    03.6
04DC:  MOVWF  4C
04DD:  MOVF   4A,W
04DE:  MOVWF  4E
04DF:  BCF    03.5
04E0:  CALL   263
04E1:  BSF    03.5
04E2:  MOVF   4B,W
04E3:  BCF    03.5
04E4:  BSF    03.6
04E5:  MOVWF  0D
04E6:  BSF    03.5
04E7:  BCF    03.6
04E8:  MOVF   4C,W
04E9:  BCF    03.5
04EA:  BSF    03.6
04EB:  MOVWF  0F
04EC:  INCF   0D,F
04ED:  BTFSC  03.2
04EE:  INCF   0F,F
04EF:  BCF    03.0
04F0:  BSF    03.5
04F1:  BCF    03.6
04F2:  DECFSZ 49,F
04F3:  GOTO   4F5
04F4:  GOTO   4F7
04F5:  BCF    03.5
04F6:  GOTO   47F
04F7:  BCF    03.5
04F8:  RETURN
*
06B6:  MOVF   37,W
06B7:  XORWF  39,W
06B8:  ANDLW  80
06B9:  MOVWF  3B
06BA:  BTFSS  37.7
06BB:  GOTO   6C1
06BC:  COMF   36,F
06BD:  COMF   37,F
06BE:  INCF   36,F
06BF:  BTFSC  03.2
06C0:  INCF   37,F
06C1:  BTFSS  39.7
06C2:  GOTO   6C8
06C3:  COMF   38,F
06C4:  COMF   39,F
06C5:  INCF   38,F
06C6:  BTFSC  03.2
06C7:  INCF   39,F
06C8:  MOVLW  10
06C9:  MOVWF  3A
06CA:  CLRF   77
06CB:  CLRF   7A
06CC:  RRF    37,F
06CD:  RRF    36,F
06CE:  BTFSS  03.0
06CF:  GOTO   6D6
06D0:  MOVF   38,W
06D1:  ADDWF  77,F
06D2:  BTFSC  03.0
06D3:  INCF   7A,F
06D4:  MOVF   39,W
06D5:  ADDWF  7A,F
06D6:  RRF    7A,F
06D7:  RRF    77,F
06D8:  RRF    79,F
06D9:  RRF    78,F
06DA:  DECFSZ 3A,F
06DB:  GOTO   6CC
06DC:  BTFSS  3B.7
06DD:  GOTO   6E3
06DE:  COMF   78,F
06DF:  COMF   79,F
06E0:  INCF   78,F
06E1:  BTFSC  03.2
06E2:  INCF   79,F
*
09B2:  MOVF   00,F
09B3:  BTFSC  03.2
09B4:  GOTO   1D0
09B5:  BSF    03.5
09B6:  CLRF   48
09B7:  MOVF   04,W
09B8:  MOVWF  47
09B9:  BCF    48.0
09BA:  BTFSC  03.7
09BB:  BSF    48.0
09BC:  MOVF   00,W
09BD:  MOVWF  4E
09BE:  BCF    0A.3
09BF:  BCF    03.5
09C0:  CALL   263
09C1:  BSF    0A.3
09C2:  BSF    03.5
09C3:  MOVF   47,W
09C4:  MOVWF  04
09C5:  BCF    03.7
09C6:  BTFSC  48.0
09C7:  BSF    03.7
09C8:  INCF   04,F
09C9:  BTFSS  03.2
09CA:  GOTO   1CE
09CB:  BCF    03.5
09CC:  INCF   05,F
09CD:  BSF    03.5
09CE:  BCF    03.5
09CF:  GOTO   1B2
09D0:  RETURN
*
0B9D:  BSF    03.5
0B9E:  MOVF   3A,W
0B9F:  CLRF   78
0BA0:  SUBWF  39,W
0BA1:  BTFSC  03.0
0BA2:  GOTO   3A6
0BA3:  MOVF   39,W
0BA4:  MOVWF  77
0BA5:  GOTO   3B2
0BA6:  CLRF   77
0BA7:  MOVLW  08
0BA8:  MOVWF  3B
0BA9:  RLF    39,F
0BAA:  RLF    77,F
0BAB:  MOVF   3A,W
0BAC:  SUBWF  77,W
0BAD:  BTFSC  03.0
0BAE:  MOVWF  77
0BAF:  RLF    78,F
0BB0:  DECFSZ 3B,F
0BB1:  GOTO   3A9
0BB2:  BCF    03.5
0BB3:  RETURN
0BB4:  MOVF   78,W
0BB5:  BSF    03.5
0BB6:  MOVF   37,W
0BB7:  MOVWF  39
0BB8:  MOVLW  64
0BB9:  MOVWF  3A
0BBA:  BCF    03.5
0BBB:  CALL   39D
0BBC:  MOVF   77,W
0BBD:  BSF    03.5
0BBE:  MOVWF  37
0BBF:  MOVF   78,W
0BC0:  MOVLW  30
0BC1:  BTFSS  03.2
0BC2:  GOTO   3CA
0BC3:  BTFSS  38.1
0BC4:  GOTO   3D5
0BC5:  BTFSC  38.3
0BC6:  GOTO   3D5
0BC7:  BTFSC  38.4
0BC8:  MOVLW  20
0BC9:  GOTO   3CD
0BCA:  BCF    38.3
0BCB:  BCF    38.4
0BCC:  BSF    38.0
0BCD:  ADDWF  78,F
0BCE:  MOVF   78,W
0BCF:  MOVWF  4E
0BD0:  BCF    0A.3
0BD1:  BCF    03.5
0BD2:  CALL   263
0BD3:  BSF    0A.3
0BD4:  BSF    03.5
0BD5:  MOVF   37,W
0BD6:  MOVWF  39
0BD7:  MOVLW  0A
0BD8:  MOVWF  3A
0BD9:  BCF    03.5
0BDA:  CALL   39D
0BDB:  MOVF   77,W
0BDC:  BSF    03.5
0BDD:  MOVWF  37
0BDE:  MOVF   78,W
0BDF:  MOVLW  30
0BE0:  BTFSS  03.2
0BE1:  GOTO   3E8
0BE2:  BTFSC  38.3
0BE3:  GOTO   3F0
0BE4:  BTFSS  38.0
0BE5:  GOTO   3F0
0BE6:  BTFSC  38.4
0BE7:  MOVLW  20
0BE8:  ADDWF  78,F
0BE9:  MOVF   78,W
0BEA:  MOVWF  4E
0BEB:  BCF    0A.3
0BEC:  BCF    03.5
0BED:  CALL   263
0BEE:  BSF    0A.3
0BEF:  BSF    03.5
0BF0:  MOVLW  30
0BF1:  ADDWF  37,F
0BF2:  MOVF   37,W
0BF3:  MOVWF  4E
0BF4:  BCF    0A.3
0BF5:  BCF    03.5
0BF6:  CALL   263
0BF7:  BSF    0A.3
0BF8:  RETURN
*
1385:  MOVLW  20
1386:  BTFSS  54.4
1387:  MOVLW  30
1388:  MOVWF  55
1389:  MOVF   53,W
138A:  MOVWF  77
138B:  BTFSS  53.7
138C:  GOTO   395
138D:  COMF   77,F
138E:  INCF   77,F
138F:  MOVF   77,W
1390:  MOVWF  53
1391:  MOVLW  2D
1392:  MOVWF  55
1393:  BSF    54.7
1394:  BSF    54.0
1395:  MOVF   53,W
1396:  BSF    03.5
1397:  MOVWF  39
1398:  MOVLW  64
1399:  MOVWF  3A
139A:  BCF    0A.4
139B:  BSF    0A.3
139C:  BCF    03.5
139D:  CALL   39D
139E:  BSF    0A.4
139F:  BCF    0A.3
13A0:  MOVF   77,W
13A1:  MOVWF  53
13A2:  MOVLW  30
13A3:  ADDWF  78,W
13A4:  MOVWF  56
13A5:  MOVF   53,W
13A6:  BSF    03.5
13A7:  MOVWF  39
13A8:  MOVLW  0A
13A9:  MOVWF  3A
13AA:  BCF    0A.4
13AB:  BSF    0A.3
13AC:  BCF    03.5
13AD:  CALL   39D
13AE:  BSF    0A.4
13AF:  BCF    0A.3
13B0:  MOVLW  30
13B1:  ADDWF  77,W
13B2:  MOVWF  58
13B3:  MOVLW  30
13B4:  ADDWF  78,W
13B5:  MOVWF  57
13B6:  MOVF   55,W
13B7:  MOVWF  77
13B8:  MOVLW  30
13B9:  SUBWF  56,W
13BA:  BTFSC  03.2
13BB:  GOTO   3C0
13BC:  BSF    54.1
13BD:  BTFSC  54.7
13BE:  BSF    54.2
13BF:  GOTO   3D4
13C0:  MOVF   55,W
13C1:  MOVWF  56
13C2:  MOVLW  20
13C3:  MOVWF  55
13C4:  MOVLW  30
13C5:  SUBWF  57,W
13C6:  BTFSC  03.2
13C7:  GOTO   3CC
13C8:  BSF    54.0
13C9:  BTFSC  54.7
13CA:  BSF    54.1
13CB:  GOTO   3D4
13CC:  BTFSS  03.2
13CD:  BSF    54.0
13CE:  BTFSS  03.2
13CF:  GOTO   3D4
13D0:  MOVF   56,W
13D1:  MOVWF  57
13D2:  MOVLW  20
13D3:  MOVWF  56
13D4:  BTFSC  54.2
13D5:  GOTO   3DB
13D6:  BTFSC  54.1
13D7:  GOTO   3E2
13D8:  BTFSC  54.0
13D9:  GOTO   3E9
13DA:  GOTO   3F0
13DB:  MOVF   55,W
13DC:  BSF    03.5
13DD:  MOVWF  4E
13DE:  BCF    0A.4
13DF:  BCF    03.5
13E0:  CALL   263
13E1:  BSF    0A.4
13E2:  MOVF   56,W
13E3:  BSF    03.5
13E4:  MOVWF  4E
13E5:  BCF    0A.4
13E6:  BCF    03.5
13E7:  CALL   263
13E8:  BSF    0A.4
13E9:  MOVF   57,W
13EA:  BSF    03.5
13EB:  MOVWF  4E
13EC:  BCF    0A.4
13ED:  BCF    03.5
13EE:  CALL   263
13EF:  BSF    0A.4
13F0:  MOVF   58,W
13F1:  BSF    03.5
13F2:  MOVWF  4E
13F3:  BCF    0A.4
13F4:  BCF    03.5
13F5:  CALL   263
13F6:  BSF    0A.4
....................  
.................... #list 
....................  
.................... #device ADC=8 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES HS  
....................  
.................... #use delay(crystal=20000000) 
*
01AC:  MOVLW  CF
01AD:  MOVWF  04
01AE:  BCF    03.7
01AF:  MOVF   00,W
01B0:  BTFSC  03.2
01B1:  GOTO   1BF
01B2:  MOVLW  06
01B3:  MOVWF  78
01B4:  CLRF   77
01B5:  DECFSZ 77,F
01B6:  GOTO   1B5
01B7:  DECFSZ 78,F
01B8:  GOTO   1B4
01B9:  MOVLW  7B
01BA:  MOVWF  77
01BB:  DECFSZ 77,F
01BC:  GOTO   1BB
01BD:  DECFSZ 00,F
01BE:  GOTO   1B2
01BF:  RETURN
.................... //#use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=PORT1) 
....................  
....................  
.................... // -------Variables' Declaration 
.................... #define RX_BUFFER_SIZE 10 
.................... #define BLOCK_SIZE sizeof(User)  
.................... signed int8 address_data_delete; 
.................... int8 rx_wr_index = 0; 
.................... int8 lock_pos = 0, rxd, read, valid_data_count; 
.................... int data_avail = FALSE, got_id = FALSE; 
.................... unsigned int8 rx_buffer[RX_BUFFER_SIZE]; 
.................... #include "functions.c" 
.................... #include "functions.h" 
....................  
.................... //Define the default pins before calling the LCD driver 
.................... #ifndef lcd_enable  
....................    #define lcd_enable     pin_e1 
....................    #define lcd_rs         pin_e2 
....................    //#define lcd_rw       pin_e2   
....................    #define lcd_d4         pin_d4 
....................    #define lcd_d5         pin_d5 
....................    #define lcd_d6         pin_d6 
....................    #define lcd_d7         pin_d7 
.................... #endif 
....................  
.................... #include "mod_lcd.c" 
.................... /************************************************************************/ 
.................... /*  MOD_LCD.C - Biblioteca de manipulaï¿½ï¿½o de mï¿½dulo LCD                 */ 
.................... /*                                                                      */ 
.................... /*  Autor: Fï¿½bio Pereira                                                */ 
.................... /*                                                                      */ 
.................... /************************************************************************/ 
....................  
.................... // As definiï¿½ï¿½es a seguir sï¿½o utilizadas para acesso aos pinos do display 
.................... // caso o pino RW nï¿½o seja utilizado, comente a definiï¿½ï¿½o lcd_rw 
.................... #ifndef lcd_enable 
....................    #define lcd_enable       pin_e1      // pino enable do LCD 
....................    #define lcd_rs         pin_e0      // pino rs do LCD 
....................    //#define lcd_rw      pin_e2      // pino rw do LCD 
....................    #define lcd_d4         pin_d4      // pino de dados d4 do LCD 
....................    #define lcd_d5         pin_d5      // pino de dados d5 do LCD 
....................    #define lcd_d6         pin_d6      // pino de dados d6 do LCD 
....................    #define lcd_d7         pin_d7      // pino de dados d7 do LCD 
.................... #endif 
....................  
.................... #define lcd_type 2           
.................... #define lcd_seg_lin 0x40     
....................  
....................  
.................... byte CONST INI_LCD[4] = {0x20 | (lcd_type << 2), 0xf, 1, 6}; 
....................  
.................... byte lcd_le_byte() 
.................... // lï¿½ um byte do LCD (somente com pino RW) 
.................... { 
....................    byte dado; 
....................    // configura os pinos de dados como entradas 
....................    input(lcd_d4); 
....................    input(lcd_d5); 
....................    input(lcd_d6); 
....................    input(lcd_d7); 
....................    // se o pino rw for utilizado, coloca em 1 
....................    #ifdef lcd_rw 
....................       output_high(lcd_rw); 
....................    #endif 
....................    output_high(lcd_enable); // habilita display 
....................    dado = 0;   // zera a variï¿½vel de leitura 
....................    // lï¿½ os quatro bits mais significativos 
....................    if (input(lcd_d7)) bit_set(dado,7); 
....................    if (input(lcd_d6)) bit_set(dado,6); 
....................    if (input(lcd_d5)) bit_set(dado,5); 
....................    if (input(lcd_d4)) bit_set(dado,4); 
....................    // dï¿½ um pulso na linha enable 
....................    output_low(lcd_enable); 
....................    output_high(lcd_enable); 
....................    // lï¿½ os quatro bits menos significativos 
....................    if (input(lcd_d7)) bit_set(dado,3); 
....................    if (input(lcd_d6)) bit_set(dado,2); 
....................    if (input(lcd_d5)) bit_set(dado,1); 
....................    if (input(lcd_d4)) bit_set(dado,0); 
....................    output_low(lcd_enable);   // desabilita o display 
....................    return dado;   // retorna o byte lido 
.................... } 
....................  
.................... void lcd_envia_nibble( byte dado ) 
.................... // envia um dado de quatro bits para o display 
.................... { 
....................    // coloca os quatro bits nas saidas 
....................    output_bit(lcd_d4,bit_test(dado,0)); 
01C0:  BSF    03.5
01C1:  BTFSC  56.0
01C2:  GOTO   1C7
01C3:  BCF    03.5
01C4:  BCF    08.4
01C5:  GOTO   1C9
01C6:  BSF    03.5
01C7:  BCF    03.5
01C8:  BSF    08.4
01C9:  BSF    03.5
01CA:  BCF    08.4
....................    output_bit(lcd_d5,bit_test(dado,1)); 
01CB:  BTFSC  56.1
01CC:  GOTO   1D1
01CD:  BCF    03.5
01CE:  BCF    08.5
01CF:  GOTO   1D3
01D0:  BSF    03.5
01D1:  BCF    03.5
01D2:  BSF    08.5
01D3:  BSF    03.5
01D4:  BCF    08.5
....................    output_bit(lcd_d6,bit_test(dado,2)); 
01D5:  BTFSC  56.2
01D6:  GOTO   1DB
01D7:  BCF    03.5
01D8:  BCF    08.6
01D9:  GOTO   1DD
01DA:  BSF    03.5
01DB:  BCF    03.5
01DC:  BSF    08.6
01DD:  BSF    03.5
01DE:  BCF    08.6
....................    output_bit(lcd_d7,bit_test(dado,3)); 
01DF:  BTFSC  56.3
01E0:  GOTO   1E5
01E1:  BCF    03.5
01E2:  BCF    08.7
01E3:  GOTO   1E7
01E4:  BSF    03.5
01E5:  BCF    03.5
01E6:  BSF    08.7
01E7:  BSF    03.5
01E8:  BCF    08.7
....................    // dï¿½ um pulso na linha enable 
....................    output_high(lcd_enable); 
01E9:  BCF    09.1
01EA:  BCF    03.5
01EB:  BSF    09.1
....................    output_low(lcd_enable); 
01EC:  BSF    03.5
01ED:  BCF    09.1
01EE:  BCF    03.5
01EF:  BCF    09.1
01F0:  RETURN
.................... } 
....................  
....................  
.................... void lcd_envia_byte( boolean endereco, byte dado ) 
.................... { 
....................    // coloca a linha rs em 0 
....................    output_low(lcd_rs); 
01F1:  BSF    03.5
01F2:  BCF    09.2
01F3:  BCF    03.5
01F4:  BCF    09.2
....................    // aguarda o display ficar desocupado 
....................    //while ( bit_test(lcd_le_byte(),7) ) ; 
....................    // configura a linha rs dependendo do modo selecionado 
....................    output_bit(lcd_rs,endereco); 
01F5:  BSF    03.5
01F6:  MOVF   53,F
01F7:  BTFSS  03.2
01F8:  GOTO   1FD
01F9:  BCF    03.5
01FA:  BCF    09.2
01FB:  GOTO   1FF
01FC:  BSF    03.5
01FD:  BCF    03.5
01FE:  BSF    09.2
01FF:  BSF    03.5
0200:  BCF    09.2
....................    delay_us(100);   // aguarda 100 us 
0201:  MOVLW  A6
0202:  MOVWF  77
0203:  DECFSZ 77,F
0204:  GOTO   203
0205:  NOP
....................    // caso a linha rw esteja definida, coloca em 0 
....................    #ifdef lcd_rw 
....................       output_low(lcd_rw); 
....................    #endif 
....................    // desativa linha enable 
....................    output_low(lcd_enable); 
0206:  BCF    09.1
0207:  BCF    03.5
0208:  BCF    09.1
....................    // envia a primeira parte do byte 
....................    lcd_envia_nibble(dado >> 4); 
0209:  BSF    03.5
020A:  SWAPF  54,W
020B:  MOVWF  55
020C:  MOVLW  0F
020D:  ANDWF  55,F
020E:  MOVF   55,W
020F:  MOVWF  56
0210:  BCF    03.5
0211:  CALL   1C0
....................    // envia a segunda parte do byte 
....................    lcd_envia_nibble(dado & 0x0f); 
0212:  BSF    03.5
0213:  MOVF   54,W
0214:  ANDLW  0F
0215:  MOVWF  55
0216:  MOVWF  56
0217:  BCF    03.5
0218:  CALL   1C0
0219:  RETURN
.................... } 
....................  
....................  
.................... void lcd_ini() 
.................... // rotina de inicializaï¿½ï¿½o do display 
.................... { 
....................    byte conta; 
....................    output_low(lcd_d4); 
021A:  BSF    03.5
021B:  BCF    08.4
021C:  BCF    03.5
021D:  BCF    08.4
....................    output_low(lcd_d5); 
021E:  BSF    03.5
021F:  BCF    08.5
0220:  BCF    03.5
0221:  BCF    08.5
....................    output_low(lcd_d6); 
0222:  BSF    03.5
0223:  BCF    08.6
0224:  BCF    03.5
0225:  BCF    08.6
....................    output_low(lcd_d7); 
0226:  BSF    03.5
0227:  BCF    08.7
0228:  BCF    03.5
0229:  BCF    08.7
....................    output_low(lcd_rs); 
022A:  BSF    03.5
022B:  BCF    09.2
022C:  BCF    03.5
022D:  BCF    09.2
....................    #ifdef lcd_rw 
....................       output_high(lcd_rw); 
....................    #endif 
....................    output_low(lcd_enable); 
022E:  BSF    03.5
022F:  BCF    09.1
0230:  BCF    03.5
0231:  BCF    09.1
....................    delay_ms(15); 
0232:  MOVLW  0F
0233:  BSF    03.5
0234:  MOVWF  4F
0235:  BCF    03.5
0236:  CALL   1AC
....................    // envia uma seqï¿½ï¿½ncia de 3 vezes 0x03 
....................    // e depois 0x02 para configurar o mï¿½dulo 
....................    // para modo de 4 bits 
....................    for(conta=1;conta<=3;++conta) 
0237:  MOVLW  01
0238:  MOVWF  4D
0239:  MOVF   4D,W
023A:  SUBLW  03
023B:  BTFSS  03.0
023C:  GOTO   249
....................    { 
....................       lcd_envia_nibble(3); 
023D:  MOVLW  03
023E:  BSF    03.5
023F:  MOVWF  56
0240:  BCF    03.5
0241:  CALL   1C0
....................       delay_ms(5); 
0242:  MOVLW  05
0243:  BSF    03.5
0244:  MOVWF  4F
0245:  BCF    03.5
0246:  CALL   1AC
0247:  INCF   4D,F
0248:  GOTO   239
....................    } 
....................    lcd_envia_nibble(2); 
0249:  MOVLW  02
024A:  BSF    03.5
024B:  MOVWF  56
024C:  BCF    03.5
024D:  CALL   1C0
....................    // envia string de inicializaï¿½ï¿½o do display 
....................    for(conta=0;conta<=3;++conta) lcd_envia_byte(0,INI_LCD[conta]); 
024E:  CLRF   4D
024F:  MOVF   4D,W
0250:  SUBLW  03
0251:  BTFSS  03.0
0252:  GOTO   260
0253:  MOVF   4D,W
0254:  CALL   004
0255:  MOVWF  4E
0256:  BSF    03.5
0257:  CLRF   53
0258:  BCF    03.5
0259:  MOVF   4E,W
025A:  BSF    03.5
025B:  MOVWF  54
025C:  BCF    03.5
025D:  CALL   1F1
025E:  INCF   4D,F
025F:  GOTO   24F
0260:  BSF    0A.3
0261:  BCF    0A.4
0262:  GOTO   491 (RETURN)
.................... } 
....................  
.................... void lcd_pos_xy( byte x, byte y) 
.................... { 
....................    byte endereco; 
....................    if(y!=1) 
*
0284:  DECFSZ 50,W
0285:  GOTO   287
0286:  GOTO   28A
....................       endereco = lcd_seg_lin; 
0287:  MOVLW  40
0288:  MOVWF  51
0289:  GOTO   28B
....................    else 
....................       endereco = 0; 
028A:  CLRF   51
....................    endereco += x-1; 
028B:  MOVLW  01
028C:  SUBWF  4F,W
028D:  ADDWF  51,F
....................    lcd_envia_byte(0,0x80|endereco); 
028E:  MOVF   51,W
028F:  IORLW  80
0290:  MOVWF  52
0291:  CLRF   53
0292:  MOVF   52,W
0293:  MOVWF  54
0294:  BCF    03.5
0295:  CALL   1F1
.................... } 
....................  
.................... void lcd_escreve( char c) 
.................... // envia caractere para o display 
.................... { 
....................    switch (c) 
*
0263:  BSF    03.5
0264:  MOVF   4E,W
0265:  XORLW  0C
0266:  BCF    03.5
0267:  BTFSC  03.2
0268:  GOTO   273
0269:  XORLW  06
026A:  BTFSC  03.2
026B:  GOTO   27F
026C:  XORLW  07
026D:  BTFSC  03.2
026E:  GOTO   27F
026F:  XORLW  05
0270:  BTFSC  03.2
0271:  GOTO   297
0272:  GOTO   29E
....................    { 
....................      case '\f'    :   lcd_envia_byte(0,1); 
0273:  BSF    03.5
0274:  CLRF   53
0275:  MOVLW  01
0276:  MOVWF  54
0277:  BCF    03.5
0278:  CALL   1F1
....................               delay_ms(2); 
0279:  MOVLW  02
027A:  BSF    03.5
027B:  MOVWF  4F
027C:  BCF    03.5
027D:  CALL   1AC
....................             break; 
027E:  GOTO   2A5
....................      case '\n'   : 
....................       case '\r'    :   lcd_pos_xy(1,2); 
027F:  MOVLW  01
0280:  BSF    03.5
0281:  MOVWF  4F
0282:  MOVLW  02
0283:  MOVWF  50
....................               break; 
*
0296:  GOTO   2A5
....................      case '\b'    :   lcd_envia_byte(0,0x10); 
0297:  BSF    03.5
0298:  CLRF   53
0299:  MOVLW  10
029A:  MOVWF  54
029B:  BCF    03.5
029C:  CALL   1F1
....................               break; 
029D:  GOTO   2A5
....................      default   :   lcd_envia_byte(1,c); 
029E:  MOVLW  01
029F:  BSF    03.5
02A0:  MOVWF  53
02A1:  MOVF   4E,W
02A2:  MOVWF  54
02A3:  BCF    03.5
02A4:  CALL   1F1
....................               break; 
....................    } 
02A5:  RETURN
.................... } 
....................  
.................... char lcd_le( byte x, byte y) 
.................... // le caractere do display 
.................... { 
....................    char valor; 
....................    // seleciona a posiï¿½ï¿½o do caractere 
....................    lcd_pos_xy(x,y); 
....................    // ativa rs 
....................    output_high(lcd_rs); 
....................    // lï¿½ o caractere 
....................    valor = lcd_le_byte(); 
....................    // desativa rs 
....................    output_low(lcd_rs); 
....................    // retorna o valor do caractere 
....................    return valor; 
.................... } 
....................  
....................  
.................... #include "2401.c" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a MicroChip 24LC01B configured for a x8 org         //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);  Read the byte d from the address a     //// 
.................... ////                                                                   //// 
.................... ////   b = ext_eeprom_ready();  Returns TRUE if the eeprom is ready    //// 
.................... ////                            to receive opcodes                     //// 
.................... ////                                                                   //// 
.................... ////   The main program may define EEPROM_SDA                          //// 
.................... ////   and EEPROM_SCL to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... ////                            Pin Layout                             //// 
.................... ////   -----------------------------------------------------------     //// 
.................... ////   |                                                         |     //// 
.................... ////   | 1: NC   Not Connected | 8: VCC   +5V                    |     //// 
.................... ////   |                       |                                 |     //// 
.................... ////   | 2: NC   Not Connected | 7: WP    GND                    |     //// 
.................... ////   |                       |                                 |     //// 
.................... ////   | 3: NC   Not Connected | 6: SCL   EEPROM_SCL and Pull-Up |     //// 
.................... ////   |                       |                                 |     //// 
.................... ////   | 4: VSS  GND           | 5: SDA   EEPROM_SDA and Pull-Up |     //// 
.................... ////   -----------------------------------------------------------     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2003 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef EEPROM_SDA 
....................  
.................... #define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C3 
....................  
.................... #endif 
....................  
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
0800:  MOVLW  08
0801:  MOVWF  78
0802:  MOVLW  04
0803:  MOVWF  77
0804:  DECFSZ 77,F
0805:  GOTO   004
0806:  BCF    07.3
0807:  BCF    32.3
0808:  MOVF   32,W
0809:  BSF    03.5
080A:  MOVWF  07
080B:  MOVLW  03
080C:  MOVWF  77
080D:  DECFSZ 77,F
080E:  GOTO   00D
080F:  RLF    4D,F
0810:  BCF    03.5
0811:  BCF    07.4
0812:  BTFSS  03.0
0813:  GOTO   01A
0814:  BSF    32.4
0815:  MOVF   32,W
0816:  BSF    03.5
0817:  MOVWF  07
0818:  GOTO   01E
0819:  BCF    03.5
081A:  BCF    32.4
081B:  MOVF   32,W
081C:  BSF    03.5
081D:  MOVWF  07
081E:  NOP
081F:  BCF    03.5
0820:  BSF    32.3
0821:  MOVF   32,W
0822:  BSF    03.5
0823:  MOVWF  07
0824:  BCF    03.5
0825:  BTFSS  07.3
0826:  GOTO   025
0827:  DECFSZ 78,F
0828:  GOTO   002
0829:  MOVLW  04
082A:  MOVWF  77
082B:  DECFSZ 77,F
082C:  GOTO   02B
082D:  BCF    07.3
082E:  BCF    32.3
082F:  MOVF   32,W
0830:  BSF    03.5
0831:  MOVWF  07
0832:  NOP
0833:  BCF    03.5
0834:  BSF    32.4
0835:  MOVF   32,W
0836:  BSF    03.5
0837:  MOVWF  07
0838:  MOVLW  03
0839:  MOVWF  77
083A:  DECFSZ 77,F
083B:  GOTO   03A
083C:  MOVLW  03
083D:  MOVWF  77
083E:  DECFSZ 77,F
083F:  GOTO   03E
0840:  BCF    03.5
0841:  BSF    32.3
0842:  MOVF   32,W
0843:  BSF    03.5
0844:  MOVWF  07
0845:  BCF    03.5
0846:  BTFSS  07.3
0847:  GOTO   046
0848:  CLRF   78
0849:  MOVLW  03
084A:  MOVWF  77
084B:  DECFSZ 77,F
084C:  GOTO   04B
084D:  BTFSC  07.4
084E:  BSF    78.0
084F:  BCF    07.3
0850:  BCF    32.3
0851:  MOVF   32,W
0852:  BSF    03.5
0853:  MOVWF  07
0854:  BCF    03.5
0855:  BCF    07.4
0856:  BCF    32.4
0857:  MOVF   32,W
0858:  BSF    03.5
0859:  MOVWF  07
085A:  BCF    03.5
085B:  RETURN
*
08FE:  MOVLW  08
08FF:  BSF    03.5
0900:  MOVWF  47
0901:  MOVF   77,W
0902:  MOVWF  48
0903:  BCF    03.5
0904:  BSF    32.4
0905:  MOVF   32,W
0906:  BSF    03.5
0907:  MOVWF  07
0908:  MOVLW  03
0909:  MOVWF  77
090A:  DECFSZ 77,F
090B:  GOTO   10A
090C:  BCF    03.5
090D:  BSF    32.3
090E:  MOVF   32,W
090F:  BSF    03.5
0910:  MOVWF  07
0911:  BCF    03.5
0912:  BTFSS  07.3
0913:  GOTO   112
0914:  BTFSC  07.4
0915:  BSF    03.0
0916:  BTFSS  07.4
0917:  BCF    03.0
0918:  RLF    78,F
0919:  MOVLW  04
091A:  MOVWF  77
091B:  DECFSZ 77,F
091C:  GOTO   11B
091D:  BCF    32.3
091E:  MOVF   32,W
091F:  BSF    03.5
0920:  MOVWF  07
0921:  BCF    03.5
0922:  BCF    07.3
0923:  BSF    03.5
0924:  DECFSZ 47,F
0925:  GOTO   103
0926:  BCF    03.5
0927:  BSF    32.4
0928:  MOVF   32,W
0929:  BSF    03.5
092A:  MOVWF  07
092B:  MOVLW  03
092C:  MOVWF  77
092D:  DECFSZ 77,F
092E:  GOTO   12D
092F:  BCF    03.5
0930:  BCF    07.4
0931:  BSF    03.5
0932:  MOVF   48,W
0933:  BTFSC  03.2
0934:  GOTO   13A
0935:  BCF    03.5
0936:  BCF    32.4
0937:  MOVF   32,W
0938:  BSF    03.5
0939:  MOVWF  07
093A:  NOP
093B:  BCF    03.5
093C:  BSF    32.3
093D:  MOVF   32,W
093E:  BSF    03.5
093F:  MOVWF  07
0940:  BCF    03.5
0941:  BTFSS  07.3
0942:  GOTO   141
0943:  MOVLW  04
0944:  MOVWF  77
0945:  DECFSZ 77,F
0946:  GOTO   145
0947:  BCF    07.3
0948:  BCF    32.3
0949:  MOVF   32,W
094A:  BSF    03.5
094B:  MOVWF  07
094C:  MOVLW  03
094D:  MOVWF  77
094E:  DECFSZ 77,F
094F:  GOTO   14E
0950:  BCF    03.5
0951:  BCF    07.4
0952:  BCF    32.4
0953:  MOVF   32,W
0954:  BSF    03.5
0955:  MOVWF  07
....................  
.................... #define EEPROM_ADDRESS BYTE 
.................... #define EEPROM_SIZE    128 
....................  
.................... void init_ext_eeprom() { 
....................    output_float(EEPROM_SCL); 
*
019F:  BSF    32.3
01A0:  MOVF   32,W
01A1:  BSF    03.5
01A2:  MOVWF  07
....................    output_float(EEPROM_SDA); 
01A3:  BCF    03.5
01A4:  BSF    32.4
01A5:  MOVF   32,W
01A6:  BSF    03.5
01A7:  MOVWF  07
01A8:  BCF    03.5
01A9:  BSF    0A.3
01AA:  BCF    0A.4
01AB:  GOTO   48E (RETURN)
.................... } 
....................  
.................... BOOLEAN ext_eeprom_ready() { 
....................    int1 ack; 
....................    i2c_start();            // If the write command is acknowledged, 
*
085C:  BSF    32.4
085D:  MOVF   32,W
085E:  BSF    03.5
085F:  MOVWF  07
0860:  MOVLW  04
0861:  MOVWF  77
0862:  DECFSZ 77,F
0863:  GOTO   062
0864:  BCF    03.5
0865:  BSF    32.3
0866:  MOVF   32,W
0867:  BSF    03.5
0868:  MOVWF  07
0869:  MOVLW  03
086A:  MOVWF  77
086B:  DECFSZ 77,F
086C:  GOTO   06B
086D:  BCF    03.5
086E:  BCF    07.4
086F:  BCF    32.4
0870:  MOVF   32,W
0871:  BSF    03.5
0872:  MOVWF  07
0873:  MOVLW  04
0874:  MOVWF  77
0875:  DECFSZ 77,F
0876:  GOTO   075
0877:  BCF    03.5
0878:  BCF    07.3
0879:  BCF    32.3
087A:  MOVF   32,W
087B:  BSF    03.5
087C:  MOVWF  07
....................    ack = i2c_write(0xa0);  // then the device is ready. 
087D:  MOVLW  A0
087E:  MOVWF  4D
087F:  BCF    03.5
0880:  CALL   000
0881:  MOVF   78,W
0882:  BSF    03.5
0883:  BCF    4C.0
0884:  BTFSC  78.0
0885:  BSF    4C.0
....................    i2c_stop(); 
0886:  BCF    03.5
0887:  BCF    32.4
0888:  MOVF   32,W
0889:  BSF    03.5
088A:  MOVWF  07
088B:  NOP
088C:  BCF    03.5
088D:  BSF    32.3
088E:  MOVF   32,W
088F:  BSF    03.5
0890:  MOVWF  07
0891:  BCF    03.5
0892:  BTFSS  07.3
0893:  GOTO   092
0894:  MOVLW  04
0895:  MOVWF  77
0896:  DECFSZ 77,F
0897:  GOTO   096
0898:  GOTO   099
0899:  NOP
089A:  BSF    32.4
089B:  MOVF   32,W
089C:  BSF    03.5
089D:  MOVWF  07
089E:  MOVLW  04
089F:  MOVWF  77
08A0:  DECFSZ 77,F
08A1:  GOTO   0A0
....................    return !ack; 
08A2:  MOVLW  00
08A3:  BTFSS  4C.0
08A4:  MOVLW  01
08A5:  MOVWF  78
08A6:  BCF    03.5
08A7:  RETURN
.................... } 
....................  
.................... void write_ext_eeprom(BYTE address, BYTE data) { 
....................    while(!ext_eeprom_ready()); 
*
0BF9:  CALL   05C
0BFA:  MOVF   78,F
0BFB:  BTFSC  03.2
0BFC:  GOTO   3F9
....................    i2c_start(); 
0BFD:  BSF    32.4
0BFE:  MOVF   32,W
0BFF:  BSF    03.5
0C00:  MOVWF  07
0C01:  MOVLW  04
0C02:  MOVWF  77
0C03:  DECFSZ 77,F
0C04:  GOTO   403
0C05:  BCF    03.5
0C06:  BSF    32.3
0C07:  MOVF   32,W
0C08:  BSF    03.5
0C09:  MOVWF  07
0C0A:  MOVLW  03
0C0B:  MOVWF  77
0C0C:  DECFSZ 77,F
0C0D:  GOTO   40C
0C0E:  BCF    03.5
0C0F:  BCF    07.4
0C10:  BCF    32.4
0C11:  MOVF   32,W
0C12:  BSF    03.5
0C13:  MOVWF  07
0C14:  MOVLW  04
0C15:  MOVWF  77
0C16:  DECFSZ 77,F
0C17:  GOTO   416
0C18:  BCF    03.5
0C19:  BCF    07.3
0C1A:  BCF    32.3
0C1B:  MOVF   32,W
0C1C:  BSF    03.5
0C1D:  MOVWF  07
....................    i2c_write(0xa0); 
0C1E:  MOVLW  A0
0C1F:  MOVWF  4D
0C20:  BCF    03.5
0C21:  CALL   000
....................    i2c_write(address); 
0C22:  BSF    03.5
0C23:  MOVF   4A,W
0C24:  MOVWF  4D
0C25:  BCF    03.5
0C26:  CALL   000
....................    i2c_write(data); 
0C27:  BSF    03.5
0C28:  MOVF   4B,W
0C29:  MOVWF  4D
0C2A:  BCF    03.5
0C2B:  CALL   000
....................    i2c_stop(); 
0C2C:  BCF    32.4
0C2D:  MOVF   32,W
0C2E:  BSF    03.5
0C2F:  MOVWF  07
0C30:  NOP
0C31:  BCF    03.5
0C32:  BSF    32.3
0C33:  MOVF   32,W
0C34:  BSF    03.5
0C35:  MOVWF  07
0C36:  BCF    03.5
0C37:  BTFSS  07.3
0C38:  GOTO   437
0C39:  MOVLW  04
0C3A:  MOVWF  77
0C3B:  DECFSZ 77,F
0C3C:  GOTO   43B
0C3D:  GOTO   43E
0C3E:  NOP
0C3F:  BSF    32.4
0C40:  MOVF   32,W
0C41:  BSF    03.5
0C42:  MOVWF  07
0C43:  MOVLW  04
0C44:  MOVWF  77
0C45:  DECFSZ 77,F
0C46:  GOTO   445
0C47:  BCF    03.5
0C48:  RETURN
.................... } 
....................  
....................  
.................... BYTE read_ext_eeprom(BYTE address) { 
....................    BYTE data; 
....................  
....................    while(!ext_eeprom_ready()); 
*
08A8:  CALL   05C
08A9:  MOVF   78,F
08AA:  BTFSC  03.2
08AB:  GOTO   0A8
....................    i2c_start(); 
08AC:  BSF    32.4
08AD:  MOVF   32,W
08AE:  BSF    03.5
08AF:  MOVWF  07
08B0:  MOVLW  04
08B1:  MOVWF  77
08B2:  DECFSZ 77,F
08B3:  GOTO   0B2
08B4:  BCF    03.5
08B5:  BSF    32.3
08B6:  MOVF   32,W
08B7:  BSF    03.5
08B8:  MOVWF  07
08B9:  MOVLW  03
08BA:  MOVWF  77
08BB:  DECFSZ 77,F
08BC:  GOTO   0BB
08BD:  BCF    03.5
08BE:  BCF    07.4
08BF:  BCF    32.4
08C0:  MOVF   32,W
08C1:  BSF    03.5
08C2:  MOVWF  07
08C3:  MOVLW  04
08C4:  MOVWF  77
08C5:  DECFSZ 77,F
08C6:  GOTO   0C5
08C7:  BCF    03.5
08C8:  BCF    07.3
08C9:  BCF    32.3
08CA:  MOVF   32,W
08CB:  BSF    03.5
08CC:  MOVWF  07
....................    i2c_write(0xa0); 
08CD:  MOVLW  A0
08CE:  MOVWF  4D
08CF:  BCF    03.5
08D0:  CALL   000
....................    i2c_write(address); 
08D1:  BSF    03.5
08D2:  MOVF   44,W
08D3:  MOVWF  4D
08D4:  BCF    03.5
08D5:  CALL   000
....................    i2c_start(); 
08D6:  BSF    32.4
08D7:  MOVF   32,W
08D8:  BSF    03.5
08D9:  MOVWF  07
08DA:  MOVLW  04
08DB:  MOVWF  77
08DC:  DECFSZ 77,F
08DD:  GOTO   0DC
08DE:  BCF    03.5
08DF:  BSF    32.3
08E0:  MOVF   32,W
08E1:  BSF    03.5
08E2:  MOVWF  07
08E3:  MOVLW  03
08E4:  MOVWF  77
08E5:  DECFSZ 77,F
08E6:  GOTO   0E5
08E7:  BCF    03.5
08E8:  BTFSS  07.3
08E9:  GOTO   0E8
08EA:  BCF    07.4
08EB:  BCF    32.4
08EC:  MOVF   32,W
08ED:  BSF    03.5
08EE:  MOVWF  07
08EF:  MOVLW  04
08F0:  MOVWF  77
08F1:  DECFSZ 77,F
08F2:  GOTO   0F1
08F3:  BCF    03.5
08F4:  BCF    07.3
08F5:  BCF    32.3
08F6:  MOVF   32,W
08F7:  BSF    03.5
08F8:  MOVWF  07
....................    i2c_write(0xa1); 
08F9:  MOVLW  A1
08FA:  MOVWF  4D
08FB:  BCF    03.5
08FC:  CALL   000
....................    data=i2c_read(0); 
08FD:  CLRF   77
*
0956:  MOVF   78,W
0957:  MOVWF  45
....................    i2c_stop(); 
0958:  BCF    03.5
0959:  BCF    32.4
095A:  MOVF   32,W
095B:  BSF    03.5
095C:  MOVWF  07
095D:  NOP
095E:  BCF    03.5
095F:  BSF    32.3
0960:  MOVF   32,W
0961:  BSF    03.5
0962:  MOVWF  07
0963:  BCF    03.5
0964:  BTFSS  07.3
0965:  GOTO   164
0966:  MOVLW  04
0967:  MOVWF  77
0968:  DECFSZ 77,F
0969:  GOTO   168
096A:  GOTO   16B
096B:  NOP
096C:  BSF    32.4
096D:  MOVF   32,W
096E:  BSF    03.5
096F:  MOVWF  07
0970:  MOVLW  04
0971:  MOVWF  77
0972:  DECFSZ 77,F
0973:  GOTO   172
....................    return(data); 
0974:  MOVF   45,W
0975:  MOVWF  78
0976:  BCF    03.5
0977:  RETURN
.................... } 
....................  
.................... #include "kbd_board4.c" 
.................... /*######################################################################  
....................    Rotina utilização do teclado da placa PicSim board4 
....................    Adaptada para o compilador CCS 
....................    Autor: Alberto Willia Mascarenhas (adaptou para o compilador) 
....................    For e-mail suggestions :  awmascarenhas@gmail.com 
.................... ######################################################################## */ 
.................... unsigned char tc_tecla(unsigned int timeout) 
*
031D:  CLRF   4C
031E:  CLRF   4D
.................... { 
....................   unsigned int to=0; 
....................   unsigned char k = 0;   
....................   while(((to < timeout)||(!timeout))&&(!k)){ 
031F:  MOVF   4B,W
0320:  SUBWF  4C,W
0321:  BTFSS  03.0
0322:  GOTO   326
0323:  MOVF   4B,F
0324:  BTFSS  03.2
0325:  GOTO   465
0326:  MOVF   4D,F
0327:  BTFSS  03.2
0328:  GOTO   465
....................       
....................        
....................       //------------------------------------------------------------------------- 
....................       //inicio do programa de varredura do teclado matricial 
....................       //-------------------------------------------------------------------------- 
....................       //habilita primeira coluna do teclado 
....................       output_low(PIN_B0);output_high(PIN_B1);output_high(PIN_B2);output_high(PIN_B3); 
0329:  BCF    06.0
032A:  BCF    03.5
032B:  BCF    06.0
032C:  BSF    03.5
032D:  BCF    06.1
032E:  BCF    03.5
032F:  BSF    06.1
0330:  BSF    03.5
0331:  BCF    06.2
0332:  BCF    03.5
0333:  BSF    06.2
0334:  BSF    03.5
0335:  BCF    06.3
0336:  BCF    03.5
0337:  BSF    06.3
....................       delay_ms(20); 
0338:  MOVLW  14
0339:  BSF    03.5
033A:  MOVWF  4F
033B:  BCF    03.5
033C:  CALL   1AC
....................       if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='1';}; 
033D:  BSF    03.5
033E:  BSF    08.0
033F:  BCF    03.5
0340:  BTFSC  08.0
0341:  GOTO   34B
0342:  BSF    03.5
0343:  BSF    08.0
0344:  BCF    03.5
0345:  BTFSS  08.0
0346:  GOTO   342
0347:  MOVLW  31
0348:  BSF    03.5
0349:  MOVWF  4D
034A:  BCF    03.5
....................       if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='4';}; 
034B:  BSF    03.5
034C:  BSF    08.1
034D:  BCF    03.5
034E:  BTFSC  08.1
034F:  GOTO   359
0350:  BSF    03.5
0351:  BSF    08.1
0352:  BCF    03.5
0353:  BTFSS  08.1
0354:  GOTO   350
0355:  MOVLW  34
0356:  BSF    03.5
0357:  MOVWF  4D
0358:  BCF    03.5
....................       if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='7';}; 
0359:  BSF    03.5
035A:  BSF    08.2
035B:  BCF    03.5
035C:  BTFSC  08.2
035D:  GOTO   367
035E:  BSF    03.5
035F:  BSF    08.2
0360:  BCF    03.5
0361:  BTFSS  08.2
0362:  GOTO   35E
0363:  MOVLW  37
0364:  BSF    03.5
0365:  MOVWF  4D
0366:  BCF    03.5
....................       if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='*';}; 
0367:  BSF    03.5
0368:  BSF    08.3
0369:  BCF    03.5
036A:  BTFSC  08.3
036B:  GOTO   375
036C:  BSF    03.5
036D:  BSF    08.3
036E:  BCF    03.5
036F:  BTFSS  08.3
0370:  GOTO   36C
0371:  MOVLW  2A
0372:  BSF    03.5
0373:  MOVWF  4D
0374:  BCF    03.5
....................       //habilita segunda coluna do teclado 
....................       output_high(PIN_B0);output_low(PIN_B1);output_high(PIN_B2);output_high(PIN_B3); 
0375:  BSF    03.5
0376:  BCF    06.0
0377:  BCF    03.5
0378:  BSF    06.0
0379:  BSF    03.5
037A:  BCF    06.1
037B:  BCF    03.5
037C:  BCF    06.1
037D:  BSF    03.5
037E:  BCF    06.2
037F:  BCF    03.5
0380:  BSF    06.2
0381:  BSF    03.5
0382:  BCF    06.3
0383:  BCF    03.5
0384:  BSF    06.3
....................       delay_ms(20);       
0385:  MOVLW  14
0386:  BSF    03.5
0387:  MOVWF  4F
0388:  BCF    03.5
0389:  CALL   1AC
....................       if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='2';}; 
038A:  BSF    03.5
038B:  BSF    08.0
038C:  BCF    03.5
038D:  BTFSC  08.0
038E:  GOTO   398
038F:  BSF    03.5
0390:  BSF    08.0
0391:  BCF    03.5
0392:  BTFSS  08.0
0393:  GOTO   38F
0394:  MOVLW  32
0395:  BSF    03.5
0396:  MOVWF  4D
0397:  BCF    03.5
....................       if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='5';}; 
0398:  BSF    03.5
0399:  BSF    08.1
039A:  BCF    03.5
039B:  BTFSC  08.1
039C:  GOTO   3A6
039D:  BSF    03.5
039E:  BSF    08.1
039F:  BCF    03.5
03A0:  BTFSS  08.1
03A1:  GOTO   39D
03A2:  MOVLW  35
03A3:  BSF    03.5
03A4:  MOVWF  4D
03A5:  BCF    03.5
....................       if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='8';}; 
03A6:  BSF    03.5
03A7:  BSF    08.2
03A8:  BCF    03.5
03A9:  BTFSC  08.2
03AA:  GOTO   3B4
03AB:  BSF    03.5
03AC:  BSF    08.2
03AD:  BCF    03.5
03AE:  BTFSS  08.2
03AF:  GOTO   3AB
03B0:  MOVLW  38
03B1:  BSF    03.5
03B2:  MOVWF  4D
03B3:  BCF    03.5
....................       if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='0';}; 
03B4:  BSF    03.5
03B5:  BSF    08.3
03B6:  BCF    03.5
03B7:  BTFSC  08.3
03B8:  GOTO   3C2
03B9:  BSF    03.5
03BA:  BSF    08.3
03BB:  BCF    03.5
03BC:  BTFSS  08.3
03BD:  GOTO   3B9
03BE:  MOVLW  30
03BF:  BSF    03.5
03C0:  MOVWF  4D
03C1:  BCF    03.5
....................        
....................       //habilita terceira coluna do teclado 
....................       output_high(PIN_B0);output_high(PIN_B1);output_low(PIN_B2);output_high(PIN_B3); 
03C2:  BSF    03.5
03C3:  BCF    06.0
03C4:  BCF    03.5
03C5:  BSF    06.0
03C6:  BSF    03.5
03C7:  BCF    06.1
03C8:  BCF    03.5
03C9:  BSF    06.1
03CA:  BSF    03.5
03CB:  BCF    06.2
03CC:  BCF    03.5
03CD:  BCF    06.2
03CE:  BSF    03.5
03CF:  BCF    06.3
03D0:  BCF    03.5
03D1:  BSF    06.3
....................       delay_ms(20);       
03D2:  MOVLW  14
03D3:  BSF    03.5
03D4:  MOVWF  4F
03D5:  BCF    03.5
03D6:  CALL   1AC
....................       if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='3';}; 
03D7:  BSF    03.5
03D8:  BSF    08.0
03D9:  BCF    03.5
03DA:  BTFSC  08.0
03DB:  GOTO   3E5
03DC:  BSF    03.5
03DD:  BSF    08.0
03DE:  BCF    03.5
03DF:  BTFSS  08.0
03E0:  GOTO   3DC
03E1:  MOVLW  33
03E2:  BSF    03.5
03E3:  MOVWF  4D
03E4:  BCF    03.5
....................       if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='6';}; 
03E5:  BSF    03.5
03E6:  BSF    08.1
03E7:  BCF    03.5
03E8:  BTFSC  08.1
03E9:  GOTO   3F3
03EA:  BSF    03.5
03EB:  BSF    08.1
03EC:  BCF    03.5
03ED:  BTFSS  08.1
03EE:  GOTO   3EA
03EF:  MOVLW  36
03F0:  BSF    03.5
03F1:  MOVWF  4D
03F2:  BCF    03.5
....................       if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='9';}; 
03F3:  BSF    03.5
03F4:  BSF    08.2
03F5:  BCF    03.5
03F6:  BTFSC  08.2
03F7:  GOTO   401
03F8:  BSF    03.5
03F9:  BSF    08.2
03FA:  BCF    03.5
03FB:  BTFSS  08.2
03FC:  GOTO   3F8
03FD:  MOVLW  39
03FE:  BSF    03.5
03FF:  MOVWF  4D
0400:  BCF    03.5
....................       if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='#';}; 
0401:  BSF    03.5
0402:  BSF    08.3
0403:  BCF    03.5
0404:  BTFSC  08.3
0405:  GOTO   40F
0406:  BSF    03.5
0407:  BSF    08.3
0408:  BCF    03.5
0409:  BTFSS  08.3
040A:  GOTO   406
040B:  MOVLW  23
040C:  BSF    03.5
040D:  MOVWF  4D
040E:  BCF    03.5
....................   
....................        //habilita quarta coluna do teclado 
....................       output_high(PIN_B0);output_high(PIN_B1);output_high(PIN_B2);output_low(PIN_B3); 
040F:  BSF    03.5
0410:  BCF    06.0
0411:  BCF    03.5
0412:  BSF    06.0
0413:  BSF    03.5
0414:  BCF    06.1
0415:  BCF    03.5
0416:  BSF    06.1
0417:  BSF    03.5
0418:  BCF    06.2
0419:  BCF    03.5
041A:  BSF    06.2
041B:  BSF    03.5
041C:  BCF    06.3
041D:  BCF    03.5
041E:  BCF    06.3
....................       delay_ms(20);       
041F:  MOVLW  14
0420:  BSF    03.5
0421:  MOVWF  4F
0422:  BCF    03.5
0423:  CALL   1AC
....................       if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='A';}; 
0424:  BSF    03.5
0425:  BSF    08.0
0426:  BCF    03.5
0427:  BTFSC  08.0
0428:  GOTO   432
0429:  BSF    03.5
042A:  BSF    08.0
042B:  BCF    03.5
042C:  BTFSS  08.0
042D:  GOTO   429
042E:  MOVLW  41
042F:  BSF    03.5
0430:  MOVWF  4D
0431:  BCF    03.5
....................       if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='B';}; 
0432:  BSF    03.5
0433:  BSF    08.1
0434:  BCF    03.5
0435:  BTFSC  08.1
0436:  GOTO   440
0437:  BSF    03.5
0438:  BSF    08.1
0439:  BCF    03.5
043A:  BTFSS  08.1
043B:  GOTO   437
043C:  MOVLW  42
043D:  BSF    03.5
043E:  MOVWF  4D
043F:  BCF    03.5
....................       if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='C';}; 
0440:  BSF    03.5
0441:  BSF    08.2
0442:  BCF    03.5
0443:  BTFSC  08.2
0444:  GOTO   44E
0445:  BSF    03.5
0446:  BSF    08.2
0447:  BCF    03.5
0448:  BTFSS  08.2
0449:  GOTO   445
044A:  MOVLW  43
044B:  BSF    03.5
044C:  MOVWF  4D
044D:  BCF    03.5
....................       if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='D';}; 
044E:  BSF    03.5
044F:  BSF    08.3
0450:  BCF    03.5
0451:  BTFSC  08.3
0452:  GOTO   45C
0453:  BSF    03.5
0454:  BSF    08.3
0455:  BCF    03.5
0456:  BTFSS  08.3
0457:  GOTO   453
0458:  MOVLW  44
0459:  BSF    03.5
045A:  MOVWF  4D
045B:  BCF    03.5
....................   
....................       //printf (lcd_escreve,"\f saiu geral %u",k); 
....................       //delay_ms(1000); 
....................       delay_ms(5); 
045C:  MOVLW  05
045D:  BSF    03.5
045E:  MOVWF  4F
045F:  BCF    03.5
0460:  CALL   1AC
....................       to+=5; 
0461:  MOVLW  05
0462:  BSF    03.5
0463:  ADDWF  4C,F
0464:  GOTO   31F
....................   } 
....................    if(!k)k=255; 
0465:  MOVF   4D,F
0466:  BTFSS  03.2
0467:  GOTO   46A
0468:  MOVLW  FF
0469:  MOVWF  4D
....................   return k;   
046A:  MOVF   4D,W
046B:  MOVWF  78
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /* 
.................... int status -> 0 - Unpaid, 1 - Paid, 3 - Admin 
.................... int chooseAddr: 
....................          Param < 0 - SAVE in a available address to CREATE  
....................          Param >= 0 - SAVE in a existing address to OVERWRITE (edit) 
.................... */ 
.................... void saveUser(int * id, int * pass, int status); 
.................... int getAddressByID(int * id);    
.................... void searchUser(int * id); 
.................... int deleteUser(int * id); 
.................... void editUser(); 
.................... void updateUser(int * id, int * pass, int status); 
....................  
.................... // int isIdAvailable(int id);     
.................... void printUser(); 
.................... void erase_program_eeprom(int addrr); 
.................... int incrementID(); 
.................... int lastNewUserPosition(); 
.................... void resetMemory(); 
.................... void adminMenu(); 
.................... int login(int * id); 
.................... int checkPassword(int initBlockAddr, int * pass); 
.................... //show = 1 -> Print(Paid/Unpaid) 
.................... int getUserStatus(int address, int show); 
.................... unsigned char readKeyboard();  
.................... int * getAdminsID(); 
.................... void listAdmins(); 
.................... int * strToInt(char * str); 
.................... char * strfromchar(char destination[], char source); 
.................... int * inputId(); 
.................... int * inputToKeyboard(char * msg, int max); 
.................... void inputKeyboardUser(); 
....................  
....................  
.................... typedef struct {  
....................    int id[2];   
....................    int pass[4]; //password 
....................    int status; //0 - Unpaid, 1 - Paid, 3 - Admin 
.................... }User; 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
*
04F9:  BSF    03.6
04FA:  MOVF   37,W
04FB:  MOVWF  3A
....................    for(su=s;0<n;++su,--n) 
04FC:  MOVF   36,W
04FD:  MOVWF  3C
04FE:  MOVF   35,W
04FF:  MOVWF  3B
0500:  MOVF   39,F
0501:  BTFSS  03.2
0502:  GOTO   507
0503:  MOVF   38,W
0504:  SUBLW  00
0505:  BTFSC  03.0
0506:  GOTO   51F
....................       if(*su==uc) 
0507:  MOVF   3C,W
0508:  MOVWF  7A
0509:  MOVF   3B,W
050A:  MOVWF  04
050B:  BCF    03.7
050C:  BTFSC  7A.0
050D:  BSF    03.7
050E:  MOVF   3A,W
050F:  SUBWF  00,W
0510:  BTFSS  03.2
0511:  GOTO   517
....................       return su; 
0512:  MOVF   3B,W
0513:  MOVWF  78
0514:  MOVF   3C,W
0515:  MOVWF  79
0516:  GOTO   522
0517:  INCF   3B,F
0518:  BTFSC  03.2
0519:  INCF   3C,F
051A:  MOVF   38,W
051B:  BTFSC  03.2
051C:  DECF   39,F
051D:  DECF   38,F
051E:  GOTO   500
....................    return NULL; 
051F:  MOVLW  00
0520:  MOVWF  78
0521:  MOVWF  79
0522:  BCF    03.6
0523:  RETURN
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
0C7B:  BCF    03.5
0C7C:  CLRF   33
0C7D:  CLRF   34
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
*
0524:  BSF    03.5
0525:  CLRF   5D
0526:  CLRF   5C
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
0527:  MOVLW  30
0528:  BCF    03.5
0529:  BSF    03.6
052A:  MOVWF  10
052B:  MOVLW  31
052C:  MOVWF  11
052D:  MOVLW  32
052E:  MOVWF  12
052F:  MOVLW  33
0530:  MOVWF  13
0531:  MOVLW  34
0532:  MOVWF  14
0533:  MOVLW  35
0534:  MOVWF  15
0535:  MOVLW  36
0536:  MOVWF  16
0537:  MOVLW  37
0538:  MOVWF  17
0539:  MOVLW  38
053A:  MOVWF  18
053B:  MOVLW  39
053C:  MOVWF  19
053D:  MOVLW  61
053E:  MOVWF  1A
053F:  MOVLW  62
0540:  MOVWF  1B
0541:  MOVLW  63
0542:  MOVWF  1C
0543:  MOVLW  64
0544:  MOVWF  1D
0545:  MOVLW  65
0546:  MOVWF  1E
0547:  MOVLW  66
0548:  MOVWF  1F
0549:  MOVLW  67
054A:  MOVWF  20
054B:  MOVLW  68
054C:  MOVWF  21
054D:  MOVLW  69
054E:  MOVWF  22
054F:  MOVLW  6A
0550:  MOVWF  23
0551:  MOVLW  6B
0552:  MOVWF  24
0553:  MOVLW  6C
0554:  MOVWF  25
0555:  MOVLW  6D
0556:  MOVWF  26
0557:  MOVLW  6E
0558:  MOVWF  27
0559:  MOVLW  6F
055A:  MOVWF  28
055B:  MOVLW  70
055C:  MOVWF  29
055D:  MOVLW  71
055E:  MOVWF  2A
055F:  MOVLW  73
0560:  MOVWF  2B
0561:  MOVLW  74
0562:  MOVWF  2C
0563:  MOVLW  75
0564:  MOVWF  2D
0565:  MOVLW  76
0566:  MOVWF  2E
0567:  MOVLW  77
0568:  MOVWF  2F
0569:  MOVLW  78
056A:  MOVWF  30
056B:  MOVLW  79
056C:  MOVWF  31
056D:  MOVLW  7A
056E:  MOVWF  32
056F:  CLRF   33
....................    for(sc=s;isspace(*sc);++sc); 
0570:  BSF    03.5
0571:  BCF    03.6
0572:  MOVF   52,W
0573:  MOVWF  57
0574:  MOVF   51,W
0575:  MOVWF  56
0576:  MOVF   57,W
0577:  MOVWF  7A
0578:  MOVF   56,W
0579:  MOVWF  04
057A:  BCF    03.7
057B:  BTFSC  7A.0
057C:  BSF    03.7
057D:  MOVF   00,W
057E:  SUBLW  20
057F:  BTFSS  03.2
0580:  GOTO   585
0581:  INCF   56,F
0582:  BTFSC  03.2
0583:  INCF   57,F
0584:  GOTO   576
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
0585:  MOVF   57,W
0586:  MOVWF  7A
0587:  MOVF   56,W
0588:  MOVWF  04
0589:  BCF    03.7
058A:  BTFSC  57.0
058B:  BSF    03.7
058C:  MOVF   00,W
058D:  SUBLW  2D
058E:  BTFSC  03.2
058F:  GOTO   59B
0590:  MOVF   57,W
0591:  MOVWF  7A
0592:  MOVF   56,W
0593:  MOVWF  04
0594:  BCF    03.7
0595:  BTFSC  57.0
0596:  BSF    03.7
0597:  MOVF   00,W
0598:  SUBLW  2B
0599:  BTFSS  03.2
059A:  GOTO   5A7
059B:  MOVF   57,W
059C:  MOVWF  7A
059D:  MOVF   56,W
059E:  INCF   56,F
059F:  BTFSC  03.2
05A0:  INCF   57,F
05A1:  MOVWF  04
05A2:  BCF    03.7
05A3:  BTFSC  7A.0
05A4:  BSF    03.7
05A5:  MOVF   00,W
05A6:  GOTO   5A8
05A7:  MOVLW  2B
05A8:  MOVWF  5E
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
05A9:  MOVF   5E,W
05AA:  SUBLW  2D
05AB:  BTFSC  03.2
05AC:  GOTO   5B8
05AD:  BTFSC  55.7
05AE:  GOTO   5B8
05AF:  DECFSZ 55,W
05B0:  GOTO   5B2
05B1:  GOTO   5B8
05B2:  BTFSC  55.7
05B3:  GOTO   5BA
05B4:  MOVF   55,W
05B5:  SUBLW  24
05B6:  BTFSC  03.0
05B7:  GOTO   5BA
....................    goto StrtoulGO; 
05B8:  GOTO   738
05B9:  GOTO   650
....................  
....................    else if (base) 
05BA:  MOVF   55,F
05BB:  BTFSC  03.2
05BC:  GOTO   615
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
05BD:  MOVF   55,W
05BE:  SUBLW  10
05BF:  BTFSS  03.2
05C0:  GOTO   5E4
05C1:  MOVF   57,W
05C2:  MOVWF  7A
05C3:  MOVF   56,W
05C4:  MOVWF  04
05C5:  BCF    03.7
05C6:  BTFSC  7A.0
05C7:  BSF    03.7
05C8:  MOVF   00,W
05C9:  SUBLW  30
05CA:  BTFSS  03.2
05CB:  GOTO   5E4
05CC:  MOVLW  01
05CD:  ADDWF  56,W
05CE:  MOVWF  04
05CF:  BCF    03.7
05D0:  BTFSC  57.0
05D1:  BSF    03.7
05D2:  MOVF   00,W
05D3:  SUBLW  78
05D4:  BTFSC  03.2
05D5:  GOTO   5E0
05D6:  MOVLW  01
05D7:  ADDWF  56,W
05D8:  MOVWF  04
05D9:  BCF    03.7
05DA:  BTFSC  57.0
05DB:  BSF    03.7
05DC:  MOVF   00,W
05DD:  SUBLW  58
05DE:  BTFSS  03.2
05DF:  GOTO   5E4
....................          sc+=2; 
05E0:  MOVLW  02
05E1:  ADDWF  56,F
05E2:  BTFSC  03.0
05E3:  INCF   57,F
....................       if(base==8 && *sc =='0') 
05E4:  MOVF   55,W
05E5:  SUBLW  08
05E6:  BTFSS  03.2
05E7:  GOTO   5F7
05E8:  MOVF   57,W
05E9:  MOVWF  7A
05EA:  MOVF   56,W
05EB:  MOVWF  04
05EC:  BCF    03.7
05ED:  BTFSC  7A.0
05EE:  BSF    03.7
05EF:  MOVF   00,W
05F0:  SUBLW  30
05F1:  BTFSS  03.2
05F2:  GOTO   5F7
....................          sc+=1; 
05F3:  MOVLW  01
05F4:  ADDWF  56,F
05F5:  BTFSC  03.0
05F6:  INCF   57,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
05F7:  MOVF   55,W
05F8:  SUBLW  02
05F9:  BTFSS  03.2
05FA:  GOTO   614
05FB:  MOVF   57,W
05FC:  MOVWF  7A
05FD:  MOVF   56,W
05FE:  MOVWF  04
05FF:  BCF    03.7
0600:  BTFSC  7A.0
0601:  BSF    03.7
0602:  MOVF   00,W
0603:  SUBLW  30
0604:  BTFSS  03.2
0605:  GOTO   614
0606:  MOVLW  01
0607:  ADDWF  56,W
0608:  MOVWF  04
0609:  BCF    03.7
060A:  BTFSC  57.0
060B:  BSF    03.7
060C:  MOVF   00,W
060D:  SUBLW  62
060E:  BTFSS  03.2
060F:  GOTO   614
....................          sc+=2; 
0610:  MOVLW  02
0611:  ADDWF  56,F
0612:  BTFSC  03.0
0613:  INCF   57,F
....................  
....................    } 
0614:  GOTO   650
....................    else if(*sc!='0') // base is 0, find base 
0615:  MOVF   57,W
0616:  MOVWF  7A
0617:  MOVF   56,W
0618:  MOVWF  04
0619:  BCF    03.7
061A:  BTFSC  7A.0
061B:  BSF    03.7
061C:  MOVF   00,W
061D:  SUBLW  30
061E:  BTFSC  03.2
061F:  GOTO   623
....................       base=10; 
0620:  MOVLW  0A
0621:  MOVWF  55
0622:  GOTO   650
....................    else if (sc[1]=='x' || sc[1]=='X') 
0623:  MOVLW  01
0624:  ADDWF  56,W
0625:  MOVWF  04
0626:  BCF    03.7
0627:  BTFSC  57.0
0628:  BSF    03.7
0629:  MOVF   00,W
062A:  SUBLW  78
062B:  BTFSC  03.2
062C:  GOTO   637
062D:  MOVLW  01
062E:  ADDWF  56,W
062F:  MOVWF  04
0630:  BCF    03.7
0631:  BTFSC  57.0
0632:  BSF    03.7
0633:  MOVF   00,W
0634:  SUBLW  58
0635:  BTFSS  03.2
0636:  GOTO   63E
....................       base =16,sc+=2; 
0637:  MOVLW  10
0638:  MOVWF  55
0639:  MOVLW  02
063A:  ADDWF  56,F
063B:  BTFSC  03.0
063C:  INCF   57,F
063D:  GOTO   650
....................    else if(sc[1]=='b') 
063E:  MOVLW  01
063F:  ADDWF  56,W
0640:  MOVWF  04
0641:  BCF    03.7
0642:  BTFSC  57.0
0643:  BSF    03.7
0644:  MOVF   00,W
0645:  SUBLW  62
0646:  BTFSS  03.2
0647:  GOTO   64E
....................       base=2,sc+=2; 
0648:  MOVLW  02
0649:  MOVWF  55
064A:  ADDWF  56,F
064B:  BTFSC  03.0
064C:  INCF   57,F
064D:  GOTO   650
....................    else 
....................       base=8; 
064E:  MOVLW  08
064F:  MOVWF  55
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
0650:  MOVF   57,W
0651:  MOVWF  59
0652:  MOVF   56,W
0653:  MOVWF  58
0654:  MOVF   57,W
0655:  MOVWF  7A
0656:  MOVF   56,W
0657:  MOVWF  04
0658:  BCF    03.7
0659:  BTFSC  7A.0
065A:  BSF    03.7
065B:  MOVF   00,W
065C:  SUBLW  30
065D:  BTFSS  03.2
065E:  GOTO   663
065F:  INCF   56,F
0660:  BTFSC  03.2
0661:  INCF   57,F
0662:  GOTO   654
....................    sd=memchr(digits,tolower(*sc),base); 
0663:  MOVF   57,W
0664:  MOVWF  7A
0665:  MOVF   56,W
0666:  MOVWF  04
0667:  BCF    03.7
0668:  BTFSC  57.0
0669:  BSF    03.7
066A:  MOVF   00,W
066B:  MOVWF  5F
066C:  SUBLW  40
066D:  BTFSC  03.0
066E:  GOTO   676
066F:  MOVF   5F,W
0670:  SUBLW  5A
0671:  BTFSS  03.0
0672:  GOTO   676
0673:  MOVF   5F,W
0674:  IORLW  20
0675:  GOTO   677
0676:  MOVF   5F,W
0677:  MOVWF  5F
0678:  MOVLW  01
0679:  BCF    03.5
067A:  BSF    03.6
067B:  MOVWF  36
067C:  MOVLW  10
067D:  MOVWF  35
067E:  BSF    03.5
067F:  BCF    03.6
0680:  MOVF   5F,W
0681:  BCF    03.5
0682:  BSF    03.6
0683:  MOVWF  37
0684:  CLRF   39
0685:  BSF    03.5
0686:  BCF    03.6
0687:  MOVF   55,W
0688:  BCF    03.5
0689:  BSF    03.6
068A:  MOVWF  38
068B:  BCF    03.6
068C:  CALL   4F9
068D:  MOVF   79,W
068E:  BSF    03.5
068F:  MOVWF  5B
0690:  MOVF   78,W
0691:  MOVWF  5A
....................    for(; sd!=0; ) 
0692:  MOVF   5A,F
0693:  BTFSS  03.2
0694:  GOTO   698
0695:  MOVF   5B,F
0696:  BTFSC  03.2
0697:  GOTO   730
....................    { 
....................       x=x*base+(int16)(sd-digits); 
0698:  CLRF   7A
0699:  MOVF   55,W
069A:  MOVWF  77
069B:  BTFSC  77.7
069C:  DECF   7A,F
069D:  MOVWF  5F
069E:  MOVF   7A,W
069F:  MOVWF  60
06A0:  MOVF   5D,W
06A1:  BCF    03.5
06A2:  BSF    03.6
06A3:  MOVWF  37
06A4:  BSF    03.5
06A5:  BCF    03.6
06A6:  MOVF   5C,W
06A7:  BCF    03.5
06A8:  BSF    03.6
06A9:  MOVWF  36
06AA:  BSF    03.5
06AB:  BCF    03.6
06AC:  MOVF   60,W
06AD:  BCF    03.5
06AE:  BSF    03.6
06AF:  MOVWF  39
06B0:  BSF    03.5
06B1:  BCF    03.6
06B2:  MOVF   5F,W
06B3:  BCF    03.5
06B4:  BSF    03.6
06B5:  MOVWF  38
*
06E3:  MOVF   79,W
06E4:  BSF    03.5
06E5:  BCF    03.6
06E6:  MOVWF  60
06E7:  MOVF   78,W
06E8:  MOVWF  5F
06E9:  MOVLW  10
06EA:  SUBWF  5A,W
06EB:  MOVWF  77
06EC:  MOVF   5B,W
06ED:  MOVWF  7A
06EE:  MOVLW  01
06EF:  BTFSS  03.0
06F0:  MOVLW  02
06F1:  SUBWF  7A,F
06F2:  MOVF   77,W
06F3:  ADDWF  5F,W
06F4:  MOVWF  78
06F5:  MOVF   60,W
06F6:  BTFSC  03.0
06F7:  INCFSZ 60,W
06F8:  ADDWF  7A,F
06F9:  MOVF   78,W
06FA:  MOVWF  5C
06FB:  MOVF   7A,W
06FC:  MOVWF  5D
....................       ++sc; 
06FD:  INCF   56,F
06FE:  BTFSC  03.2
06FF:  INCF   57,F
....................       sd=memchr(digits,tolower(*sc),base); 
0700:  MOVF   57,W
0701:  MOVWF  7A
0702:  MOVF   56,W
0703:  MOVWF  04
0704:  BCF    03.7
0705:  BTFSC  57.0
0706:  BSF    03.7
0707:  MOVF   00,W
0708:  MOVWF  5F
0709:  SUBLW  40
070A:  BTFSC  03.0
070B:  GOTO   713
070C:  MOVF   5F,W
070D:  SUBLW  5A
070E:  BTFSS  03.0
070F:  GOTO   713
0710:  MOVF   5F,W
0711:  IORLW  20
0712:  GOTO   714
0713:  MOVF   5F,W
0714:  MOVWF  5F
0715:  MOVLW  01
0716:  BCF    03.5
0717:  BSF    03.6
0718:  MOVWF  36
0719:  MOVLW  10
071A:  MOVWF  35
071B:  BSF    03.5
071C:  BCF    03.6
071D:  MOVF   5F,W
071E:  BCF    03.5
071F:  BSF    03.6
0720:  MOVWF  37
0721:  CLRF   39
0722:  BSF    03.5
0723:  BCF    03.6
0724:  MOVF   55,W
0725:  BCF    03.5
0726:  BSF    03.6
0727:  MOVWF  38
0728:  BCF    03.6
0729:  CALL   4F9
072A:  MOVF   79,W
072B:  BSF    03.5
072C:  MOVWF  5B
072D:  MOVF   78,W
072E:  MOVWF  5A
072F:  GOTO   692
....................    } 
....................    if(s1==sc) 
0730:  MOVF   56,W
0731:  SUBWF  58,W
0732:  BTFSS  03.2
0733:  GOTO   74B
0734:  MOVF   57,W
0735:  SUBWF  59,W
0736:  BTFSS  03.2
0737:  GOTO   74B
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
0738:  MOVF   53,W
0739:  IORWF  54,W
073A:  BTFSC  03.2
073B:  GOTO   747
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
073C:  MOVF   53,W
073D:  MOVWF  04
073E:  BCF    03.7
073F:  BTFSC  54.0
0740:  BSF    03.7
0741:  INCF   04,F
0742:  MOVF   52,W
0743:  MOVWF  00
0744:  DECF   04,F
0745:  MOVF   51,W
0746:  MOVWF  00
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
0747:  MOVLW  00
0748:  MOVWF  78
0749:  MOVWF  79
074A:  GOTO   75E
....................    } 
....................    if (endptr) 
074B:  MOVF   53,W
074C:  IORWF  54,W
074D:  BTFSC  03.2
074E:  GOTO   75A
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
074F:  MOVF   53,W
0750:  MOVWF  04
0751:  BCF    03.7
0752:  BTFSC  54.0
0753:  BSF    03.7
0754:  INCF   04,F
0755:  MOVF   57,W
0756:  MOVWF  00
0757:  DECF   04,F
0758:  MOVF   56,W
0759:  MOVWF  00
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
075A:  MOVF   5C,W
075B:  MOVWF  78
075C:  MOVF   5D,W
075D:  MOVWF  79
075E:  BCF    03.5
075F:  RETURN
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... void saveUser(int * id, int * pass, int status){ 
....................    if( id[0] <= 99 && id[1] <= 99 && getAddressByID(id) == -1 ){ 
*
1155:  MOVF   31,W
1156:  MOVWF  04
1157:  BCF    03.7
1158:  BTFSC  32.0
1159:  BSF    03.7
115A:  MOVF   00,W
115B:  SUBLW  63
115C:  BTFSS  03.0
115D:  GOTO   22E
115E:  MOVLW  01
115F:  ADDWF  31,W
1160:  MOVWF  04
1161:  BCF    03.7
1162:  BTFSC  32.0
1163:  BSF    03.7
1164:  MOVF   00,W
1165:  SUBLW  63
1166:  BTFSS  03.0
1167:  GOTO   22E
1168:  MOVF   32,W
1169:  MOVWF  3F
116A:  MOVF   31,W
116B:  MOVWF  3E
116C:  BCF    0A.4
116D:  BSF    0A.3
116E:  BCF    03.5
116F:  CALL   178
1170:  BSF    0A.4
1171:  BCF    0A.3
1172:  MOVF   78,W
1173:  SUBLW  FF
1174:  BTFSC  03.2
1175:  GOTO   178
1176:  BSF    03.5
1177:  GOTO   22E
....................       int address = lastNewUserPosition(); 
....................  
....................       //recebe os parÃ¢metros do usuÃ¡rio 
....................       User user; 
*
118E:  MOVF   78,W
118F:  MOVWF  36
....................       user.id[0] = id[0]; 
1190:  MOVF   31,W
1191:  MOVWF  04
1192:  BCF    03.7
1193:  BTFSC  32.0
1194:  BSF    03.7
1195:  MOVF   00,W
1196:  MOVWF  37
....................       user.id[1] = id[1]; 
1197:  MOVLW  01
1198:  ADDWF  31,W
1199:  MOVWF  04
119A:  BCF    03.7
119B:  BTFSC  32.0
119C:  BSF    03.7
119D:  MOVF   00,W
119E:  MOVWF  38
....................       user.pass[0] = pass[0]; 
119F:  MOVF   33,W
11A0:  MOVWF  04
11A1:  BCF    03.7
11A2:  BTFSC  34.0
11A3:  BSF    03.7
11A4:  MOVF   00,W
11A5:  MOVWF  39
....................       user.pass[1] = pass[1]; 
11A6:  MOVLW  01
11A7:  ADDWF  33,W
11A8:  MOVWF  04
11A9:  BCF    03.7
11AA:  BTFSC  34.0
11AB:  BSF    03.7
11AC:  MOVF   00,W
11AD:  MOVWF  3A
....................       user.pass[2] = pass[2]; 
11AE:  MOVLW  02
11AF:  ADDWF  33,W
11B0:  MOVWF  04
11B1:  BCF    03.7
11B2:  BTFSC  34.0
11B3:  BSF    03.7
11B4:  MOVF   00,W
11B5:  MOVWF  3B
....................       user.pass[3] = pass[3]; 
11B6:  MOVLW  03
11B7:  ADDWF  33,W
11B8:  MOVWF  04
11B9:  BCF    03.7
11BA:  BTFSC  34.0
11BB:  BSF    03.7
11BC:  MOVF   00,W
11BD:  MOVWF  3C
....................       user.status = status; 
11BE:  MOVF   35,W
11BF:  MOVWF  3D
....................        
....................       write_ext_eeprom(address, user.id[0]); 
11C0:  MOVF   36,W
11C1:  MOVWF  4A
11C2:  MOVF   37,W
11C3:  MOVWF  4B
11C4:  BCF    0A.4
11C5:  BSF    0A.3
11C6:  BCF    03.5
11C7:  CALL   3F9
11C8:  BSF    0A.4
11C9:  BCF    0A.3
....................       write_ext_eeprom(address+1, user.id[1]); 
11CA:  MOVLW  01
11CB:  BSF    03.5
11CC:  ADDWF  36,W
11CD:  MOVWF  3E
11CE:  MOVWF  4A
11CF:  MOVF   38,W
11D0:  MOVWF  4B
11D1:  BCF    0A.4
11D2:  BSF    0A.3
11D3:  BCF    03.5
11D4:  CALL   3F9
11D5:  BSF    0A.4
11D6:  BCF    0A.3
....................       write_ext_eeprom(address+2, user.pass[0]); 
11D7:  MOVLW  02
11D8:  BSF    03.5
11D9:  ADDWF  36,W
11DA:  MOVWF  3E
11DB:  MOVWF  4A
11DC:  MOVF   39,W
11DD:  MOVWF  4B
11DE:  BCF    0A.4
11DF:  BSF    0A.3
11E0:  BCF    03.5
11E1:  CALL   3F9
11E2:  BSF    0A.4
11E3:  BCF    0A.3
....................       write_ext_eeprom(address+3, user.pass[1]); 
11E4:  MOVLW  03
11E5:  BSF    03.5
11E6:  ADDWF  36,W
11E7:  MOVWF  3E
11E8:  MOVWF  4A
11E9:  MOVF   3A,W
11EA:  MOVWF  4B
11EB:  BCF    0A.4
11EC:  BSF    0A.3
11ED:  BCF    03.5
11EE:  CALL   3F9
11EF:  BSF    0A.4
11F0:  BCF    0A.3
....................       write_ext_eeprom(address+4, user.pass[2]); 
11F1:  MOVLW  04
11F2:  BSF    03.5
11F3:  ADDWF  36,W
11F4:  MOVWF  3E
11F5:  MOVWF  4A
11F6:  MOVF   3B,W
11F7:  MOVWF  4B
11F8:  BCF    0A.4
11F9:  BSF    0A.3
11FA:  BCF    03.5
11FB:  CALL   3F9
11FC:  BSF    0A.4
11FD:  BCF    0A.3
....................       write_ext_eeprom(address+5, user.pass[3]);        
11FE:  MOVLW  05
11FF:  BSF    03.5
1200:  ADDWF  36,W
1201:  MOVWF  3E
1202:  MOVWF  4A
1203:  MOVF   3C,W
1204:  MOVWF  4B
1205:  BCF    0A.4
1206:  BSF    0A.3
1207:  BCF    03.5
1208:  CALL   3F9
1209:  BSF    0A.4
120A:  BCF    0A.3
....................       write_ext_eeprom(address+6, user.status); 
120B:  MOVLW  06
120C:  BSF    03.5
120D:  ADDWF  36,W
120E:  MOVWF  3E
120F:  MOVWF  4A
1210:  MOVF   3D,W
1211:  MOVWF  4B
1212:  BCF    0A.4
1213:  BSF    0A.3
1214:  BCF    03.5
1215:  CALL   3F9
1216:  BSF    0A.4
1217:  BCF    0A.3
....................  
....................       printf (lcd_escreve,"\fUsuario Cadastrado"); 
1218:  MOVLW  22
1219:  BSF    03.6
121A:  MOVWF  0D
121B:  MOVLW  00
121C:  MOVWF  0F
121D:  BCF    0A.4
121E:  BCF    03.6
121F:  CALL   2A6
1220:  BSF    0A.4
....................       delay_ms(500); 
1221:  MOVLW  02
1222:  BSF    03.5
1223:  MOVWF  3E
1224:  MOVLW  FA
1225:  MOVWF  4F
1226:  BCF    0A.4
1227:  BCF    03.5
1228:  CALL   1AC
1229:  BSF    0A.4
122A:  BSF    03.5
122B:  DECFSZ 3E,F
122C:  GOTO   224
....................  
....................    }else{ 
122D:  GOTO   24D
....................       printf (lcd_escreve,"\fID incompativel"); 
122E:  MOVLW  2C
122F:  BCF    03.5
1230:  BSF    03.6
1231:  MOVWF  0D
1232:  MOVLW  00
1233:  MOVWF  0F
1234:  BCF    0A.4
1235:  BCF    03.6
1236:  CALL   2A6
1237:  BSF    0A.4
....................       printf (lcd_escreve,"\r\nTente novamente"); 
1238:  MOVLW  35
1239:  BSF    03.6
123A:  MOVWF  0D
123B:  MOVLW  00
123C:  MOVWF  0F
123D:  BCF    0A.4
123E:  BCF    03.6
123F:  CALL   2A6
1240:  BSF    0A.4
....................       delay_ms(1000); 
1241:  MOVLW  04
1242:  BSF    03.5
1243:  MOVWF  3E
1244:  MOVLW  FA
1245:  MOVWF  4F
1246:  BCF    0A.4
1247:  BCF    03.5
1248:  CALL   1AC
1249:  BSF    0A.4
124A:  BSF    03.5
124B:  DECFSZ 3E,F
124C:  GOTO   244
....................  
....................    } 
.................... } 
....................  
.................... void updateUser(int * id, int * pass, int status, int address){ 
....................    if( id[0] <= 99 && id[1] <= 99){ 
*
155D:  MOVF   3C,W
155E:  MOVWF  04
155F:  BCF    03.7
1560:  BTFSC  3D.0
1561:  BSF    03.7
1562:  MOVF   00,W
1563:  SUBLW  63
1564:  BTFSS  03.0
1565:  GOTO   60E
1566:  MOVLW  01
1567:  ADDWF  3C,W
1568:  MOVWF  04
1569:  BCF    03.7
156A:  BTFSC  3D.0
156B:  BSF    03.7
156C:  MOVF   00,W
156D:  SUBLW  63
156E:  BTFSS  03.0
156F:  GOTO   60E
....................       //recebe os parÃ¢metros do usuÃ¡rio 
....................       User user; 
....................       user.id[0] = id[0]; 
1570:  MOVF   3C,W
1571:  MOVWF  04
1572:  BCF    03.7
1573:  BTFSC  3D.0
1574:  BSF    03.7
1575:  MOVF   00,W
1576:  MOVWF  42
....................       user.id[1] = id[1]; 
1577:  MOVLW  01
1578:  ADDWF  3C,W
1579:  MOVWF  04
157A:  BCF    03.7
157B:  BTFSC  3D.0
157C:  BSF    03.7
157D:  MOVF   00,W
157E:  MOVWF  43
....................       user.pass[0] = pass[0]; 
157F:  MOVF   3E,W
1580:  MOVWF  04
1581:  BCF    03.7
1582:  BTFSC  3F.0
1583:  BSF    03.7
1584:  MOVF   00,W
1585:  MOVWF  44
....................       user.pass[1] = pass[1]; 
1586:  MOVLW  01
1587:  ADDWF  3E,W
1588:  MOVWF  04
1589:  BCF    03.7
158A:  BTFSC  3F.0
158B:  BSF    03.7
158C:  MOVF   00,W
158D:  MOVWF  45
....................       user.pass[2] = pass[2]; 
158E:  MOVLW  02
158F:  ADDWF  3E,W
1590:  MOVWF  04
1591:  BCF    03.7
1592:  BTFSC  3F.0
1593:  BSF    03.7
1594:  MOVF   00,W
1595:  MOVWF  46
....................       user.pass[3] = pass[3]; 
1596:  MOVLW  03
1597:  ADDWF  3E,W
1598:  MOVWF  04
1599:  BCF    03.7
159A:  BTFSC  3F.0
159B:  BSF    03.7
159C:  MOVF   00,W
159D:  MOVWF  47
....................       user.status = status; 
159E:  MOVF   40,W
159F:  MOVWF  48
....................        
....................       write_ext_eeprom(address, user.id[0]); 
15A0:  MOVF   41,W
15A1:  MOVWF  4A
15A2:  MOVF   42,W
15A3:  MOVWF  4B
15A4:  BCF    0A.4
15A5:  BSF    0A.3
15A6:  BCF    03.5
15A7:  CALL   3F9
15A8:  BSF    0A.4
15A9:  BCF    0A.3
....................       write_ext_eeprom(address+1, user.id[1]); 
15AA:  MOVLW  01
15AB:  BSF    03.5
15AC:  ADDWF  41,W
15AD:  MOVWF  49
15AE:  MOVWF  4A
15AF:  MOVF   43,W
15B0:  MOVWF  4B
15B1:  BCF    0A.4
15B2:  BSF    0A.3
15B3:  BCF    03.5
15B4:  CALL   3F9
15B5:  BSF    0A.4
15B6:  BCF    0A.3
....................       write_ext_eeprom(address+2, user.pass[0]); 
15B7:  MOVLW  02
15B8:  BSF    03.5
15B9:  ADDWF  41,W
15BA:  MOVWF  49
15BB:  MOVWF  4A
15BC:  MOVF   44,W
15BD:  MOVWF  4B
15BE:  BCF    0A.4
15BF:  BSF    0A.3
15C0:  BCF    03.5
15C1:  CALL   3F9
15C2:  BSF    0A.4
15C3:  BCF    0A.3
....................       write_ext_eeprom(address+3, user.pass[1]); 
15C4:  MOVLW  03
15C5:  BSF    03.5
15C6:  ADDWF  41,W
15C7:  MOVWF  49
15C8:  MOVWF  4A
15C9:  MOVF   45,W
15CA:  MOVWF  4B
15CB:  BCF    0A.4
15CC:  BSF    0A.3
15CD:  BCF    03.5
15CE:  CALL   3F9
15CF:  BSF    0A.4
15D0:  BCF    0A.3
....................       write_ext_eeprom(address+4, user.pass[2]); 
15D1:  MOVLW  04
15D2:  BSF    03.5
15D3:  ADDWF  41,W
15D4:  MOVWF  49
15D5:  MOVWF  4A
15D6:  MOVF   46,W
15D7:  MOVWF  4B
15D8:  BCF    0A.4
15D9:  BSF    0A.3
15DA:  BCF    03.5
15DB:  CALL   3F9
15DC:  BSF    0A.4
15DD:  BCF    0A.3
....................       write_ext_eeprom(address+5, user.pass[3]);        
15DE:  MOVLW  05
15DF:  BSF    03.5
15E0:  ADDWF  41,W
15E1:  MOVWF  49
15E2:  MOVWF  4A
15E3:  MOVF   47,W
15E4:  MOVWF  4B
15E5:  BCF    0A.4
15E6:  BSF    0A.3
15E7:  BCF    03.5
15E8:  CALL   3F9
15E9:  BSF    0A.4
15EA:  BCF    0A.3
....................       write_ext_eeprom(address+6, user.status); 
15EB:  MOVLW  06
15EC:  BSF    03.5
15ED:  ADDWF  41,W
15EE:  MOVWF  49
15EF:  MOVWF  4A
15F0:  MOVF   48,W
15F1:  MOVWF  4B
15F2:  BCF    0A.4
15F3:  BSF    0A.3
15F4:  BCF    03.5
15F5:  CALL   3F9
15F6:  BSF    0A.4
15F7:  BCF    0A.3
....................  
....................       printf (lcd_escreve,"\fUsuario Atualizado"); 
15F8:  MOVLW  3E
15F9:  BSF    03.6
15FA:  MOVWF  0D
15FB:  MOVLW  00
15FC:  MOVWF  0F
15FD:  BCF    0A.4
15FE:  BCF    03.6
15FF:  CALL   2A6
1600:  BSF    0A.4
....................       delay_ms(500); 
1601:  MOVLW  02
1602:  BSF    03.5
1603:  MOVWF  49
1604:  MOVLW  FA
1605:  MOVWF  4F
1606:  BCF    0A.4
1607:  BCF    03.5
1608:  CALL   1AC
1609:  BSF    0A.4
160A:  BSF    03.5
160B:  DECFSZ 49,F
160C:  GOTO   604
....................  
....................    }else{ 
160D:  GOTO   62D
....................       printf (lcd_escreve,"\fID incompativel"); 
160E:  MOVLW  48
160F:  BCF    03.5
1610:  BSF    03.6
1611:  MOVWF  0D
1612:  MOVLW  00
1613:  MOVWF  0F
1614:  BCF    0A.4
1615:  BCF    03.6
1616:  CALL   2A6
1617:  BSF    0A.4
....................       printf (lcd_escreve,"\r\nTente novamente"); 
1618:  MOVLW  51
1619:  BSF    03.6
161A:  MOVWF  0D
161B:  MOVLW  00
161C:  MOVWF  0F
161D:  BCF    0A.4
161E:  BCF    03.6
161F:  CALL   2A6
1620:  BSF    0A.4
....................       delay_ms(1000); 
1621:  MOVLW  04
1622:  BSF    03.5
1623:  MOVWF  49
1624:  MOVLW  FA
1625:  MOVWF  4F
1626:  BCF    0A.4
1627:  BCF    03.5
1628:  CALL   1AC
1629:  BSF    0A.4
162A:  BSF    03.5
162B:  DECFSZ 49,F
162C:  GOTO   624
....................    } 
....................  
.................... } 
....................  
.................... void printUser(){ 
....................    //delay_ms(50); 
....................    int tmp_result = read_ext_eeprom(0);   
....................  
....................    delay_ms(50);   
....................     
....................    printf (lcd_escreve,"\f Button: %d", tmp_result); 
....................    printf(lcd_escreve, "\r\nPw:%d%d%d%d St:%d %d", read_ext_eeprom(1), read_ext_eeprom(2), read_ext_eeprom(3), read_ext_eeprom(4), read_ext_eeprom(5), read_ext_eeprom(6)); 
....................     
....................    //printf(lcd_escreve, "\f Client () elseÂ´{}{} 
....................    // printf(lcd_escreve, "\r\nPw:%c%c%c%c St:%c %c", U1.pass[0], U1.pass[1], U1.pass[2], U1.pass[3], U1.status, U1.type_usr); 
.................... } 
....................  
.................... int getAddressByID(int * id){ 
*
0978:  BSF    03.5
0979:  CLRF   42
....................    int id_temp[2]; 
....................    int address = 0; 
....................     
....................    while( read_ext_eeprom(address) != -1){ 
097A:  MOVF   42,W
097B:  MOVWF  44
097C:  BCF    03.5
097D:  CALL   0A8
097E:  MOVF   78,W
097F:  SUBLW  FF
0980:  BTFSC  03.2
0981:  GOTO   1AD
....................       id_temp[0] = read_ext_eeprom(address); 
0982:  BSF    03.5
0983:  MOVF   42,W
0984:  MOVWF  44
0985:  BCF    03.5
0986:  CALL   0A8
0987:  MOVF   78,W
0988:  BSF    03.5
0989:  MOVWF  40
....................       id_temp[1] = read_ext_eeprom(address+1); 
098A:  MOVLW  01
098B:  ADDWF  42,W
098C:  MOVWF  43
098D:  MOVWF  44
098E:  BCF    03.5
098F:  CALL   0A8
0990:  MOVF   78,W
0991:  BSF    03.5
0992:  MOVWF  41
....................        
....................       if (id_temp[0] == id[0] && id_temp[1] == id[1]){ 
0993:  MOVF   3E,W
0994:  MOVWF  04
0995:  BCF    03.7
0996:  BTFSC  3F.0
0997:  BSF    03.7
0998:  MOVF   00,W
0999:  SUBWF  40,W
099A:  BTFSS  03.2
099B:  GOTO   1A9
099C:  MOVLW  01
099D:  ADDWF  3E,W
099E:  MOVWF  04
099F:  BCF    03.7
09A0:  BTFSC  3F.0
09A1:  BSF    03.7
09A2:  MOVF   00,W
09A3:  SUBWF  41,W
09A4:  BTFSS  03.2
09A5:  GOTO   1A9
....................          return address; 
09A6:  MOVF   42,W
09A7:  MOVWF  78
09A8:  GOTO   1B0
....................       } 
....................  
....................       address += BLOCK_SIZE;  
09A9:  MOVLW  07
09AA:  ADDWF  42,F
09AB:  GOTO   17A
09AC:  BCF    03.5
....................    } 
....................    return -1; 
09AD:  MOVLW  FF
09AE:  MOVWF  78
09AF:  BSF    03.5
09B0:  BCF    03.5
09B1:  RETURN
.................... } 
....................  
.................... void searchUser(int * id){ 
*
127E:  MOVF   54,W
127F:  BSF    03.5
1280:  MOVWF  3F
1281:  BCF    03.5
1282:  MOVF   53,W
1283:  BSF    03.5
1284:  MOVWF  3E
1285:  BCF    0A.4
1286:  BSF    0A.3
1287:  BCF    03.5
1288:  CALL   178
1289:  BSF    0A.4
128A:  BCF    0A.3
128B:  MOVF   78,W
128C:  MOVWF  55
....................  
....................    int address = getAddressByID(id); 
....................    if(address != -1){ 
128D:  MOVF   55,W
128E:  SUBLW  FF
128F:  BTFSC  03.2
1290:  GOTO   2D0
....................       printf (lcd_escreve,"\fID:%u%u",id[0],id[1]); 
1291:  MOVF   53,W
1292:  MOVWF  04
1293:  BCF    03.7
1294:  BTFSC  54.0
1295:  BSF    03.7
1296:  MOVF   00,W
1297:  MOVWF  57
1298:  MOVLW  01
1299:  ADDWF  53,W
129A:  MOVWF  04
129B:  BCF    03.7
129C:  BTFSC  54.0
129D:  BSF    03.7
129E:  MOVF   00,W
129F:  MOVWF  58
12A0:  MOVLW  6D
12A1:  BSF    03.6
12A2:  MOVWF  0D
12A3:  MOVLW  00
12A4:  MOVWF  0F
12A5:  BCF    03.0
12A6:  MOVLW  04
12A7:  BSF    03.5
12A8:  BCF    03.6
12A9:  MOVWF  49
12AA:  BCF    0A.4
12AB:  BCF    03.5
12AC:  CALL   47F
12AD:  BSF    0A.4
12AE:  MOVF   57,W
12AF:  BSF    03.5
12B0:  MOVWF  37
12B1:  MOVLW  1B
12B2:  MOVWF  38
12B3:  BCF    0A.4
12B4:  BSF    0A.3
12B5:  BCF    03.5
12B6:  CALL   3B4
12B7:  BSF    0A.4
12B8:  BCF    0A.3
12B9:  MOVF   58,W
12BA:  BSF    03.5
12BB:  MOVWF  37
12BC:  MOVLW  1B
12BD:  MOVWF  38
12BE:  BCF    0A.4
12BF:  BSF    0A.3
12C0:  BCF    03.5
12C1:  CALL   3B4
12C2:  BSF    0A.4
12C3:  BCF    0A.3
....................       int showStatus = 1; 
12C4:  MOVLW  01
12C5:  MOVWF  56
....................       getUserStatus(address,showStatus); 
12C6:  MOVF   55,W
12C7:  MOVWF  6B
12C8:  MOVF   56,W
12C9:  MOVWF  6C
12CA:  BCF    0A.4
12CB:  BSF    0A.3
12CC:  CALL   25D
12CD:  BSF    0A.4
12CE:  BCF    0A.3
....................    }else{ 
12CF:  GOTO   2E4
....................       printf(lcd_escreve,"\fUsuario N Existe"); 
12D0:  MOVLW  72
12D1:  BSF    03.6
12D2:  MOVWF  0D
12D3:  MOVLW  00
12D4:  MOVWF  0F
12D5:  BCF    0A.4
12D6:  BCF    03.6
12D7:  CALL   2A6
12D8:  BSF    0A.4
....................       delay_ms(1000); 
12D9:  MOVLW  04
12DA:  MOVWF  57
12DB:  MOVLW  FA
12DC:  BSF    03.5
12DD:  MOVWF  4F
12DE:  BCF    0A.4
12DF:  BCF    03.5
12E0:  CALL   1AC
12E1:  BSF    0A.4
12E2:  DECFSZ 57,F
12E3:  GOTO   2DB
....................    } 
.................... } 
....................  
.................... void erase_program_eeprom(int addrr){ 
....................    for(int i=0; i < BLOCK_SIZE; i++){ 
*
0C49:  CLRF   5B
0C4A:  MOVF   5B,W
0C4B:  SUBLW  06
0C4C:  BTFSS  03.0
0C4D:  GOTO   459
....................          write_ext_eeprom(addrr + i, -1); 
0C4E:  MOVF   5B,W
0C4F:  ADDWF  5A,W
0C50:  MOVWF  5C
0C51:  BSF    03.5
0C52:  MOVWF  4A
0C53:  MOVLW  FF
0C54:  MOVWF  4B
0C55:  BCF    03.5
0C56:  CALL   3F9
0C57:  INCF   5B,F
0C58:  GOTO   44A
....................    }   
....................    printf (lcd_escreve,"\f User erased "); 
0C59:  MOVLW  7B
0C5A:  BSF    03.6
0C5B:  MOVWF  0D
0C5C:  MOVLW  00
0C5D:  MOVWF  0F
0C5E:  BCF    0A.3
0C5F:  BCF    03.6
0C60:  CALL   2A6
0C61:  BSF    0A.3
....................    delay_ms(200); 
0C62:  MOVLW  C8
0C63:  BSF    03.5
0C64:  MOVWF  4F
0C65:  BCF    0A.3
0C66:  BCF    03.5
0C67:  CALL   1AC
0C68:  BSF    0A.3
0C69:  RETURN
.................... } 
....................  
.................... int getUserStatus(int address, int show){ 
*
0A5D:  MOVLW  07
0A5E:  ADDWF  6B,W
0A5F:  ADDLW  FF
0A60:  MOVWF  6E
0A61:  BSF    03.5
0A62:  MOVWF  44
0A63:  BCF    03.5
0A64:  CALL   0A8
0A65:  MOVF   78,W
0A66:  MOVWF  6D
....................    int status = read_ext_eeprom(address+BLOCK_SIZE - 1); 
....................  
....................    if(show == 1){ 
0A67:  DECFSZ 6C,W
0A68:  GOTO   2AE
....................       char msg_status[10]; 
....................       if( status == 0){ 
0A69:  MOVF   6D,F
0A6A:  BTFSS  03.2
0A6B:  GOTO   27F
....................          strcpy(msg_status,"NAO PAGO"); 
0A6C:  CLRF   6E
0A6D:  CLRF   6F
0A6E:  MOVLW  A0
0A6F:  MOVWF  04
0A70:  BCF    03.7
0A71:  MOVF   6E,W
0A72:  ADDWF  04,F
0A73:  MOVF   6F,W
0A74:  BCF    0A.3
0A75:  CALL   00C
0A76:  BSF    0A.3
0A77:  MOVWF  00
0A78:  IORLW  00
0A79:  BTFSC  03.2
0A7A:  GOTO   27E
0A7B:  INCF   6F,F
0A7C:  INCF   6E,F
0A7D:  GOTO   26E
....................       }else{ 
0A7E:  GOTO   291
....................          strcpy(msg_status,"PAGO"); 
0A7F:  CLRF   6E
0A80:  CLRF   6F
0A81:  MOVLW  A0
0A82:  MOVWF  04
0A83:  BCF    03.7
0A84:  MOVF   6E,W
0A85:  ADDWF  04,F
0A86:  MOVF   6F,W
0A87:  BCF    0A.3
0A88:  CALL   019
0A89:  BSF    0A.3
0A8A:  MOVWF  00
0A8B:  IORLW  00
0A8C:  BTFSC  03.2
0A8D:  GOTO   291
0A8E:  INCF   6F,F
0A8F:  INCF   6E,F
0A90:  GOTO   281
....................       } 
....................       printf (lcd_escreve,"\r\nStatus:%s",msg_status); 
0A91:  MOVLW  83
0A92:  BSF    03.6
0A93:  MOVWF  0D
0A94:  MOVLW  00
0A95:  MOVWF  0F
0A96:  BCF    03.0
0A97:  MOVLW  09
0A98:  BSF    03.5
0A99:  BCF    03.6
0A9A:  MOVWF  49
0A9B:  BCF    0A.3
0A9C:  BCF    03.5
0A9D:  CALL   47F
0A9E:  BSF    0A.3
0A9F:  MOVLW  A0
0AA0:  MOVWF  04
0AA1:  BCF    03.7
0AA2:  CALL   1B2
....................       delay_ms(1500); 
0AA3:  MOVLW  06
0AA4:  MOVWF  6E
0AA5:  MOVLW  FA
0AA6:  BSF    03.5
0AA7:  MOVWF  4F
0AA8:  BCF    0A.3
0AA9:  BCF    03.5
0AAA:  CALL   1AC
0AAB:  BSF    0A.3
0AAC:  DECFSZ 6E,F
0AAD:  GOTO   2A5
....................    } 
....................    return status; 
0AAE:  MOVF   6D,W
0AAF:  MOVWF  78
0AB0:  RETURN
.................... } 
....................  
.................... int deleteUser(int * id){ 
*
12FF:  MOVF   54,W
1300:  BSF    03.5
1301:  MOVWF  3F
1302:  BCF    03.5
1303:  MOVF   53,W
1304:  BSF    03.5
1305:  MOVWF  3E
1306:  BCF    0A.4
1307:  BSF    0A.3
1308:  BCF    03.5
1309:  CALL   178
130A:  BSF    0A.4
130B:  BCF    0A.3
130C:  MOVF   78,W
130D:  MOVWF  55
....................     
....................    int address = getAddressByID(id); 
....................    if(address == -1) 
130E:  MOVF   55,W
130F:  SUBLW  FF
1310:  BTFSS  03.2
1311:  GOTO   315
....................       return -1; 
1312:  MOVLW  FF
1313:  MOVWF  78
1314:  GOTO   371
....................    int data_temp; 
....................    int previous_block = address; 
....................    int next_block = address + BLOCK_SIZE; 
1315:  MOVF   55,W
1316:  MOVWF  57
1317:  MOVLW  07
1318:  ADDWF  55,W
1319:  MOVWF  58
....................  
....................    //Case 1: without the next block 
....................    if (read_ext_eeprom(next_block) == -1){ 
131A:  MOVF   58,W
131B:  BSF    03.5
131C:  MOVWF  44
131D:  BCF    0A.4
131E:  BSF    0A.3
131F:  BCF    03.5
1320:  CALL   0A8
1321:  BSF    0A.4
1322:  BCF    0A.3
1323:  MOVF   78,W
1324:  SUBLW  FF
1325:  BTFSS  03.2
1326:  GOTO   331
....................       erase_program_eeprom(previous_block);       
1327:  MOVF   57,W
1328:  MOVWF  5A
1329:  BCF    0A.4
132A:  BSF    0A.3
132B:  CALL   449
132C:  BSF    0A.4
132D:  BCF    0A.3
....................       return 1; 
132E:  MOVLW  01
132F:  MOVWF  78
1330:  GOTO   371
....................    } 
....................  
....................    //Case 2: Check whether the data in the next block address is empty 
....................    while(read_ext_eeprom(next_block) != -1){ 
1331:  MOVF   58,W
1332:  BSF    03.5
1333:  MOVWF  44
1334:  BCF    0A.4
1335:  BSF    0A.3
1336:  BCF    03.5
1337:  CALL   0A8
1338:  BSF    0A.4
1339:  BCF    0A.3
133A:  MOVF   78,W
133B:  SUBLW  FF
133C:  BTFSC  03.2
133D:  GOTO   366
....................       //data_temp[index] = read_ext_eeprom(address); 
....................       for(int i=0; i < BLOCK_SIZE; i++){ 
133E:  CLRF   59
133F:  MOVF   59,W
1340:  SUBLW  06
1341:  BTFSS  03.0
1342:  GOTO   361
....................          //Read the data from the next block  
....................          data_temp = read_ext_eeprom(next_block + i);            
1343:  MOVF   59,W
1344:  ADDWF  58,W
1345:  MOVWF  5A
1346:  BSF    03.5
1347:  MOVWF  44
1348:  BCF    0A.4
1349:  BSF    0A.3
134A:  BCF    03.5
134B:  CALL   0A8
134C:  BSF    0A.4
134D:  BCF    0A.3
134E:  MOVF   78,W
134F:  MOVWF  56
....................          //overwrite the previous block with the data from the next 
....................          write_ext_eeprom(previous_block + i, data_temp);   
1350:  MOVF   59,W
1351:  ADDWF  57,W
1352:  MOVWF  5A
1353:  BSF    03.5
1354:  MOVWF  4A
1355:  BCF    03.5
1356:  MOVF   56,W
1357:  BSF    03.5
1358:  MOVWF  4B
1359:  BCF    0A.4
135A:  BSF    0A.3
135B:  BCF    03.5
135C:  CALL   3F9
135D:  BSF    0A.4
135E:  BCF    0A.3
135F:  INCF   59,F
1360:  GOTO   33F
....................       }   
....................       previous_block = next_block; 
1361:  MOVF   58,W
1362:  MOVWF  57
....................       next_block += BLOCK_SIZE; 
1363:  MOVLW  07
1364:  ADDWF  58,F
1365:  GOTO   331
....................    } 
....................    //Go back to erase the block that's duplicated  
....................    next_block -= BLOCK_SIZE; 
1366:  MOVLW  07
1367:  SUBWF  58,F
....................    //Erase the last block since everything  
....................    //moved a block_size to the left 
....................    erase_program_eeprom(next_block); 
1368:  MOVF   58,W
1369:  MOVWF  5A
136A:  BCF    0A.4
136B:  BSF    0A.3
136C:  CALL   449
136D:  BSF    0A.4
136E:  BCF    0A.3
....................     
....................    return 1; 
136F:  MOVLW  01
1370:  MOVWF  78
....................  
.................... } 
....................  
.................... int lastNewUserPosition(){ 
*
1178:  BSF    03.5
1179:  CLRF   3E
....................    int address = 0; 
....................     
....................  
....................    while( read_ext_eeprom(address) != -1){ 
117A:  MOVF   3E,W
117B:  MOVWF  44
117C:  BCF    0A.4
117D:  BSF    0A.3
117E:  BCF    03.5
117F:  CALL   0A8
1180:  BSF    0A.4
1181:  BCF    0A.3
1182:  MOVF   78,W
1183:  SUBLW  FF
1184:  BTFSC  03.2
1185:  GOTO   18B
....................       address += BLOCK_SIZE;  
1186:  MOVLW  07
1187:  BSF    03.5
1188:  ADDWF  3E,F
1189:  GOTO   17A
118A:  BCF    03.5
....................    } 
....................    // printf (lcd_escreve,"\fAddress: %u", address); 
....................    // delay_ms(500); 
....................     
....................    return address; 
118B:  BSF    03.5
118C:  MOVF   3E,W
118D:  MOVWF  78
....................  
.................... } 
....................  
.................... void resetMemory(){ 
....................    int address = 0; 
....................    for(; read_ext_eeprom(address) != -1; 
....................     erase_program_eeprom(address), address += BLOCK_SIZE); 
.................... } 
....................  
.................... void adminMenu(){ 
....................    unsigned char option; 
....................    unsigned int * temp; 
....................    unsigned int id [2]; 
....................    do{ 
....................       printf(lcd_escreve,"\f1:CAD|2:BUSCAR"); 
*
1000:  MOVLW  89
1001:  BSF    03.6
1002:  MOVWF  0D
1003:  MOVLW  00
1004:  MOVWF  0F
1005:  BCF    0A.4
1006:  BCF    03.6
1007:  CALL   2A6
1008:  BSF    0A.4
....................       printf(lcd_escreve,"\r\n3:DEL|4:EDITAR"); 
1009:  MOVLW  91
100A:  BSF    03.6
100B:  MOVWF  0D
100C:  MOVLW  00
100D:  MOVWF  0F
100E:  BCF    0A.4
100F:  BCF    03.6
1010:  CALL   2A6
1011:  BSF    0A.4
....................       delay_ms(1000); 
1012:  MOVLW  04
1013:  MOVWF  53
1014:  MOVLW  FA
1015:  BSF    03.5
1016:  MOVWF  4F
1017:  BCF    0A.4
1018:  BCF    03.5
1019:  CALL   1AC
101A:  BSF    0A.4
101B:  DECFSZ 53,F
101C:  GOTO   014
....................       printf(lcd_escreve,"\f5: SAIR do Menu "); 
101D:  MOVLW  9A
101E:  BSF    03.6
101F:  MOVWF  0D
1020:  MOVLW  00
1021:  MOVWF  0F
1022:  BCF    0A.4
1023:  BCF    03.6
1024:  CALL   2A6
1025:  BSF    0A.4
....................       delay_ms(100); 
1026:  MOVLW  64
1027:  BSF    03.5
1028:  MOVWF  4F
1029:  BCF    0A.4
102A:  BCF    03.5
102B:  CALL   1AC
102C:  BSF    0A.4
....................      
....................       option = readKeyboard(); 
102D:  BCF    0A.4
102E:  CALL   31A
102F:  BSF    0A.4
1030:  MOVF   78,W
1031:  MOVWF  4D
....................  
....................       if(option != 255){ 
1032:  INCFSZ 4D,W
1033:  GOTO   035
1034:  GOTO   665
....................          printf(lcd_escreve,"\f Option: %c", option); 
1035:  MOVLW  A3
1036:  BSF    03.6
1037:  MOVWF  0D
1038:  MOVLW  00
1039:  MOVWF  0F
103A:  BCF    03.0
103B:  MOVLW  0A
103C:  BSF    03.5
103D:  BCF    03.6
103E:  MOVWF  49
103F:  BCF    0A.4
1040:  BCF    03.5
1041:  CALL   47F
1042:  BSF    0A.4
1043:  MOVF   4D,W
1044:  BSF    03.5
1045:  MOVWF  4E
1046:  BCF    0A.4
1047:  BCF    03.5
1048:  CALL   263
1049:  BSF    0A.4
....................          delay_ms(500); 
104A:  MOVLW  02
104B:  MOVWF  53
104C:  MOVLW  FA
104D:  BSF    03.5
104E:  MOVWF  4F
104F:  BCF    0A.4
1050:  BCF    03.5
1051:  CALL   1AC
1052:  BSF    0A.4
1053:  DECFSZ 53,F
1054:  GOTO   04C
....................  
....................          switch(option){ 
1055:  MOVF   4D,W
1056:  XORLW  31
1057:  BTFSC  03.2
1058:  GOTO   063
1059:  XORLW  03
105A:  BTFSC  03.2
105B:  GOTO   265
105C:  XORLW  01
105D:  BTFSC  03.2
105E:  GOTO   2E6
105F:  XORLW  07
1060:  BTFSC  03.2
1061:  GOTO   429
1062:  GOTO   646
....................             case '1': 
....................                inputKeyboardUser(); 
....................                break; 
*
1264:  GOTO   664
....................             case '2': 
....................                temp = inputId(); 
1265:  BCF    0A.4
1266:  CALL   79C
1267:  BSF    0A.4
1268:  MOVF   79,W
1269:  MOVWF  4F
126A:  MOVF   78,W
126B:  MOVWF  4E
....................                id[0] = temp[0]; 
126C:  MOVF   4E,W
126D:  MOVWF  04
126E:  BCF    03.7
126F:  BTFSC  4F.0
1270:  BSF    03.7
1271:  MOVF   00,W
1272:  MOVWF  50
....................                id[1] = temp[1]; 
1273:  MOVLW  01
1274:  ADDWF  4E,W
1275:  MOVWF  04
1276:  BCF    03.7
1277:  BTFSC  4F.0
1278:  BSF    03.7
1279:  MOVF   00,W
127A:  MOVWF  51
....................                searchUser(id); 
127B:  CLRF   54
127C:  MOVLW  50
127D:  MOVWF  53
....................                break; 
*
12E4:  BSF    03.5
12E5:  GOTO   664
....................             case '3': 
....................                temp = inputId(); 
12E6:  BCF    0A.4
12E7:  CALL   79C
12E8:  BSF    0A.4
12E9:  MOVF   79,W
12EA:  MOVWF  4F
12EB:  MOVF   78,W
12EC:  MOVWF  4E
....................                id[0] = temp[0]; 
12ED:  MOVF   4E,W
12EE:  MOVWF  04
12EF:  BCF    03.7
12F0:  BTFSC  4F.0
12F1:  BSF    03.7
12F2:  MOVF   00,W
12F3:  MOVWF  50
....................                id[1] = temp[1]; 
12F4:  MOVLW  01
12F5:  ADDWF  4E,W
12F6:  MOVWF  04
12F7:  BCF    03.7
12F8:  BTFSC  4F.0
12F9:  BSF    03.7
12FA:  MOVF   00,W
12FB:  MOVWF  51
....................                signed int success = deleteUser(id); 
12FC:  CLRF   54
12FD:  MOVLW  50
12FE:  MOVWF  53
*
1371:  MOVF   78,W
1372:  MOVWF  52
....................                printf(lcd_escreve,"\fSuccess -> %d", success); 
1373:  MOVLW  AA
1374:  BSF    03.6
1375:  MOVWF  0D
1376:  MOVLW  00
1377:  MOVWF  0F
1378:  BCF    03.0
1379:  MOVLW  0C
137A:  BSF    03.5
137B:  BCF    03.6
137C:  MOVWF  49
137D:  BCF    0A.4
137E:  BCF    03.5
137F:  CALL   47F
1380:  BSF    0A.4
1381:  MOVF   52,W
1382:  MOVWF  53
1383:  MOVLW  18
1384:  MOVWF  54
....................                delay_ms(500); 
*
13F7:  MOVLW  02
13F8:  MOVWF  53
13F9:  MOVLW  FA
13FA:  BSF    03.5
13FB:  MOVWF  4F
13FC:  BCF    0A.4
13FD:  BCF    03.5
13FE:  CALL   1AC
13FF:  BSF    0A.4
1400:  DECFSZ 53,F
1401:  GOTO   3F9
....................                (success >= 1)?  
....................                printf(lcd_escreve,"\fusuario deletado"): 
....................                printf(lcd_escreve,"\fusuario N Existe"); 
1402:  BTFSC  52.7
1403:  GOTO   413
1404:  MOVF   52,W
1405:  SUBLW  00
1406:  BTFSC  03.0
1407:  GOTO   413
1408:  MOVLW  B2
1409:  BSF    03.6
140A:  MOVWF  0D
140B:  MOVLW  00
140C:  MOVWF  0F
140D:  BCF    0A.4
140E:  BCF    03.6
140F:  CALL   2A6
1410:  BSF    0A.4
1411:  CLRF   7A
1412:  GOTO   41C
1413:  MOVLW  BB
1414:  BSF    03.6
1415:  MOVWF  0D
1416:  MOVLW  00
1417:  MOVWF  0F
1418:  BCF    0A.4
1419:  BCF    03.6
141A:  CALL   2A6
141B:  BSF    0A.4
....................                delay_ms(500); 
141C:  MOVLW  02
141D:  MOVWF  53
141E:  MOVLW  FA
141F:  BSF    03.5
1420:  MOVWF  4F
1421:  BCF    0A.4
1422:  BCF    03.5
1423:  CALL   1AC
1424:  BSF    0A.4
1425:  DECFSZ 53,F
1426:  GOTO   41E
....................                break; 
1427:  BSF    03.5
1428:  GOTO   664
....................             case '4': 
....................                editUser(); 
....................                break; 
*
1644:  GOTO   664
1645:  BCF    03.5
....................             default: 
....................                printf(lcd_escreve,"\fDigite um valor"); 
1646:  MOVLW  C4
1647:  BSF    03.6
1648:  MOVWF  0D
1649:  MOVLW  00
164A:  MOVWF  0F
164B:  BCF    0A.4
164C:  BCF    03.6
164D:  CALL   2A6
164E:  BSF    0A.4
....................                printf(lcd_escreve,"\r\nValido!"); 
164F:  MOVLW  CD
1650:  BSF    03.6
1651:  MOVWF  0D
1652:  MOVLW  00
1653:  MOVWF  0F
1654:  BCF    0A.4
1655:  BCF    03.6
1656:  CALL   2A6
1657:  BSF    0A.4
....................                delay_ms(500); 
1658:  MOVLW  02
1659:  MOVWF  53
165A:  MOVLW  FA
165B:  BSF    03.5
165C:  MOVWF  4F
165D:  BCF    0A.4
165E:  BCF    03.5
165F:  CALL   1AC
1660:  BSF    0A.4
1661:  DECFSZ 53,F
1662:  GOTO   65A
....................                break; 
1663:  BSF    03.5
1664:  BCF    03.5
....................          } 
....................       } 
....................    }while(option != '5'); 
1665:  MOVF   4D,W
1666:  SUBLW  35
1667:  BTFSS  03.2
1668:  GOTO   000
1669:  BSF    0A.3
166A:  BCF    0A.4
166B:  GOTO   579 (RETURN)
.................... } 
....................  
....................  
.................... int login(int * id){ 
*
0AB1:  MOVF   4E,W
0AB2:  BSF    03.5
0AB3:  MOVWF  3F
0AB4:  BCF    03.5
0AB5:  MOVF   4D,W
0AB6:  BSF    03.5
0AB7:  MOVWF  3E
0AB8:  BCF    03.5
0AB9:  CALL   178
0ABA:  MOVF   78,W
0ABB:  MOVWF  4F
....................  
....................    int address = getAddressByID(id); 
....................    if(address == -1){ 
0ABC:  MOVF   4F,W
0ABD:  SUBLW  FF
0ABE:  BTFSS  03.2
0ABF:  GOTO   2E0
....................       printf(lcd_escreve,"\fID N Existe"); 
0AC0:  MOVLW  D2
0AC1:  BSF    03.6
0AC2:  MOVWF  0D
0AC3:  MOVLW  00
0AC4:  MOVWF  0F
0AC5:  BCF    0A.3
0AC6:  BCF    03.6
0AC7:  CALL   2A6
0AC8:  BSF    0A.3
....................       printf(lcd_escreve,"\r\nTente de novo"); 
0AC9:  MOVLW  D9
0ACA:  BSF    03.6
0ACB:  MOVWF  0D
0ACC:  MOVLW  00
0ACD:  MOVWF  0F
0ACE:  BCF    0A.3
0ACF:  BCF    03.6
0AD0:  CALL   2A6
0AD1:  BSF    0A.3
....................       delay_ms(1000); 
0AD2:  MOVLW  04
0AD3:  MOVWF  6B
0AD4:  MOVLW  FA
0AD5:  BSF    03.5
0AD6:  MOVWF  4F
0AD7:  BCF    0A.3
0AD8:  BCF    03.5
0AD9:  CALL   1AC
0ADA:  BSF    0A.3
0ADB:  DECFSZ 6B,F
0ADC:  GOTO   2D4
....................       return -1; 
0ADD:  MOVLW  FF
0ADE:  MOVWF  78
0ADF:  GOTO   39C
....................    } 
....................    unsigned int * temp; 
....................    unsigned int pass[4]; 
....................  
....................    char msg [] = "Digite a senha: "; 
0AE0:  MOVLW  44
0AE1:  MOVWF  56
0AE2:  MOVLW  69
0AE3:  MOVWF  57
0AE4:  MOVLW  67
0AE5:  MOVWF  58
0AE6:  MOVLW  69
0AE7:  MOVWF  59
0AE8:  MOVLW  74
0AE9:  MOVWF  5A
0AEA:  MOVLW  65
0AEB:  MOVWF  5B
0AEC:  MOVLW  20
0AED:  MOVWF  5C
0AEE:  MOVLW  61
0AEF:  MOVWF  5D
0AF0:  MOVLW  20
0AF1:  MOVWF  5E
0AF2:  MOVLW  73
0AF3:  MOVWF  5F
0AF4:  MOVLW  65
0AF5:  MOVWF  60
0AF6:  MOVLW  6E
0AF7:  MOVWF  61
0AF8:  MOVLW  68
0AF9:  MOVWF  62
0AFA:  MOVLW  61
0AFB:  MOVWF  63
0AFC:  MOVLW  3A
0AFD:  MOVWF  64
0AFE:  MOVLW  20
0AFF:  MOVWF  65
0B00:  CLRF   66
....................    int max = 4; 
0B01:  MOVLW  04
0B02:  MOVWF  67
....................    temp = inputToKeyboard(msg, max); 
0B03:  BSF    03.5
0B04:  CLRF   38
0B05:  MOVLW  56
0B06:  MOVWF  37
0B07:  BCF    03.5
0B08:  MOVF   67,W
0B09:  BSF    03.5
0B0A:  MOVWF  39
0B0B:  BCF    03.5
0B0C:  CALL   1D1
0B0D:  MOVF   79,W
0B0E:  MOVWF  51
0B0F:  MOVF   78,W
0B10:  MOVWF  50
....................    pass[0] = temp[0]; 
0B11:  MOVF   50,W
0B12:  MOVWF  04
0B13:  BCF    03.7
0B14:  BTFSC  51.0
0B15:  BSF    03.7
0B16:  MOVF   00,W
0B17:  MOVWF  52
....................    pass[1] = temp[1]; 
0B18:  MOVLW  01
0B19:  ADDWF  50,W
0B1A:  MOVWF  04
0B1B:  BCF    03.7
0B1C:  BTFSC  51.0
0B1D:  BSF    03.7
0B1E:  MOVF   00,W
0B1F:  MOVWF  53
....................    pass[2] = temp[2]; 
0B20:  MOVLW  02
0B21:  ADDWF  50,W
0B22:  MOVWF  04
0B23:  BCF    03.7
0B24:  BTFSC  51.0
0B25:  BSF    03.7
0B26:  MOVF   00,W
0B27:  MOVWF  54
....................    pass[3] = temp[3]; 
0B28:  MOVLW  03
0B29:  ADDWF  50,W
0B2A:  MOVWF  04
0B2B:  BCF    03.7
0B2C:  BTFSC  51.0
0B2D:  BSF    03.7
0B2E:  MOVF   00,W
0B2F:  MOVWF  55
....................    // printf(lcd_escreve,"\fPASS(4): %u%u%u%u",pass[0],pass[1],pass[2],pass[3]); 
....................    // delay_ms(1000); 
....................    int result_pass = checkPassword(address,pass); 
0B30:  MOVF   4F,W
0B31:  MOVWF  6B
0B32:  CLRF   6D
0B33:  MOVLW  52
0B34:  MOVWF  6C
*
0B59:  MOVF   78,W
0B5A:  MOVWF  68
....................    if(result_pass != 0){ 
0B5B:  MOVF   68,F
0B5C:  BTFSC  03.2
0B5D:  GOTO   392
....................       printf(lcd_escreve,"\fProcure a secretaria"); 
0B5E:  MOVLW  E1
0B5F:  BSF    03.6
0B60:  MOVWF  0D
0B61:  MOVLW  00
0B62:  MOVWF  0F
0B63:  BCF    0A.3
0B64:  BCF    03.6
0B65:  CALL   2A6
0B66:  BSF    0A.3
....................       printf(lcd_escreve,"\r\nP/ resolver"); 
0B67:  MOVLW  EC
0B68:  BSF    03.6
0B69:  MOVWF  0D
0B6A:  MOVLW  00
0B6B:  MOVWF  0F
0B6C:  BCF    0A.3
0B6D:  BCF    03.6
0B6E:  CALL   2A6
0B6F:  BSF    0A.3
....................       delay_ms(1000); 
0B70:  MOVLW  04
0B71:  MOVWF  6B
0B72:  MOVLW  FA
0B73:  BSF    03.5
0B74:  MOVWF  4F
0B75:  BCF    0A.3
0B76:  BCF    03.5
0B77:  CALL   1AC
0B78:  BSF    0A.3
0B79:  DECFSZ 6B,F
0B7A:  GOTO   372
....................       printf(lcd_escreve,"\fNADA eh Ligado!"); 
0B7B:  MOVLW  F3
0B7C:  BSF    03.6
0B7D:  MOVWF  0D
0B7E:  MOVLW  00
0B7F:  MOVWF  0F
0B80:  BCF    0A.3
0B81:  BCF    03.6
0B82:  CALL   2A6
0B83:  BSF    0A.3
....................       delay_ms(500); 
0B84:  MOVLW  02
0B85:  MOVWF  6B
0B86:  MOVLW  FA
0B87:  BSF    03.5
0B88:  MOVWF  4F
0B89:  BCF    0A.3
0B8A:  BCF    03.5
0B8B:  CALL   1AC
0B8C:  BSF    0A.3
0B8D:  DECFSZ 6B,F
0B8E:  GOTO   386
....................       return -1; 
0B8F:  MOVLW  FF
0B90:  MOVWF  78
0B91:  GOTO   39C
....................    } 
....................  
....................    int show = 0; 
....................    int status = getUserStatus(address,show); 
0B92:  CLRF   69
0B93:  MOVF   4F,W
0B94:  MOVWF  6B
0B95:  MOVF   69,W
0B96:  MOVWF  6C
0B97:  CALL   25D
0B98:  MOVF   78,W
0B99:  MOVWF  6A
....................    return status; 
0B9A:  MOVF   6A,W
0B9B:  MOVWF  78
0B9C:  RETURN
....................  
.................... } 
....................  
.................... int checkPassword(int initBlockAddr, int * pass){ 
*
0B35:  MOVLW  02
0B36:  ADDWF  6B,W
0B37:  MOVWF  6E
0B38:  MOVLW  04
0B39:  MOVWF  6F
....................    int pass_addr = initBlockAddr + 2; 
....................    int len = 4;  
....................    for(int i=0; i < len;i++,pass_addr++){ 
0B3A:  CLRF   70
0B3B:  MOVF   6F,W
0B3C:  SUBWF  70,W
0B3D:  BTFSC  03.0
0B3E:  GOTO   357
....................       if(pass[i] != read_ext_eeprom(pass_addr)) 
0B3F:  MOVF   70,W
0B40:  ADDWF  6C,W
0B41:  MOVWF  04
0B42:  BCF    03.7
0B43:  BTFSC  6D.0
0B44:  BSF    03.7
0B45:  MOVF   00,W
0B46:  MOVWF  71
0B47:  MOVF   6E,W
0B48:  BSF    03.5
0B49:  MOVWF  44
0B4A:  BCF    03.5
0B4B:  CALL   0A8
0B4C:  MOVF   78,W
0B4D:  SUBWF  71,W
0B4E:  BTFSC  03.2
0B4F:  GOTO   353
....................          return -1; 
0B50:  MOVLW  FF
0B51:  MOVWF  78
0B52:  GOTO   359
0B53:  MOVF   70,W
0B54:  INCF   70,F
0B55:  INCF   6E,F
0B56:  GOTO   33B
....................    } 
....................    return 0; 
0B57:  MOVLW  00
0B58:  MOVWF  78
....................  
.................... } 
.................... unsigned char readKeyboard(){ 
....................  
....................    unsigned char tmp; 
....................    unsigned char tmp_result; 
....................     
....................    tmp = tc_tecla(1300); // ms 
*
031A:  MOVLW  14
031B:  BSF    03.5
031C:  MOVWF  4B
*
046C:  MOVF   78,W
046D:  MOVWF  49
....................    if(tmp != 255){ 
046E:  INCFSZ 49,W
046F:  GOTO   471
0470:  GOTO   472
....................       // write_ext_eeprom(0, tmp); 
....................       // delay_ms(50); 
....................       // tmp_result = read_ext_eeprom(0); 
....................       // delay_ms(50); 
....................       // tmp_result = tmp; 
....................       // printf(lcd_escreve,"\f Button: %c", tmp); 
....................       // delay_ms(50); 
....................    }else{  
0471:  GOTO   47B
....................       printf(lcd_escreve,"\f Digite"); 
0472:  MOVLW  FC
0473:  BCF    03.5
0474:  BSF    03.6
0475:  MOVWF  0D
0476:  MOVLW  00
0477:  MOVWF  0F
0478:  BCF    03.6
0479:  CALL   2A6
047A:  BSF    03.5
....................    } 
....................  
....................    return tmp; 
047B:  MOVF   49,W
047C:  MOVWF  78
047D:  BCF    03.5
047E:  RETURN
.................... } 
....................  
....................  
.................... int * getAdminsID(){ 
....................  
....................    int address = 0; 
....................    int temp_status; 
....................    int index= 0; 
....................    static int admins[BLOCK_SIZE]; 
*
0C7E:  CLRF   39
0C7F:  CLRF   3A
0C80:  CLRF   3B
0C81:  CLRF   3C
0C82:  CLRF   3D
0C83:  CLRF   3E
0C84:  CLRF   3F
....................    admins[0] = -1; 
....................    while( read_ext_eeprom(address) != -1){ 
....................       temp_status = read_ext_eeprom(address + (BLOCK_SIZE - 1));//status of the user 
....................       if (temp_status == 3){ 
....................          printf (lcd_escreve,"\fAdmin Encontrado"); 
....................          delay_ms(1000); 
....................          for(int i=0; i < 2; i++){ 
....................             int id = read_ext_eeprom(address+i);    
....................             admins[index] = id; 
....................             index++; 
....................          } 
....................  
....................       } 
....................  
....................       address += BLOCK_SIZE;  
....................    } 
....................  
....................    return admins; 
....................  
.................... } 
....................  
.................... void listAdmins(){ 
....................    int * admins; 
....................  
....................    admins = getAdminsID(); 
....................    printf(lcd_escreve,"\f admins[0]: %d", admins[0]); 
....................    delay_ms(1000); 
....................    if(admins[0] != -1){ 
....................       for (int16 i=0; i < sizeof(admins); i+=2){ 
....................          printf(lcd_escreve, "\fid:%u%u",admins[i], admins[i+1]); 
....................          delay_ms(1000); 
....................       }  
....................    } 
.................... } 
....................  
....................  
.................... int * strToInt(char * str){ 
*
0760:  BSF    03.5
0761:  MOVF   4A,W
0762:  MOVWF  4C
0763:  MOVF   49,W
0764:  MOVWF  4B
0765:  CLRF   4F
....................  
....................   char *p = str; 
....................   //https://flaviocopes.com/c-array-length/ 
....................   static unsigned int buffer[BLOCK_SIZE];   
*
0C85:  CLRF   40
0C86:  CLRF   41
0C87:  CLRF   42
0C88:  CLRF   43
0C89:  CLRF   44
0C8A:  CLRF   45
0C8B:  CLRF   46
....................   char * end; 
....................   int index = 0; 
....................  
....................   for (unsigned int number = strtoul(p, &end, 10); 
*
0766:  MOVF   4C,W
0767:  MOVWF  52
0768:  MOVF   4B,W
0769:  MOVWF  51
076A:  CLRF   54
076B:  MOVLW  CD
076C:  MOVWF  53
076D:  MOVLW  0A
076E:  MOVWF  55
076F:  BCF    03.5
0770:  CALL   524
0771:  MOVF   78,W
0772:  BSF    03.5
0773:  MOVWF  50
....................         p != end; 
0774:  MOVF   4D,W
0775:  SUBWF  4B,W
0776:  BTFSS  03.2
0777:  GOTO   77C
0778:  MOVF   4E,W
0779:  SUBWF  4C,W
077A:  BTFSC  03.2
077B:  GOTO   796
....................         number = strtoul(p, &end, 10)) 
....................   { 
....................     p = end; 
077C:  MOVF   4E,W
077D:  MOVWF  4C
077E:  MOVF   4D,W
077F:  MOVWF  4B
....................  
....................     buffer[index] = number;  
0780:  MOVLW  40
0781:  ADDWF  4F,W
0782:  MOVWF  04
0783:  BCF    03.7
0784:  MOVF   50,W
0785:  MOVWF  00
....................     index++; 
0786:  INCF   4F,F
0787:  MOVF   4C,W
0788:  MOVWF  52
0789:  MOVF   4B,W
078A:  MOVWF  51
078B:  CLRF   54
078C:  MOVLW  CD
078D:  MOVWF  53
078E:  MOVLW  0A
078F:  MOVWF  55
0790:  BCF    03.5
0791:  CALL   524
0792:  MOVF   78,W
0793:  BSF    03.5
0794:  MOVWF  50
0795:  GOTO   774
....................   } 
....................  
....................    return buffer; 
0796:  MOVLW  40
0797:  MOVWF  78
0798:  MOVLW  00
0799:  MOVWF  79
079A:  BCF    03.5
079B:  RETURN
.................... } 
....................  
.................... char * strfromchar(char destination[], char source)  
.................... {  
....................    destination[0] = source;   // copy the character into the string  
*
0A1C:  MOVF   47,W
0A1D:  MOVWF  04
0A1E:  BCF    03.7
0A1F:  BTFSC  48.0
0A20:  BSF    03.7
0A21:  MOVF   49,W
0A22:  MOVWF  00
....................    destination[1] = '\0';      // null-terminate the string  
0A23:  MOVLW  01
0A24:  ADDWF  47,W
0A25:  MOVWF  04
0A26:  BCF    03.7
0A27:  BTFSC  48.0
0A28:  BSF    03.7
0A29:  CLRF   00
....................   
....................    return destination;         // common convention for str functions  
0A2A:  MOVF   47,W
0A2B:  MOVWF  78
0A2C:  MOVF   48,W
0A2D:  MOVWF  79
.................... }  
....................  
....................  
.................... int * inputId(){ 
*
079C:  BSF    03.5
079D:  CLRF   48
....................    unsigned char keyboard_buffer[BLOCK_SIZE * 2]; 
....................    unsigned char option; 
....................  
....................    int * temp; 
....................    int i = 0; 
....................    //The user needs to type 4 digits 
....................    //For example, even if it's just 9 
....................    //He/she will type: 0009 
....................    while(i < 5){ 
079E:  MOVF   48,W
079F:  SUBLW  04
07A0:  BTFSS  03.0
07A1:  GOTO   7E5
....................       printf(lcd_escreve,"\fDigite o ID: "); 
07A2:  MOVLW  17
07A3:  BCF    03.5
07A4:  BSF    03.6
07A5:  MOVWF  0D
07A6:  MOVLW  01
07A7:  MOVWF  0F
07A8:  BCF    03.6
07A9:  CALL   2A6
....................       delay_ms(50); 
07AA:  MOVLW  32
07AB:  BSF    03.5
07AC:  MOVWF  4F
07AD:  BCF    03.5
07AE:  CALL   1AC
....................       option = readKeyboard(); 
07AF:  CALL   31A
07B0:  MOVF   78,W
07B1:  BSF    03.5
07B2:  MOVWF  45
....................       if(option != 255){ 
07B3:  INCFSZ 45,W
07B4:  GOTO   7B6
07B5:  GOTO   7E4
....................          printf(lcd_escreve,"\n\rTyped:%c", option); 
07B6:  MOVLW  1F
07B7:  BCF    03.5
07B8:  BSF    03.6
07B9:  MOVWF  0D
07BA:  MOVLW  01
07BB:  MOVWF  0F
07BC:  BCF    03.0
07BD:  MOVLW  08
07BE:  BSF    03.5
07BF:  BCF    03.6
07C0:  MOVWF  49
07C1:  BCF    03.5
07C2:  CALL   47F
07C3:  BSF    03.5
07C4:  MOVF   45,W
07C5:  MOVWF  4E
07C6:  BCF    03.5
07C7:  CALL   263
....................          delay_ms(400); 
07C8:  MOVLW  02
07C9:  BSF    03.5
07CA:  MOVWF  49
07CB:  MOVLW  C8
07CC:  MOVWF  4F
07CD:  BCF    03.5
07CE:  CALL   1AC
07CF:  BSF    03.5
07D0:  DECFSZ 49,F
07D1:  GOTO   7CB
....................          if(i == 2){ 
07D2:  MOVF   48,W
07D3:  SUBLW  02
07D4:  BTFSS  03.2
07D5:  GOTO   7DD
....................             //To convert to int will be easier with space between them 
....................             keyboard_buffer[i] = ' '; 
07D6:  MOVLW  B7
07D7:  ADDWF  48,W
07D8:  MOVWF  04
07D9:  BCF    03.7
07DA:  MOVLW  20
07DB:  MOVWF  00
....................             i++; 
07DC:  INCF   48,F
....................          } 
....................          keyboard_buffer[i] = option; 
07DD:  MOVLW  B7
07DE:  ADDWF  48,W
07DF:  MOVWF  04
07E0:  BCF    03.7
07E1:  MOVF   45,W
07E2:  MOVWF  00
....................          i++; 
07E3:  INCF   48,F
....................       } 
07E4:  GOTO   79E
....................    } 
....................    // unsigned char *id; 
....................    // id = keyboard_buffer; 
....................    temp = strToInt(keyboard_buffer); 
07E5:  CLRF   4A
07E6:  MOVLW  B7
07E7:  MOVWF  49
07E8:  BCF    03.5
07E9:  CALL   760
07EA:  MOVF   79,W
07EB:  BSF    03.5
07EC:  MOVWF  47
07ED:  MOVF   78,W
07EE:  MOVWF  46
....................    return temp; 
07EF:  MOVF   46,W
07F0:  MOVWF  78
07F1:  MOVF   47,W
07F2:  MOVWF  79
07F3:  BCF    03.5
07F4:  RETURN
.................... } 
....................  
.................... int * inputToKeyboard(char * msg, int max){ 
*
09D1:  BSF    03.5
09D2:  CLRF   44
....................    unsigned char option; 
....................    int data[BLOCK_SIZE]; 
....................    int * temp; 
....................    int i = 0; 
....................  
....................    while(i < max){ 
09D3:  MOVF   39,W
09D4:  SUBWF  44,W
09D5:  BTFSC  03.0
09D6:  GOTO   254
....................  
....................       printf(lcd_escreve,"\f%s", msg); 
09D7:  MOVLW  0C
09D8:  MOVWF  4E
09D9:  BCF    0A.3
09DA:  BCF    03.5
09DB:  CALL   263
09DC:  BSF    0A.3
09DD:  BSF    03.5
09DE:  MOVF   37,W
09DF:  MOVWF  04
09E0:  BCF    03.7
09E1:  BTFSC  38.0
09E2:  BSF    03.7
09E3:  BCF    03.5
09E4:  CALL   1B2
....................       delay_ms(50); 
09E5:  MOVLW  32
09E6:  BSF    03.5
09E7:  MOVWF  4F
09E8:  BCF    0A.3
09E9:  BCF    03.5
09EA:  CALL   1AC
09EB:  BSF    0A.3
....................       option = readKeyboard(); 
09EC:  BCF    0A.3
09ED:  CALL   31A
09EE:  BSF    0A.3
09EF:  MOVF   78,W
09F0:  BSF    03.5
09F1:  MOVWF  3A
....................       if(option != 255){ 
09F2:  INCFSZ 3A,W
09F3:  GOTO   1F5
09F4:  GOTO   253
....................          printf(lcd_escreve,"\n\rTyped:%c", option); 
09F5:  MOVLW  25
09F6:  BCF    03.5
09F7:  BSF    03.6
09F8:  MOVWF  0D
09F9:  MOVLW  01
09FA:  MOVWF  0F
09FB:  BCF    03.0
09FC:  MOVLW  08
09FD:  BSF    03.5
09FE:  BCF    03.6
09FF:  MOVWF  49
0A00:  BCF    0A.3
0A01:  BCF    03.5
0A02:  CALL   47F
0A03:  BSF    0A.3
0A04:  BSF    03.5
0A05:  MOVF   3A,W
0A06:  MOVWF  4E
0A07:  BCF    0A.3
0A08:  BCF    03.5
0A09:  CALL   263
0A0A:  BSF    0A.3
....................          delay_ms(400); 
0A0B:  MOVLW  02
0A0C:  BSF    03.5
0A0D:  MOVWF  47
0A0E:  MOVLW  C8
0A0F:  MOVWF  4F
0A10:  BCF    0A.3
0A11:  BCF    03.5
0A12:  CALL   1AC
0A13:  BSF    0A.3
0A14:  BSF    03.5
0A15:  DECFSZ 47,F
0A16:  GOTO   20E
....................          unsigned char destination[2]; 
....................          //Convert string from char and return  
....................          //to the left array of char(str_pass) 
....................          strfromchar(destination,option); 
0A17:  CLRF   48
0A18:  MOVLW  C5
0A19:  MOVWF  47
0A1A:  MOVF   3A,W
0A1B:  MOVWF  49
....................          temp = strToInt(destination); 
*
0A2E:  CLRF   4A
0A2F:  MOVLW  C5
0A30:  MOVWF  49
0A31:  BCF    0A.3
0A32:  BCF    03.5
0A33:  CALL   760
0A34:  BSF    0A.3
0A35:  MOVF   79,W
0A36:  BSF    03.5
0A37:  MOVWF  43
0A38:  MOVF   78,W
0A39:  MOVWF  42
....................          data[i] = temp[0]; 
0A3A:  MOVLW  BB
0A3B:  ADDWF  44,W
0A3C:  MOVWF  78
0A3D:  CLRF   7A
0A3E:  BTFSC  03.0
0A3F:  INCF   7A,F
0A40:  MOVF   78,W
0A41:  MOVWF  47
0A42:  MOVF   7A,W
0A43:  MOVWF  48
0A44:  MOVF   42,W
0A45:  MOVWF  04
0A46:  BCF    03.7
0A47:  BTFSC  43.0
0A48:  BSF    03.7
0A49:  MOVF   00,W
0A4A:  MOVWF  49
0A4B:  MOVF   47,W
0A4C:  MOVWF  04
0A4D:  BCF    03.7
0A4E:  BTFSC  48.0
0A4F:  BSF    03.7
0A50:  MOVF   49,W
0A51:  MOVWF  00
....................          i++; 
0A52:  INCF   44,F
....................       } 
0A53:  GOTO   1D3
....................    } 
....................  
....................    temp = data; 
0A54:  CLRF   43
0A55:  MOVLW  BB
0A56:  MOVWF  42
....................    return temp; 
0A57:  MOVF   42,W
0A58:  MOVWF  78
0A59:  MOVF   43,W
0A5A:  MOVWF  79
0A5B:  BCF    03.5
0A5C:  RETURN
....................  
.................... } 
.................... void inputKeyboardUser(){ 
....................  
....................    unsigned int * temp; 
....................    unsigned int id [2]; 
....................    temp = inputId(); 
*
1063:  BCF    0A.4
1064:  CALL   79C
1065:  BSF    0A.4
1066:  MOVF   79,W
1067:  MOVWF  54
1068:  MOVF   78,W
1069:  MOVWF  53
....................    id[0] = temp[0]; 
106A:  MOVF   53,W
106B:  MOVWF  04
106C:  BCF    03.7
106D:  BTFSC  54.0
106E:  BSF    03.7
106F:  MOVF   00,W
1070:  MOVWF  55
....................    id[1] = temp[1]; 
1071:  MOVLW  01
1072:  ADDWF  53,W
1073:  MOVWF  04
1074:  BCF    03.7
1075:  BTFSC  54.0
1076:  BSF    03.7
1077:  MOVF   00,W
1078:  MOVWF  56
....................    int address = getAddressByID(id); 
1079:  BSF    03.5
107A:  CLRF   3F
107B:  MOVLW  55
107C:  MOVWF  3E
107D:  BCF    0A.4
107E:  BSF    0A.3
107F:  BCF    03.5
1080:  CALL   178
1081:  BSF    0A.4
1082:  BCF    0A.3
1083:  MOVF   78,W
1084:  MOVWF  57
....................    printf(lcd_escreve,"\fid: %u%u",id[0],id[1]); 
1085:  MOVLW  2B
1086:  BSF    03.6
1087:  MOVWF  0D
1088:  MOVLW  01
1089:  MOVWF  0F
108A:  BCF    03.0
108B:  MOVLW  05
108C:  BSF    03.5
108D:  BCF    03.6
108E:  MOVWF  49
108F:  BCF    0A.4
1090:  BCF    03.5
1091:  CALL   47F
1092:  BSF    0A.4
1093:  MOVF   55,W
1094:  BSF    03.5
1095:  MOVWF  37
1096:  MOVLW  1B
1097:  MOVWF  38
1098:  BCF    0A.4
1099:  BSF    0A.3
109A:  BCF    03.5
109B:  CALL   3B4
109C:  BSF    0A.4
109D:  BCF    0A.3
109E:  MOVF   56,W
109F:  BSF    03.5
10A0:  MOVWF  37
10A1:  MOVLW  1B
10A2:  MOVWF  38
10A3:  BCF    0A.4
10A4:  BSF    0A.3
10A5:  BCF    03.5
10A6:  CALL   3B4
10A7:  BSF    0A.4
10A8:  BCF    0A.3
....................    delay_ms(500); 
10A9:  MOVLW  02
10AA:  MOVWF  6F
10AB:  MOVLW  FA
10AC:  BSF    03.5
10AD:  MOVWF  4F
10AE:  BCF    0A.4
10AF:  BCF    03.5
10B0:  CALL   1AC
10B1:  BSF    0A.4
10B2:  DECFSZ 6F,F
10B3:  GOTO   0AB
....................    if(address == -1){//-1: ID is available to use 
10B4:  MOVF   57,W
10B5:  SUBLW  FF
10B6:  BTFSS  03.2
10B7:  GOTO   24F
....................       unsigned int pass[4]; 
....................       unsigned int status; 
....................  
....................       char msg [] = "Digite a senha: "; 
10B8:  MOVLW  44
10B9:  MOVWF  5D
10BA:  MOVLW  69
10BB:  MOVWF  5E
10BC:  MOVLW  67
10BD:  MOVWF  5F
10BE:  MOVLW  69
10BF:  MOVWF  60
10C0:  MOVLW  74
10C1:  MOVWF  61
10C2:  MOVLW  65
10C3:  MOVWF  62
10C4:  MOVLW  20
10C5:  MOVWF  63
10C6:  MOVLW  61
10C7:  MOVWF  64
10C8:  MOVLW  20
10C9:  MOVWF  65
10CA:  MOVLW  73
10CB:  MOVWF  66
10CC:  MOVLW  65
10CD:  MOVWF  67
10CE:  MOVLW  6E
10CF:  MOVWF  68
10D0:  MOVLW  68
10D1:  MOVWF  69
10D2:  MOVLW  61
10D3:  MOVWF  6A
10D4:  MOVLW  3A
10D5:  MOVWF  6B
10D6:  MOVLW  20
10D7:  MOVWF  6C
10D8:  CLRF   6D
....................       int max = 4; 
10D9:  MOVLW  04
10DA:  MOVWF  6E
....................       temp = inputToKeyboard(msg, max); 
10DB:  BSF    03.5
10DC:  CLRF   38
10DD:  MOVLW  5D
10DE:  MOVWF  37
10DF:  BCF    03.5
10E0:  MOVF   6E,W
10E1:  BSF    03.5
10E2:  MOVWF  39
10E3:  BCF    0A.4
10E4:  BSF    0A.3
10E5:  BCF    03.5
10E6:  CALL   1D1
10E7:  BSF    0A.4
10E8:  BCF    0A.3
10E9:  MOVF   79,W
10EA:  MOVWF  54
10EB:  MOVF   78,W
10EC:  MOVWF  53
....................       pass[0] = temp[0]; 
10ED:  MOVF   53,W
10EE:  MOVWF  04
10EF:  BCF    03.7
10F0:  BTFSC  54.0
10F1:  BSF    03.7
10F2:  MOVF   00,W
10F3:  MOVWF  58
....................       pass[1] = temp[1]; 
10F4:  MOVLW  01
10F5:  ADDWF  53,W
10F6:  MOVWF  04
10F7:  BCF    03.7
10F8:  BTFSC  54.0
10F9:  BSF    03.7
10FA:  MOVF   00,W
10FB:  MOVWF  59
....................       pass[2] = temp[2]; 
10FC:  MOVLW  02
10FD:  ADDWF  53,W
10FE:  MOVWF  04
10FF:  BCF    03.7
1100:  BTFSC  54.0
1101:  BSF    03.7
1102:  MOVF   00,W
1103:  MOVWF  5A
....................       pass[3] = temp[3]; 
1104:  MOVLW  03
1105:  ADDWF  53,W
1106:  MOVWF  04
1107:  BCF    03.7
1108:  BTFSC  54.0
1109:  BSF    03.7
110A:  MOVF   00,W
110B:  MOVWF  5B
....................  
....................       char msg2 [] = "Status (0,1,3): "; 
110C:  MOVLW  53
110D:  BSF    03.5
110E:  MOVWF  20
110F:  MOVLW  74
1110:  MOVWF  21
1111:  MOVLW  61
1112:  MOVWF  22
1113:  MOVLW  74
1114:  MOVWF  23
1115:  MOVLW  75
1116:  MOVWF  24
1117:  MOVLW  73
1118:  MOVWF  25
1119:  MOVLW  20
111A:  MOVWF  26
111B:  MOVLW  28
111C:  MOVWF  27
111D:  MOVLW  30
111E:  MOVWF  28
111F:  MOVLW  2C
1120:  MOVWF  29
1121:  MOVLW  31
1122:  MOVWF  2A
1123:  MOVLW  2C
1124:  MOVWF  2B
1125:  MOVLW  33
1126:  MOVWF  2C
1127:  MOVLW  29
1128:  MOVWF  2D
1129:  MOVLW  3A
112A:  MOVWF  2E
112B:  MOVLW  20
112C:  MOVWF  2F
112D:  CLRF   30
....................       max = 1; 
112E:  MOVLW  01
112F:  BCF    03.5
1130:  MOVWF  6E
....................       temp = inputToKeyboard(msg2, max); 
1131:  BSF    03.5
1132:  CLRF   38
1133:  MOVLW  A0
1134:  MOVWF  37
1135:  BCF    03.5
1136:  MOVF   6E,W
1137:  BSF    03.5
1138:  MOVWF  39
1139:  BCF    0A.4
113A:  BSF    0A.3
113B:  BCF    03.5
113C:  CALL   1D1
113D:  BSF    0A.4
113E:  BCF    0A.3
113F:  MOVF   79,W
1140:  MOVWF  54
1141:  MOVF   78,W
1142:  MOVWF  53
....................       status = temp[0]; 
1143:  MOVF   53,W
1144:  MOVWF  04
1145:  BCF    03.7
1146:  BTFSC  54.0
1147:  BSF    03.7
1148:  MOVF   00,W
1149:  MOVWF  5C
....................  
....................       saveUser(id,pass,status); 
114A:  BSF    03.5
114B:  CLRF   32
114C:  MOVLW  55
114D:  MOVWF  31
114E:  CLRF   34
114F:  MOVLW  58
1150:  MOVWF  33
1151:  BCF    03.5
1152:  MOVF   5C,W
1153:  BSF    03.5
1154:  MOVWF  35
....................    }else{ 
*
124D:  GOTO   264
124E:  BCF    03.5
....................       printf (lcd_escreve,"\fID Jah Existe"); 
124F:  MOVLW  30
1250:  BSF    03.6
1251:  MOVWF  0D
1252:  MOVLW  01
1253:  MOVWF  0F
1254:  BCF    0A.4
1255:  BCF    03.6
1256:  CALL   2A6
1257:  BSF    0A.4
....................       delay_ms(1000); 
1258:  MOVLW  04
1259:  MOVWF  6F
125A:  MOVLW  FA
125B:  BSF    03.5
125C:  MOVWF  4F
125D:  BCF    0A.4
125E:  BCF    03.5
125F:  CALL   1AC
1260:  BSF    0A.4
1261:  DECFSZ 6F,F
1262:  GOTO   25A
1263:  BSF    03.5
....................    } 
.................... } 
....................  
.................... void editUser(){ 
....................    unsigned int * temp; 
....................    unsigned int id [2]; 
....................    temp = inputId(); 
*
1429:  BCF    0A.4
142A:  CALL   79C
142B:  BSF    0A.4
142C:  MOVF   79,W
142D:  MOVWF  54
142E:  MOVF   78,W
142F:  MOVWF  53
....................    id[0] = temp[0]; 
1430:  MOVF   53,W
1431:  MOVWF  04
1432:  BCF    03.7
1433:  BTFSC  54.0
1434:  BSF    03.7
1435:  MOVF   00,W
1436:  MOVWF  55
....................    id[1] = temp[1]; 
1437:  MOVLW  01
1438:  ADDWF  53,W
1439:  MOVWF  04
143A:  BCF    03.7
143B:  BTFSC  54.0
143C:  BSF    03.7
143D:  MOVF   00,W
143E:  MOVWF  56
....................    int address = getAddressByID(id); 
143F:  BSF    03.5
1440:  CLRF   3F
1441:  MOVLW  55
1442:  MOVWF  3E
1443:  BCF    0A.4
1444:  BSF    0A.3
1445:  BCF    03.5
1446:  CALL   178
1447:  BSF    0A.4
1448:  BCF    0A.3
1449:  MOVF   78,W
144A:  MOVWF  57
....................    if(address != -1){ 
144B:  MOVF   57,W
144C:  SUBLW  FF
144D:  BTFSC  03.2
144E:  GOTO   62F
....................       unsigned int * temp; 
....................       unsigned int pass[4]; 
....................       unsigned int status; 
....................  
....................       char msg [] = "Nova senha: "; 
144F:  MOVLW  4E
1450:  MOVWF  5F
1451:  MOVLW  6F
1452:  MOVWF  60
1453:  MOVLW  76
1454:  MOVWF  61
1455:  MOVLW  61
1456:  MOVWF  62
1457:  MOVLW  20
1458:  MOVWF  63
1459:  MOVLW  73
145A:  MOVWF  64
145B:  MOVLW  65
145C:  MOVWF  65
145D:  MOVLW  6E
145E:  MOVWF  66
145F:  MOVLW  68
1460:  MOVWF  67
1461:  MOVLW  61
1462:  MOVWF  68
1463:  MOVLW  3A
1464:  MOVWF  69
1465:  MOVLW  20
1466:  MOVWF  6A
1467:  CLRF   6B
....................       int max = 4; 
1468:  MOVLW  04
1469:  MOVWF  6C
....................       temp = inputToKeyboard(msg, max); 
146A:  BSF    03.5
146B:  CLRF   38
146C:  MOVLW  5F
146D:  MOVWF  37
146E:  BCF    03.5
146F:  MOVF   6C,W
1470:  BSF    03.5
1471:  MOVWF  39
1472:  BCF    0A.4
1473:  BSF    0A.3
1474:  BCF    03.5
1475:  CALL   1D1
1476:  BSF    0A.4
1477:  BCF    0A.3
1478:  MOVF   79,W
1479:  MOVWF  59
147A:  MOVF   78,W
147B:  MOVWF  58
....................       pass[0] = temp[0]; 
147C:  MOVF   58,W
147D:  MOVWF  04
147E:  BCF    03.7
147F:  BTFSC  59.0
1480:  BSF    03.7
1481:  MOVF   00,W
1482:  MOVWF  5A
....................       pass[1] = temp[1]; 
1483:  MOVLW  01
1484:  ADDWF  58,W
1485:  MOVWF  04
1486:  BCF    03.7
1487:  BTFSC  59.0
1488:  BSF    03.7
1489:  MOVF   00,W
148A:  MOVWF  5B
....................       pass[2] = temp[2]; 
148B:  MOVLW  02
148C:  ADDWF  58,W
148D:  MOVWF  04
148E:  BCF    03.7
148F:  BTFSC  59.0
1490:  BSF    03.7
1491:  MOVF   00,W
1492:  MOVWF  5C
....................       pass[3] = temp[3]; 
1493:  MOVLW  03
1494:  ADDWF  58,W
1495:  MOVWF  04
1496:  BCF    03.7
1497:  BTFSC  59.0
1498:  BSF    03.7
1499:  MOVF   00,W
149A:  MOVWF  5D
....................       printf(lcd_escreve,"\fPASS(4): %u%u%u%u",pass[0],pass[1],pass[2],pass[3]); 
149B:  MOVLW  38
149C:  BSF    03.6
149D:  MOVWF  0D
149E:  MOVLW  01
149F:  MOVWF  0F
14A0:  BCF    03.0
14A1:  MOVLW  0A
14A2:  BSF    03.5
14A3:  BCF    03.6
14A4:  MOVWF  49
14A5:  BCF    0A.4
14A6:  BCF    03.5
14A7:  CALL   47F
14A8:  BSF    0A.4
14A9:  MOVF   5A,W
14AA:  BSF    03.5
14AB:  MOVWF  37
14AC:  MOVLW  1B
14AD:  MOVWF  38
14AE:  BCF    0A.4
14AF:  BSF    0A.3
14B0:  BCF    03.5
14B1:  CALL   3B4
14B2:  BSF    0A.4
14B3:  BCF    0A.3
14B4:  MOVF   5B,W
14B5:  BSF    03.5
14B6:  MOVWF  37
14B7:  MOVLW  1B
14B8:  MOVWF  38
14B9:  BCF    0A.4
14BA:  BSF    0A.3
14BB:  BCF    03.5
14BC:  CALL   3B4
14BD:  BSF    0A.4
14BE:  BCF    0A.3
14BF:  MOVF   5C,W
14C0:  BSF    03.5
14C1:  MOVWF  37
14C2:  MOVLW  1B
14C3:  MOVWF  38
14C4:  BCF    0A.4
14C5:  BSF    0A.3
14C6:  BCF    03.5
14C7:  CALL   3B4
14C8:  BSF    0A.4
14C9:  BCF    0A.3
14CA:  MOVF   5D,W
14CB:  BSF    03.5
14CC:  MOVWF  37
14CD:  MOVLW  1B
14CE:  MOVWF  38
14CF:  BCF    0A.4
14D0:  BSF    0A.3
14D1:  BCF    03.5
14D2:  CALL   3B4
14D3:  BSF    0A.4
14D4:  BCF    0A.3
....................       delay_ms(500); 
14D5:  MOVLW  02
14D6:  MOVWF  6D
14D7:  MOVLW  FA
14D8:  BSF    03.5
14D9:  MOVWF  4F
14DA:  BCF    0A.4
14DB:  BCF    03.5
14DC:  CALL   1AC
14DD:  BSF    0A.4
14DE:  DECFSZ 6D,F
14DF:  GOTO   4D7
....................  
....................       char msg2 [] = "Novo Status\r\n(0,1,3): "; 
14E0:  MOVLW  4E
14E1:  BSF    03.5
14E2:  MOVWF  20
14E3:  MOVLW  6F
14E4:  MOVWF  21
14E5:  MOVLW  76
14E6:  MOVWF  22
14E7:  MOVLW  6F
14E8:  MOVWF  23
14E9:  MOVLW  20
14EA:  MOVWF  24
14EB:  MOVLW  53
14EC:  MOVWF  25
14ED:  MOVLW  74
14EE:  MOVWF  26
14EF:  MOVLW  61
14F0:  MOVWF  27
14F1:  MOVLW  74
14F2:  MOVWF  28
14F3:  MOVLW  75
14F4:  MOVWF  29
14F5:  MOVLW  73
14F6:  MOVWF  2A
14F7:  MOVLW  0D
14F8:  MOVWF  2B
14F9:  MOVLW  0A
14FA:  MOVWF  2C
14FB:  MOVLW  28
14FC:  MOVWF  2D
14FD:  MOVLW  30
14FE:  MOVWF  2E
14FF:  MOVLW  2C
1500:  MOVWF  2F
1501:  MOVLW  31
1502:  MOVWF  30
1503:  MOVLW  2C
1504:  MOVWF  31
1505:  MOVLW  33
1506:  MOVWF  32
1507:  MOVLW  29
1508:  MOVWF  33
1509:  MOVLW  3A
150A:  MOVWF  34
150B:  MOVLW  20
150C:  MOVWF  35
150D:  CLRF   36
....................       max = 1; 
150E:  MOVLW  01
150F:  BCF    03.5
1510:  MOVWF  6C
....................       temp = inputToKeyboard(msg2, max); 
1511:  BSF    03.5
1512:  CLRF   38
1513:  MOVLW  A0
1514:  MOVWF  37
1515:  BCF    03.5
1516:  MOVF   6C,W
1517:  BSF    03.5
1518:  MOVWF  39
1519:  BCF    0A.4
151A:  BSF    0A.3
151B:  BCF    03.5
151C:  CALL   1D1
151D:  BSF    0A.4
151E:  BCF    0A.3
151F:  MOVF   79,W
1520:  MOVWF  59
1521:  MOVF   78,W
1522:  MOVWF  58
....................       status = temp[0]; 
1523:  MOVF   58,W
1524:  MOVWF  04
1525:  BCF    03.7
1526:  BTFSC  59.0
1527:  BSF    03.7
1528:  MOVF   00,W
1529:  MOVWF  5E
....................       printf(lcd_escreve,"\fSTATUS: %u",status); 
152A:  MOVLW  42
152B:  BSF    03.6
152C:  MOVWF  0D
152D:  MOVLW  01
152E:  MOVWF  0F
152F:  BCF    03.0
1530:  MOVLW  09
1531:  BSF    03.5
1532:  BCF    03.6
1533:  MOVWF  49
1534:  BCF    0A.4
1535:  BCF    03.5
1536:  CALL   47F
1537:  BSF    0A.4
1538:  MOVF   5E,W
1539:  BSF    03.5
153A:  MOVWF  37
153B:  MOVLW  1B
153C:  MOVWF  38
153D:  BCF    0A.4
153E:  BSF    0A.3
153F:  BCF    03.5
1540:  CALL   3B4
1541:  BSF    0A.4
1542:  BCF    0A.3
....................       delay_ms(500); 
1543:  MOVLW  02
1544:  MOVWF  6D
1545:  MOVLW  FA
1546:  BSF    03.5
1547:  MOVWF  4F
1548:  BCF    0A.4
1549:  BCF    03.5
154A:  CALL   1AC
154B:  BSF    0A.4
154C:  DECFSZ 6D,F
154D:  GOTO   545
....................  
....................       updateUser(id,pass,status,address); 
154E:  BSF    03.5
154F:  CLRF   3D
1550:  MOVLW  55
1551:  MOVWF  3C
1552:  CLRF   3F
1553:  MOVLW  5A
1554:  MOVWF  3E
1555:  BCF    03.5
1556:  MOVF   5E,W
1557:  BSF    03.5
1558:  MOVWF  40
1559:  BCF    03.5
155A:  MOVF   57,W
155B:  BSF    03.5
155C:  MOVWF  41
....................    }else{ 
*
162D:  GOTO   644
162E:  BCF    03.5
....................       printf (lcd_escreve,"\fID N Existe"); 
162F:  MOVLW  48
1630:  BSF    03.6
1631:  MOVWF  0D
1632:  MOVLW  01
1633:  MOVWF  0F
1634:  BCF    0A.4
1635:  BCF    03.6
1636:  CALL   2A6
1637:  BSF    0A.4
....................       delay_ms(1000); 
1638:  MOVLW  04
1639:  MOVWF  6D
163A:  MOVLW  FA
163B:  BSF    03.5
163C:  MOVWF  4F
163D:  BCF    0A.4
163E:  BCF    03.5
163F:  CALL   1AC
1640:  BSF    0A.4
1641:  DECFSZ 6D,F
1642:  GOTO   63A
1643:  BSF    03.5
....................    } 
.................... } 
....................  
....................  
.................... /* 
.................... // ---- MSG from serial communication 
.................... #int_RDA 
.................... void RDA_isr(void){ 
....................    rx_buffer[rx_wr_index] = getc(); 
....................    rxd = rx_buffer[rx_wr_index]; 
....................    rx_wr_index++; 
....................  
....................    if(rx_wr_index > RX_BUFFER_SIZE){ 
....................       rx_wr_index = 0; 
....................    } 
....................  
....................    //Look for unique ID: "IFMT" 
....................    if(rxd == 'I' && lock_pos == 0){ 
....................       lock_pos++; 
....................    } 
....................    else if(rxd == 'F' && lock_pos == 1){ 
....................       lock_pos++; 
....................    } 
....................    else if(rxd == 'M' && lock_pos == 2){ 
....................       lock_pos++; 
....................    } 
....................    else if(rxd == 'T' && lock_pos == 3){ 
....................       lock_pos=0; //Reset the "combination lock" 
....................       got_id = TRUE; 
....................       read = rxd; 
....................       //get ready to count the number of data bytes 
....................       valid_data_count = 0xff;  
....................  
....................       //buffer is reset to index 0 
....................       rx_wr_index = 0; 
....................    }else { 
....................       lock_pos = 0; 
....................    } 
....................  
....................    if(got_id && ++valid_data_count >= 6){ 
....................       data_avail = TRUE; 
....................       got_id = FALSE; 
....................    } 
....................     
.................... } 
.................... */ 
....................  
....................  
....................  
....................  
.................... // #int_TIMER1 
.................... // void TIMER1_isr(void) 
.................... // { 
.................... // } 
....................  
.................... // #int_RTCC 
.................... // void RTCC_isr(void) 
.................... // { 
....................  
....................        
.................... // } 
....................  
.................... void main() 
*
0C6A:  MOVF   03,W
0C6B:  ANDLW  1F
0C6C:  MOVWF  03
0C6D:  CLRF   21
0C6E:  CLRF   22
0C6F:  CLRF   26
0C70:  CLRF   27
0C71:  MOVLW  FF
0C72:  MOVWF  32
0C73:  BSF    03.5
0C74:  BSF    1F.0
0C75:  BSF    1F.1
0C76:  BSF    1F.2
0C77:  BCF    1F.3
0C78:  MOVLW  07
0C79:  MOVWF  1C
0C7A:  BCF    03.7
.................... { 
....................    //VARIAVEIS 
....................  
....................    // setup_timer_0(RTCC_INTERNAL|RTCC_DIV_256|RTCC_8_bit);      //13.1ms overflow 
....................    // setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); //Overflow in 104ms | Resolution 1.6 us 
....................    init_ext_eeprom(); 
*
0C8C:  BCF    0A.3
0C8D:  GOTO   19F
0C8E:  BSF    0A.3
....................    // enable_interrupts(INT_TIMER0); 
....................    // enable_interrupts(INT_TIMER1); 
....................    // enable_interrupts(GLOBAL); 
....................  
....................    lcd_ini(); 
0C8F:  BCF    0A.3
0C90:  GOTO   21A
0C91:  BSF    0A.3
....................    delay_us(50); 
0C92:  MOVLW  52
0C93:  MOVWF  77
0C94:  DECFSZ 77,F
0C95:  GOTO   494
0C96:  GOTO   497
0C97:  NOP
....................  
....................    printf(lcd_escreve, "\f  iniciando... "); 
0C98:  MOVLW  4F
0C99:  BSF    03.6
0C9A:  MOVWF  0D
0C9B:  MOVLW  01
0C9C:  MOVWF  0F
0C9D:  BCF    0A.3
0C9E:  BCF    03.6
0C9F:  CALL   2A6
0CA0:  BSF    0A.3
....................    delay_ms(200); 
0CA1:  MOVLW  C8
0CA2:  BSF    03.5
0CA3:  MOVWF  4F
0CA4:  BCF    0A.3
0CA5:  BCF    03.5
0CA6:  CALL   1AC
0CA7:  BSF    0A.3
....................  
....................    // printf(lcd_escreve, "\fIFMT - Serial"); 
....................    // delay_ms(50); 
....................  
....................    // resetmemory(); 
....................  
....................    // int id [2] = {12,34}; 
....................    // int pass [4] = {1,2,3,4}; 
....................    // saveuser(id, pass, 1); 
....................    // int id1 [2] = {14,0}; 
....................    // saveuser(id1, pass, 0); 
....................    // int id2 [2] = {70,10}; 
....................    // saveuser(id2, pass, 1); 
....................    // int id3 [2] = {0,10}; 
....................    // saveuser(id3, pass, 1); 
....................    // int id4 [2] = {99,99}; 
....................    // saveuser(id4, pass, 3);//admin 
....................     
....................     
....................    // unsigned int * temp; 
....................    // unsigned int id [2]; 
....................    // temp = inputId(); 
....................    // id[0] = temp[0]; 
....................    // id[1] = temp[1]; 
....................    // login(id); 
....................  
....................    unsigned char option; 
....................    unsigned int * temp; 
....................    unsigned int id [2]; 
....................    int status; 
....................    do{ 
....................       printf(lcd_escreve,"\f1:Login|2:Admin"); 
0CA8:  MOVLW  58
0CA9:  BSF    03.6
0CAA:  MOVWF  0D
0CAB:  MOVLW  01
0CAC:  MOVWF  0F
0CAD:  BCF    0A.3
0CAE:  BCF    03.6
0CAF:  CALL   2A6
0CB0:  BSF    0A.3
....................       delay_ms(500); 
0CB1:  MOVLW  02
0CB2:  MOVWF  4D
0CB3:  MOVLW  FA
0CB4:  BSF    03.5
0CB5:  MOVWF  4F
0CB6:  BCF    0A.3
0CB7:  BCF    03.5
0CB8:  CALL   1AC
0CB9:  BSF    0A.3
0CBA:  DECFSZ 4D,F
0CBB:  GOTO   4B3
....................       option = readKeyboard(); 
0CBC:  BCF    0A.3
0CBD:  CALL   31A
0CBE:  BSF    0A.3
0CBF:  MOVF   78,W
0CC0:  MOVWF  47
....................  
....................       if(option != 255){ 
0CC1:  INCFSZ 47,W
0CC2:  GOTO   4C4
0CC3:  GOTO   5AE
....................          printf(lcd_escreve,"\r\n Option: %c", option); 
0CC4:  MOVLW  61
0CC5:  BSF    03.6
0CC6:  MOVWF  0D
0CC7:  MOVLW  01
0CC8:  MOVWF  0F
0CC9:  BCF    03.0
0CCA:  MOVLW  0B
0CCB:  BSF    03.5
0CCC:  BCF    03.6
0CCD:  MOVWF  49
0CCE:  BCF    0A.3
0CCF:  BCF    03.5
0CD0:  CALL   47F
0CD1:  BSF    0A.3
0CD2:  MOVF   47,W
0CD3:  BSF    03.5
0CD4:  MOVWF  4E
0CD5:  BCF    0A.3
0CD6:  BCF    03.5
0CD7:  CALL   263
0CD8:  BSF    0A.3
....................          delay_ms(500); 
0CD9:  MOVLW  02
0CDA:  MOVWF  4D
0CDB:  MOVLW  FA
0CDC:  BSF    03.5
0CDD:  MOVWF  4F
0CDE:  BCF    0A.3
0CDF:  BCF    03.5
0CE0:  CALL   1AC
0CE1:  BSF    0A.3
0CE2:  DECFSZ 4D,F
0CE3:  GOTO   4DB
....................  
....................          switch(option){ 
0CE4:  MOVF   47,W
0CE5:  XORLW  31
0CE6:  BTFSC  03.2
0CE7:  GOTO   4EC
0CE8:  XORLW  03
0CE9:  BTFSC  03.2
0CEA:  GOTO   556
0CEB:  GOTO   591
....................             case '1': 
....................                temp = inputId(); 
0CEC:  BCF    0A.3
0CED:  CALL   79C
0CEE:  BSF    0A.3
0CEF:  MOVF   79,W
0CF0:  MOVWF  49
0CF1:  MOVF   78,W
0CF2:  MOVWF  48
....................                id[0] = temp[0]; 
0CF3:  MOVF   48,W
0CF4:  MOVWF  04
0CF5:  BCF    03.7
0CF6:  BTFSC  49.0
0CF7:  BSF    03.7
0CF8:  MOVF   00,W
0CF9:  MOVWF  4A
....................                id[1] = temp[1]; 
0CFA:  MOVLW  01
0CFB:  ADDWF  48,W
0CFC:  MOVWF  04
0CFD:  BCF    03.7
0CFE:  BTFSC  49.0
0CFF:  BSF    03.7
0D00:  MOVF   00,W
0D01:  MOVWF  4B
....................                status = login(id); 
0D02:  CLRF   4E
0D03:  MOVLW  4A
0D04:  MOVWF  4D
0D05:  CALL   2B1
0D06:  MOVF   78,W
0D07:  MOVWF  4C
....................                if(status == 1 || status == 3){ 
0D08:  DECFSZ 4C,W
0D09:  GOTO   50B
0D0A:  GOTO   50F
0D0B:  MOVF   4C,W
0D0C:  SUBLW  03
0D0D:  BTFSS  03.2
0D0E:  GOTO   538
....................                   printf(lcd_escreve,"\fBem Vindo(a)!"); 
0D0F:  MOVLW  68
0D10:  BSF    03.6
0D11:  MOVWF  0D
0D12:  MOVLW  01
0D13:  MOVWF  0F
0D14:  BCF    0A.3
0D15:  BCF    03.6
0D16:  CALL   2A6
0D17:  BSF    0A.3
....................                   delay_ms(1000); 
0D18:  MOVLW  04
0D19:  MOVWF  4D
0D1A:  MOVLW  FA
0D1B:  BSF    03.5
0D1C:  MOVWF  4F
0D1D:  BCF    0A.3
0D1E:  BCF    03.5
0D1F:  CALL   1AC
0D20:  BSF    0A.3
0D21:  DECFSZ 4D,F
0D22:  GOTO   51A
....................                   printf(lcd_escreve,"\fLiga Led e Rele"); 
0D23:  MOVLW  70
0D24:  BSF    03.6
0D25:  MOVWF  0D
0D26:  MOVLW  01
0D27:  MOVWF  0F
0D28:  BCF    0A.3
0D29:  BCF    03.6
0D2A:  CALL   2A6
0D2B:  BSF    0A.3
....................                   delay_ms(500); 
0D2C:  MOVLW  02
0D2D:  MOVWF  4D
0D2E:  MOVLW  FA
0D2F:  BSF    03.5
0D30:  MOVWF  4F
0D31:  BCF    0A.3
0D32:  BCF    03.5
0D33:  CALL   1AC
0D34:  BSF    0A.3
0D35:  DECFSZ 4D,F
0D36:  GOTO   52E
....................                }else{//Unpaid 
0D37:  GOTO   555
....................                   printf(lcd_escreve,"\fConta Existe"); 
0D38:  MOVLW  79
0D39:  BSF    03.6
0D3A:  MOVWF  0D
0D3B:  MOVLW  01
0D3C:  MOVWF  0F
0D3D:  BCF    0A.3
0D3E:  BCF    03.6
0D3F:  CALL   2A6
0D40:  BSF    0A.3
....................                   printf(lcd_escreve,"\r\r,Mas Falta Pagar!"); 
0D41:  MOVLW  80
0D42:  BSF    03.6
0D43:  MOVWF  0D
0D44:  MOVLW  01
0D45:  MOVWF  0F
0D46:  BCF    0A.3
0D47:  BCF    03.6
0D48:  CALL   2A6
0D49:  BSF    0A.3
....................                   delay_ms(1000); 
0D4A:  MOVLW  04
0D4B:  MOVWF  4D
0D4C:  MOVLW  FA
0D4D:  BSF    03.5
0D4E:  MOVWF  4F
0D4F:  BCF    0A.3
0D50:  BCF    03.5
0D51:  CALL   1AC
0D52:  BSF    0A.3
0D53:  DECFSZ 4D,F
0D54:  GOTO   54C
....................                } 
....................                break; 
0D55:  GOTO   5AE
....................             case '2': 
....................                temp = inputId(); 
0D56:  BCF    0A.3
0D57:  CALL   79C
0D58:  BSF    0A.3
0D59:  MOVF   79,W
0D5A:  MOVWF  49
0D5B:  MOVF   78,W
0D5C:  MOVWF  48
....................                id[0] = temp[0]; 
0D5D:  MOVF   48,W
0D5E:  MOVWF  04
0D5F:  BCF    03.7
0D60:  BTFSC  49.0
0D61:  BSF    03.7
0D62:  MOVF   00,W
0D63:  MOVWF  4A
....................                id[1] = temp[1]; 
0D64:  MOVLW  01
0D65:  ADDWF  48,W
0D66:  MOVWF  04
0D67:  BCF    03.7
0D68:  BTFSC  49.0
0D69:  BSF    03.7
0D6A:  MOVF   00,W
0D6B:  MOVWF  4B
....................                status = login(id); 
0D6C:  CLRF   4E
0D6D:  MOVLW  4A
0D6E:  MOVWF  4D
0D6F:  CALL   2B1
0D70:  MOVF   78,W
0D71:  MOVWF  4C
....................                if(status == 3){ 
0D72:  MOVF   4C,W
0D73:  SUBLW  03
0D74:  BTFSS  03.2
0D75:  GOTO   57C
....................                   adminMenu(); 
0D76:  BSF    0A.4
0D77:  BCF    0A.3
0D78:  GOTO   000
0D79:  BCF    0A.4
0D7A:  BSF    0A.3
....................                } 
0D7B:  GOTO   590
....................                else{ 
....................                   printf(lcd_escreve,"\fN Permitido"); 
0D7C:  MOVLW  8A
0D7D:  BSF    03.6
0D7E:  MOVWF  0D
0D7F:  MOVLW  01
0D80:  MOVWF  0F
0D81:  BCF    0A.3
0D82:  BCF    03.6
0D83:  CALL   2A6
0D84:  BSF    0A.3
....................                   delay_ms(500); 
0D85:  MOVLW  02
0D86:  MOVWF  4D
0D87:  MOVLW  FA
0D88:  BSF    03.5
0D89:  MOVWF  4F
0D8A:  BCF    0A.3
0D8B:  BCF    03.5
0D8C:  CALL   1AC
0D8D:  BSF    0A.3
0D8E:  DECFSZ 4D,F
0D8F:  GOTO   587
....................                } 
....................                break; 
0D90:  GOTO   5AE
....................             default: 
....................                printf(lcd_escreve,"\fDigite um valor"); 
0D91:  MOVLW  91
0D92:  BSF    03.6
0D93:  MOVWF  0D
0D94:  MOVLW  01
0D95:  MOVWF  0F
0D96:  BCF    0A.3
0D97:  BCF    03.6
0D98:  CALL   2A6
0D99:  BSF    0A.3
....................                printf(lcd_escreve,"\r\nValido!"); 
0D9A:  MOVLW  9A
0D9B:  BSF    03.6
0D9C:  MOVWF  0D
0D9D:  MOVLW  01
0D9E:  MOVWF  0F
0D9F:  BCF    0A.3
0DA0:  BCF    03.6
0DA1:  CALL   2A6
0DA2:  BSF    0A.3
....................                delay_ms(500); 
0DA3:  MOVLW  02
0DA4:  MOVWF  4D
0DA5:  MOVLW  FA
0DA6:  BSF    03.5
0DA7:  MOVWF  4F
0DA8:  BCF    0A.3
0DA9:  BCF    03.5
0DAA:  CALL   1AC
0DAB:  BSF    0A.3
0DAC:  DECFSZ 4D,F
0DAD:  GOTO   5A5
....................                break; 
....................          } 
....................       } 
....................  
....................  
....................    }while(option != '5'); 
0DAE:  MOVF   47,W
0DAF:  SUBLW  35
0DB0:  BTFSS  03.2
0DB1:  GOTO   4A8
....................  
.................... } 
....................  
0DB2:  SLEEP

Configuration Fuses:
   Word  1: 3F32   HS NOWDT PUT NOBROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT

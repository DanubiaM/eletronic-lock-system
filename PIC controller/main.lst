CCS PCM C Compiler, Version 5.025, 7201               21-Nov-21 17:28

               Filename:   E:\University\Microcontrollers\PCW Projects\eletronic-lock-system\PIC controller\main.lst

               ROM used:   4818 words (59%)
                           Largest free fragment is 2048
               RAM used:   58 (16%) at main() level
                           227 (62%) worst case
               Stack used: 7 locations (6 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  0B
0001:  MOVWF  0A
0002:  GOTO   399
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  BTFSS  0B.5
0028:  GOTO   02B
0029:  BTFSC  0B.2
002A:  GOTO   052
002B:  MOVLW  8C
002C:  MOVWF  04
002D:  BTFSS  00.0
002E:  GOTO   031
002F:  BTFSC  0C.0
0030:  GOTO   055
0031:  MOVF   22,W
0032:  MOVWF  04
0033:  MOVF   23,W
0034:  MOVWF  77
0035:  MOVF   24,W
0036:  MOVWF  78
0037:  MOVF   25,W
0038:  MOVWF  79
0039:  MOVF   26,W
003A:  MOVWF  7A
003B:  MOVF   27,W
003C:  BSF    03.6
003D:  MOVWF  0D
003E:  BCF    03.6
003F:  MOVF   28,W
0040:  BSF    03.6
0041:  MOVWF  0F
0042:  BCF    03.6
0043:  MOVF   29,W
0044:  BSF    03.6
0045:  MOVWF  0C
0046:  BCF    03.6
0047:  MOVF   2A,W
0048:  BSF    03.6
0049:  MOVWF  0E
004A:  BCF    03.6
004B:  MOVF   20,W
004C:  MOVWF  0A
004D:  SWAPF  21,W
004E:  MOVWF  03
004F:  SWAPF  7F,F
0050:  SWAPF  7F,W
0051:  RETFIE
0052:  BCF    0A.3
0053:  BCF    0A.4
0054:  GOTO   193
0055:  BCF    0A.3
0056:  BCF    0A.4
0057:  GOTO   18F
....................  
.................... #include <16F877A.h> 
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
0058:  BCF    0A.0
0059:  BCF    0A.1
005A:  BCF    0A.2
005B:  ADDWF  02,F
005C:  RETLW  28
005D:  RETLW  0F
005E:  RETLW  01
005F:  RETLW  06
0060:  BCF    0A.0
0061:  BCF    0A.1
0062:  BCF    0A.2
0063:  ADDWF  02,F
0064:  RETLW  4E
0065:  RETLW  41
0066:  RETLW  4F
0067:  RETLW  20
0068:  RETLW  50
0069:  RETLW  41
006A:  RETLW  47
006B:  RETLW  4F
006C:  RETLW  00
006D:  BCF    0A.0
006E:  BCF    0A.1
006F:  BCF    0A.2
0070:  ADDWF  02,F
0071:  RETLW  50
0072:  RETLW  41
0073:  RETLW  47
0074:  RETLW  4F
0075:  RETLW  00
0076:  DATA 8C,2A
0077:  DATA F3,3A
0078:  DATA 61,39
0079:  DATA E9,37
007A:  DATA A0,21
007B:  DATA 61,32
007C:  DATA E1,39
007D:  DATA 74,39
007E:  DATA 61,32
007F:  DATA 6F,00
0080:  DATA 8C,24
0081:  DATA 44,10
0082:  DATA 69,37
0083:  DATA E3,37
0084:  DATA 6D,38
0085:  DATA 61,3A
0086:  DATA 69,3B
0087:  DATA 65,36
0088:  DATA 00,01
0089:  DATA 0D,05
008A:  DATA D4,32
008B:  DATA 6E,3A
008C:  DATA 65,10
008D:  DATA EE,37
008E:  DATA F6,30
008F:  DATA ED,32
0090:  DATA 6E,3A
0091:  DATA 65,00
0092:  DATA 8C,2A
0093:  DATA F3,3A
0094:  DATA 61,39
0095:  DATA E9,37
0096:  DATA A0,20
0097:  DATA F4,3A
0098:  DATA 61,36
0099:  DATA 69,3D
009A:  DATA 61,32
009B:  DATA 6F,00
009C:  DATA 8C,24
009D:  DATA 44,10
009E:  DATA 69,37
009F:  DATA E3,37
00A0:  DATA 6D,38
00A1:  DATA 61,3A
00A2:  DATA 69,3B
00A3:  DATA 65,36
00A4:  DATA 00,01
00A5:  DATA 0D,05
00A6:  DATA D4,32
00A7:  DATA 6E,3A
00A8:  DATA 65,10
00A9:  DATA EE,37
00AA:  DATA F6,30
00AB:  DATA ED,32
00AC:  DATA 6E,3A
00AD:  DATA 65,00
00AE:  DATA 0C,10
00AF:  DATA C2,3A
00B0:  DATA 74,3A
00B1:  DATA 6F,37
00B2:  DATA 3A,10
00B3:  DATA 25,32
00B4:  DATA 00,00
00B5:  DATA 0D,05
00B6:  DATA D0,3B
00B7:  DATA BA,12
00B8:  DATA E4,12
00B9:  DATA E4,12
00BA:  DATA E4,12
00BB:  DATA 64,10
00BC:  DATA 53,3A
00BD:  DATA BA,12
00BE:  DATA 64,10
00BF:  DATA 25,32
00C0:  DATA 00,00
00C1:  DATA 8C,24
00C2:  DATA 44,10
00C3:  DATA 45,3C
00C4:  DATA E9,39
00C5:  DATA F4,32
00C6:  DATA BA,12
00C7:  DATA F5,12
00C8:  DATA 75,00
00C9:  DATA 8C,24
00CA:  DATA 44,1D
00CB:  DATA A5,3A
00CC:  DATA A5,3A
00CD:  DATA A0,06
00CE:  DATA 0A,22
00CF:  DATA E9,39
00D0:  DATA F0,37
00D1:  DATA EE,34
00D2:  DATA F6,32
00D3:  DATA 6C,00
00D4:  DATA 8C,24
00D5:  DATA 44,1D
00D6:  DATA A5,3A
00D7:  DATA A5,3A
00D8:  DATA 00,01
00D9:  DATA 0D,05
00DA:  DATA 53,3A
00DB:  DATA 61,3A
00DC:  DATA F5,39
00DD:  DATA BA,12
00DE:  DATA 73,00
00DF:  DATA 8C,2A
00E0:  DATA F3,3A
00E1:  DATA 61,39
00E2:  DATA E9,37
00E3:  DATA 20,27
00E4:  DATA A0,22
00E5:  DATA F8,34
00E6:  DATA 73,3A
00E7:  DATA 65,00
00E8:  DATA 0C,10
00E9:  DATA D5,39
00EA:  DATA 65,39
00EB:  DATA A0,32
00EC:  DATA F2,30
00ED:  DATA F3,32
00EE:  DATA 64,10
00EF:  DATA 00,00
00F0:  DATA 0D,05
00F1:  DATA 34,1D
00F2:  DATA A0,22
00F3:  DATA E4,34
00F4:  DATA F4,30
00F5:  DATA 72,10
00F6:  DATA 43,36
00F7:  DATA E9,32
00F8:  DATA 6E,3A
00F9:  DATA 65,00
00FA:  DATA 8C,1A
00FB:  DATA 3A,10
00FC:  DATA D3,20
00FD:  DATA 49,29
00FE:  DATA 20,32
00FF:  DATA 6F,10
0100:  DATA CD,32
0101:  DATA EE,3A
0102:  DATA 20,00
0103:  DATA 0C,10
0104:  DATA 4F,38
0105:  DATA F4,34
0106:  DATA 6F,37
0107:  DATA 3A,10
0108:  DATA A5,31
0109:  DATA 00,01
010A:  DATA 8C,29
010B:  DATA F5,31
010C:  DATA E3,32
010D:  DATA F3,39
010E:  DATA A0,16
010F:  DATA 3E,10
0110:  DATA 25,32
0111:  DATA 00,01
0112:  DATA 8C,3A
0113:  DATA F3,3A
0114:  DATA 61,39
0115:  DATA E9,37
0116:  DATA 20,32
0117:  DATA 65,36
0118:  DATA 65,3A
0119:  DATA 61,32
011A:  DATA 6F,00
011B:  DATA 8C,3A
011C:  DATA F3,3A
011D:  DATA 61,39
011E:  DATA E9,37
011F:  DATA 20,27
0120:  DATA A0,22
0121:  DATA F8,34
0122:  DATA 73,3A
0123:  DATA 65,00
0124:  DATA 0C,22
0125:  DATA E9,33
0126:  DATA 69,3A
0127:  DATA 65,10
0128:  DATA F5,36
0129:  DATA 20,3B
012A:  DATA 61,36
012B:  DATA 6F,39
012C:  DATA 00,01
012D:  DATA 0D,05
012E:  DATA D6,30
012F:  DATA EC,34
0130:  DATA E4,37
0131:  DATA 21,00
0132:  DATA 0C,10
0133:  DATA 20,10
0134:  DATA D4,22
0135:  DATA 43,26
0136:  DATA 41,22
0137:  DATA 4F,10
0138:  DATA 20,00
0139:  DATA 8C,20
013A:  DATA E4,36
013B:  DATA 69,37
013C:  DATA A0,22
013D:  DATA EE,31
013E:  DATA 6F,37
013F:  DATA 74,39
0140:  DATA 61,32
0141:  DATA 6F,00
0142:  DATA 0C,10
0143:  DATA 61,32
0144:  DATA ED,34
0145:  DATA EE,39
0146:  DATA 5B,18
0147:  DATA 5D,1D
0148:  DATA A0,12
0149:  DATA 64,00
014A:  DATA 8C,34
014B:  DATA 64,1D
014C:  DATA A5,3A
014D:  DATA A5,3A
014E:  DATA 00,00
014F:  DATA 0C,22
0150:  DATA E9,33
0151:  DATA 69,3A
0152:  DATA 65,10
0153:  DATA 6F,10
0154:  DATA 49,22
0155:  DATA 3A,10
0156:  DATA 00,01
0157:  DATA 8A,06
0158:  DATA D4,3C
0159:  DATA F0,32
015A:  DATA 64,1D
015B:  DATA A5,31
015C:  DATA 00,00
015D:  DATA 8A,06
015E:  DATA D4,3C
015F:  DATA F0,32
0160:  DATA 64,1D
0161:  DATA A5,31
0162:  DATA 00,00
0163:  DATA 8C,34
0164:  DATA 64,1D
0165:  DATA A0,12
0166:  DATA F5,12
0167:  DATA 75,00
0168:  DATA 0C,28
0169:  DATA C1,29
016A:  DATA 53,14
016B:  DATA B4,14
016C:  DATA 3A,10
016D:  DATA A5,3A
016E:  DATA A5,3A
016F:  DATA A5,3A
0170:  DATA A5,3A
0171:  DATA 00,01
0172:  DATA 8C,29
0173:  DATA D4,20
0174:  DATA D4,2A
0175:  DATA 53,1D
0176:  DATA A0,12
0177:  DATA 75,00
0178:  DATA 0C,28
0179:  DATA C1,29
017A:  DATA 53,14
017B:  DATA B4,14
017C:  DATA 3A,10
017D:  DATA A5,3A
017E:  DATA A5,3A
017F:  DATA A5,3A
0180:  DATA A5,3A
0181:  DATA 00,01
0182:  DATA 8C,29
0183:  DATA D4,20
0184:  DATA D4,2A
0185:  DATA 53,1D
0186:  DATA A0,12
0187:  DATA 75,00
0188:  DATA 8C,24
0189:  DATA 44,10
018A:  DATA 4E,10
018B:  DATA 45,3C
018C:  DATA E9,39
018D:  DATA F4,32
018E:  DATA 00,00
*
0197:  DATA 0C,10
0198:  DATA A0,34
0199:  DATA EE,34
019A:  DATA E3,34
019B:  DATA 61,37
019C:  DATA E4,37
019D:  DATA 2E,17
019E:  DATA 2E,10
019F:  DATA 00,00
*
02A7:  MOVF   0B,W
02A8:  BSF    03.5
02A9:  MOVWF  57
02AA:  BCF    03.5
02AB:  BCF    0B.7
02AC:  BSF    03.5
02AD:  BSF    03.6
02AE:  BSF    0C.7
02AF:  BSF    0C.0
02B0:  NOP
02B1:  NOP
02B2:  BCF    03.6
02B3:  BTFSS  57.7
02B4:  GOTO   2B8
02B5:  BCF    03.5
02B6:  BSF    0B.7
02B7:  BSF    03.5
02B8:  BCF    03.5
02B9:  BSF    03.6
02BA:  MOVF   0C,W
02BB:  ANDLW  7F
02BC:  BTFSC  03.2
02BD:  GOTO   319
02BE:  BSF    03.5
02BF:  BCF    03.6
02C0:  MOVWF  57
02C1:  BCF    03.5
02C2:  BSF    03.6
02C3:  MOVF   0D,W
02C4:  BSF    03.5
02C5:  BCF    03.6
02C6:  MOVWF  58
02C7:  BCF    03.5
02C8:  BSF    03.6
02C9:  MOVF   0F,W
02CA:  BSF    03.5
02CB:  BCF    03.6
02CC:  MOVWF  59
02CD:  MOVF   57,W
02CE:  MOVWF  5A
02CF:  BCF    03.5
02D0:  CALL   264
02D1:  BSF    03.5
02D2:  MOVF   58,W
02D3:  BCF    03.5
02D4:  BSF    03.6
02D5:  MOVWF  0D
02D6:  BSF    03.5
02D7:  BCF    03.6
02D8:  MOVF   59,W
02D9:  BCF    03.5
02DA:  BSF    03.6
02DB:  MOVWF  0F
02DC:  BCF    03.6
02DD:  MOVF   0B,W
02DE:  BSF    03.5
02DF:  MOVWF  5A
02E0:  BCF    03.5
02E1:  BCF    0B.7
02E2:  BSF    03.5
02E3:  BSF    03.6
02E4:  BSF    0C.7
02E5:  BSF    0C.0
02E6:  NOP
02E7:  NOP
02E8:  BCF    03.6
02E9:  BTFSS  5A.7
02EA:  GOTO   2EE
02EB:  BCF    03.5
02EC:  BSF    0B.7
02ED:  BSF    03.5
02EE:  BCF    03.5
02EF:  BSF    03.6
02F0:  RLF    0C,W
02F1:  RLF    0E,W
02F2:  ANDLW  7F
02F3:  BTFSC  03.2
02F4:  GOTO   319
02F5:  BSF    03.5
02F6:  BCF    03.6
02F7:  MOVWF  57
02F8:  BCF    03.5
02F9:  BSF    03.6
02FA:  MOVF   0D,W
02FB:  BSF    03.5
02FC:  BCF    03.6
02FD:  MOVWF  58
02FE:  BCF    03.5
02FF:  BSF    03.6
0300:  MOVF   0F,W
0301:  BSF    03.5
0302:  BCF    03.6
0303:  MOVWF  59
0304:  MOVF   57,W
0305:  MOVWF  5A
0306:  BCF    03.5
0307:  CALL   264
0308:  BSF    03.5
0309:  MOVF   58,W
030A:  BCF    03.5
030B:  BSF    03.6
030C:  MOVWF  0D
030D:  BSF    03.5
030E:  BCF    03.6
030F:  MOVF   59,W
0310:  BCF    03.5
0311:  BSF    03.6
0312:  MOVWF  0F
0313:  INCF   0D,F
0314:  BTFSC  03.2
0315:  INCF   0F,F
0316:  BCF    03.6
0317:  GOTO   2A7
0318:  BSF    03.6
0319:  BCF    03.6
031A:  RETURN
*
0480:  MOVF   0B,W
0481:  BSF    03.5
0482:  MOVWF  56
0483:  BCF    03.5
0484:  BCF    0B.7
0485:  BSF    03.5
0486:  BSF    03.6
0487:  BSF    0C.7
0488:  BSF    0C.0
0489:  NOP
048A:  NOP
048B:  BCF    03.6
048C:  BTFSS  56.7
048D:  GOTO   491
048E:  BCF    03.5
048F:  BSF    0B.7
0490:  BSF    03.5
0491:  BTFSC  03.0
0492:  GOTO   4CA
0493:  BCF    03.5
0494:  BSF    03.6
0495:  MOVF   0C,W
0496:  ANDLW  7F
0497:  BSF    03.5
0498:  BCF    03.6
0499:  MOVWF  56
049A:  BCF    03.5
049B:  BSF    03.6
049C:  MOVF   0D,W
049D:  BSF    03.5
049E:  BCF    03.6
049F:  MOVWF  57
04A0:  BCF    03.5
04A1:  BSF    03.6
04A2:  MOVF   0F,W
04A3:  BSF    03.5
04A4:  BCF    03.6
04A5:  MOVWF  58
04A6:  MOVF   56,W
04A7:  MOVWF  5A
04A8:  BCF    03.5
04A9:  CALL   264
04AA:  BSF    03.5
04AB:  MOVF   57,W
04AC:  BCF    03.5
04AD:  BSF    03.6
04AE:  MOVWF  0D
04AF:  BSF    03.5
04B0:  BCF    03.6
04B1:  MOVF   58,W
04B2:  BCF    03.5
04B3:  BSF    03.6
04B4:  MOVWF  0F
04B5:  BCF    03.6
04B6:  MOVF   0B,W
04B7:  BSF    03.5
04B8:  MOVWF  59
04B9:  BCF    03.5
04BA:  BCF    0B.7
04BB:  BSF    03.5
04BC:  BSF    03.6
04BD:  BSF    0C.7
04BE:  BSF    0C.0
04BF:  NOP
04C0:  NOP
04C1:  BCF    03.6
04C2:  BTFSS  59.7
04C3:  GOTO   4C7
04C4:  BCF    03.5
04C5:  BSF    0B.7
04C6:  BSF    03.5
04C7:  DECFSZ 55,F
04C8:  GOTO   4CA
04C9:  GOTO   4F8
04CA:  BCF    03.5
04CB:  BSF    03.6
04CC:  RLF    0C,W
04CD:  RLF    0E,W
04CE:  ANDLW  7F
04CF:  BSF    03.5
04D0:  BCF    03.6
04D1:  MOVWF  56
04D2:  BCF    03.5
04D3:  BSF    03.6
04D4:  MOVF   0D,W
04D5:  BSF    03.5
04D6:  BCF    03.6
04D7:  MOVWF  57
04D8:  BCF    03.5
04D9:  BSF    03.6
04DA:  MOVF   0F,W
04DB:  BSF    03.5
04DC:  BCF    03.6
04DD:  MOVWF  58
04DE:  MOVF   56,W
04DF:  MOVWF  5A
04E0:  BCF    03.5
04E1:  CALL   264
04E2:  BSF    03.5
04E3:  MOVF   57,W
04E4:  BCF    03.5
04E5:  BSF    03.6
04E6:  MOVWF  0D
04E7:  BSF    03.5
04E8:  BCF    03.6
04E9:  MOVF   58,W
04EA:  BCF    03.5
04EB:  BSF    03.6
04EC:  MOVWF  0F
04ED:  INCF   0D,F
04EE:  BTFSC  03.2
04EF:  INCF   0F,F
04F0:  BCF    03.0
04F1:  BSF    03.5
04F2:  BCF    03.6
04F3:  DECFSZ 55,F
04F4:  GOTO   4F6
04F5:  GOTO   4F8
04F6:  BCF    03.5
04F7:  GOTO   480
04F8:  BCF    03.5
04F9:  RETURN
*
06B7:  MOVF   37,W
06B8:  XORWF  39,W
06B9:  ANDLW  80
06BA:  MOVWF  3B
06BB:  BTFSS  37.7
06BC:  GOTO   6C2
06BD:  COMF   36,F
06BE:  COMF   37,F
06BF:  INCF   36,F
06C0:  BTFSC  03.2
06C1:  INCF   37,F
06C2:  BTFSS  39.7
06C3:  GOTO   6C9
06C4:  COMF   38,F
06C5:  COMF   39,F
06C6:  INCF   38,F
06C7:  BTFSC  03.2
06C8:  INCF   39,F
06C9:  MOVLW  10
06CA:  MOVWF  3A
06CB:  CLRF   77
06CC:  CLRF   7A
06CD:  RRF    37,F
06CE:  RRF    36,F
06CF:  BTFSS  03.0
06D0:  GOTO   6D7
06D1:  MOVF   38,W
06D2:  ADDWF  77,F
06D3:  BTFSC  03.0
06D4:  INCF   7A,F
06D5:  MOVF   39,W
06D6:  ADDWF  7A,F
06D7:  RRF    7A,F
06D8:  RRF    77,F
06D9:  RRF    79,F
06DA:  RRF    78,F
06DB:  DECFSZ 3A,F
06DC:  GOTO   6CD
06DD:  BTFSS  3B.7
06DE:  GOTO   6E4
06DF:  COMF   78,F
06E0:  COMF   79,F
06E1:  INCF   78,F
06E2:  BTFSC  03.2
06E3:  INCF   79,F
*
0800:  BSF    03.5
0801:  MOVF   4D,W
0802:  CLRF   78
0803:  SUBWF  4C,W
0804:  BTFSC  03.0
0805:  GOTO   009
0806:  MOVF   4C,W
0807:  MOVWF  77
0808:  GOTO   015
0809:  CLRF   77
080A:  MOVLW  08
080B:  MOVWF  4E
080C:  RLF    4C,F
080D:  RLF    77,F
080E:  MOVF   4D,W
080F:  SUBWF  77,W
0810:  BTFSC  03.0
0811:  MOVWF  77
0812:  RLF    78,F
0813:  DECFSZ 4E,F
0814:  GOTO   00C
0815:  BCF    03.5
0816:  RETURN
0817:  MOVF   78,W
0818:  BSF    03.5
0819:  MOVF   4A,W
081A:  MOVWF  4C
081B:  MOVLW  64
081C:  MOVWF  4D
081D:  BCF    03.5
081E:  CALL   000
081F:  MOVF   77,W
0820:  BSF    03.5
0821:  MOVWF  4A
0822:  MOVF   78,W
0823:  MOVLW  30
0824:  BTFSS  03.2
0825:  GOTO   02D
0826:  BTFSS  4B.1
0827:  GOTO   038
0828:  BTFSC  4B.3
0829:  GOTO   038
082A:  BTFSC  4B.4
082B:  MOVLW  20
082C:  GOTO   030
082D:  BCF    4B.3
082E:  BCF    4B.4
082F:  BSF    4B.0
0830:  ADDWF  78,F
0831:  MOVF   78,W
0832:  MOVWF  5A
0833:  BCF    0A.3
0834:  BCF    03.5
0835:  CALL   264
0836:  BSF    0A.3
0837:  BSF    03.5
0838:  MOVF   4A,W
0839:  MOVWF  4C
083A:  MOVLW  0A
083B:  MOVWF  4D
083C:  BCF    03.5
083D:  CALL   000
083E:  MOVF   77,W
083F:  BSF    03.5
0840:  MOVWF  4A
0841:  MOVF   78,W
0842:  MOVLW  30
0843:  BTFSS  03.2
0844:  GOTO   04B
0845:  BTFSC  4B.3
0846:  GOTO   053
0847:  BTFSS  4B.0
0848:  GOTO   053
0849:  BTFSC  4B.4
084A:  MOVLW  20
084B:  ADDWF  78,F
084C:  MOVF   78,W
084D:  MOVWF  5A
084E:  BCF    0A.3
084F:  BCF    03.5
0850:  CALL   264
0851:  BSF    0A.3
0852:  BSF    03.5
0853:  MOVLW  30
0854:  ADDWF  4A,F
0855:  MOVF   4A,W
0856:  MOVWF  5A
0857:  BCF    0A.3
0858:  BCF    03.5
0859:  CALL   264
085A:  BSF    0A.3
085B:  RETURN
085C:  MOVF   00,F
085D:  BTFSC  03.2
085E:  GOTO   07A
085F:  BSF    03.5
0860:  CLRF   54
0861:  MOVF   04,W
0862:  MOVWF  53
0863:  BCF    54.0
0864:  BTFSC  03.7
0865:  BSF    54.0
0866:  MOVF   00,W
0867:  MOVWF  5A
0868:  BCF    0A.3
0869:  BCF    03.5
086A:  CALL   264
086B:  BSF    0A.3
086C:  BSF    03.5
086D:  MOVF   53,W
086E:  MOVWF  04
086F:  BCF    03.7
0870:  BTFSC  54.0
0871:  BSF    03.7
0872:  INCF   04,F
0873:  BTFSS  03.2
0874:  GOTO   078
0875:  BCF    03.5
0876:  INCF   05,F
0877:  BSF    03.5
0878:  BCF    03.5
0879:  GOTO   05C
087A:  RETURN
*
1403:  MOVLW  20
1404:  BTFSS  5C.4
1405:  MOVLW  30
1406:  MOVWF  5D
1407:  MOVF   5B,W
1408:  MOVWF  77
1409:  BTFSS  5B.7
140A:  GOTO   413
140B:  COMF   77,F
140C:  INCF   77,F
140D:  MOVF   77,W
140E:  MOVWF  5B
140F:  MOVLW  2D
1410:  MOVWF  5D
1411:  BSF    5C.7
1412:  BSF    5C.0
1413:  MOVF   5B,W
1414:  BSF    03.5
1415:  MOVWF  4C
1416:  MOVLW  64
1417:  MOVWF  4D
1418:  BCF    0A.4
1419:  BSF    0A.3
141A:  BCF    03.5
141B:  CALL   000
141C:  BSF    0A.4
141D:  BCF    0A.3
141E:  MOVF   77,W
141F:  MOVWF  5B
1420:  MOVLW  30
1421:  ADDWF  78,W
1422:  MOVWF  5E
1423:  MOVF   5B,W
1424:  BSF    03.5
1425:  MOVWF  4C
1426:  MOVLW  0A
1427:  MOVWF  4D
1428:  BCF    0A.4
1429:  BSF    0A.3
142A:  BCF    03.5
142B:  CALL   000
142C:  BSF    0A.4
142D:  BCF    0A.3
142E:  MOVLW  30
142F:  ADDWF  77,W
1430:  MOVWF  60
1431:  MOVLW  30
1432:  ADDWF  78,W
1433:  MOVWF  5F
1434:  MOVF   5D,W
1435:  MOVWF  77
1436:  MOVLW  30
1437:  SUBWF  5E,W
1438:  BTFSC  03.2
1439:  GOTO   43E
143A:  BSF    5C.1
143B:  BTFSC  5C.7
143C:  BSF    5C.2
143D:  GOTO   452
143E:  MOVF   5D,W
143F:  MOVWF  5E
1440:  MOVLW  20
1441:  MOVWF  5D
1442:  MOVLW  30
1443:  SUBWF  5F,W
1444:  BTFSC  03.2
1445:  GOTO   44A
1446:  BSF    5C.0
1447:  BTFSC  5C.7
1448:  BSF    5C.1
1449:  GOTO   452
144A:  BTFSS  03.2
144B:  BSF    5C.0
144C:  BTFSS  03.2
144D:  GOTO   452
144E:  MOVF   5E,W
144F:  MOVWF  5F
1450:  MOVLW  20
1451:  MOVWF  5E
1452:  BTFSC  5C.2
1453:  GOTO   459
1454:  BTFSC  5C.1
1455:  GOTO   460
1456:  BTFSC  5C.0
1457:  GOTO   467
1458:  GOTO   46E
1459:  MOVF   5D,W
145A:  BSF    03.5
145B:  MOVWF  5A
145C:  BCF    0A.4
145D:  BCF    03.5
145E:  CALL   264
145F:  BSF    0A.4
1460:  MOVF   5E,W
1461:  BSF    03.5
1462:  MOVWF  5A
1463:  BCF    0A.4
1464:  BCF    03.5
1465:  CALL   264
1466:  BSF    0A.4
1467:  MOVF   5F,W
1468:  BSF    03.5
1469:  MOVWF  5A
146A:  BCF    0A.4
146B:  BCF    03.5
146C:  CALL   264
146D:  BSF    0A.4
146E:  MOVF   60,W
146F:  BSF    03.5
1470:  MOVWF  5A
1471:  BCF    0A.4
1472:  BCF    03.5
1473:  CALL   264
1474:  BSF    0A.4
....................  
.................... #list 
....................  
.................... #device ADC=8 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES HS  
....................  
.................... #use delay(crystal=20000000) 
*
01AD:  MOVLW  DB
01AE:  MOVWF  04
01AF:  BCF    03.7
01B0:  MOVF   00,W
01B1:  BTFSC  03.2
01B2:  GOTO   1C0
01B3:  MOVLW  06
01B4:  MOVWF  78
01B5:  CLRF   77
01B6:  DECFSZ 77,F
01B7:  GOTO   1B6
01B8:  DECFSZ 78,F
01B9:  GOTO   1B5
01BA:  MOVLW  7B
01BB:  MOVWF  77
01BC:  DECFSZ 77,F
01BD:  GOTO   1BC
01BE:  DECFSZ 00,F
01BF:  GOTO   1B3
01C0:  RETURN
.................... //#use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=PORT1) 
....................  
....................  
.................... // -------Variables' Declaration 
.................... #define RX_BUFFER_SIZE 10 
.................... #define BLOCK_SIZE sizeof(User)  
.................... signed int8 address_data_delete; 
.................... int8 rx_wr_index = 0; 
.................... int8 lock_pos = 0, rxd, read, valid_data_count; 
.................... int data_avail = FALSE, got_id = FALSE; 
.................... unsigned int8 rx_buffer[RX_BUFFER_SIZE]; 
.................... #include "functions.c" 
.................... #include "functions.h" 
....................  
.................... //Define the default pins before calling the LCD driver 
.................... #ifndef lcd_enable  
....................    #define lcd_enable     pin_e1 
....................    #define lcd_rs         pin_e2 
....................    //#define lcd_rw       pin_e2   
....................    #define lcd_d4         pin_d4 
....................    #define lcd_d5         pin_d5 
....................    #define lcd_d6         pin_d6 
....................    #define lcd_d7         pin_d7 
.................... #endif 
....................  
.................... #include "mod_lcd.c" 
.................... /************************************************************************/ 
.................... /*  MOD_LCD.C - Biblioteca de manipulaï¿½ï¿½o de mï¿½dulo LCD                 */ 
.................... /*                                                                      */ 
.................... /*  Autor: Fï¿½bio Pereira                                                */ 
.................... /*                                                                      */ 
.................... /************************************************************************/ 
....................  
.................... // As definiï¿½ï¿½es a seguir sï¿½o utilizadas para acesso aos pinos do display 
.................... // caso o pino RW nï¿½o seja utilizado, comente a definiï¿½ï¿½o lcd_rw 
.................... #ifndef lcd_enable 
.................... 	#define lcd_enable 		pin_e1		// pino enable do LCD 
.................... 	#define lcd_rs			pin_e0		// pino rs do LCD 
.................... 	//#define lcd_rw		pin_e2		// pino rw do LCD 
.................... 	#define lcd_d4			pin_d4		// pino de dados d4 do LCD 
.................... 	#define lcd_d5			pin_d5		// pino de dados d5 do LCD 
.................... 	#define lcd_d6			pin_d6		// pino de dados d6 do LCD 
.................... 	#define lcd_d7			pin_d7		// pino de dados d7 do LCD 
.................... #endif 
....................  
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 linhas 
.................... #define lcd_seg_lin 0x40    // Endereï¿½o da segunda linha na RAM do LCD 
....................  
.................... // a constante abaixo define a seqï¿½ï¿½ncia de inicializaï¿½ï¿½o do mï¿½dulo LCD 
.................... byte CONST INI_LCD[4] = {0x20 | (lcd_type << 2), 0xf, 1, 6}; 
....................  
.................... byte lcd_le_byte() 
.................... // lï¿½ um byte do LCD (somente com pino RW) 
.................... { 
.................... 	byte dado; 
.................... 	// configura os pinos de dados como entradas 
.................... 	input(lcd_d4); 
.................... 	input(lcd_d5); 
.................... 	input(lcd_d6); 
.................... 	input(lcd_d7); 
.................... 	// se o pino rw for utilizado, coloca em 1 
.................... 	#ifdef lcd_rw 
.................... 		output_high(lcd_rw); 
.................... 	#endif 
....................    output_high(lcd_enable); // habilita display 
.................... 	dado = 0;	// zera a variï¿½vel de leitura 
.................... 	// lï¿½ os quatro bits mais significativos 
.................... 	if (input(lcd_d7)) bit_set(dado,7); 
.................... 	if (input(lcd_d6)) bit_set(dado,6); 
.................... 	if (input(lcd_d5)) bit_set(dado,5); 
.................... 	if (input(lcd_d4)) bit_set(dado,4); 
.................... 	// dï¿½ um pulso na linha enable 
.................... 	output_low(lcd_enable); 
.................... 	output_high(lcd_enable); 
.................... 	// lï¿½ os quatro bits menos significativos 
.................... 	if (input(lcd_d7)) bit_set(dado,3); 
.................... 	if (input(lcd_d6)) bit_set(dado,2); 
.................... 	if (input(lcd_d5)) bit_set(dado,1); 
.................... 	if (input(lcd_d4)) bit_set(dado,0); 
.................... 	output_low(lcd_enable);	// desabilita o display 
.................... 	return dado;	// retorna o byte lido 
.................... } 
....................  
.................... void lcd_envia_nibble( byte dado ) 
.................... // envia um dado de quatro bits para o display 
.................... { 
.................... 	// coloca os quatro bits nas saidas 
.................... 	output_bit(lcd_d4,bit_test(dado,0)); 
01C1:  BSF    03.5
01C2:  BTFSC  62.0
01C3:  GOTO   1C8
01C4:  BCF    03.5
01C5:  BCF    08.4
01C6:  GOTO   1CA
01C7:  BSF    03.5
01C8:  BCF    03.5
01C9:  BSF    08.4
01CA:  BSF    03.5
01CB:  BCF    08.4
.................... 	output_bit(lcd_d5,bit_test(dado,1)); 
01CC:  BTFSC  62.1
01CD:  GOTO   1D2
01CE:  BCF    03.5
01CF:  BCF    08.5
01D0:  GOTO   1D4
01D1:  BSF    03.5
01D2:  BCF    03.5
01D3:  BSF    08.5
01D4:  BSF    03.5
01D5:  BCF    08.5
.................... 	output_bit(lcd_d6,bit_test(dado,2)); 
01D6:  BTFSC  62.2
01D7:  GOTO   1DC
01D8:  BCF    03.5
01D9:  BCF    08.6
01DA:  GOTO   1DE
01DB:  BSF    03.5
01DC:  BCF    03.5
01DD:  BSF    08.6
01DE:  BSF    03.5
01DF:  BCF    08.6
.................... 	output_bit(lcd_d7,bit_test(dado,3)); 
01E0:  BTFSC  62.3
01E1:  GOTO   1E6
01E2:  BCF    03.5
01E3:  BCF    08.7
01E4:  GOTO   1E8
01E5:  BSF    03.5
01E6:  BCF    03.5
01E7:  BSF    08.7
01E8:  BSF    03.5
01E9:  BCF    08.7
.................... 	// dï¿½ um pulso na linha enable 
.................... 	output_high(lcd_enable); 
01EA:  BCF    09.1
01EB:  BCF    03.5
01EC:  BSF    09.1
.................... 	output_low(lcd_enable); 
01ED:  BSF    03.5
01EE:  BCF    09.1
01EF:  BCF    03.5
01F0:  BCF    09.1
01F1:  RETURN
.................... } 
....................  
....................  
.................... void lcd_envia_byte( boolean endereco, byte dado ) 
.................... { 
.................... 	// coloca a linha rs em 0 
.................... 	output_low(lcd_rs); 
01F2:  BSF    03.5
01F3:  BCF    09.2
01F4:  BCF    03.5
01F5:  BCF    09.2
.................... 	// aguarda o display ficar desocupado 
.................... 	//while ( bit_test(lcd_le_byte(),7) ) ; 
.................... 	// configura a linha rs dependendo do modo selecionado 
.................... 	output_bit(lcd_rs,endereco); 
01F6:  BSF    03.5
01F7:  MOVF   5F,F
01F8:  BTFSS  03.2
01F9:  GOTO   1FE
01FA:  BCF    03.5
01FB:  BCF    09.2
01FC:  GOTO   200
01FD:  BSF    03.5
01FE:  BCF    03.5
01FF:  BSF    09.2
0200:  BSF    03.5
0201:  BCF    09.2
.................... 	delay_us(100);	// aguarda 100 us 
0202:  MOVLW  A6
0203:  MOVWF  77
0204:  DECFSZ 77,F
0205:  GOTO   204
0206:  NOP
.................... 	// caso a linha rw esteja definida, coloca em 0 
.................... 	#ifdef lcd_rw 
.................... 		output_low(lcd_rw); 
.................... 	#endif 
.................... 	// desativa linha enable 
.................... 	output_low(lcd_enable); 
0207:  BCF    09.1
0208:  BCF    03.5
0209:  BCF    09.1
.................... 	// envia a primeira parte do byte 
.................... 	lcd_envia_nibble(dado >> 4); 
020A:  BSF    03.5
020B:  SWAPF  60,W
020C:  MOVWF  61
020D:  MOVLW  0F
020E:  ANDWF  61,F
020F:  MOVF   61,W
0210:  MOVWF  62
0211:  BCF    03.5
0212:  CALL   1C1
.................... 	// envia a segunda parte do byte 
.................... 	lcd_envia_nibble(dado & 0x0f); 
0213:  BSF    03.5
0214:  MOVF   60,W
0215:  ANDLW  0F
0216:  MOVWF  61
0217:  MOVWF  62
0218:  BCF    03.5
0219:  CALL   1C1
021A:  RETURN
.................... } 
....................  
....................  
.................... void lcd_ini() 
.................... // rotina de inicializaï¿½ï¿½o do display 
.................... { 
.................... 	byte conta; 
.................... 	output_low(lcd_d4); 
021B:  BSF    03.5
021C:  BCF    08.4
021D:  BCF    03.5
021E:  BCF    08.4
.................... 	output_low(lcd_d5); 
021F:  BSF    03.5
0220:  BCF    08.5
0221:  BCF    03.5
0222:  BCF    08.5
.................... 	output_low(lcd_d6); 
0223:  BSF    03.5
0224:  BCF    08.6
0225:  BCF    03.5
0226:  BCF    08.6
.................... 	output_low(lcd_d7); 
0227:  BSF    03.5
0228:  BCF    08.7
0229:  BCF    03.5
022A:  BCF    08.7
.................... 	output_low(lcd_rs); 
022B:  BSF    03.5
022C:  BCF    09.2
022D:  BCF    03.5
022E:  BCF    09.2
.................... 	#ifdef lcd_rw 
.................... 		output_high(lcd_rw); 
.................... 	#endif 
.................... 	output_low(lcd_enable); 
022F:  BSF    03.5
0230:  BCF    09.1
0231:  BCF    03.5
0232:  BCF    09.1
.................... 	delay_ms(15); 
0233:  MOVLW  0F
0234:  BSF    03.5
0235:  MOVWF  5B
0236:  BCF    03.5
0237:  CALL   1AD
.................... 	// envia uma seqï¿½ï¿½ncia de 3 vezes 0x03 
.................... 	// e depois 0x02 para configurar o mï¿½dulo 
.................... 	// para modo de 4 bits 
.................... 	for(conta=1;conta<=3;++conta) 
0238:  MOVLW  01
0239:  MOVWF  55
023A:  MOVF   55,W
023B:  SUBLW  03
023C:  BTFSS  03.0
023D:  GOTO   24A
.................... 	{ 
.................... 		lcd_envia_nibble(3); 
023E:  MOVLW  03
023F:  BSF    03.5
0240:  MOVWF  62
0241:  BCF    03.5
0242:  CALL   1C1
.................... 		delay_ms(5); 
0243:  MOVLW  05
0244:  BSF    03.5
0245:  MOVWF  5B
0246:  BCF    03.5
0247:  CALL   1AD
0248:  INCF   55,F
0249:  GOTO   23A
.................... 	} 
.................... 	lcd_envia_nibble(2); 
024A:  MOVLW  02
024B:  BSF    03.5
024C:  MOVWF  62
024D:  BCF    03.5
024E:  CALL   1C1
.................... 	// envia string de inicializaï¿½ï¿½o do display 
.................... 	for(conta=0;conta<=3;++conta) lcd_envia_byte(0,INI_LCD[conta]); 
024F:  CLRF   55
0250:  MOVF   55,W
0251:  SUBLW  03
0252:  BTFSS  03.0
0253:  GOTO   261
0254:  MOVF   55,W
0255:  CALL   058
0256:  MOVWF  56
0257:  BSF    03.5
0258:  CLRF   5F
0259:  BCF    03.5
025A:  MOVF   56,W
025B:  BSF    03.5
025C:  MOVWF  60
025D:  BCF    03.5
025E:  CALL   1F2
025F:  INCF   55,F
0260:  GOTO   250
0261:  BSF    0A.3
0262:  BCF    0A.4
0263:  GOTO   3CF (RETURN)
.................... } 
....................  
.................... void lcd_pos_xy( byte x, byte y) 
.................... { 
....................    byte endereco; 
....................    if(y!=1) 
*
0285:  DECFSZ 5C,W
0286:  GOTO   288
0287:  GOTO   28B
....................    	endereco = lcd_seg_lin; 
0288:  MOVLW  40
0289:  MOVWF  5D
028A:  GOTO   28C
....................    else 
....................    	endereco = 0; 
028B:  CLRF   5D
....................    endereco += x-1; 
028C:  MOVLW  01
028D:  SUBWF  5B,W
028E:  ADDWF  5D,F
....................    lcd_envia_byte(0,0x80|endereco); 
028F:  MOVF   5D,W
0290:  IORLW  80
0291:  MOVWF  5E
0292:  CLRF   5F
0293:  MOVF   5E,W
0294:  MOVWF  60
0295:  BCF    03.5
0296:  CALL   1F2
.................... } 
....................  
.................... void lcd_escreve( char c) 
.................... // envia caractere para o display 
.................... { 
....................    switch (c) 
*
0264:  BSF    03.5
0265:  MOVF   5A,W
0266:  XORLW  0C
0267:  BCF    03.5
0268:  BTFSC  03.2
0269:  GOTO   274
026A:  XORLW  06
026B:  BTFSC  03.2
026C:  GOTO   280
026D:  XORLW  07
026E:  BTFSC  03.2
026F:  GOTO   280
0270:  XORLW  05
0271:  BTFSC  03.2
0272:  GOTO   298
0273:  GOTO   29F
.................... 	{ 
....................      case '\f' 	:	lcd_envia_byte(0,1); 
0274:  BSF    03.5
0275:  CLRF   5F
0276:  MOVLW  01
0277:  MOVWF  60
0278:  BCF    03.5
0279:  CALL   1F2
.................... 	  			delay_ms(2); 
027A:  MOVLW  02
027B:  BSF    03.5
027C:  MOVWF  5B
027D:  BCF    03.5
027E:  CALL   1AD
.................... 				break; 
027F:  GOTO   2A6
....................      case '\n'	: 
.................... 	   case '\r' 	:	lcd_pos_xy(1,2); 
0280:  MOVLW  01
0281:  BSF    03.5
0282:  MOVWF  5B
0283:  MOVLW  02
0284:  MOVWF  5C
.................... 	  			break; 
*
0297:  GOTO   2A6
....................      case '\b' 	:	lcd_envia_byte(0,0x10); 
0298:  BSF    03.5
0299:  CLRF   5F
029A:  MOVLW  10
029B:  MOVWF  60
029C:  BCF    03.5
029D:  CALL   1F2
.................... 	  			break; 
029E:  GOTO   2A6
....................      default	:	lcd_envia_byte(1,c); 
029F:  MOVLW  01
02A0:  BSF    03.5
02A1:  MOVWF  5F
02A2:  MOVF   5A,W
02A3:  MOVWF  60
02A4:  BCF    03.5
02A5:  CALL   1F2
.................... 	  			break; 
....................    } 
02A6:  RETURN
.................... } 
....................  
.................... char lcd_le( byte x, byte y) 
.................... // le caractere do display 
.................... { 
.................... 	char valor; 
.................... 	// seleciona a posiï¿½ï¿½o do caractere 
.................... 	lcd_pos_xy(x,y); 
.................... 	// ativa rs 
.................... 	output_high(lcd_rs); 
.................... 	// lï¿½ o caractere 
.................... 	valor = lcd_le_byte(); 
.................... 	// desativa rs 
.................... 	output_low(lcd_rs); 
.................... 	// retorna o valor do caractere 
.................... 	return valor; 
.................... } 
....................  
....................  
.................... #include "2401.c" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a MicroChip 24LC01B configured for a x8 org         //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);  Read the byte d from the address a     //// 
.................... ////                                                                   //// 
.................... ////   b = ext_eeprom_ready();  Returns TRUE if the eeprom is ready    //// 
.................... ////                            to receive opcodes                     //// 
.................... ////                                                                   //// 
.................... ////   The main program may define EEPROM_SDA                          //// 
.................... ////   and EEPROM_SCL to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... ////                            Pin Layout                             //// 
.................... ////   -----------------------------------------------------------     //// 
.................... ////   |                                                         |     //// 
.................... ////   | 1: NC   Not Connected | 8: VCC   +5V                    |     //// 
.................... ////   |                       |                                 |     //// 
.................... ////   | 2: NC   Not Connected | 7: WP    GND                    |     //// 
.................... ////   |                       |                                 |     //// 
.................... ////   | 3: NC   Not Connected | 6: SCL   EEPROM_SCL and Pull-Up |     //// 
.................... ////   |                       |                                 |     //// 
.................... ////   | 4: VSS  GND           | 5: SDA   EEPROM_SDA and Pull-Up |     //// 
.................... ////   -----------------------------------------------------------     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2003 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef EEPROM_SDA 
....................  
.................... #define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C3 
....................  
.................... #endif 
....................  
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
0907:  MOVLW  08
0908:  MOVWF  78
0909:  MOVLW  04
090A:  MOVWF  77
090B:  DECFSZ 77,F
090C:  GOTO   10B
090D:  BCF    07.3
090E:  BCF    3D.3
090F:  MOVF   3D,W
0910:  BSF    03.5
0911:  MOVWF  07
0912:  MOVLW  03
0913:  MOVWF  77
0914:  DECFSZ 77,F
0915:  GOTO   114
0916:  RLF    59,F
0917:  BCF    03.5
0918:  BCF    07.4
0919:  BTFSS  03.0
091A:  GOTO   121
091B:  BSF    3D.4
091C:  MOVF   3D,W
091D:  BSF    03.5
091E:  MOVWF  07
091F:  GOTO   125
0920:  BCF    03.5
0921:  BCF    3D.4
0922:  MOVF   3D,W
0923:  BSF    03.5
0924:  MOVWF  07
0925:  NOP
0926:  BCF    03.5
0927:  BSF    3D.3
0928:  MOVF   3D,W
0929:  BSF    03.5
092A:  MOVWF  07
092B:  BCF    03.5
092C:  BTFSS  07.3
092D:  GOTO   12C
092E:  DECFSZ 78,F
092F:  GOTO   109
0930:  MOVLW  04
0931:  MOVWF  77
0932:  DECFSZ 77,F
0933:  GOTO   132
0934:  BCF    07.3
0935:  BCF    3D.3
0936:  MOVF   3D,W
0937:  BSF    03.5
0938:  MOVWF  07
0939:  NOP
093A:  BCF    03.5
093B:  BSF    3D.4
093C:  MOVF   3D,W
093D:  BSF    03.5
093E:  MOVWF  07
093F:  MOVLW  03
0940:  MOVWF  77
0941:  DECFSZ 77,F
0942:  GOTO   141
0943:  MOVLW  03
0944:  MOVWF  77
0945:  DECFSZ 77,F
0946:  GOTO   145
0947:  BCF    03.5
0948:  BSF    3D.3
0949:  MOVF   3D,W
094A:  BSF    03.5
094B:  MOVWF  07
094C:  BCF    03.5
094D:  BTFSS  07.3
094E:  GOTO   14D
094F:  CLRF   78
0950:  MOVLW  03
0951:  MOVWF  77
0952:  DECFSZ 77,F
0953:  GOTO   152
0954:  BTFSC  07.4
0955:  BSF    78.0
0956:  BCF    07.3
0957:  BCF    3D.3
0958:  MOVF   3D,W
0959:  BSF    03.5
095A:  MOVWF  07
095B:  BCF    03.5
095C:  BCF    07.4
095D:  BCF    3D.4
095E:  MOVF   3D,W
095F:  BSF    03.5
0960:  MOVWF  07
0961:  BCF    03.5
0962:  RETURN
*
0A05:  MOVLW  08
0A06:  BSF    03.5
0A07:  MOVWF  4C
0A08:  MOVF   77,W
0A09:  MOVWF  4D
0A0A:  BCF    03.5
0A0B:  BSF    3D.4
0A0C:  MOVF   3D,W
0A0D:  BSF    03.5
0A0E:  MOVWF  07
0A0F:  MOVLW  03
0A10:  MOVWF  77
0A11:  DECFSZ 77,F
0A12:  GOTO   211
0A13:  BCF    03.5
0A14:  BSF    3D.3
0A15:  MOVF   3D,W
0A16:  BSF    03.5
0A17:  MOVWF  07
0A18:  BCF    03.5
0A19:  BTFSS  07.3
0A1A:  GOTO   219
0A1B:  BTFSC  07.4
0A1C:  BSF    03.0
0A1D:  BTFSS  07.4
0A1E:  BCF    03.0
0A1F:  RLF    78,F
0A20:  MOVLW  04
0A21:  MOVWF  77
0A22:  DECFSZ 77,F
0A23:  GOTO   222
0A24:  BCF    3D.3
0A25:  MOVF   3D,W
0A26:  BSF    03.5
0A27:  MOVWF  07
0A28:  BCF    03.5
0A29:  BCF    07.3
0A2A:  BSF    03.5
0A2B:  DECFSZ 4C,F
0A2C:  GOTO   20A
0A2D:  BCF    03.5
0A2E:  BSF    3D.4
0A2F:  MOVF   3D,W
0A30:  BSF    03.5
0A31:  MOVWF  07
0A32:  MOVLW  03
0A33:  MOVWF  77
0A34:  DECFSZ 77,F
0A35:  GOTO   234
0A36:  BCF    03.5
0A37:  BCF    07.4
0A38:  BSF    03.5
0A39:  MOVF   4D,W
0A3A:  BTFSC  03.2
0A3B:  GOTO   241
0A3C:  BCF    03.5
0A3D:  BCF    3D.4
0A3E:  MOVF   3D,W
0A3F:  BSF    03.5
0A40:  MOVWF  07
0A41:  NOP
0A42:  BCF    03.5
0A43:  BSF    3D.3
0A44:  MOVF   3D,W
0A45:  BSF    03.5
0A46:  MOVWF  07
0A47:  BCF    03.5
0A48:  BTFSS  07.3
0A49:  GOTO   248
0A4A:  MOVLW  04
0A4B:  MOVWF  77
0A4C:  DECFSZ 77,F
0A4D:  GOTO   24C
0A4E:  BCF    07.3
0A4F:  BCF    3D.3
0A50:  MOVF   3D,W
0A51:  BSF    03.5
0A52:  MOVWF  07
0A53:  MOVLW  03
0A54:  MOVWF  77
0A55:  DECFSZ 77,F
0A56:  GOTO   255
0A57:  BCF    03.5
0A58:  BCF    07.4
0A59:  BCF    3D.4
0A5A:  MOVF   3D,W
0A5B:  BSF    03.5
0A5C:  MOVWF  07
....................  
.................... #define EEPROM_ADDRESS BYTE 
.................... #define EEPROM_SIZE    128 
....................  
.................... void init_ext_eeprom() { 
....................    output_float(EEPROM_SCL); 
*
01A0:  BSF    3D.3
01A1:  MOVF   3D,W
01A2:  BSF    03.5
01A3:  MOVWF  07
....................    output_float(EEPROM_SDA); 
01A4:  BCF    03.5
01A5:  BSF    3D.4
01A6:  MOVF   3D,W
01A7:  BSF    03.5
01A8:  MOVWF  07
01A9:  BCF    03.5
01AA:  BSF    0A.3
01AB:  BCF    0A.4
01AC:  GOTO   3C6 (RETURN)
.................... } 
....................  
.................... BOOLEAN ext_eeprom_ready() { 
....................    int1 ack; 
....................    i2c_start();            // If the write command is acknowledged, 
*
0963:  BSF    3D.4
0964:  MOVF   3D,W
0965:  BSF    03.5
0966:  MOVWF  07
0967:  MOVLW  04
0968:  MOVWF  77
0969:  DECFSZ 77,F
096A:  GOTO   169
096B:  BCF    03.5
096C:  BSF    3D.3
096D:  MOVF   3D,W
096E:  BSF    03.5
096F:  MOVWF  07
0970:  MOVLW  03
0971:  MOVWF  77
0972:  DECFSZ 77,F
0973:  GOTO   172
0974:  BCF    03.5
0975:  BCF    07.4
0976:  BCF    3D.4
0977:  MOVF   3D,W
0978:  BSF    03.5
0979:  MOVWF  07
097A:  MOVLW  04
097B:  MOVWF  77
097C:  DECFSZ 77,F
097D:  GOTO   17C
097E:  BCF    03.5
097F:  BCF    07.3
0980:  BCF    3D.3
0981:  MOVF   3D,W
0982:  BSF    03.5
0983:  MOVWF  07
....................    ack = i2c_write(0xa0);  // then the device is ready. 
0984:  MOVLW  A0
0985:  MOVWF  59
0986:  BCF    03.5
0987:  CALL   107
0988:  MOVF   78,W
0989:  BSF    03.5
098A:  BCF    58.0
098B:  BTFSC  78.0
098C:  BSF    58.0
....................    i2c_stop(); 
098D:  BCF    03.5
098E:  BCF    3D.4
098F:  MOVF   3D,W
0990:  BSF    03.5
0991:  MOVWF  07
0992:  NOP
0993:  BCF    03.5
0994:  BSF    3D.3
0995:  MOVF   3D,W
0996:  BSF    03.5
0997:  MOVWF  07
0998:  BCF    03.5
0999:  BTFSS  07.3
099A:  GOTO   199
099B:  MOVLW  04
099C:  MOVWF  77
099D:  DECFSZ 77,F
099E:  GOTO   19D
099F:  GOTO   1A0
09A0:  NOP
09A1:  BSF    3D.4
09A2:  MOVF   3D,W
09A3:  BSF    03.5
09A4:  MOVWF  07
09A5:  MOVLW  04
09A6:  MOVWF  77
09A7:  DECFSZ 77,F
09A8:  GOTO   1A7
....................    return !ack; 
09A9:  MOVLW  00
09AA:  BTFSS  58.0
09AB:  MOVLW  01
09AC:  MOVWF  78
09AD:  BCF    03.5
09AE:  RETURN
.................... } 
....................  
.................... void write_ext_eeprom(BYTE address, BYTE data) { 
....................    while(!ext_eeprom_ready()); 
*
0B28:  CALL   163
0B29:  MOVF   78,F
0B2A:  BTFSC  03.2
0B2B:  GOTO   328
....................    i2c_start(); 
0B2C:  BSF    3D.4
0B2D:  MOVF   3D,W
0B2E:  BSF    03.5
0B2F:  MOVWF  07
0B30:  MOVLW  04
0B31:  MOVWF  77
0B32:  DECFSZ 77,F
0B33:  GOTO   332
0B34:  BCF    03.5
0B35:  BSF    3D.3
0B36:  MOVF   3D,W
0B37:  BSF    03.5
0B38:  MOVWF  07
0B39:  MOVLW  03
0B3A:  MOVWF  77
0B3B:  DECFSZ 77,F
0B3C:  GOTO   33B
0B3D:  BCF    03.5
0B3E:  BCF    07.4
0B3F:  BCF    3D.4
0B40:  MOVF   3D,W
0B41:  BSF    03.5
0B42:  MOVWF  07
0B43:  MOVLW  04
0B44:  MOVWF  77
0B45:  DECFSZ 77,F
0B46:  GOTO   345
0B47:  BCF    03.5
0B48:  BCF    07.3
0B49:  BCF    3D.3
0B4A:  MOVF   3D,W
0B4B:  BSF    03.5
0B4C:  MOVWF  07
....................    i2c_write(0xa0); 
0B4D:  MOVLW  A0
0B4E:  MOVWF  59
0B4F:  BCF    03.5
0B50:  CALL   107
....................    i2c_write(address); 
0B51:  BSF    03.5
0B52:  MOVF   56,W
0B53:  MOVWF  59
0B54:  BCF    03.5
0B55:  CALL   107
....................    i2c_write(data); 
0B56:  BSF    03.5
0B57:  MOVF   57,W
0B58:  MOVWF  59
0B59:  BCF    03.5
0B5A:  CALL   107
....................    i2c_stop(); 
0B5B:  BCF    3D.4
0B5C:  MOVF   3D,W
0B5D:  BSF    03.5
0B5E:  MOVWF  07
0B5F:  NOP
0B60:  BCF    03.5
0B61:  BSF    3D.3
0B62:  MOVF   3D,W
0B63:  BSF    03.5
0B64:  MOVWF  07
0B65:  BCF    03.5
0B66:  BTFSS  07.3
0B67:  GOTO   366
0B68:  MOVLW  04
0B69:  MOVWF  77
0B6A:  DECFSZ 77,F
0B6B:  GOTO   36A
0B6C:  GOTO   36D
0B6D:  NOP
0B6E:  BSF    3D.4
0B6F:  MOVF   3D,W
0B70:  BSF    03.5
0B71:  MOVWF  07
0B72:  MOVLW  04
0B73:  MOVWF  77
0B74:  DECFSZ 77,F
0B75:  GOTO   374
0B76:  BCF    03.5
0B77:  RETURN
.................... } 
....................  
....................  
.................... BYTE read_ext_eeprom(BYTE address) { 
....................    BYTE data; 
....................  
....................    while(!ext_eeprom_ready()); 
*
09AF:  CALL   163
09B0:  MOVF   78,F
09B1:  BTFSC  03.2
09B2:  GOTO   1AF
....................    i2c_start(); 
09B3:  BSF    3D.4
09B4:  MOVF   3D,W
09B5:  BSF    03.5
09B6:  MOVWF  07
09B7:  MOVLW  04
09B8:  MOVWF  77
09B9:  DECFSZ 77,F
09BA:  GOTO   1B9
09BB:  BCF    03.5
09BC:  BSF    3D.3
09BD:  MOVF   3D,W
09BE:  BSF    03.5
09BF:  MOVWF  07
09C0:  MOVLW  03
09C1:  MOVWF  77
09C2:  DECFSZ 77,F
09C3:  GOTO   1C2
09C4:  BCF    03.5
09C5:  BCF    07.4
09C6:  BCF    3D.4
09C7:  MOVF   3D,W
09C8:  BSF    03.5
09C9:  MOVWF  07
09CA:  MOVLW  04
09CB:  MOVWF  77
09CC:  DECFSZ 77,F
09CD:  GOTO   1CC
09CE:  BCF    03.5
09CF:  BCF    07.3
09D0:  BCF    3D.3
09D1:  MOVF   3D,W
09D2:  BSF    03.5
09D3:  MOVWF  07
....................    i2c_write(0xa0); 
09D4:  MOVLW  A0
09D5:  MOVWF  59
09D6:  BCF    03.5
09D7:  CALL   107
....................    i2c_write(address); 
09D8:  BSF    03.5
09D9:  MOVF   49,W
09DA:  MOVWF  59
09DB:  BCF    03.5
09DC:  CALL   107
....................    i2c_start(); 
09DD:  BSF    3D.4
09DE:  MOVF   3D,W
09DF:  BSF    03.5
09E0:  MOVWF  07
09E1:  MOVLW  04
09E2:  MOVWF  77
09E3:  DECFSZ 77,F
09E4:  GOTO   1E3
09E5:  BCF    03.5
09E6:  BSF    3D.3
09E7:  MOVF   3D,W
09E8:  BSF    03.5
09E9:  MOVWF  07
09EA:  MOVLW  03
09EB:  MOVWF  77
09EC:  DECFSZ 77,F
09ED:  GOTO   1EC
09EE:  BCF    03.5
09EF:  BTFSS  07.3
09F0:  GOTO   1EF
09F1:  BCF    07.4
09F2:  BCF    3D.4
09F3:  MOVF   3D,W
09F4:  BSF    03.5
09F5:  MOVWF  07
09F6:  MOVLW  04
09F7:  MOVWF  77
09F8:  DECFSZ 77,F
09F9:  GOTO   1F8
09FA:  BCF    03.5
09FB:  BCF    07.3
09FC:  BCF    3D.3
09FD:  MOVF   3D,W
09FE:  BSF    03.5
09FF:  MOVWF  07
....................    i2c_write(0xa1); 
0A00:  MOVLW  A1
0A01:  MOVWF  59
0A02:  BCF    03.5
0A03:  CALL   107
....................    data=i2c_read(0); 
0A04:  CLRF   77
*
0A5D:  MOVF   78,W
0A5E:  MOVWF  4A
....................    i2c_stop(); 
0A5F:  BCF    03.5
0A60:  BCF    3D.4
0A61:  MOVF   3D,W
0A62:  BSF    03.5
0A63:  MOVWF  07
0A64:  NOP
0A65:  BCF    03.5
0A66:  BSF    3D.3
0A67:  MOVF   3D,W
0A68:  BSF    03.5
0A69:  MOVWF  07
0A6A:  BCF    03.5
0A6B:  BTFSS  07.3
0A6C:  GOTO   26B
0A6D:  MOVLW  04
0A6E:  MOVWF  77
0A6F:  DECFSZ 77,F
0A70:  GOTO   26F
0A71:  GOTO   272
0A72:  NOP
0A73:  BSF    3D.4
0A74:  MOVF   3D,W
0A75:  BSF    03.5
0A76:  MOVWF  07
0A77:  MOVLW  04
0A78:  MOVWF  77
0A79:  DECFSZ 77,F
0A7A:  GOTO   279
....................    return(data); 
0A7B:  MOVF   4A,W
0A7C:  MOVWF  78
0A7D:  BCF    03.5
0A7E:  RETURN
.................... } 
....................  
.................... #include "kbd_board4.c" 
.................... /*######################################################################  
....................    Rotina utilização do teclado da placa PicSim board4 
....................    Adaptada para o compilador CCS 
....................    Autor: Alberto Willia Mascarenhas (adaptou para o compilador) 
....................    For e-mail suggestions :  awmascarenhas@gmail.com 
.................... ######################################################################## */ 
.................... unsigned char tc_tecla(unsigned int timeout) 
*
031E:  CLRF   58
031F:  CLRF   59
.................... { 
....................   unsigned int to=0; 
....................   unsigned char k = 0;   
....................   while(((to < timeout)||(!timeout))&&(!k)){ 
0320:  MOVF   57,W
0321:  SUBWF  58,W
0322:  BTFSS  03.0
0323:  GOTO   327
0324:  MOVF   57,F
0325:  BTFSS  03.2
0326:  GOTO   466
0327:  MOVF   59,F
0328:  BTFSS  03.2
0329:  GOTO   466
....................       
....................        
....................       //------------------------------------------------------------------------- 
....................       //inicio do programa de varredura do teclado matricial 
....................       //-------------------------------------------------------------------------- 
....................       //habilita primeira coluna do teclado 
....................       output_low(PIN_B0);output_high(PIN_B1);output_high(PIN_B2);output_high(PIN_B3); 
032A:  BCF    06.0
032B:  BCF    03.5
032C:  BCF    06.0
032D:  BSF    03.5
032E:  BCF    06.1
032F:  BCF    03.5
0330:  BSF    06.1
0331:  BSF    03.5
0332:  BCF    06.2
0333:  BCF    03.5
0334:  BSF    06.2
0335:  BSF    03.5
0336:  BCF    06.3
0337:  BCF    03.5
0338:  BSF    06.3
....................       delay_ms(20); 
0339:  MOVLW  14
033A:  BSF    03.5
033B:  MOVWF  5B
033C:  BCF    03.5
033D:  CALL   1AD
....................       if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='1';}; 
033E:  BSF    03.5
033F:  BSF    08.0
0340:  BCF    03.5
0341:  BTFSC  08.0
0342:  GOTO   34C
0343:  BSF    03.5
0344:  BSF    08.0
0345:  BCF    03.5
0346:  BTFSS  08.0
0347:  GOTO   343
0348:  MOVLW  31
0349:  BSF    03.5
034A:  MOVWF  59
034B:  BCF    03.5
....................       if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='4';}; 
034C:  BSF    03.5
034D:  BSF    08.1
034E:  BCF    03.5
034F:  BTFSC  08.1
0350:  GOTO   35A
0351:  BSF    03.5
0352:  BSF    08.1
0353:  BCF    03.5
0354:  BTFSS  08.1
0355:  GOTO   351
0356:  MOVLW  34
0357:  BSF    03.5
0358:  MOVWF  59
0359:  BCF    03.5
....................       if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='7';}; 
035A:  BSF    03.5
035B:  BSF    08.2
035C:  BCF    03.5
035D:  BTFSC  08.2
035E:  GOTO   368
035F:  BSF    03.5
0360:  BSF    08.2
0361:  BCF    03.5
0362:  BTFSS  08.2
0363:  GOTO   35F
0364:  MOVLW  37
0365:  BSF    03.5
0366:  MOVWF  59
0367:  BCF    03.5
....................       if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='*';}; 
0368:  BSF    03.5
0369:  BSF    08.3
036A:  BCF    03.5
036B:  BTFSC  08.3
036C:  GOTO   376
036D:  BSF    03.5
036E:  BSF    08.3
036F:  BCF    03.5
0370:  BTFSS  08.3
0371:  GOTO   36D
0372:  MOVLW  2A
0373:  BSF    03.5
0374:  MOVWF  59
0375:  BCF    03.5
....................       //habilita segunda coluna do teclado 
....................       output_high(PIN_B0);output_low(PIN_B1);output_high(PIN_B2);output_high(PIN_B3); 
0376:  BSF    03.5
0377:  BCF    06.0
0378:  BCF    03.5
0379:  BSF    06.0
037A:  BSF    03.5
037B:  BCF    06.1
037C:  BCF    03.5
037D:  BCF    06.1
037E:  BSF    03.5
037F:  BCF    06.2
0380:  BCF    03.5
0381:  BSF    06.2
0382:  BSF    03.5
0383:  BCF    06.3
0384:  BCF    03.5
0385:  BSF    06.3
....................       delay_ms(20);       
0386:  MOVLW  14
0387:  BSF    03.5
0388:  MOVWF  5B
0389:  BCF    03.5
038A:  CALL   1AD
....................       if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='2';}; 
038B:  BSF    03.5
038C:  BSF    08.0
038D:  BCF    03.5
038E:  BTFSC  08.0
038F:  GOTO   399
0390:  BSF    03.5
0391:  BSF    08.0
0392:  BCF    03.5
0393:  BTFSS  08.0
0394:  GOTO   390
0395:  MOVLW  32
0396:  BSF    03.5
0397:  MOVWF  59
0398:  BCF    03.5
....................       if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='5';}; 
0399:  BSF    03.5
039A:  BSF    08.1
039B:  BCF    03.5
039C:  BTFSC  08.1
039D:  GOTO   3A7
039E:  BSF    03.5
039F:  BSF    08.1
03A0:  BCF    03.5
03A1:  BTFSS  08.1
03A2:  GOTO   39E
03A3:  MOVLW  35
03A4:  BSF    03.5
03A5:  MOVWF  59
03A6:  BCF    03.5
....................       if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='8';}; 
03A7:  BSF    03.5
03A8:  BSF    08.2
03A9:  BCF    03.5
03AA:  BTFSC  08.2
03AB:  GOTO   3B5
03AC:  BSF    03.5
03AD:  BSF    08.2
03AE:  BCF    03.5
03AF:  BTFSS  08.2
03B0:  GOTO   3AC
03B1:  MOVLW  38
03B2:  BSF    03.5
03B3:  MOVWF  59
03B4:  BCF    03.5
....................       if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='0';}; 
03B5:  BSF    03.5
03B6:  BSF    08.3
03B7:  BCF    03.5
03B8:  BTFSC  08.3
03B9:  GOTO   3C3
03BA:  BSF    03.5
03BB:  BSF    08.3
03BC:  BCF    03.5
03BD:  BTFSS  08.3
03BE:  GOTO   3BA
03BF:  MOVLW  30
03C0:  BSF    03.5
03C1:  MOVWF  59
03C2:  BCF    03.5
....................        
....................       //habilita terceira coluna do teclado 
....................       output_high(PIN_B0);output_high(PIN_B1);output_low(PIN_B2);output_high(PIN_B3); 
03C3:  BSF    03.5
03C4:  BCF    06.0
03C5:  BCF    03.5
03C6:  BSF    06.0
03C7:  BSF    03.5
03C8:  BCF    06.1
03C9:  BCF    03.5
03CA:  BSF    06.1
03CB:  BSF    03.5
03CC:  BCF    06.2
03CD:  BCF    03.5
03CE:  BCF    06.2
03CF:  BSF    03.5
03D0:  BCF    06.3
03D1:  BCF    03.5
03D2:  BSF    06.3
....................       delay_ms(20);       
03D3:  MOVLW  14
03D4:  BSF    03.5
03D5:  MOVWF  5B
03D6:  BCF    03.5
03D7:  CALL   1AD
....................       if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='3';}; 
03D8:  BSF    03.5
03D9:  BSF    08.0
03DA:  BCF    03.5
03DB:  BTFSC  08.0
03DC:  GOTO   3E6
03DD:  BSF    03.5
03DE:  BSF    08.0
03DF:  BCF    03.5
03E0:  BTFSS  08.0
03E1:  GOTO   3DD
03E2:  MOVLW  33
03E3:  BSF    03.5
03E4:  MOVWF  59
03E5:  BCF    03.5
....................       if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='6';}; 
03E6:  BSF    03.5
03E7:  BSF    08.1
03E8:  BCF    03.5
03E9:  BTFSC  08.1
03EA:  GOTO   3F4
03EB:  BSF    03.5
03EC:  BSF    08.1
03ED:  BCF    03.5
03EE:  BTFSS  08.1
03EF:  GOTO   3EB
03F0:  MOVLW  36
03F1:  BSF    03.5
03F2:  MOVWF  59
03F3:  BCF    03.5
....................       if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='9';}; 
03F4:  BSF    03.5
03F5:  BSF    08.2
03F6:  BCF    03.5
03F7:  BTFSC  08.2
03F8:  GOTO   402
03F9:  BSF    03.5
03FA:  BSF    08.2
03FB:  BCF    03.5
03FC:  BTFSS  08.2
03FD:  GOTO   3F9
03FE:  MOVLW  39
03FF:  BSF    03.5
0400:  MOVWF  59
0401:  BCF    03.5
....................       if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='#';}; 
0402:  BSF    03.5
0403:  BSF    08.3
0404:  BCF    03.5
0405:  BTFSC  08.3
0406:  GOTO   410
0407:  BSF    03.5
0408:  BSF    08.3
0409:  BCF    03.5
040A:  BTFSS  08.3
040B:  GOTO   407
040C:  MOVLW  23
040D:  BSF    03.5
040E:  MOVWF  59
040F:  BCF    03.5
....................   
....................        //habilita quarta coluna do teclado 
....................       output_high(PIN_B0);output_high(PIN_B1);output_high(PIN_B2);output_low(PIN_B3); 
0410:  BSF    03.5
0411:  BCF    06.0
0412:  BCF    03.5
0413:  BSF    06.0
0414:  BSF    03.5
0415:  BCF    06.1
0416:  BCF    03.5
0417:  BSF    06.1
0418:  BSF    03.5
0419:  BCF    06.2
041A:  BCF    03.5
041B:  BSF    06.2
041C:  BSF    03.5
041D:  BCF    06.3
041E:  BCF    03.5
041F:  BCF    06.3
....................       delay_ms(20);       
0420:  MOVLW  14
0421:  BSF    03.5
0422:  MOVWF  5B
0423:  BCF    03.5
0424:  CALL   1AD
....................       if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='A';}; 
0425:  BSF    03.5
0426:  BSF    08.0
0427:  BCF    03.5
0428:  BTFSC  08.0
0429:  GOTO   433
042A:  BSF    03.5
042B:  BSF    08.0
042C:  BCF    03.5
042D:  BTFSS  08.0
042E:  GOTO   42A
042F:  MOVLW  41
0430:  BSF    03.5
0431:  MOVWF  59
0432:  BCF    03.5
....................       if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='B';}; 
0433:  BSF    03.5
0434:  BSF    08.1
0435:  BCF    03.5
0436:  BTFSC  08.1
0437:  GOTO   441
0438:  BSF    03.5
0439:  BSF    08.1
043A:  BCF    03.5
043B:  BTFSS  08.1
043C:  GOTO   438
043D:  MOVLW  42
043E:  BSF    03.5
043F:  MOVWF  59
0440:  BCF    03.5
....................       if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='C';}; 
0441:  BSF    03.5
0442:  BSF    08.2
0443:  BCF    03.5
0444:  BTFSC  08.2
0445:  GOTO   44F
0446:  BSF    03.5
0447:  BSF    08.2
0448:  BCF    03.5
0449:  BTFSS  08.2
044A:  GOTO   446
044B:  MOVLW  43
044C:  BSF    03.5
044D:  MOVWF  59
044E:  BCF    03.5
....................       if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='D';}; 
044F:  BSF    03.5
0450:  BSF    08.3
0451:  BCF    03.5
0452:  BTFSC  08.3
0453:  GOTO   45D
0454:  BSF    03.5
0455:  BSF    08.3
0456:  BCF    03.5
0457:  BTFSS  08.3
0458:  GOTO   454
0459:  MOVLW  44
045A:  BSF    03.5
045B:  MOVWF  59
045C:  BCF    03.5
....................   
....................       //printf (lcd_escreve,"\f saiu geral %u",k); 
....................       //delay_ms(1000); 
....................       delay_ms(5); 
045D:  MOVLW  05
045E:  BSF    03.5
045F:  MOVWF  5B
0460:  BCF    03.5
0461:  CALL   1AD
....................       to+=5; 
0462:  MOVLW  05
0463:  BSF    03.5
0464:  ADDWF  58,F
0465:  GOTO   320
....................   } 
....................    if(!k)k=255; 
0466:  MOVF   59,F
0467:  BTFSS  03.2
0468:  GOTO   46B
0469:  MOVLW  FF
046A:  MOVWF  59
....................   return k;   
046B:  MOVF   59,W
046C:  MOVWF  78
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /* 
.................... int status -> 0 - Unpaid, 1 - Paid, 3 - Admin 
.................... int chooseAddr: 
....................          Param < 0 - SAVE in a available address to CREATE  
....................          Param >= 0 - SAVE in a existing address to OVERWRITE (edit) 
.................... */ 
.................... void saveUser(int * id, int * pass, int status); 
.................... int getAddressByID(int * id);    
.................... void searchUser(int * id); 
.................... int deleteUser(int * id); 
.................... void editUser(); 
.................... void updateUser(int * id, int * pass, int status); 
....................  
.................... // int isIdAvailable(int id);     
.................... void printUser(); 
.................... void erase_program_eeprom(int addrr); 
.................... int incrementID(); 
.................... int lastNewUserPosition(); 
.................... void resetMemory(); 
.................... void adminMenu(); 
.................... unsigned char readKeyboard();  
.................... int * getAdminsID(); 
.................... void listAdmins(); 
.................... int * strToInt(char * str); 
.................... char * strfromchar(char destination[], char source); 
.................... int * inputId(); 
.................... int * inputToKeyboard(char * msg, int max); 
.................... void inputKeyboardUser(); 
....................  
....................  
.................... typedef struct {  
....................    int id[2];   
....................    int pass[4]; //password 
....................    int status; //0 - Unpaid, 1 - Paid, 3 - Admin 
.................... }User; 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
*
04FA:  BSF    03.6
04FB:  MOVF   37,W
04FC:  MOVWF  3A
....................    for(su=s;0<n;++su,--n) 
04FD:  MOVF   36,W
04FE:  MOVWF  3C
04FF:  MOVF   35,W
0500:  MOVWF  3B
0501:  MOVF   39,F
0502:  BTFSS  03.2
0503:  GOTO   508
0504:  MOVF   38,W
0505:  SUBLW  00
0506:  BTFSC  03.0
0507:  GOTO   520
....................       if(*su==uc) 
0508:  MOVF   3C,W
0509:  MOVWF  7A
050A:  MOVF   3B,W
050B:  MOVWF  04
050C:  BCF    03.7
050D:  BTFSC  7A.0
050E:  BSF    03.7
050F:  MOVF   3A,W
0510:  SUBWF  00,W
0511:  BTFSS  03.2
0512:  GOTO   518
....................       return su; 
0513:  MOVF   3B,W
0514:  MOVWF  78
0515:  MOVF   3C,W
0516:  MOVWF  79
0517:  GOTO   523
0518:  INCF   3B,F
0519:  BTFSC  03.2
051A:  INCF   3C,F
051B:  MOVF   38,W
051C:  BTFSC  03.2
051D:  DECF   39,F
051E:  DECF   38,F
051F:  GOTO   501
....................    return NULL; 
0520:  MOVLW  00
0521:  MOVWF  78
0522:  MOVWF  79
0523:  BCF    03.6
0524:  RETURN
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
0BAA:  BCF    03.5
0BAB:  CLRF   3E
0BAC:  CLRF   3F
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
*
0525:  BSF    03.5
0526:  CLRF   69
0527:  CLRF   68
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
0528:  MOVLW  30
0529:  BCF    03.5
052A:  BSF    03.6
052B:  MOVWF  10
052C:  MOVLW  31
052D:  MOVWF  11
052E:  MOVLW  32
052F:  MOVWF  12
0530:  MOVLW  33
0531:  MOVWF  13
0532:  MOVLW  34
0533:  MOVWF  14
0534:  MOVLW  35
0535:  MOVWF  15
0536:  MOVLW  36
0537:  MOVWF  16
0538:  MOVLW  37
0539:  MOVWF  17
053A:  MOVLW  38
053B:  MOVWF  18
053C:  MOVLW  39
053D:  MOVWF  19
053E:  MOVLW  61
053F:  MOVWF  1A
0540:  MOVLW  62
0541:  MOVWF  1B
0542:  MOVLW  63
0543:  MOVWF  1C
0544:  MOVLW  64
0545:  MOVWF  1D
0546:  MOVLW  65
0547:  MOVWF  1E
0548:  MOVLW  66
0549:  MOVWF  1F
054A:  MOVLW  67
054B:  MOVWF  20
054C:  MOVLW  68
054D:  MOVWF  21
054E:  MOVLW  69
054F:  MOVWF  22
0550:  MOVLW  6A
0551:  MOVWF  23
0552:  MOVLW  6B
0553:  MOVWF  24
0554:  MOVLW  6C
0555:  MOVWF  25
0556:  MOVLW  6D
0557:  MOVWF  26
0558:  MOVLW  6E
0559:  MOVWF  27
055A:  MOVLW  6F
055B:  MOVWF  28
055C:  MOVLW  70
055D:  MOVWF  29
055E:  MOVLW  71
055F:  MOVWF  2A
0560:  MOVLW  73
0561:  MOVWF  2B
0562:  MOVLW  74
0563:  MOVWF  2C
0564:  MOVLW  75
0565:  MOVWF  2D
0566:  MOVLW  76
0567:  MOVWF  2E
0568:  MOVLW  77
0569:  MOVWF  2F
056A:  MOVLW  78
056B:  MOVWF  30
056C:  MOVLW  79
056D:  MOVWF  31
056E:  MOVLW  7A
056F:  MOVWF  32
0570:  CLRF   33
....................    for(sc=s;isspace(*sc);++sc); 
0571:  BSF    03.5
0572:  BCF    03.6
0573:  MOVF   5E,W
0574:  MOVWF  63
0575:  MOVF   5D,W
0576:  MOVWF  62
0577:  MOVF   63,W
0578:  MOVWF  7A
0579:  MOVF   62,W
057A:  MOVWF  04
057B:  BCF    03.7
057C:  BTFSC  7A.0
057D:  BSF    03.7
057E:  MOVF   00,W
057F:  SUBLW  20
0580:  BTFSS  03.2
0581:  GOTO   586
0582:  INCF   62,F
0583:  BTFSC  03.2
0584:  INCF   63,F
0585:  GOTO   577
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
0586:  MOVF   63,W
0587:  MOVWF  7A
0588:  MOVF   62,W
0589:  MOVWF  04
058A:  BCF    03.7
058B:  BTFSC  63.0
058C:  BSF    03.7
058D:  MOVF   00,W
058E:  SUBLW  2D
058F:  BTFSC  03.2
0590:  GOTO   59C
0591:  MOVF   63,W
0592:  MOVWF  7A
0593:  MOVF   62,W
0594:  MOVWF  04
0595:  BCF    03.7
0596:  BTFSC  63.0
0597:  BSF    03.7
0598:  MOVF   00,W
0599:  SUBLW  2B
059A:  BTFSS  03.2
059B:  GOTO   5A8
059C:  MOVF   63,W
059D:  MOVWF  7A
059E:  MOVF   62,W
059F:  INCF   62,F
05A0:  BTFSC  03.2
05A1:  INCF   63,F
05A2:  MOVWF  04
05A3:  BCF    03.7
05A4:  BTFSC  7A.0
05A5:  BSF    03.7
05A6:  MOVF   00,W
05A7:  GOTO   5A9
05A8:  MOVLW  2B
05A9:  MOVWF  6A
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
05AA:  MOVF   6A,W
05AB:  SUBLW  2D
05AC:  BTFSC  03.2
05AD:  GOTO   5B9
05AE:  BTFSC  61.7
05AF:  GOTO   5B9
05B0:  DECFSZ 61,W
05B1:  GOTO   5B3
05B2:  GOTO   5B9
05B3:  BTFSC  61.7
05B4:  GOTO   5BB
05B5:  MOVF   61,W
05B6:  SUBLW  24
05B7:  BTFSC  03.0
05B8:  GOTO   5BB
....................    goto StrtoulGO; 
05B9:  GOTO   739
05BA:  GOTO   651
....................  
....................    else if (base) 
05BB:  MOVF   61,F
05BC:  BTFSC  03.2
05BD:  GOTO   616
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
05BE:  MOVF   61,W
05BF:  SUBLW  10
05C0:  BTFSS  03.2
05C1:  GOTO   5E5
05C2:  MOVF   63,W
05C3:  MOVWF  7A
05C4:  MOVF   62,W
05C5:  MOVWF  04
05C6:  BCF    03.7
05C7:  BTFSC  7A.0
05C8:  BSF    03.7
05C9:  MOVF   00,W
05CA:  SUBLW  30
05CB:  BTFSS  03.2
05CC:  GOTO   5E5
05CD:  MOVLW  01
05CE:  ADDWF  62,W
05CF:  MOVWF  04
05D0:  BCF    03.7
05D1:  BTFSC  63.0
05D2:  BSF    03.7
05D3:  MOVF   00,W
05D4:  SUBLW  78
05D5:  BTFSC  03.2
05D6:  GOTO   5E1
05D7:  MOVLW  01
05D8:  ADDWF  62,W
05D9:  MOVWF  04
05DA:  BCF    03.7
05DB:  BTFSC  63.0
05DC:  BSF    03.7
05DD:  MOVF   00,W
05DE:  SUBLW  58
05DF:  BTFSS  03.2
05E0:  GOTO   5E5
....................          sc+=2; 
05E1:  MOVLW  02
05E2:  ADDWF  62,F
05E3:  BTFSC  03.0
05E4:  INCF   63,F
....................       if(base==8 && *sc =='0') 
05E5:  MOVF   61,W
05E6:  SUBLW  08
05E7:  BTFSS  03.2
05E8:  GOTO   5F8
05E9:  MOVF   63,W
05EA:  MOVWF  7A
05EB:  MOVF   62,W
05EC:  MOVWF  04
05ED:  BCF    03.7
05EE:  BTFSC  7A.0
05EF:  BSF    03.7
05F0:  MOVF   00,W
05F1:  SUBLW  30
05F2:  BTFSS  03.2
05F3:  GOTO   5F8
....................          sc+=1; 
05F4:  MOVLW  01
05F5:  ADDWF  62,F
05F6:  BTFSC  03.0
05F7:  INCF   63,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
05F8:  MOVF   61,W
05F9:  SUBLW  02
05FA:  BTFSS  03.2
05FB:  GOTO   615
05FC:  MOVF   63,W
05FD:  MOVWF  7A
05FE:  MOVF   62,W
05FF:  MOVWF  04
0600:  BCF    03.7
0601:  BTFSC  7A.0
0602:  BSF    03.7
0603:  MOVF   00,W
0604:  SUBLW  30
0605:  BTFSS  03.2
0606:  GOTO   615
0607:  MOVLW  01
0608:  ADDWF  62,W
0609:  MOVWF  04
060A:  BCF    03.7
060B:  BTFSC  63.0
060C:  BSF    03.7
060D:  MOVF   00,W
060E:  SUBLW  62
060F:  BTFSS  03.2
0610:  GOTO   615
....................          sc+=2; 
0611:  MOVLW  02
0612:  ADDWF  62,F
0613:  BTFSC  03.0
0614:  INCF   63,F
....................  
....................    } 
0615:  GOTO   651
....................    else if(*sc!='0') // base is 0, find base 
0616:  MOVF   63,W
0617:  MOVWF  7A
0618:  MOVF   62,W
0619:  MOVWF  04
061A:  BCF    03.7
061B:  BTFSC  7A.0
061C:  BSF    03.7
061D:  MOVF   00,W
061E:  SUBLW  30
061F:  BTFSC  03.2
0620:  GOTO   624
....................       base=10; 
0621:  MOVLW  0A
0622:  MOVWF  61
0623:  GOTO   651
....................    else if (sc[1]=='x' || sc[1]=='X') 
0624:  MOVLW  01
0625:  ADDWF  62,W
0626:  MOVWF  04
0627:  BCF    03.7
0628:  BTFSC  63.0
0629:  BSF    03.7
062A:  MOVF   00,W
062B:  SUBLW  78
062C:  BTFSC  03.2
062D:  GOTO   638
062E:  MOVLW  01
062F:  ADDWF  62,W
0630:  MOVWF  04
0631:  BCF    03.7
0632:  BTFSC  63.0
0633:  BSF    03.7
0634:  MOVF   00,W
0635:  SUBLW  58
0636:  BTFSS  03.2
0637:  GOTO   63F
....................       base =16,sc+=2; 
0638:  MOVLW  10
0639:  MOVWF  61
063A:  MOVLW  02
063B:  ADDWF  62,F
063C:  BTFSC  03.0
063D:  INCF   63,F
063E:  GOTO   651
....................    else if(sc[1]=='b') 
063F:  MOVLW  01
0640:  ADDWF  62,W
0641:  MOVWF  04
0642:  BCF    03.7
0643:  BTFSC  63.0
0644:  BSF    03.7
0645:  MOVF   00,W
0646:  SUBLW  62
0647:  BTFSS  03.2
0648:  GOTO   64F
....................       base=2,sc+=2; 
0649:  MOVLW  02
064A:  MOVWF  61
064B:  ADDWF  62,F
064C:  BTFSC  03.0
064D:  INCF   63,F
064E:  GOTO   651
....................    else 
....................       base=8; 
064F:  MOVLW  08
0650:  MOVWF  61
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
0651:  MOVF   63,W
0652:  MOVWF  65
0653:  MOVF   62,W
0654:  MOVWF  64
0655:  MOVF   63,W
0656:  MOVWF  7A
0657:  MOVF   62,W
0658:  MOVWF  04
0659:  BCF    03.7
065A:  BTFSC  7A.0
065B:  BSF    03.7
065C:  MOVF   00,W
065D:  SUBLW  30
065E:  BTFSS  03.2
065F:  GOTO   664
0660:  INCF   62,F
0661:  BTFSC  03.2
0662:  INCF   63,F
0663:  GOTO   655
....................    sd=memchr(digits,tolower(*sc),base); 
0664:  MOVF   63,W
0665:  MOVWF  7A
0666:  MOVF   62,W
0667:  MOVWF  04
0668:  BCF    03.7
0669:  BTFSC  63.0
066A:  BSF    03.7
066B:  MOVF   00,W
066C:  MOVWF  6B
066D:  SUBLW  40
066E:  BTFSC  03.0
066F:  GOTO   677
0670:  MOVF   6B,W
0671:  SUBLW  5A
0672:  BTFSS  03.0
0673:  GOTO   677
0674:  MOVF   6B,W
0675:  IORLW  20
0676:  GOTO   678
0677:  MOVF   6B,W
0678:  MOVWF  6B
0679:  MOVLW  01
067A:  BCF    03.5
067B:  BSF    03.6
067C:  MOVWF  36
067D:  MOVLW  10
067E:  MOVWF  35
067F:  BSF    03.5
0680:  BCF    03.6
0681:  MOVF   6B,W
0682:  BCF    03.5
0683:  BSF    03.6
0684:  MOVWF  37
0685:  CLRF   39
0686:  BSF    03.5
0687:  BCF    03.6
0688:  MOVF   61,W
0689:  BCF    03.5
068A:  BSF    03.6
068B:  MOVWF  38
068C:  BCF    03.6
068D:  CALL   4FA
068E:  MOVF   79,W
068F:  BSF    03.5
0690:  MOVWF  67
0691:  MOVF   78,W
0692:  MOVWF  66
....................    for(; sd!=0; ) 
0693:  MOVF   66,F
0694:  BTFSS  03.2
0695:  GOTO   699
0696:  MOVF   67,F
0697:  BTFSC  03.2
0698:  GOTO   731
....................    { 
....................       x=x*base+(int16)(sd-digits); 
0699:  CLRF   7A
069A:  MOVF   61,W
069B:  MOVWF  77
069C:  BTFSC  77.7
069D:  DECF   7A,F
069E:  MOVWF  6B
069F:  MOVF   7A,W
06A0:  MOVWF  6C
06A1:  MOVF   69,W
06A2:  BCF    03.5
06A3:  BSF    03.6
06A4:  MOVWF  37
06A5:  BSF    03.5
06A6:  BCF    03.6
06A7:  MOVF   68,W
06A8:  BCF    03.5
06A9:  BSF    03.6
06AA:  MOVWF  36
06AB:  BSF    03.5
06AC:  BCF    03.6
06AD:  MOVF   6C,W
06AE:  BCF    03.5
06AF:  BSF    03.6
06B0:  MOVWF  39
06B1:  BSF    03.5
06B2:  BCF    03.6
06B3:  MOVF   6B,W
06B4:  BCF    03.5
06B5:  BSF    03.6
06B6:  MOVWF  38
*
06E4:  MOVF   79,W
06E5:  BSF    03.5
06E6:  BCF    03.6
06E7:  MOVWF  6C
06E8:  MOVF   78,W
06E9:  MOVWF  6B
06EA:  MOVLW  10
06EB:  SUBWF  66,W
06EC:  MOVWF  77
06ED:  MOVF   67,W
06EE:  MOVWF  7A
06EF:  MOVLW  01
06F0:  BTFSS  03.0
06F1:  MOVLW  02
06F2:  SUBWF  7A,F
06F3:  MOVF   77,W
06F4:  ADDWF  6B,W
06F5:  MOVWF  78
06F6:  MOVF   6C,W
06F7:  BTFSC  03.0
06F8:  INCFSZ 6C,W
06F9:  ADDWF  7A,F
06FA:  MOVF   78,W
06FB:  MOVWF  68
06FC:  MOVF   7A,W
06FD:  MOVWF  69
....................       ++sc; 
06FE:  INCF   62,F
06FF:  BTFSC  03.2
0700:  INCF   63,F
....................       sd=memchr(digits,tolower(*sc),base); 
0701:  MOVF   63,W
0702:  MOVWF  7A
0703:  MOVF   62,W
0704:  MOVWF  04
0705:  BCF    03.7
0706:  BTFSC  63.0
0707:  BSF    03.7
0708:  MOVF   00,W
0709:  MOVWF  6B
070A:  SUBLW  40
070B:  BTFSC  03.0
070C:  GOTO   714
070D:  MOVF   6B,W
070E:  SUBLW  5A
070F:  BTFSS  03.0
0710:  GOTO   714
0711:  MOVF   6B,W
0712:  IORLW  20
0713:  GOTO   715
0714:  MOVF   6B,W
0715:  MOVWF  6B
0716:  MOVLW  01
0717:  BCF    03.5
0718:  BSF    03.6
0719:  MOVWF  36
071A:  MOVLW  10
071B:  MOVWF  35
071C:  BSF    03.5
071D:  BCF    03.6
071E:  MOVF   6B,W
071F:  BCF    03.5
0720:  BSF    03.6
0721:  MOVWF  37
0722:  CLRF   39
0723:  BSF    03.5
0724:  BCF    03.6
0725:  MOVF   61,W
0726:  BCF    03.5
0727:  BSF    03.6
0728:  MOVWF  38
0729:  BCF    03.6
072A:  CALL   4FA
072B:  MOVF   79,W
072C:  BSF    03.5
072D:  MOVWF  67
072E:  MOVF   78,W
072F:  MOVWF  66
0730:  GOTO   693
....................    } 
....................    if(s1==sc) 
0731:  MOVF   62,W
0732:  SUBWF  64,W
0733:  BTFSS  03.2
0734:  GOTO   74C
0735:  MOVF   63,W
0736:  SUBWF  65,W
0737:  BTFSS  03.2
0738:  GOTO   74C
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
0739:  MOVF   5F,W
073A:  IORWF  60,W
073B:  BTFSC  03.2
073C:  GOTO   748
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
073D:  MOVF   5F,W
073E:  MOVWF  04
073F:  BCF    03.7
0740:  BTFSC  60.0
0741:  BSF    03.7
0742:  INCF   04,F
0743:  MOVF   5E,W
0744:  MOVWF  00
0745:  DECF   04,F
0746:  MOVF   5D,W
0747:  MOVWF  00
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
0748:  MOVLW  00
0749:  MOVWF  78
074A:  MOVWF  79
074B:  GOTO   75F
....................    } 
....................    if (endptr) 
074C:  MOVF   5F,W
074D:  IORWF  60,W
074E:  BTFSC  03.2
074F:  GOTO   75B
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
0750:  MOVF   5F,W
0751:  MOVWF  04
0752:  BCF    03.7
0753:  BTFSC  60.0
0754:  BSF    03.7
0755:  INCF   04,F
0756:  MOVF   63,W
0757:  MOVWF  00
0758:  DECF   04,F
0759:  MOVF   62,W
075A:  MOVWF  00
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
075B:  MOVF   68,W
075C:  MOVWF  78
075D:  MOVF   69,W
075E:  MOVWF  79
075F:  BCF    03.5
0760:  RETURN
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... void saveUser(int * id, int * pass, int status){ 
....................    if( id[0] <= 99 && id[1] <= 99 && getAddressByID(id) == -1 ){ 
*
11A0:  MOVF   31,W
11A1:  MOVWF  04
11A2:  BCF    03.7
11A3:  BTFSC  32.0
11A4:  BSF    03.7
11A5:  MOVF   00,W
11A6:  SUBLW  63
11A7:  BTFSS  03.0
11A8:  GOTO   279
11A9:  MOVLW  01
11AA:  ADDWF  31,W
11AB:  MOVWF  04
11AC:  BCF    03.7
11AD:  BTFSC  32.0
11AE:  BSF    03.7
11AF:  MOVF   00,W
11B0:  SUBLW  63
11B1:  BTFSS  03.0
11B2:  GOTO   279
11B3:  MOVF   32,W
11B4:  MOVWF  44
11B5:  MOVF   31,W
11B6:  MOVWF  43
11B7:  BCF    0A.4
11B8:  BSF    0A.3
11B9:  BCF    03.5
11BA:  CALL   27F
11BB:  BSF    0A.4
11BC:  BCF    0A.3
11BD:  MOVF   78,W
11BE:  SUBLW  FF
11BF:  BTFSC  03.2
11C0:  GOTO   1C3
11C1:  BSF    03.5
11C2:  GOTO   279
....................       int address = lastNewUserPosition(); 
....................  
....................       //recebe os parÃ¢metros do usuÃ¡rio 
....................       User user; 
*
11D9:  MOVF   78,W
11DA:  MOVWF  36
....................       user.id[0] = id[0]; 
11DB:  MOVF   31,W
11DC:  MOVWF  04
11DD:  BCF    03.7
11DE:  BTFSC  32.0
11DF:  BSF    03.7
11E0:  MOVF   00,W
11E1:  MOVWF  37
....................       user.id[1] = id[1]; 
11E2:  MOVLW  01
11E3:  ADDWF  31,W
11E4:  MOVWF  04
11E5:  BCF    03.7
11E6:  BTFSC  32.0
11E7:  BSF    03.7
11E8:  MOVF   00,W
11E9:  MOVWF  38
....................       user.pass[0] = pass[0]; 
11EA:  MOVF   33,W
11EB:  MOVWF  04
11EC:  BCF    03.7
11ED:  BTFSC  34.0
11EE:  BSF    03.7
11EF:  MOVF   00,W
11F0:  MOVWF  39
....................       user.pass[1] = pass[1]; 
11F1:  MOVLW  01
11F2:  ADDWF  33,W
11F3:  MOVWF  04
11F4:  BCF    03.7
11F5:  BTFSC  34.0
11F6:  BSF    03.7
11F7:  MOVF   00,W
11F8:  MOVWF  3A
....................       user.pass[2] = pass[2]; 
11F9:  MOVLW  02
11FA:  ADDWF  33,W
11FB:  MOVWF  04
11FC:  BCF    03.7
11FD:  BTFSC  34.0
11FE:  BSF    03.7
11FF:  MOVF   00,W
1200:  MOVWF  3B
....................       user.pass[3] = pass[3]; 
1201:  MOVLW  03
1202:  ADDWF  33,W
1203:  MOVWF  04
1204:  BCF    03.7
1205:  BTFSC  34.0
1206:  BSF    03.7
1207:  MOVF   00,W
1208:  MOVWF  3C
....................       user.status = status; 
1209:  MOVF   35,W
120A:  MOVWF  3D
....................        
....................       write_ext_eeprom(address, user.id[0]); 
120B:  MOVF   36,W
120C:  MOVWF  56
120D:  MOVF   37,W
120E:  MOVWF  57
120F:  BCF    0A.4
1210:  BSF    0A.3
1211:  BCF    03.5
1212:  CALL   328
1213:  BSF    0A.4
1214:  BCF    0A.3
....................       write_ext_eeprom(address+1, user.id[1]); 
1215:  MOVLW  01
1216:  BSF    03.5
1217:  ADDWF  36,W
1218:  MOVWF  3E
1219:  MOVWF  56
121A:  MOVF   38,W
121B:  MOVWF  57
121C:  BCF    0A.4
121D:  BSF    0A.3
121E:  BCF    03.5
121F:  CALL   328
1220:  BSF    0A.4
1221:  BCF    0A.3
....................       write_ext_eeprom(address+2, user.pass[0]); 
1222:  MOVLW  02
1223:  BSF    03.5
1224:  ADDWF  36,W
1225:  MOVWF  3E
1226:  MOVWF  56
1227:  MOVF   39,W
1228:  MOVWF  57
1229:  BCF    0A.4
122A:  BSF    0A.3
122B:  BCF    03.5
122C:  CALL   328
122D:  BSF    0A.4
122E:  BCF    0A.3
....................       write_ext_eeprom(address+3, user.pass[1]); 
122F:  MOVLW  03
1230:  BSF    03.5
1231:  ADDWF  36,W
1232:  MOVWF  3E
1233:  MOVWF  56
1234:  MOVF   3A,W
1235:  MOVWF  57
1236:  BCF    0A.4
1237:  BSF    0A.3
1238:  BCF    03.5
1239:  CALL   328
123A:  BSF    0A.4
123B:  BCF    0A.3
....................       write_ext_eeprom(address+4, user.pass[2]); 
123C:  MOVLW  04
123D:  BSF    03.5
123E:  ADDWF  36,W
123F:  MOVWF  3E
1240:  MOVWF  56
1241:  MOVF   3B,W
1242:  MOVWF  57
1243:  BCF    0A.4
1244:  BSF    0A.3
1245:  BCF    03.5
1246:  CALL   328
1247:  BSF    0A.4
1248:  BCF    0A.3
....................       write_ext_eeprom(address+5, user.pass[3]);        
1249:  MOVLW  05
124A:  BSF    03.5
124B:  ADDWF  36,W
124C:  MOVWF  3E
124D:  MOVWF  56
124E:  MOVF   3C,W
124F:  MOVWF  57
1250:  BCF    0A.4
1251:  BSF    0A.3
1252:  BCF    03.5
1253:  CALL   328
1254:  BSF    0A.4
1255:  BCF    0A.3
....................       write_ext_eeprom(address+6, user.status); 
1256:  MOVLW  06
1257:  BSF    03.5
1258:  ADDWF  36,W
1259:  MOVWF  3E
125A:  MOVWF  56
125B:  MOVF   3D,W
125C:  MOVWF  57
125D:  BCF    0A.4
125E:  BSF    0A.3
125F:  BCF    03.5
1260:  CALL   328
1261:  BSF    0A.4
1262:  BCF    0A.3
....................  
....................       printf (lcd_escreve,"\fUsuario Cadastrado"); 
1263:  MOVLW  76
1264:  BSF    03.6
1265:  MOVWF  0D
1266:  MOVLW  00
1267:  MOVWF  0F
1268:  BCF    0A.4
1269:  BCF    03.6
126A:  CALL   2A7
126B:  BSF    0A.4
....................       delay_ms(500); 
126C:  MOVLW  02
126D:  BSF    03.5
126E:  MOVWF  3E
126F:  MOVLW  FA
1270:  MOVWF  5B
1271:  BCF    0A.4
1272:  BCF    03.5
1273:  CALL   1AD
1274:  BSF    0A.4
1275:  BSF    03.5
1276:  DECFSZ 3E,F
1277:  GOTO   26F
....................  
....................    }else{ 
1278:  GOTO   298
....................       printf (lcd_escreve,"\fID incompativel"); 
1279:  MOVLW  80
127A:  BCF    03.5
127B:  BSF    03.6
127C:  MOVWF  0D
127D:  MOVLW  00
127E:  MOVWF  0F
127F:  BCF    0A.4
1280:  BCF    03.6
1281:  CALL   2A7
1282:  BSF    0A.4
....................       printf (lcd_escreve,"\r\nTente novamente"); 
1283:  MOVLW  89
1284:  BSF    03.6
1285:  MOVWF  0D
1286:  MOVLW  00
1287:  MOVWF  0F
1288:  BCF    0A.4
1289:  BCF    03.6
128A:  CALL   2A7
128B:  BSF    0A.4
....................       delay_ms(1000); 
128C:  MOVLW  04
128D:  BSF    03.5
128E:  MOVWF  3E
128F:  MOVLW  FA
1290:  MOVWF  5B
1291:  BCF    0A.4
1292:  BCF    03.5
1293:  CALL   1AD
1294:  BSF    0A.4
1295:  BSF    03.5
1296:  DECFSZ 3E,F
1297:  GOTO   28F
....................  
....................    } 
.................... } 
....................  
.................... void updateUser(int * id, int * pass, int status, int address){ 
....................    if( id[0] <= 99 && id[1] <= 99){ 
*
15D9:  MOVF   48,W
15DA:  MOVWF  04
15DB:  BCF    03.7
15DC:  BTFSC  49.0
15DD:  BSF    03.7
15DE:  MOVF   00,W
15DF:  SUBLW  63
15E0:  BTFSS  03.0
15E1:  GOTO   68A
15E2:  MOVLW  01
15E3:  ADDWF  48,W
15E4:  MOVWF  04
15E5:  BCF    03.7
15E6:  BTFSC  49.0
15E7:  BSF    03.7
15E8:  MOVF   00,W
15E9:  SUBLW  63
15EA:  BTFSS  03.0
15EB:  GOTO   68A
....................       //recebe os parÃ¢metros do usuÃ¡rio 
....................       User user; 
....................       user.id[0] = id[0]; 
15EC:  MOVF   48,W
15ED:  MOVWF  04
15EE:  BCF    03.7
15EF:  BTFSC  49.0
15F0:  BSF    03.7
15F1:  MOVF   00,W
15F2:  MOVWF  4E
....................       user.id[1] = id[1]; 
15F3:  MOVLW  01
15F4:  ADDWF  48,W
15F5:  MOVWF  04
15F6:  BCF    03.7
15F7:  BTFSC  49.0
15F8:  BSF    03.7
15F9:  MOVF   00,W
15FA:  MOVWF  4F
....................       user.pass[0] = pass[0]; 
15FB:  MOVF   4A,W
15FC:  MOVWF  04
15FD:  BCF    03.7
15FE:  BTFSC  4B.0
15FF:  BSF    03.7
1600:  MOVF   00,W
1601:  MOVWF  50
....................       user.pass[1] = pass[1]; 
1602:  MOVLW  01
1603:  ADDWF  4A,W
1604:  MOVWF  04
1605:  BCF    03.7
1606:  BTFSC  4B.0
1607:  BSF    03.7
1608:  MOVF   00,W
1609:  MOVWF  51
....................       user.pass[2] = pass[2]; 
160A:  MOVLW  02
160B:  ADDWF  4A,W
160C:  MOVWF  04
160D:  BCF    03.7
160E:  BTFSC  4B.0
160F:  BSF    03.7
1610:  MOVF   00,W
1611:  MOVWF  52
....................       user.pass[3] = pass[3]; 
1612:  MOVLW  03
1613:  ADDWF  4A,W
1614:  MOVWF  04
1615:  BCF    03.7
1616:  BTFSC  4B.0
1617:  BSF    03.7
1618:  MOVF   00,W
1619:  MOVWF  53
....................       user.status = status; 
161A:  MOVF   4C,W
161B:  MOVWF  54
....................        
....................       write_ext_eeprom(address, user.id[0]); 
161C:  MOVF   4D,W
161D:  MOVWF  56
161E:  MOVF   4E,W
161F:  MOVWF  57
1620:  BCF    0A.4
1621:  BSF    0A.3
1622:  BCF    03.5
1623:  CALL   328
1624:  BSF    0A.4
1625:  BCF    0A.3
....................       write_ext_eeprom(address+1, user.id[1]); 
1626:  MOVLW  01
1627:  BSF    03.5
1628:  ADDWF  4D,W
1629:  MOVWF  55
162A:  MOVWF  56
162B:  MOVF   4F,W
162C:  MOVWF  57
162D:  BCF    0A.4
162E:  BSF    0A.3
162F:  BCF    03.5
1630:  CALL   328
1631:  BSF    0A.4
1632:  BCF    0A.3
....................       write_ext_eeprom(address+2, user.pass[0]); 
1633:  MOVLW  02
1634:  BSF    03.5
1635:  ADDWF  4D,W
1636:  MOVWF  55
1637:  MOVWF  56
1638:  MOVF   50,W
1639:  MOVWF  57
163A:  BCF    0A.4
163B:  BSF    0A.3
163C:  BCF    03.5
163D:  CALL   328
163E:  BSF    0A.4
163F:  BCF    0A.3
....................       write_ext_eeprom(address+3, user.pass[1]); 
1640:  MOVLW  03
1641:  BSF    03.5
1642:  ADDWF  4D,W
1643:  MOVWF  55
1644:  MOVWF  56
1645:  MOVF   51,W
1646:  MOVWF  57
1647:  BCF    0A.4
1648:  BSF    0A.3
1649:  BCF    03.5
164A:  CALL   328
164B:  BSF    0A.4
164C:  BCF    0A.3
....................       write_ext_eeprom(address+4, user.pass[2]); 
164D:  MOVLW  04
164E:  BSF    03.5
164F:  ADDWF  4D,W
1650:  MOVWF  55
1651:  MOVWF  56
1652:  MOVF   52,W
1653:  MOVWF  57
1654:  BCF    0A.4
1655:  BSF    0A.3
1656:  BCF    03.5
1657:  CALL   328
1658:  BSF    0A.4
1659:  BCF    0A.3
....................       write_ext_eeprom(address+5, user.pass[3]);        
165A:  MOVLW  05
165B:  BSF    03.5
165C:  ADDWF  4D,W
165D:  MOVWF  55
165E:  MOVWF  56
165F:  MOVF   53,W
1660:  MOVWF  57
1661:  BCF    0A.4
1662:  BSF    0A.3
1663:  BCF    03.5
1664:  CALL   328
1665:  BSF    0A.4
1666:  BCF    0A.3
....................       write_ext_eeprom(address+6, user.status); 
1667:  MOVLW  06
1668:  BSF    03.5
1669:  ADDWF  4D,W
166A:  MOVWF  55
166B:  MOVWF  56
166C:  MOVF   54,W
166D:  MOVWF  57
166E:  BCF    0A.4
166F:  BSF    0A.3
1670:  BCF    03.5
1671:  CALL   328
1672:  BSF    0A.4
1673:  BCF    0A.3
....................  
....................       printf (lcd_escreve,"\fUsuario Atualizado"); 
1674:  MOVLW  92
1675:  BSF    03.6
1676:  MOVWF  0D
1677:  MOVLW  00
1678:  MOVWF  0F
1679:  BCF    0A.4
167A:  BCF    03.6
167B:  CALL   2A7
167C:  BSF    0A.4
....................       delay_ms(500); 
167D:  MOVLW  02
167E:  BSF    03.5
167F:  MOVWF  55
1680:  MOVLW  FA
1681:  MOVWF  5B
1682:  BCF    0A.4
1683:  BCF    03.5
1684:  CALL   1AD
1685:  BSF    0A.4
1686:  BSF    03.5
1687:  DECFSZ 55,F
1688:  GOTO   680
....................  
....................    }else{ 
1689:  GOTO   6A9
....................       printf (lcd_escreve,"\fID incompativel"); 
168A:  MOVLW  9C
168B:  BCF    03.5
168C:  BSF    03.6
168D:  MOVWF  0D
168E:  MOVLW  00
168F:  MOVWF  0F
1690:  BCF    0A.4
1691:  BCF    03.6
1692:  CALL   2A7
1693:  BSF    0A.4
....................       printf (lcd_escreve,"\r\nTente novamente"); 
1694:  MOVLW  A5
1695:  BSF    03.6
1696:  MOVWF  0D
1697:  MOVLW  00
1698:  MOVWF  0F
1699:  BCF    0A.4
169A:  BCF    03.6
169B:  CALL   2A7
169C:  BSF    0A.4
....................       delay_ms(1000); 
169D:  MOVLW  04
169E:  BSF    03.5
169F:  MOVWF  55
16A0:  MOVLW  FA
16A1:  MOVWF  5B
16A2:  BCF    0A.4
16A3:  BCF    03.5
16A4:  CALL   1AD
16A5:  BSF    0A.4
16A6:  BSF    03.5
16A7:  DECFSZ 55,F
16A8:  GOTO   6A0
....................    } 
....................  
.................... } 
....................  
.................... void printUser(){ 
....................    //delay_ms(50); 
....................    int tmp_result = read_ext_eeprom(0);   
....................  
....................    delay_ms(50);   
....................     
....................    printf (lcd_escreve,"\f Button: %d", tmp_result); 
....................    printf(lcd_escreve, "\r\nPw:%d%d%d%d St:%d %d", read_ext_eeprom(1), read_ext_eeprom(2), read_ext_eeprom(3), read_ext_eeprom(4), read_ext_eeprom(5), read_ext_eeprom(6)); 
....................     
....................    //printf(lcd_escreve, "\f Client () elseÂ´{}{} 
....................    // printf(lcd_escreve, "\r\nPw:%c%c%c%c St:%c %c", U1.pass[0], U1.pass[1], U1.pass[2], U1.pass[3], U1.status, U1.type_usr); 
.................... } 
....................  
.................... int getAddressByID(int * id){ 
*
0A7F:  BSF    03.5
0A80:  CLRF   47
....................    int id_temp[2]; 
....................    int address = 0; 
....................     
....................    while( read_ext_eeprom(address) != -1){ 
0A81:  MOVF   47,W
0A82:  MOVWF  49
0A83:  BCF    03.5
0A84:  CALL   1AF
0A85:  MOVF   78,W
0A86:  SUBLW  FF
0A87:  BTFSC  03.2
0A88:  GOTO   2DD
....................       id_temp[0] = read_ext_eeprom(address); 
0A89:  BSF    03.5
0A8A:  MOVF   47,W
0A8B:  MOVWF  49
0A8C:  BCF    03.5
0A8D:  CALL   1AF
0A8E:  MOVF   78,W
0A8F:  BSF    03.5
0A90:  MOVWF  45
....................       id_temp[1] = read_ext_eeprom(address+1); 
0A91:  MOVLW  01
0A92:  ADDWF  47,W
0A93:  MOVWF  48
0A94:  MOVWF  49
0A95:  BCF    03.5
0A96:  CALL   1AF
0A97:  MOVF   78,W
0A98:  BSF    03.5
0A99:  MOVWF  46
....................        
....................       if (id_temp[0] == id[0] && id_temp[1] == id[1]){ 
0A9A:  MOVF   43,W
0A9B:  MOVWF  04
0A9C:  BCF    03.7
0A9D:  BTFSC  44.0
0A9E:  BSF    03.7
0A9F:  MOVF   00,W
0AA0:  SUBWF  45,W
0AA1:  BTFSS  03.2
0AA2:  GOTO   2D9
0AA3:  MOVLW  01
0AA4:  ADDWF  43,W
0AA5:  MOVWF  04
0AA6:  BCF    03.7
0AA7:  BTFSC  44.0
0AA8:  BSF    03.7
0AA9:  MOVF   00,W
0AAA:  SUBWF  46,W
0AAB:  BTFSS  03.2
0AAC:  GOTO   2D9
....................          printf (lcd_escreve,"\fID Existe:%u%u", id_temp[0],id_temp[1]); 
0AAD:  MOVLW  C1
0AAE:  BCF    03.5
0AAF:  BSF    03.6
0AB0:  MOVWF  0D
0AB1:  MOVLW  00
0AB2:  MOVWF  0F
0AB3:  BCF    03.0
0AB4:  MOVLW  0B
0AB5:  BSF    03.5
0AB6:  BCF    03.6
0AB7:  MOVWF  55
0AB8:  BCF    0A.3
0AB9:  BCF    03.5
0ABA:  CALL   480
0ABB:  BSF    0A.3
0ABC:  BSF    03.5
0ABD:  MOVF   45,W
0ABE:  MOVWF  4A
0ABF:  MOVLW  1B
0AC0:  MOVWF  4B
0AC1:  BCF    03.5
0AC2:  CALL   017
0AC3:  BSF    03.5
0AC4:  MOVF   46,W
0AC5:  MOVWF  4A
0AC6:  MOVLW  1B
0AC7:  MOVWF  4B
0AC8:  BCF    03.5
0AC9:  CALL   017
....................          delay_ms(1000); 
0ACA:  MOVLW  04
0ACB:  BSF    03.5
0ACC:  MOVWF  48
0ACD:  MOVLW  FA
0ACE:  MOVWF  5B
0ACF:  BCF    0A.3
0AD0:  BCF    03.5
0AD1:  CALL   1AD
0AD2:  BSF    0A.3
0AD3:  BSF    03.5
0AD4:  DECFSZ 48,F
0AD5:  GOTO   2CD
....................          return address; 
0AD6:  MOVF   47,W
0AD7:  MOVWF  78
0AD8:  GOTO   326
....................       } 
....................  
....................       address += BLOCK_SIZE;  
0AD9:  MOVLW  07
0ADA:  ADDWF  47,F
0ADB:  GOTO   281
0ADC:  BCF    03.5
....................    } 
....................    printf (lcd_escreve,"\fID:%u%u \r\nDisponivel",id[0],id[1]); 
0ADD:  BSF    03.5
0ADE:  MOVF   43,W
0ADF:  MOVWF  04
0AE0:  BCF    03.7
0AE1:  BTFSC  44.0
0AE2:  BSF    03.7
0AE3:  MOVF   00,W
0AE4:  MOVWF  48
0AE5:  MOVLW  01
0AE6:  ADDWF  43,W
0AE7:  MOVWF  04
0AE8:  BCF    03.7
0AE9:  BTFSC  44.0
0AEA:  BSF    03.7
0AEB:  MOVF   00,W
0AEC:  MOVWF  49
0AED:  MOVLW  C9
0AEE:  BCF    03.5
0AEF:  BSF    03.6
0AF0:  MOVWF  0D
0AF1:  MOVLW  00
0AF2:  MOVWF  0F
0AF3:  BCF    03.0
0AF4:  MOVLW  04
0AF5:  BSF    03.5
0AF6:  BCF    03.6
0AF7:  MOVWF  55
0AF8:  BCF    0A.3
0AF9:  BCF    03.5
0AFA:  CALL   480
0AFB:  BSF    0A.3
0AFC:  BSF    03.5
0AFD:  MOVF   48,W
0AFE:  MOVWF  4A
0AFF:  MOVLW  1B
0B00:  MOVWF  4B
0B01:  BCF    03.5
0B02:  CALL   017
0B03:  BSF    03.5
0B04:  MOVF   49,W
0B05:  MOVWF  4A
0B06:  MOVLW  1B
0B07:  MOVWF  4B
0B08:  BCF    03.5
0B09:  CALL   017
0B0A:  MOVLW  CD
0B0B:  BSF    03.6
0B0C:  MOVWF  0D
0B0D:  MOVLW  00
0B0E:  MOVWF  0F
0B0F:  BCF    03.0
0B10:  MOVLW  0D
0B11:  BSF    03.5
0B12:  BCF    03.6
0B13:  MOVWF  55
0B14:  BCF    0A.3
0B15:  BCF    03.5
0B16:  CALL   480
0B17:  BSF    0A.3
....................    delay_ms(1000); 
0B18:  MOVLW  04
0B19:  BSF    03.5
0B1A:  MOVWF  48
0B1B:  MOVLW  FA
0B1C:  MOVWF  5B
0B1D:  BCF    0A.3
0B1E:  BCF    03.5
0B1F:  CALL   1AD
0B20:  BSF    0A.3
0B21:  BSF    03.5
0B22:  DECFSZ 48,F
0B23:  GOTO   31B
....................    return -1; 
0B24:  MOVLW  FF
0B25:  MOVWF  78
0B26:  BCF    03.5
0B27:  RETURN
.................... } 
....................  
.................... void searchUser(int * id){ 
*
12B2:  MOVF   5C,W
12B3:  BSF    03.5
12B4:  MOVWF  44
12B5:  BCF    03.5
12B6:  MOVF   5B,W
12B7:  BSF    03.5
12B8:  MOVWF  43
12B9:  BCF    0A.4
12BA:  BSF    0A.3
12BB:  BCF    03.5
12BC:  CALL   27F
12BD:  BSF    0A.4
12BE:  BCF    0A.3
12BF:  MOVF   78,W
12C0:  MOVWF  5D
....................  
....................    int address = getAddressByID(id); 
....................    if(address != -1){ 
12C1:  MOVF   5D,W
12C2:  SUBLW  FF
12C3:  BTFSC  03.2
12C4:  GOTO   34E
....................       printf (lcd_escreve,"\fID:%u%u",id[0],id[1]); 
12C5:  MOVF   5B,W
12C6:  MOVWF  04
12C7:  BCF    03.7
12C8:  BTFSC  5C.0
12C9:  BSF    03.7
12CA:  MOVF   00,W
12CB:  MOVWF  68
12CC:  MOVLW  01
12CD:  ADDWF  5B,W
12CE:  MOVWF  04
12CF:  BCF    03.7
12D0:  BTFSC  5C.0
12D1:  BSF    03.7
12D2:  MOVF   00,W
12D3:  MOVWF  69
12D4:  MOVLW  D4
12D5:  BSF    03.6
12D6:  MOVWF  0D
12D7:  MOVLW  00
12D8:  MOVWF  0F
12D9:  BCF    03.0
12DA:  MOVLW  04
12DB:  BSF    03.5
12DC:  BCF    03.6
12DD:  MOVWF  55
12DE:  BCF    0A.4
12DF:  BCF    03.5
12E0:  CALL   480
12E1:  BSF    0A.4
12E2:  MOVF   68,W
12E3:  BSF    03.5
12E4:  MOVWF  4A
12E5:  MOVLW  1B
12E6:  MOVWF  4B
12E7:  BCF    0A.4
12E8:  BSF    0A.3
12E9:  BCF    03.5
12EA:  CALL   017
12EB:  BSF    0A.4
12EC:  BCF    0A.3
12ED:  MOVF   69,W
12EE:  BSF    03.5
12EF:  MOVWF  4A
12F0:  MOVLW  1B
12F1:  MOVWF  4B
12F2:  BCF    0A.4
12F3:  BSF    0A.3
12F4:  BCF    03.5
12F5:  CALL   017
12F6:  BSF    0A.4
12F7:  BCF    0A.3
....................       char msg_status[10]; 
....................       if(read_ext_eeprom(address+BLOCK_SIZE - 1) == 0){ 
12F8:  MOVLW  07
12F9:  ADDWF  5D,W
12FA:  ADDLW  FF
12FB:  MOVWF  68
12FC:  BSF    03.5
12FD:  MOVWF  49
12FE:  BCF    0A.4
12FF:  BSF    0A.3
1300:  BCF    03.5
1301:  CALL   1AF
1302:  BSF    0A.4
1303:  BCF    0A.3
1304:  MOVF   78,F
1305:  BTFSS  03.2
1306:  GOTO   31A
....................          strcpy(msg_status,"NAO PAGO"); 
1307:  CLRF   68
1308:  CLRF   69
1309:  MOVLW  5E
130A:  MOVWF  04
130B:  BCF    03.7
130C:  MOVF   68,W
130D:  ADDWF  04,F
130E:  MOVF   69,W
130F:  BCF    0A.4
1310:  CALL   060
1311:  BSF    0A.4
1312:  MOVWF  00
1313:  IORLW  00
1314:  BTFSC  03.2
1315:  GOTO   319
1316:  INCF   69,F
1317:  INCF   68,F
1318:  GOTO   309
....................       }else{ 
1319:  GOTO   32C
....................          strcpy(msg_status,"PAGO"); 
131A:  CLRF   68
131B:  CLRF   69
131C:  MOVLW  5E
131D:  MOVWF  04
131E:  BCF    03.7
131F:  MOVF   68,W
1320:  ADDWF  04,F
1321:  MOVF   69,W
1322:  BCF    0A.4
1323:  CALL   06D
1324:  BSF    0A.4
1325:  MOVWF  00
1326:  IORLW  00
1327:  BTFSC  03.2
1328:  GOTO   32C
1329:  INCF   69,F
132A:  INCF   68,F
132B:  GOTO   31C
....................       } 
....................       printf (lcd_escreve,"\r\nStatus:%s",msg_status); 
132C:  MOVLW  D9
132D:  BSF    03.6
132E:  MOVWF  0D
132F:  MOVLW  00
1330:  MOVWF  0F
1331:  BCF    03.0
1332:  MOVLW  09
1333:  BSF    03.5
1334:  BCF    03.6
1335:  MOVWF  55
1336:  BCF    0A.4
1337:  BCF    03.5
1338:  CALL   480
1339:  BSF    0A.4
133A:  MOVLW  5E
133B:  MOVWF  04
133C:  BCF    03.7
133D:  BCF    0A.4
133E:  BSF    0A.3
133F:  CALL   05C
1340:  BSF    0A.4
1341:  BCF    0A.3
....................       delay_ms(2000); 
1342:  MOVLW  08
1343:  MOVWF  68
1344:  MOVLW  FA
1345:  BSF    03.5
1346:  MOVWF  5B
1347:  BCF    0A.4
1348:  BCF    03.5
1349:  CALL   1AD
134A:  BSF    0A.4
134B:  DECFSZ 68,F
134C:  GOTO   344
....................    }else{ 
134D:  GOTO   362
....................       printf(lcd_escreve,"\fUsuario N Existe"); 
134E:  MOVLW  DF
134F:  BSF    03.6
1350:  MOVWF  0D
1351:  MOVLW  00
1352:  MOVWF  0F
1353:  BCF    0A.4
1354:  BCF    03.6
1355:  CALL   2A7
1356:  BSF    0A.4
....................       delay_ms(1000); 
1357:  MOVLW  04
1358:  MOVWF  68
1359:  MOVLW  FA
135A:  BSF    03.5
135B:  MOVWF  5B
135C:  BCF    0A.4
135D:  BCF    03.5
135E:  CALL   1AD
135F:  BSF    0A.4
1360:  DECFSZ 68,F
1361:  GOTO   359
....................    } 
.................... } 
....................  
.................... void erase_program_eeprom(int addrr){ 
....................    for(int i=0; i < BLOCK_SIZE; i++){ 
*
0B78:  CLRF   63
0B79:  MOVF   63,W
0B7A:  SUBLW  06
0B7B:  BTFSS  03.0
0B7C:  GOTO   388
....................          write_ext_eeprom(addrr + i, -1); 
0B7D:  MOVF   63,W
0B7E:  ADDWF  62,W
0B7F:  MOVWF  64
0B80:  BSF    03.5
0B81:  MOVWF  56
0B82:  MOVLW  FF
0B83:  MOVWF  57
0B84:  BCF    03.5
0B85:  CALL   328
0B86:  INCF   63,F
0B87:  GOTO   379
....................    }   
....................    printf (lcd_escreve,"\f User erased "); 
0B88:  MOVLW  E8
0B89:  BSF    03.6
0B8A:  MOVWF  0D
0B8B:  MOVLW  00
0B8C:  MOVWF  0F
0B8D:  BCF    0A.3
0B8E:  BCF    03.6
0B8F:  CALL   2A7
0B90:  BSF    0A.3
....................    delay_ms(200); 
0B91:  MOVLW  C8
0B92:  BSF    03.5
0B93:  MOVWF  5B
0B94:  BCF    0A.3
0B95:  BCF    03.5
0B96:  CALL   1AD
0B97:  BSF    0A.3
0B98:  RETURN
.................... } 
....................  
.................... int deleteUser(int * id){ 
*
137D:  MOVF   5C,W
137E:  BSF    03.5
137F:  MOVWF  44
1380:  BCF    03.5
1381:  MOVF   5B,W
1382:  BSF    03.5
1383:  MOVWF  43
1384:  BCF    0A.4
1385:  BSF    0A.3
1386:  BCF    03.5
1387:  CALL   27F
1388:  BSF    0A.4
1389:  BCF    0A.3
138A:  MOVF   78,W
138B:  MOVWF  5D
....................     
....................    int address = getAddressByID(id); 
....................    if(address == -1) 
138C:  MOVF   5D,W
138D:  SUBLW  FF
138E:  BTFSS  03.2
138F:  GOTO   393
....................       return -1; 
1390:  MOVLW  FF
1391:  MOVWF  78
1392:  GOTO   3EF
....................    int data_temp; 
....................    int previous_block = address; 
....................    int next_block = address + BLOCK_SIZE; 
1393:  MOVF   5D,W
1394:  MOVWF  5F
1395:  MOVLW  07
1396:  ADDWF  5D,W
1397:  MOVWF  60
....................  
....................    //Case 1: without the next block 
....................    if (read_ext_eeprom(next_block) == -1){ 
1398:  MOVF   60,W
1399:  BSF    03.5
139A:  MOVWF  49
139B:  BCF    0A.4
139C:  BSF    0A.3
139D:  BCF    03.5
139E:  CALL   1AF
139F:  BSF    0A.4
13A0:  BCF    0A.3
13A1:  MOVF   78,W
13A2:  SUBLW  FF
13A3:  BTFSS  03.2
13A4:  GOTO   3AF
....................       erase_program_eeprom(previous_block);       
13A5:  MOVF   5F,W
13A6:  MOVWF  62
13A7:  BCF    0A.4
13A8:  BSF    0A.3
13A9:  CALL   378
13AA:  BSF    0A.4
13AB:  BCF    0A.3
....................       return 1; 
13AC:  MOVLW  01
13AD:  MOVWF  78
13AE:  GOTO   3EF
....................    } 
....................  
....................    //Case 2: Check whether the data in the next block address is empty 
....................    while(read_ext_eeprom(next_block) != -1){ 
13AF:  MOVF   60,W
13B0:  BSF    03.5
13B1:  MOVWF  49
13B2:  BCF    0A.4
13B3:  BSF    0A.3
13B4:  BCF    03.5
13B5:  CALL   1AF
13B6:  BSF    0A.4
13B7:  BCF    0A.3
13B8:  MOVF   78,W
13B9:  SUBLW  FF
13BA:  BTFSC  03.2
13BB:  GOTO   3E4
....................       //data_temp[index] = read_ext_eeprom(address); 
....................       for(int i=0; i < BLOCK_SIZE; i++){ 
13BC:  CLRF   61
13BD:  MOVF   61,W
13BE:  SUBLW  06
13BF:  BTFSS  03.0
13C0:  GOTO   3DF
....................          //Read the data from the next block  
....................          data_temp = read_ext_eeprom(next_block + i);            
13C1:  MOVF   61,W
13C2:  ADDWF  60,W
13C3:  MOVWF  62
13C4:  BSF    03.5
13C5:  MOVWF  49
13C6:  BCF    0A.4
13C7:  BSF    0A.3
13C8:  BCF    03.5
13C9:  CALL   1AF
13CA:  BSF    0A.4
13CB:  BCF    0A.3
13CC:  MOVF   78,W
13CD:  MOVWF  5E
....................          //overwrite the previous block with the data from the next 
....................          write_ext_eeprom(previous_block + i, data_temp);   
13CE:  MOVF   61,W
13CF:  ADDWF  5F,W
13D0:  MOVWF  62
13D1:  BSF    03.5
13D2:  MOVWF  56
13D3:  BCF    03.5
13D4:  MOVF   5E,W
13D5:  BSF    03.5
13D6:  MOVWF  57
13D7:  BCF    0A.4
13D8:  BSF    0A.3
13D9:  BCF    03.5
13DA:  CALL   328
13DB:  BSF    0A.4
13DC:  BCF    0A.3
13DD:  INCF   61,F
13DE:  GOTO   3BD
....................       }   
....................       previous_block = next_block; 
13DF:  MOVF   60,W
13E0:  MOVWF  5F
....................       next_block += BLOCK_SIZE; 
13E1:  MOVLW  07
13E2:  ADDWF  60,F
13E3:  GOTO   3AF
....................    } 
....................    //Go back to erase the block that's duplicated  
....................    next_block -= BLOCK_SIZE; 
13E4:  MOVLW  07
13E5:  SUBWF  60,F
....................    //Erase the last block since everything  
....................    //moved a block_size to the left 
....................    erase_program_eeprom(next_block); 
13E6:  MOVF   60,W
13E7:  MOVWF  62
13E8:  BCF    0A.4
13E9:  BSF    0A.3
13EA:  CALL   378
13EB:  BSF    0A.4
13EC:  BCF    0A.3
....................     
....................    return 1; 
13ED:  MOVLW  01
13EE:  MOVWF  78
....................  
.................... } 
....................  
.................... int lastNewUserPosition(){ 
*
11C3:  BSF    03.5
11C4:  CLRF   3E
....................    int address = 0; 
....................    int id_temp; 
....................  
....................    while( read_ext_eeprom(address) != -1){ 
11C5:  MOVF   3E,W
11C6:  MOVWF  49
11C7:  BCF    0A.4
11C8:  BSF    0A.3
11C9:  BCF    03.5
11CA:  CALL   1AF
11CB:  BSF    0A.4
11CC:  BCF    0A.3
11CD:  MOVF   78,W
11CE:  SUBLW  FF
11CF:  BTFSC  03.2
11D0:  GOTO   1D6
....................       address += BLOCK_SIZE;  
11D1:  MOVLW  07
11D2:  BSF    03.5
11D3:  ADDWF  3E,F
11D4:  GOTO   1C5
11D5:  BCF    03.5
....................    } 
....................    // printf (lcd_escreve,"\fAddress: %u", address); 
....................    // delay_ms(500); 
....................     
....................    return address; 
11D6:  BSF    03.5
11D7:  MOVF   3E,W
11D8:  MOVWF  78
....................  
.................... } 
....................  
.................... void resetMemory(){ 
....................    int address = 0; 
....................    for(; read_ext_eeprom(address) != -1; 
....................     erase_program_eeprom(address), address += BLOCK_SIZE); 
.................... } 
....................  
.................... void adminMenu(){ 
....................    unsigned char option; 
....................    unsigned int * temp; 
....................    unsigned int id [2]; 
....................    // printf(lcd_escreve,"\f1: CAD Cliente "); 
....................    // delay_ms(500); 
....................    // printf(lcd_escreve,"\r\n2: Buscar Cliente"); 
....................    // delay_ms(500); 
....................    // printf(lcd_escreve,"\f3: DEL Cliente "); 
....................    // delay_ms(500); 
....................    printf(lcd_escreve,"\r\n4: Editar Cliente"); 
*
1000:  MOVLW  F0
1001:  BSF    03.6
1002:  MOVWF  0D
1003:  MOVLW  00
1004:  MOVWF  0F
1005:  BCF    0A.4
1006:  BCF    03.6
1007:  CALL   2A7
1008:  BSF    0A.4
....................    delay_ms(500); 
1009:  MOVLW  02
100A:  MOVWF  5B
100B:  MOVLW  FA
100C:  BSF    03.5
100D:  MOVWF  5B
100E:  BCF    0A.4
100F:  BCF    03.5
1010:  CALL   1AD
1011:  BSF    0A.4
1012:  DECFSZ 5B,F
1013:  GOTO   00B
....................    printf(lcd_escreve,"\f5: SAIR do Menu "); 
1014:  MOVLW  FA
1015:  BSF    03.6
1016:  MOVWF  0D
1017:  MOVLW  00
1018:  MOVWF  0F
1019:  BCF    0A.4
101A:  BCF    03.6
101B:  CALL   2A7
101C:  BSF    0A.4
....................    delay_ms(500); 
101D:  MOVLW  02
101E:  MOVWF  5B
101F:  MOVLW  FA
1020:  BSF    03.5
1021:  MOVWF  5B
1022:  BCF    0A.4
1023:  BCF    03.5
1024:  CALL   1AD
1025:  BSF    0A.4
1026:  DECFSZ 5B,F
1027:  GOTO   01F
....................    do{ 
....................      
....................       option = readKeyboard(); 
1028:  BCF    0A.4
1029:  CALL   31B
102A:  BSF    0A.4
102B:  MOVF   78,W
102C:  MOVWF  55
....................       printf(lcd_escreve,"\f Option: %c", option); 
102D:  MOVLW  03
102E:  BSF    03.6
102F:  MOVWF  0D
1030:  MOVLW  01
1031:  MOVWF  0F
1032:  BCF    03.0
1033:  MOVLW  0A
1034:  BSF    03.5
1035:  BCF    03.6
1036:  MOVWF  55
1037:  BCF    0A.4
1038:  BCF    03.5
1039:  CALL   480
103A:  BSF    0A.4
103B:  MOVF   55,W
103C:  BSF    03.5
103D:  MOVWF  5A
103E:  BCF    0A.4
103F:  BCF    03.5
1040:  CALL   264
1041:  BSF    0A.4
....................       delay_ms(500); 
1042:  MOVLW  02
1043:  MOVWF  5B
1044:  MOVLW  FA
1045:  BSF    03.5
1046:  MOVWF  5B
1047:  BCF    0A.4
1048:  BCF    03.5
1049:  CALL   1AD
104A:  BSF    0A.4
104B:  DECFSZ 5B,F
104C:  GOTO   044
....................  
....................  
....................       switch(option){ 
104D:  MOVF   55,W
104E:  XORLW  31
104F:  BTFSC  03.2
1050:  GOTO   05B
1051:  XORLW  03
1052:  BTFSC  03.2
1053:  GOTO   299
1054:  XORLW  01
1055:  BTFSC  03.2
1056:  GOTO   364
1057:  XORLW  07
1058:  BTFSC  03.2
1059:  GOTO   4A7
105A:  GOTO   6C2
....................          case '1': 
....................             inputKeyboardUser(); 
....................             break; 
*
1298:  GOTO   6E0
....................          case '2': 
....................             temp = inputId(); 
1299:  BCF    0A.4
129A:  CALL   79D
129B:  BSF    0A.4
129C:  MOVF   79,W
129D:  MOVWF  57
129E:  MOVF   78,W
129F:  MOVWF  56
....................             id[0] = temp[0]; 
12A0:  MOVF   56,W
12A1:  MOVWF  04
12A2:  BCF    03.7
12A3:  BTFSC  57.0
12A4:  BSF    03.7
12A5:  MOVF   00,W
12A6:  MOVWF  58
....................             id[1] = temp[1]; 
12A7:  MOVLW  01
12A8:  ADDWF  56,W
12A9:  MOVWF  04
12AA:  BCF    03.7
12AB:  BTFSC  57.0
12AC:  BSF    03.7
12AD:  MOVF   00,W
12AE:  MOVWF  59
....................             searchUser(id); 
12AF:  CLRF   5C
12B0:  MOVLW  58
12B1:  MOVWF  5B
....................             break; 
*
1362:  BSF    03.5
1363:  GOTO   6E0
....................          case '3': 
....................             temp = inputId(); 
1364:  BCF    0A.4
1365:  CALL   79D
1366:  BSF    0A.4
1367:  MOVF   79,W
1368:  MOVWF  57
1369:  MOVF   78,W
136A:  MOVWF  56
....................             id[0] = temp[0]; 
136B:  MOVF   56,W
136C:  MOVWF  04
136D:  BCF    03.7
136E:  BTFSC  57.0
136F:  BSF    03.7
1370:  MOVF   00,W
1371:  MOVWF  58
....................             id[1] = temp[1]; 
1372:  MOVLW  01
1373:  ADDWF  56,W
1374:  MOVWF  04
1375:  BCF    03.7
1376:  BTFSC  57.0
1377:  BSF    03.7
1378:  MOVF   00,W
1379:  MOVWF  59
....................             signed int success = deleteUser(id); 
137A:  CLRF   5C
137B:  MOVLW  58
137C:  MOVWF  5B
*
13EF:  MOVF   78,W
13F0:  MOVWF  5A
....................             printf(lcd_escreve,"\fSuccess -> %d", success); 
13F1:  MOVLW  0A
13F2:  BSF    03.6
13F3:  MOVWF  0D
13F4:  MOVLW  01
13F5:  MOVWF  0F
13F6:  BCF    03.0
13F7:  MOVLW  0C
13F8:  BSF    03.5
13F9:  BCF    03.6
13FA:  MOVWF  55
13FB:  BCF    0A.4
13FC:  BCF    03.5
13FD:  CALL   480
13FE:  BSF    0A.4
13FF:  MOVF   5A,W
1400:  MOVWF  5B
1401:  MOVLW  18
1402:  MOVWF  5C
....................             delay_ms(500); 
*
1475:  MOVLW  02
1476:  MOVWF  5B
1477:  MOVLW  FA
1478:  BSF    03.5
1479:  MOVWF  5B
147A:  BCF    0A.4
147B:  BCF    03.5
147C:  CALL   1AD
147D:  BSF    0A.4
147E:  DECFSZ 5B,F
147F:  GOTO   477
....................             (success >= 1)?  
....................             printf(lcd_escreve,"\fusuario deletado"): 
....................             printf(lcd_escreve,"\fusuario N Existe"); 
1480:  BTFSC  5A.7
1481:  GOTO   491
1482:  MOVF   5A,W
1483:  SUBLW  00
1484:  BTFSC  03.0
1485:  GOTO   491
1486:  MOVLW  12
1487:  BSF    03.6
1488:  MOVWF  0D
1489:  MOVLW  01
148A:  MOVWF  0F
148B:  BCF    0A.4
148C:  BCF    03.6
148D:  CALL   2A7
148E:  BSF    0A.4
148F:  CLRF   7A
1490:  GOTO   49A
1491:  MOVLW  1B
1492:  BSF    03.6
1493:  MOVWF  0D
1494:  MOVLW  01
1495:  MOVWF  0F
1496:  BCF    0A.4
1497:  BCF    03.6
1498:  CALL   2A7
1499:  BSF    0A.4
....................             delay_ms(500); 
149A:  MOVLW  02
149B:  MOVWF  5B
149C:  MOVLW  FA
149D:  BSF    03.5
149E:  MOVWF  5B
149F:  BCF    0A.4
14A0:  BCF    03.5
14A1:  CALL   1AD
14A2:  BSF    0A.4
14A3:  DECFSZ 5B,F
14A4:  GOTO   49C
....................             break; 
14A5:  BSF    03.5
14A6:  GOTO   6E0
....................          case '4': 
....................             editUser(); 
....................             break; 
*
16C0:  GOTO   6E0
16C1:  BCF    03.5
....................          default: 
....................             printf(lcd_escreve,"\fDigite um valor"); 
16C2:  MOVLW  24
16C3:  BSF    03.6
16C4:  MOVWF  0D
16C5:  MOVLW  01
16C6:  MOVWF  0F
16C7:  BCF    0A.4
16C8:  BCF    03.6
16C9:  CALL   2A7
16CA:  BSF    0A.4
....................             printf(lcd_escreve,"\r\nValido!"); 
16CB:  MOVLW  2D
16CC:  BSF    03.6
16CD:  MOVWF  0D
16CE:  MOVLW  01
16CF:  MOVWF  0F
16D0:  BCF    0A.4
16D1:  BCF    03.6
16D2:  CALL   2A7
16D3:  BSF    0A.4
....................             delay_ms(500); 
16D4:  MOVLW  02
16D5:  MOVWF  5B
16D6:  MOVLW  FA
16D7:  BSF    03.5
16D8:  MOVWF  5B
16D9:  BCF    0A.4
16DA:  BCF    03.5
16DB:  CALL   1AD
16DC:  BSF    0A.4
16DD:  DECFSZ 5B,F
16DE:  GOTO   6D6
....................             break; 
16DF:  BSF    03.5
....................       } 
....................    }while(option != '5'); 
16E0:  BCF    03.5
16E1:  MOVF   55,W
16E2:  SUBLW  35
16E3:  BTFSS  03.2
16E4:  GOTO   028
16E5:  BSF    0A.3
16E6:  BCF    0A.4
16E7:  GOTO   3E9 (RETURN)
.................... } 
....................  
.................... unsigned char readKeyboard(){ 
....................    unsigned char tmp; 
....................    unsigned char tmp_result; 
....................     
....................    tmp = tc_tecla(1500); // ms 
*
031B:  MOVLW  DC
031C:  BSF    03.5
031D:  MOVWF  57
*
046D:  MOVF   78,W
046E:  MOVWF  55
....................    if(tmp != 255){ 
046F:  INCFSZ 55,W
0470:  GOTO   472
0471:  GOTO   473
....................       // write_ext_eeprom(0, tmp); 
....................       // delay_ms(50); 
....................       // tmp_result = read_ext_eeprom(0); 
....................       // delay_ms(50); 
....................       // tmp_result = tmp; 
....................       // printf(lcd_escreve,"\f Button: %c", tmp); 
....................       // delay_ms(50); 
....................    }else{  
0472:  GOTO   47C
....................       printf(lcd_escreve,"\f   TECLADO  "); 
0473:  MOVLW  32
0474:  BCF    03.5
0475:  BSF    03.6
0476:  MOVWF  0D
0477:  MOVLW  01
0478:  MOVWF  0F
0479:  BCF    03.6
047A:  CALL   2A7
047B:  BSF    03.5
....................    } 
....................  
....................    return tmp; 
047C:  MOVF   55,W
047D:  MOVWF  78
047E:  BCF    03.5
047F:  RETURN
.................... } 
....................  
....................  
.................... int * getAdminsID(){ 
....................  
....................    int address = 0; 
....................    int temp_status; 
....................    int index= 0; 
....................    static int admins[BLOCK_SIZE]; 
*
0BAD:  CLRF   44
0BAE:  CLRF   45
0BAF:  CLRF   46
0BB0:  CLRF   47
0BB1:  CLRF   48
0BB2:  CLRF   49
0BB3:  CLRF   4A
....................    admins[0] = -1; 
....................    while( read_ext_eeprom(address) != -1){ 
....................       temp_status = read_ext_eeprom(address + (BLOCK_SIZE - 1));//status of the user 
....................       if (temp_status == 3){ 
....................          printf (lcd_escreve,"\fAdmin Encontrado"); 
....................          delay_ms(1000); 
....................          for(int i=0; i < 2; i++){ 
....................             int id = read_ext_eeprom(address+i);    
....................             admins[index] = id; 
....................             index++; 
....................          } 
....................  
....................       } 
....................  
....................       address += BLOCK_SIZE;  
....................    } 
....................  
....................    return admins; 
....................  
.................... } 
....................  
.................... void listAdmins(){ 
....................    int * admins; 
....................  
....................    admins = getAdminsID(); 
....................    printf(lcd_escreve,"\f admins[0]: %d", admins[0]); 
....................    delay_ms(1000); 
....................    if(admins[0] != -1){ 
....................       for (int16 i=0; i < sizeof(admins); i+=2){ 
....................          printf(lcd_escreve, "\fid:%u%u",admins[i], admins[i+1]); 
....................          delay_ms(1000); 
....................       }  
....................    } 
.................... } 
....................  
....................  
.................... int * strToInt(char * str){ 
*
0761:  BSF    03.5
0762:  MOVF   56,W
0763:  MOVWF  58
0764:  MOVF   55,W
0765:  MOVWF  57
0766:  CLRF   5B
....................  
....................   char *p = str; 
....................   //https://flaviocopes.com/c-array-length/ 
....................   static unsigned int buffer[BLOCK_SIZE];   
*
0BB4:  CLRF   4B
0BB5:  CLRF   4C
0BB6:  CLRF   4D
0BB7:  CLRF   4E
0BB8:  CLRF   4F
0BB9:  CLRF   50
0BBA:  CLRF   51
....................   char * end; 
....................   int index = 0; 
....................  
....................   for (unsigned int number = strtoul(p, &end, 10); 
*
0767:  MOVF   58,W
0768:  MOVWF  5E
0769:  MOVF   57,W
076A:  MOVWF  5D
076B:  CLRF   60
076C:  MOVLW  D9
076D:  MOVWF  5F
076E:  MOVLW  0A
076F:  MOVWF  61
0770:  BCF    03.5
0771:  CALL   525
0772:  MOVF   78,W
0773:  BSF    03.5
0774:  MOVWF  5C
....................         p != end; 
0775:  MOVF   59,W
0776:  SUBWF  57,W
0777:  BTFSS  03.2
0778:  GOTO   77D
0779:  MOVF   5A,W
077A:  SUBWF  58,W
077B:  BTFSC  03.2
077C:  GOTO   797
....................         number = strtoul(p, &end, 10)) 
....................   { 
....................     p = end; 
077D:  MOVF   5A,W
077E:  MOVWF  58
077F:  MOVF   59,W
0780:  MOVWF  57
....................  
....................     buffer[index] = number;  
0781:  MOVLW  4B
0782:  ADDWF  5B,W
0783:  MOVWF  04
0784:  BCF    03.7
0785:  MOVF   5C,W
0786:  MOVWF  00
....................     index++; 
0787:  INCF   5B,F
0788:  MOVF   58,W
0789:  MOVWF  5E
078A:  MOVF   57,W
078B:  MOVWF  5D
078C:  CLRF   60
078D:  MOVLW  D9
078E:  MOVWF  5F
078F:  MOVLW  0A
0790:  MOVWF  61
0791:  BCF    03.5
0792:  CALL   525
0793:  MOVF   78,W
0794:  BSF    03.5
0795:  MOVWF  5C
0796:  GOTO   775
....................   } 
....................  
....................    return buffer; 
0797:  MOVLW  4B
0798:  MOVWF  78
0799:  MOVLW  00
079A:  MOVWF  79
079B:  BCF    03.5
079C:  RETURN
.................... } 
....................  
.................... char * strfromchar(char destination[], char source)  
.................... {  
....................    destination[0] = source;   // copy the character into the string  
*
08C6:  MOVF   53,W
08C7:  MOVWF  04
08C8:  BCF    03.7
08C9:  BTFSC  54.0
08CA:  BSF    03.7
08CB:  MOVF   55,W
08CC:  MOVWF  00
....................    destination[1] = '\0';      // null-terminate the string  
08CD:  MOVLW  01
08CE:  ADDWF  53,W
08CF:  MOVWF  04
08D0:  BCF    03.7
08D1:  BTFSC  54.0
08D2:  BSF    03.7
08D3:  CLRF   00
....................   
....................    return destination;         // common convention for str functions  
08D4:  MOVF   53,W
08D5:  MOVWF  78
08D6:  MOVF   54,W
08D7:  MOVWF  79
.................... }  
....................  
....................  
.................... int * inputId(){ 
*
079D:  BSF    03.5
079E:  CLRF   54
....................    unsigned char keyboard_buffer[BLOCK_SIZE * 2]; 
....................    unsigned char option; 
....................  
....................    int * temp; 
....................    int i = 0; 
....................    //The user needs to type 4 digits 
....................    //For example, even if it's just 9 
....................    //He/she will type: 0009 
....................    while(i < 5){ 
079F:  MOVF   54,W
07A0:  SUBLW  04
07A1:  BTFSS  03.0
07A2:  GOTO   7E6
....................       printf(lcd_escreve,"\fDigite o ID: "); 
07A3:  MOVLW  4F
07A4:  BCF    03.5
07A5:  BSF    03.6
07A6:  MOVWF  0D
07A7:  MOVLW  01
07A8:  MOVWF  0F
07A9:  BCF    03.6
07AA:  CALL   2A7
....................       delay_ms(50); 
07AB:  MOVLW  32
07AC:  BSF    03.5
07AD:  MOVWF  5B
07AE:  BCF    03.5
07AF:  CALL   1AD
....................       option = readKeyboard(); 
07B0:  CALL   31B
07B1:  MOVF   78,W
07B2:  BSF    03.5
07B3:  MOVWF  51
....................       printf(lcd_escreve,"\n\rTyped:%c", option); 
07B4:  MOVLW  57
07B5:  BCF    03.5
07B6:  BSF    03.6
07B7:  MOVWF  0D
07B8:  MOVLW  01
07B9:  MOVWF  0F
07BA:  BCF    03.0
07BB:  MOVLW  08
07BC:  BSF    03.5
07BD:  BCF    03.6
07BE:  MOVWF  55
07BF:  BCF    03.5
07C0:  CALL   480
07C1:  BSF    03.5
07C2:  MOVF   51,W
07C3:  MOVWF  5A
07C4:  BCF    03.5
07C5:  CALL   264
....................       delay_ms(400); 
07C6:  MOVLW  02
07C7:  BSF    03.5
07C8:  MOVWF  55
07C9:  MOVLW  C8
07CA:  MOVWF  5B
07CB:  BCF    03.5
07CC:  CALL   1AD
07CD:  BSF    03.5
07CE:  DECFSZ 55,F
07CF:  GOTO   7C9
....................       if(option != 255){ 
07D0:  INCFSZ 51,W
07D1:  GOTO   7D3
07D2:  GOTO   7E5
....................          if(i == 2){ 
07D3:  MOVF   54,W
07D4:  SUBLW  02
07D5:  BTFSS  03.2
07D6:  GOTO   7DE
....................             //To convert to int will be easier with space between them 
....................             keyboard_buffer[i] = ' '; 
07D7:  MOVLW  C3
07D8:  ADDWF  54,W
07D9:  MOVWF  04
07DA:  BCF    03.7
07DB:  MOVLW  20
07DC:  MOVWF  00
....................             i++; 
07DD:  INCF   54,F
....................          } 
....................          keyboard_buffer[i] = option; 
07DE:  MOVLW  C3
07DF:  ADDWF  54,W
07E0:  MOVWF  04
07E1:  BCF    03.7
07E2:  MOVF   51,W
07E3:  MOVWF  00
....................          i++; 
07E4:  INCF   54,F
....................       } 
07E5:  GOTO   79F
....................    } 
....................    // unsigned char *id; 
....................    // id = keyboard_buffer; 
....................    temp = strToInt(keyboard_buffer); 
07E6:  CLRF   56
07E7:  MOVLW  C3
07E8:  MOVWF  55
07E9:  BCF    03.5
07EA:  CALL   761
07EB:  MOVF   79,W
07EC:  BSF    03.5
07ED:  MOVWF  53
07EE:  MOVF   78,W
07EF:  MOVWF  52
....................    return temp; 
07F0:  MOVF   52,W
07F1:  MOVWF  78
07F2:  MOVF   53,W
07F3:  MOVWF  79
07F4:  BCF    03.5
07F5:  RETURN
....................    // id[0] = temp[0]; 
....................    // id[1] = temp[1]; 
....................    // //https://www.tutorialspoint.com/cprogramming/c_pointer_to_an_array.htm 
....................    // //*(id+1) == id[1] 
....................    // printf(lcd_escreve,"\fid: %u%u",id[0],id[1]); 
....................    // delay_ms(1000); 
.................... } 
....................  
.................... int * inputToKeyboard(char * msg, int max){ 
*
087B:  BSF    03.5
087C:  CLRF   50
....................    unsigned char option; 
....................    int data[BLOCK_SIZE]; 
....................    int * temp; 
....................    int i = 0; 
....................  
....................    while(i < max){ 
087D:  MOVF   45,W
087E:  SUBWF  50,W
087F:  BTFSC  03.0
0880:  GOTO   0FE
....................  
....................       printf(lcd_escreve,"\f%s", msg); 
0881:  MOVLW  0C
0882:  MOVWF  5A
0883:  BCF    0A.3
0884:  BCF    03.5
0885:  CALL   264
0886:  BSF    0A.3
0887:  BSF    03.5
0888:  MOVF   43,W
0889:  MOVWF  04
088A:  BCF    03.7
088B:  BTFSC  44.0
088C:  BSF    03.7
088D:  BCF    03.5
088E:  CALL   05C
....................       delay_ms(50); 
088F:  MOVLW  32
0890:  BSF    03.5
0891:  MOVWF  5B
0892:  BCF    0A.3
0893:  BCF    03.5
0894:  CALL   1AD
0895:  BSF    0A.3
....................       option = readKeyboard(); 
0896:  BCF    0A.3
0897:  CALL   31B
0898:  BSF    0A.3
0899:  MOVF   78,W
089A:  BSF    03.5
089B:  MOVWF  46
....................       printf(lcd_escreve,"\n\rTyped:%c", option); 
089C:  MOVLW  5D
089D:  BCF    03.5
089E:  BSF    03.6
089F:  MOVWF  0D
08A0:  MOVLW  01
08A1:  MOVWF  0F
08A2:  BCF    03.0
08A3:  MOVLW  08
08A4:  BSF    03.5
08A5:  BCF    03.6
08A6:  MOVWF  55
08A7:  BCF    0A.3
08A8:  BCF    03.5
08A9:  CALL   480
08AA:  BSF    0A.3
08AB:  BSF    03.5
08AC:  MOVF   46,W
08AD:  MOVWF  5A
08AE:  BCF    0A.3
08AF:  BCF    03.5
08B0:  CALL   264
08B1:  BSF    0A.3
....................       delay_ms(400); 
08B2:  MOVLW  02
08B3:  BSF    03.5
08B4:  MOVWF  53
08B5:  MOVLW  C8
08B6:  MOVWF  5B
08B7:  BCF    0A.3
08B8:  BCF    03.5
08B9:  CALL   1AD
08BA:  BSF    0A.3
08BB:  BSF    03.5
08BC:  DECFSZ 53,F
08BD:  GOTO   0B5
....................       if(option != 255){ 
08BE:  INCFSZ 46,W
08BF:  GOTO   0C1
08C0:  GOTO   0FD
....................          unsigned char destination[2]; 
....................          //Convert string from char and return  
....................          //to the left array of char(str_pass) 
....................          strfromchar(destination,option); 
08C1:  CLRF   54
08C2:  MOVLW  D1
08C3:  MOVWF  53
08C4:  MOVF   46,W
08C5:  MOVWF  55
....................          temp = strToInt(destination); 
*
08D8:  CLRF   56
08D9:  MOVLW  D1
08DA:  MOVWF  55
08DB:  BCF    0A.3
08DC:  BCF    03.5
08DD:  CALL   761
08DE:  BSF    0A.3
08DF:  MOVF   79,W
08E0:  BSF    03.5
08E1:  MOVWF  4F
08E2:  MOVF   78,W
08E3:  MOVWF  4E
....................          data[i] = temp[0]; 
08E4:  MOVLW  C7
08E5:  ADDWF  50,W
08E6:  MOVWF  78
08E7:  CLRF   7A
08E8:  BTFSC  03.0
08E9:  INCF   7A,F
08EA:  MOVF   78,W
08EB:  MOVWF  53
08EC:  MOVF   7A,W
08ED:  MOVWF  54
08EE:  MOVF   4E,W
08EF:  MOVWF  04
08F0:  BCF    03.7
08F1:  BTFSC  4F.0
08F2:  BSF    03.7
08F3:  MOVF   00,W
08F4:  MOVWF  55
08F5:  MOVF   53,W
08F6:  MOVWF  04
08F7:  BCF    03.7
08F8:  BTFSC  54.0
08F9:  BSF    03.7
08FA:  MOVF   55,W
08FB:  MOVWF  00
....................          i++; 
08FC:  INCF   50,F
....................       } 
08FD:  GOTO   07D
....................    } 
....................  
....................    temp = data; 
08FE:  CLRF   4F
08FF:  MOVLW  C7
0900:  MOVWF  4E
....................    return temp; 
0901:  MOVF   4E,W
0902:  MOVWF  78
0903:  MOVF   4F,W
0904:  MOVWF  79
0905:  BCF    03.5
0906:  RETURN
....................    // printf(lcd_escreve,"\fPASS(4): %u%u%u%u",pass[0],pass[1],pass[2],pass[3]); 
....................    // delay_ms(1000); 
....................  
.................... } 
.................... void inputKeyboardUser(){ 
....................  
....................    unsigned int * temp; 
....................    unsigned int id [2]; 
....................    unsigned int pass[4]; 
....................    unsigned int status; 
....................  
....................    temp = inputId(); 
*
105B:  BCF    0A.4
105C:  CALL   79D
105D:  BSF    0A.4
105E:  MOVF   79,W
105F:  MOVWF  5C
1060:  MOVF   78,W
1061:  MOVWF  5B
....................    id[0] = temp[0]; 
1062:  MOVF   5B,W
1063:  MOVWF  04
1064:  BCF    03.7
1065:  BTFSC  5C.0
1066:  BSF    03.7
1067:  MOVF   00,W
1068:  MOVWF  5D
....................    id[1] = temp[1]; 
1069:  MOVLW  01
106A:  ADDWF  5B,W
106B:  MOVWF  04
106C:  BCF    03.7
106D:  BTFSC  5C.0
106E:  BSF    03.7
106F:  MOVF   00,W
1070:  MOVWF  5E
....................    printf(lcd_escreve,"\fid: %u%u",id[0],id[1]); 
1071:  MOVLW  63
1072:  BSF    03.6
1073:  MOVWF  0D
1074:  MOVLW  01
1075:  MOVWF  0F
1076:  BCF    03.0
1077:  MOVLW  05
1078:  BSF    03.5
1079:  BCF    03.6
107A:  MOVWF  55
107B:  BCF    0A.4
107C:  BCF    03.5
107D:  CALL   480
107E:  BSF    0A.4
107F:  MOVF   5D,W
1080:  BSF    03.5
1081:  MOVWF  4A
1082:  MOVLW  1B
1083:  MOVWF  4B
1084:  BCF    0A.4
1085:  BSF    0A.3
1086:  BCF    03.5
1087:  CALL   017
1088:  BSF    0A.4
1089:  BCF    0A.3
108A:  MOVF   5E,W
108B:  BSF    03.5
108C:  MOVWF  4A
108D:  MOVLW  1B
108E:  MOVWF  4B
108F:  BCF    0A.4
1090:  BSF    0A.3
1091:  BCF    03.5
1092:  CALL   017
1093:  BSF    0A.4
1094:  BCF    0A.3
....................    delay_ms(500); 
1095:  MOVLW  02
1096:  MOVWF  76
1097:  MOVLW  FA
1098:  BSF    03.5
1099:  MOVWF  5B
109A:  BCF    0A.4
109B:  BCF    03.5
109C:  CALL   1AD
109D:  BSF    0A.4
109E:  DECFSZ 76,F
109F:  GOTO   097
....................  
....................    char msg [] = "Digite a senha: "; 
10A0:  MOVLW  44
10A1:  MOVWF  64
10A2:  MOVLW  69
10A3:  MOVWF  65
10A4:  MOVLW  67
10A5:  MOVWF  66
10A6:  MOVLW  69
10A7:  MOVWF  67
10A8:  MOVLW  74
10A9:  MOVWF  68
10AA:  MOVLW  65
10AB:  MOVWF  69
10AC:  MOVLW  20
10AD:  MOVWF  6A
10AE:  MOVLW  61
10AF:  MOVWF  6B
10B0:  MOVLW  20
10B1:  MOVWF  6C
10B2:  MOVLW  73
10B3:  MOVWF  6D
10B4:  MOVLW  65
10B5:  MOVWF  6E
10B6:  MOVLW  6E
10B7:  MOVWF  6F
10B8:  MOVLW  68
10B9:  MOVWF  70
10BA:  MOVLW  61
10BB:  MOVWF  71
10BC:  MOVLW  3A
10BD:  MOVWF  72
10BE:  MOVLW  20
10BF:  MOVWF  73
10C0:  CLRF   74
....................    int max = 4; 
10C1:  MOVLW  04
10C2:  MOVWF  75
....................    temp = inputToKeyboard(msg, max); 
10C3:  BSF    03.5
10C4:  CLRF   44
10C5:  MOVLW  64
10C6:  MOVWF  43
10C7:  MOVF   75,W
10C8:  MOVWF  45
10C9:  BCF    0A.4
10CA:  BSF    0A.3
10CB:  BCF    03.5
10CC:  CALL   07B
10CD:  BSF    0A.4
10CE:  BCF    0A.3
10CF:  MOVF   79,W
10D0:  MOVWF  5C
10D1:  MOVF   78,W
10D2:  MOVWF  5B
....................    pass[0] = temp[0]; 
10D3:  MOVF   5B,W
10D4:  MOVWF  04
10D5:  BCF    03.7
10D6:  BTFSC  5C.0
10D7:  BSF    03.7
10D8:  MOVF   00,W
10D9:  MOVWF  5F
....................    pass[1] = temp[1]; 
10DA:  MOVLW  01
10DB:  ADDWF  5B,W
10DC:  MOVWF  04
10DD:  BCF    03.7
10DE:  BTFSC  5C.0
10DF:  BSF    03.7
10E0:  MOVF   00,W
10E1:  MOVWF  60
....................    pass[2] = temp[2]; 
10E2:  MOVLW  02
10E3:  ADDWF  5B,W
10E4:  MOVWF  04
10E5:  BCF    03.7
10E6:  BTFSC  5C.0
10E7:  BSF    03.7
10E8:  MOVF   00,W
10E9:  MOVWF  61
....................    pass[3] = temp[3]; 
10EA:  MOVLW  03
10EB:  ADDWF  5B,W
10EC:  MOVWF  04
10ED:  BCF    03.7
10EE:  BTFSC  5C.0
10EF:  BSF    03.7
10F0:  MOVF   00,W
10F1:  MOVWF  62
....................    printf(lcd_escreve,"\fPASS(4): %u%u%u%u",pass[0],pass[1],pass[2],pass[3]); 
10F2:  MOVLW  68
10F3:  BSF    03.6
10F4:  MOVWF  0D
10F5:  MOVLW  01
10F6:  MOVWF  0F
10F7:  BCF    03.0
10F8:  MOVLW  0A
10F9:  BSF    03.5
10FA:  BCF    03.6
10FB:  MOVWF  55
10FC:  BCF    0A.4
10FD:  BCF    03.5
10FE:  CALL   480
10FF:  BSF    0A.4
1100:  MOVF   5F,W
1101:  BSF    03.5
1102:  MOVWF  4A
1103:  MOVLW  1B
1104:  MOVWF  4B
1105:  BCF    0A.4
1106:  BSF    0A.3
1107:  BCF    03.5
1108:  CALL   017
1109:  BSF    0A.4
110A:  BCF    0A.3
110B:  MOVF   60,W
110C:  BSF    03.5
110D:  MOVWF  4A
110E:  MOVLW  1B
110F:  MOVWF  4B
1110:  BCF    0A.4
1111:  BSF    0A.3
1112:  BCF    03.5
1113:  CALL   017
1114:  BSF    0A.4
1115:  BCF    0A.3
1116:  MOVF   61,W
1117:  BSF    03.5
1118:  MOVWF  4A
1119:  MOVLW  1B
111A:  MOVWF  4B
111B:  BCF    0A.4
111C:  BSF    0A.3
111D:  BCF    03.5
111E:  CALL   017
111F:  BSF    0A.4
1120:  BCF    0A.3
1121:  MOVF   62,W
1122:  BSF    03.5
1123:  MOVWF  4A
1124:  MOVLW  1B
1125:  MOVWF  4B
1126:  BCF    0A.4
1127:  BSF    0A.3
1128:  BCF    03.5
1129:  CALL   017
112A:  BSF    0A.4
112B:  BCF    0A.3
....................    delay_ms(500); 
112C:  MOVLW  02
112D:  MOVWF  76
112E:  MOVLW  FA
112F:  BSF    03.5
1130:  MOVWF  5B
1131:  BCF    0A.4
1132:  BCF    03.5
1133:  CALL   1AD
1134:  BSF    0A.4
1135:  DECFSZ 76,F
1136:  GOTO   12E
....................  
....................    char msg2 [] = "Status (0,1,3): "; 
1137:  MOVLW  53
1138:  BSF    03.5
1139:  MOVWF  20
113A:  MOVLW  74
113B:  MOVWF  21
113C:  MOVLW  61
113D:  MOVWF  22
113E:  MOVLW  74
113F:  MOVWF  23
1140:  MOVLW  75
1141:  MOVWF  24
1142:  MOVLW  73
1143:  MOVWF  25
1144:  MOVLW  20
1145:  MOVWF  26
1146:  MOVLW  28
1147:  MOVWF  27
1148:  MOVLW  30
1149:  MOVWF  28
114A:  MOVLW  2C
114B:  MOVWF  29
114C:  MOVLW  31
114D:  MOVWF  2A
114E:  MOVLW  2C
114F:  MOVWF  2B
1150:  MOVLW  33
1151:  MOVWF  2C
1152:  MOVLW  29
1153:  MOVWF  2D
1154:  MOVLW  3A
1155:  MOVWF  2E
1156:  MOVLW  20
1157:  MOVWF  2F
1158:  CLRF   30
....................    max = 1; 
1159:  MOVLW  01
115A:  MOVWF  75
....................    temp = inputToKeyboard(msg2, max); 
115B:  CLRF   44
115C:  MOVLW  A0
115D:  MOVWF  43
115E:  MOVF   75,W
115F:  MOVWF  45
1160:  BCF    0A.4
1161:  BSF    0A.3
1162:  BCF    03.5
1163:  CALL   07B
1164:  BSF    0A.4
1165:  BCF    0A.3
1166:  MOVF   79,W
1167:  MOVWF  5C
1168:  MOVF   78,W
1169:  MOVWF  5B
....................    status = temp[0]; 
116A:  MOVF   5B,W
116B:  MOVWF  04
116C:  BCF    03.7
116D:  BTFSC  5C.0
116E:  BSF    03.7
116F:  MOVF   00,W
1170:  MOVWF  63
....................    printf(lcd_escreve,"\fSTATUS: %u",status); 
1171:  MOVLW  72
1172:  BSF    03.6
1173:  MOVWF  0D
1174:  MOVLW  01
1175:  MOVWF  0F
1176:  BCF    03.0
1177:  MOVLW  09
1178:  BSF    03.5
1179:  BCF    03.6
117A:  MOVWF  55
117B:  BCF    0A.4
117C:  BCF    03.5
117D:  CALL   480
117E:  BSF    0A.4
117F:  MOVF   63,W
1180:  BSF    03.5
1181:  MOVWF  4A
1182:  MOVLW  1B
1183:  MOVWF  4B
1184:  BCF    0A.4
1185:  BSF    0A.3
1186:  BCF    03.5
1187:  CALL   017
1188:  BSF    0A.4
1189:  BCF    0A.3
....................    delay_ms(500); 
118A:  MOVLW  02
118B:  MOVWF  76
118C:  MOVLW  FA
118D:  BSF    03.5
118E:  MOVWF  5B
118F:  BCF    0A.4
1190:  BCF    03.5
1191:  CALL   1AD
1192:  BSF    0A.4
1193:  DECFSZ 76,F
1194:  GOTO   18C
....................  
....................    saveUser(id,pass,status); 
1195:  BSF    03.5
1196:  CLRF   32
1197:  MOVLW  5D
1198:  MOVWF  31
1199:  CLRF   34
119A:  MOVLW  5F
119B:  MOVWF  33
119C:  BCF    03.5
119D:  MOVF   63,W
119E:  BSF    03.5
119F:  MOVWF  35
.................... } 
....................  
.................... void editUser(){ 
....................    unsigned int * temp; 
....................    unsigned int id [2]; 
....................    temp = inputId(); 
*
14A7:  BCF    0A.4
14A8:  CALL   79D
14A9:  BSF    0A.4
14AA:  MOVF   79,W
14AB:  MOVWF  5C
14AC:  MOVF   78,W
14AD:  MOVWF  5B
....................    id[0] = temp[0]; 
14AE:  MOVF   5B,W
14AF:  MOVWF  04
14B0:  BCF    03.7
14B1:  BTFSC  5C.0
14B2:  BSF    03.7
14B3:  MOVF   00,W
14B4:  MOVWF  5D
....................    id[1] = temp[1]; 
14B5:  MOVLW  01
14B6:  ADDWF  5B,W
14B7:  MOVWF  04
14B8:  BCF    03.7
14B9:  BTFSC  5C.0
14BA:  BSF    03.7
14BB:  MOVF   00,W
14BC:  MOVWF  5E
....................  
....................    int address = getAddressByID(id); 
14BD:  BSF    03.5
14BE:  CLRF   44
14BF:  MOVLW  5D
14C0:  MOVWF  43
14C1:  BCF    0A.4
14C2:  BSF    0A.3
14C3:  BCF    03.5
14C4:  CALL   27F
14C5:  BSF    0A.4
14C6:  BCF    0A.3
14C7:  MOVF   78,W
14C8:  MOVWF  5F
....................    if(address != -1){ 
14C9:  MOVF   5F,W
14CA:  SUBLW  FF
14CB:  BTFSC  03.2
14CC:  GOTO   6AB
....................       unsigned int * temp; 
....................       unsigned int pass[4]; 
....................       unsigned int status; 
....................  
....................       char msg [] = "Digite a senha: "; 
14CD:  MOVLW  44
14CE:  BSF    03.5
14CF:  MOVWF  20
14D0:  MOVLW  69
14D1:  MOVWF  21
14D2:  MOVLW  67
14D3:  MOVWF  22
14D4:  MOVLW  69
14D5:  MOVWF  23
14D6:  MOVLW  74
14D7:  MOVWF  24
14D8:  MOVLW  65
14D9:  MOVWF  25
14DA:  MOVLW  20
14DB:  MOVWF  26
14DC:  MOVLW  61
14DD:  MOVWF  27
14DE:  MOVLW  20
14DF:  MOVWF  28
14E0:  MOVLW  73
14E1:  MOVWF  29
14E2:  MOVLW  65
14E3:  MOVWF  2A
14E4:  MOVLW  6E
14E5:  MOVWF  2B
14E6:  MOVLW  68
14E7:  MOVWF  2C
14E8:  MOVLW  61
14E9:  MOVWF  2D
14EA:  MOVLW  3A
14EB:  MOVWF  2E
14EC:  MOVLW  20
14ED:  MOVWF  2F
14EE:  CLRF   30
....................       int max = 4; 
14EF:  MOVLW  04
14F0:  BCF    03.5
14F1:  MOVWF  67
....................       temp = inputToKeyboard(msg, max); 
14F2:  BSF    03.5
14F3:  CLRF   44
14F4:  MOVLW  A0
14F5:  MOVWF  43
14F6:  BCF    03.5
14F7:  MOVF   67,W
14F8:  BSF    03.5
14F9:  MOVWF  45
14FA:  BCF    0A.4
14FB:  BSF    0A.3
14FC:  BCF    03.5
14FD:  CALL   07B
14FE:  BSF    0A.4
14FF:  BCF    0A.3
1500:  MOVF   79,W
1501:  MOVWF  61
1502:  MOVF   78,W
1503:  MOVWF  60
....................       pass[0] = temp[0]; 
1504:  MOVF   60,W
1505:  MOVWF  04
1506:  BCF    03.7
1507:  BTFSC  61.0
1508:  BSF    03.7
1509:  MOVF   00,W
150A:  MOVWF  62
....................       pass[1] = temp[1]; 
150B:  MOVLW  01
150C:  ADDWF  60,W
150D:  MOVWF  04
150E:  BCF    03.7
150F:  BTFSC  61.0
1510:  BSF    03.7
1511:  MOVF   00,W
1512:  MOVWF  63
....................       pass[2] = temp[2]; 
1513:  MOVLW  02
1514:  ADDWF  60,W
1515:  MOVWF  04
1516:  BCF    03.7
1517:  BTFSC  61.0
1518:  BSF    03.7
1519:  MOVF   00,W
151A:  MOVWF  64
....................       pass[3] = temp[3]; 
151B:  MOVLW  03
151C:  ADDWF  60,W
151D:  MOVWF  04
151E:  BCF    03.7
151F:  BTFSC  61.0
1520:  BSF    03.7
1521:  MOVF   00,W
1522:  MOVWF  65
....................       printf(lcd_escreve,"\fPASS(4): %u%u%u%u",pass[0],pass[1],pass[2],pass[3]); 
1523:  MOVLW  78
1524:  BSF    03.6
1525:  MOVWF  0D
1526:  MOVLW  01
1527:  MOVWF  0F
1528:  BCF    03.0
1529:  MOVLW  0A
152A:  BSF    03.5
152B:  BCF    03.6
152C:  MOVWF  55
152D:  BCF    0A.4
152E:  BCF    03.5
152F:  CALL   480
1530:  BSF    0A.4
1531:  MOVF   62,W
1532:  BSF    03.5
1533:  MOVWF  4A
1534:  MOVLW  1B
1535:  MOVWF  4B
1536:  BCF    0A.4
1537:  BSF    0A.3
1538:  BCF    03.5
1539:  CALL   017
153A:  BSF    0A.4
153B:  BCF    0A.3
153C:  MOVF   63,W
153D:  BSF    03.5
153E:  MOVWF  4A
153F:  MOVLW  1B
1540:  MOVWF  4B
1541:  BCF    0A.4
1542:  BSF    0A.3
1543:  BCF    03.5
1544:  CALL   017
1545:  BSF    0A.4
1546:  BCF    0A.3
1547:  MOVF   64,W
1548:  BSF    03.5
1549:  MOVWF  4A
154A:  MOVLW  1B
154B:  MOVWF  4B
154C:  BCF    0A.4
154D:  BSF    0A.3
154E:  BCF    03.5
154F:  CALL   017
1550:  BSF    0A.4
1551:  BCF    0A.3
1552:  MOVF   65,W
1553:  BSF    03.5
1554:  MOVWF  4A
1555:  MOVLW  1B
1556:  MOVWF  4B
1557:  BCF    0A.4
1558:  BSF    0A.3
1559:  BCF    03.5
155A:  CALL   017
155B:  BSF    0A.4
155C:  BCF    0A.3
....................       delay_ms(500); 
155D:  MOVLW  02
155E:  MOVWF  68
155F:  MOVLW  FA
1560:  BSF    03.5
1561:  MOVWF  5B
1562:  BCF    0A.4
1563:  BCF    03.5
1564:  CALL   1AD
1565:  BSF    0A.4
1566:  DECFSZ 68,F
1567:  GOTO   55F
....................  
....................       char msg2 [] = "Status (0,1,3): "; 
1568:  MOVLW  53
1569:  BSF    03.5
156A:  MOVWF  31
156B:  MOVLW  74
156C:  MOVWF  32
156D:  MOVLW  61
156E:  MOVWF  33
156F:  MOVLW  74
1570:  MOVWF  34
1571:  MOVLW  75
1572:  MOVWF  35
1573:  MOVLW  73
1574:  MOVWF  36
1575:  MOVLW  20
1576:  MOVWF  37
1577:  MOVLW  28
1578:  MOVWF  38
1579:  MOVLW  30
157A:  MOVWF  39
157B:  MOVLW  2C
157C:  MOVWF  3A
157D:  MOVLW  31
157E:  MOVWF  3B
157F:  MOVLW  2C
1580:  MOVWF  3C
1581:  MOVLW  33
1582:  MOVWF  3D
1583:  MOVLW  29
1584:  MOVWF  3E
1585:  MOVLW  3A
1586:  MOVWF  3F
1587:  MOVLW  20
1588:  MOVWF  40
1589:  CLRF   41
....................       max = 1; 
158A:  MOVLW  01
158B:  BCF    03.5
158C:  MOVWF  67
....................       temp = inputToKeyboard(msg2, max); 
158D:  BSF    03.5
158E:  CLRF   44
158F:  MOVLW  B1
1590:  MOVWF  43
1591:  BCF    03.5
1592:  MOVF   67,W
1593:  BSF    03.5
1594:  MOVWF  45
1595:  BCF    0A.4
1596:  BSF    0A.3
1597:  BCF    03.5
1598:  CALL   07B
1599:  BSF    0A.4
159A:  BCF    0A.3
159B:  MOVF   79,W
159C:  MOVWF  61
159D:  MOVF   78,W
159E:  MOVWF  60
....................       status = temp[0]; 
159F:  MOVF   60,W
15A0:  MOVWF  04
15A1:  BCF    03.7
15A2:  BTFSC  61.0
15A3:  BSF    03.7
15A4:  MOVF   00,W
15A5:  MOVWF  66
....................       printf(lcd_escreve,"\fSTATUS: %u",status); 
15A6:  MOVLW  82
15A7:  BSF    03.6
15A8:  MOVWF  0D
15A9:  MOVLW  01
15AA:  MOVWF  0F
15AB:  BCF    03.0
15AC:  MOVLW  09
15AD:  BSF    03.5
15AE:  BCF    03.6
15AF:  MOVWF  55
15B0:  BCF    0A.4
15B1:  BCF    03.5
15B2:  CALL   480
15B3:  BSF    0A.4
15B4:  MOVF   66,W
15B5:  BSF    03.5
15B6:  MOVWF  4A
15B7:  MOVLW  1B
15B8:  MOVWF  4B
15B9:  BCF    0A.4
15BA:  BSF    0A.3
15BB:  BCF    03.5
15BC:  CALL   017
15BD:  BSF    0A.4
15BE:  BCF    0A.3
....................       delay_ms(500); 
15BF:  MOVLW  02
15C0:  MOVWF  68
15C1:  MOVLW  FA
15C2:  BSF    03.5
15C3:  MOVWF  5B
15C4:  BCF    0A.4
15C5:  BCF    03.5
15C6:  CALL   1AD
15C7:  BSF    0A.4
15C8:  DECFSZ 68,F
15C9:  GOTO   5C1
....................  
....................       updateUser(id,pass,status,address); 
15CA:  BSF    03.5
15CB:  CLRF   49
15CC:  MOVLW  5D
15CD:  MOVWF  48
15CE:  CLRF   4B
15CF:  MOVLW  62
15D0:  MOVWF  4A
15D1:  BCF    03.5
15D2:  MOVF   66,W
15D3:  BSF    03.5
15D4:  MOVWF  4C
15D5:  BCF    03.5
15D6:  MOVF   5F,W
15D7:  BSF    03.5
15D8:  MOVWF  4D
....................    }else{ 
*
16A9:  GOTO   6C0
16AA:  BCF    03.5
....................       printf (lcd_escreve,"\fID N Existe",); 
16AB:  MOVLW  88
16AC:  BSF    03.6
16AD:  MOVWF  0D
16AE:  MOVLW  01
16AF:  MOVWF  0F
16B0:  BCF    0A.4
16B1:  BCF    03.6
16B2:  CALL   2A7
16B3:  BSF    0A.4
....................       delay_ms(500); 
16B4:  MOVLW  02
16B5:  MOVWF  68
16B6:  MOVLW  FA
16B7:  BSF    03.5
16B8:  MOVWF  5B
16B9:  BCF    0A.4
16BA:  BCF    03.5
16BB:  CALL   1AD
16BC:  BSF    0A.4
16BD:  DECFSZ 68,F
16BE:  GOTO   6B6
16BF:  BSF    03.5
....................    } 
.................... } 
....................  
....................  
.................... /* 
.................... // ---- MSG from serial communication 
.................... #int_RDA 
.................... void RDA_isr(void){ 
....................    rx_buffer[rx_wr_index] = getc(); 
....................    rxd = rx_buffer[rx_wr_index]; 
....................    rx_wr_index++; 
....................  
....................    if(rx_wr_index > RX_BUFFER_SIZE){ 
....................       rx_wr_index = 0; 
....................    } 
....................  
....................    //Look for unique ID: "IFMT" 
....................    if(rxd == 'I' && lock_pos == 0){ 
....................       lock_pos++; 
....................    } 
....................    else if(rxd == 'F' && lock_pos == 1){ 
....................       lock_pos++; 
....................    } 
....................    else if(rxd == 'M' && lock_pos == 2){ 
....................       lock_pos++; 
....................    } 
....................    else if(rxd == 'T' && lock_pos == 3){ 
....................       lock_pos=0; //Reset the "combination lock" 
....................       got_id = TRUE; 
....................       read = rxd; 
....................       //get ready to count the number of data bytes 
....................       valid_data_count = 0xff;  
....................  
....................       //buffer is reset to index 0 
....................       rx_wr_index = 0; 
....................    }else { 
....................       lock_pos = 0; 
....................    } 
....................  
....................    if(got_id && ++valid_data_count >= 6){ 
....................       data_avail = TRUE; 
....................       got_id = FALSE; 
....................    } 
....................     
.................... } 
.................... */ 
....................  
....................  
....................  
....................  
.................... #int_TIMER1 
.................... void TIMER1_isr(void) 
.................... { 
.................... } 
....................  
*
018F:  BCF    0C.0
0190:  BCF    0A.3
0191:  BCF    0A.4
0192:  GOTO   031
.................... #int_RTCC 
.................... void RTCC_isr(void) 
.................... { 
....................  
....................        
0193:  BCF    0B.2
0194:  BCF    0A.3
0195:  BCF    0A.4
0196:  GOTO   031
.................... } 
....................  
.................... void main() 
*
0B99:  MOVF   03,W
0B9A:  ANDLW  1F
0B9B:  MOVWF  03
0B9C:  CLRF   2C
0B9D:  CLRF   2D
0B9E:  CLRF   31
0B9F:  CLRF   32
0BA0:  MOVLW  FF
0BA1:  MOVWF  3D
0BA2:  BSF    03.5
0BA3:  BSF    1F.0
0BA4:  BSF    1F.1
0BA5:  BSF    1F.2
0BA6:  BCF    1F.3
0BA7:  MOVLW  07
0BA8:  MOVWF  1C
0BA9:  BCF    03.7
*
0BBB:  CLRF   54
.................... { 
....................    //VARIAVEIS 
....................    byte result; 
....................    unsigned char option; 
....................     
....................    eeprom_address address = 0; 
....................  
....................    // unsigned char tmp_result; 
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_256|RTCC_8_bit);      //13.1ms overflow 
0BBC:  BSF    03.5
0BBD:  MOVF   01,W
0BBE:  ANDLW  C0
0BBF:  IORLW  07
0BC0:  MOVWF  01
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); //Overflow in 104ms | Resolution 1.6 us 
0BC1:  MOVLW  B5
0BC2:  BCF    03.5
0BC3:  MOVWF  10
....................  
....................    init_ext_eeprom(); 
0BC4:  BCF    0A.3
0BC5:  GOTO   1A0
0BC6:  BSF    0A.3
....................  
....................    enable_interrupts(INT_TIMER0); 
0BC7:  BSF    0B.5
....................    enable_interrupts(INT_TIMER1); 
0BC8:  BSF    03.5
0BC9:  BSF    0C.0
....................  
....................    enable_interrupts(GLOBAL); 
0BCA:  MOVLW  C0
0BCB:  BCF    03.5
0BCC:  IORWF  0B,F
....................  
....................  
....................    lcd_ini(); 
0BCD:  BCF    0A.3
0BCE:  GOTO   21B
0BCF:  BSF    0A.3
....................    delay_us(50); 
0BD0:  MOVLW  52
0BD1:  MOVWF  77
0BD2:  DECFSZ 77,F
0BD3:  GOTO   3D2
0BD4:  GOTO   3D5
0BD5:  NOP
....................    printf(lcd_escreve, "\f  iniciando... "); 
0BD6:  MOVLW  97
0BD7:  BSF    03.6
0BD8:  MOVWF  0D
0BD9:  MOVLW  01
0BDA:  MOVWF  0F
0BDB:  BCF    0A.3
0BDC:  BCF    03.6
0BDD:  CALL   2A7
0BDE:  BSF    0A.3
....................    delay_ms(200); 
0BDF:  MOVLW  C8
0BE0:  BSF    03.5
0BE1:  MOVWF  5B
0BE2:  BCF    0A.3
0BE3:  BCF    03.5
0BE4:  CALL   1AD
0BE5:  BSF    0A.3
....................  
....................    // printf(lcd_escreve, "\fIFMT - Serial"); 
....................    // delay_ms(50); 
....................  
....................    // int size = BLOCK_SIZE; 
....................    // printf(lcd_escreve, "\fBlock_Size:%u", size); 
....................    // delay_ms(500); 
....................  
....................    // resetmemory(); 
....................  
....................    // int id [2] = {12,34}; 
....................    // int pass [4] = {1,2,3,4}; 
....................    // saveuser(id, pass, 1); 
....................    // int id1 [2] = {14,0}; 
....................    // saveuser(id1, pass, 0); 
....................    // int id2 [2] = {70,10}; 
....................    // saveuser(id2, pass, 1); 
....................    // int id3 [2] = {0,10}; 
....................    // saveuser(id3, pass, 1); 
....................    // int id4 [2] = {99,99}; 
....................    // saveuser(id4, pass, 3);//admin 
....................     
....................     
....................    // getAddressByID(id2); 
....................    adminMenu(); 
0BE6:  BSF    0A.4
0BE7:  BCF    0A.3
0BE8:  GOTO   000
0BE9:  BCF    0A.4
0BEA:  BSF    0A.3
....................  
....................  
....................  
....................    // char keyboard_buffer[]= '6'; 
....................    // char n = '9'; 
....................    // unsigned char temp_pass[2]; 
....................    // unsigned int * buffer; 
....................    // unsigned int pass[4]; 
....................    // strfromchar(temp_pass,n); 
....................    // buffer = strToInt(temp_pass); 
....................    // pass[0] = buffer[0]; 
....................  
....................    // printf(lcd_escreve,"\foutside:%u", pass[0]); 
....................    // delay_ms(800); 
....................  
....................  
....................    // int index = 2; 
....................    // if(index>0){//for testing purposes 
....................    //    for(int i=0; i < index; i++){ 
....................    //       printf(lcd_escreve,"\foutside:%u", buffer[i]); 
....................    //       delay_ms(800); 
....................    //    } 
....................    // } 
....................   
....................   
....................   // address_data_delete = getAddressByID(6); 
....................   // printf(lcd_escreve, "\f Address ID = %d", address_data_delete); 
....................  //  deleteBlock(address_data_delete); 
....................    delay_ms(50); 
0BEB:  MOVLW  32
0BEC:  BSF    03.5
0BED:  MOVWF  5B
0BEE:  BCF    0A.3
0BEF:  BCF    03.5
0BF0:  CALL   1AD
0BF1:  BSF    0A.3
....................     
....................    while(TRUE) 
....................    { 
0BF2:  GOTO   3F2
....................    } 
....................  
.................... } 
....................  
0BF3:  SLEEP

Configuration Fuses:
   Word  1: 3F32   HS NOWDT PUT NOBROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT

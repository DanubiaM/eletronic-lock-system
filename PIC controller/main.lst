CCS PCM C Compiler, Version 5.025, 7201               20-Nov-21 20:29

               Filename:   E:\University\Microcontrollers\PCW Projects\eletronic-lock-system\PIC controller\main.lst

               ROM used:   3564 words (44%)
                           Largest free fragment is 2048
               RAM used:   58 (16%) at main() level
                           222 (60%) worst case
               Stack used: 7 locations (6 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  0D
0001:  MOVWF  0A
0002:  GOTO   5CB
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  BTFSS  0B.5
0028:  GOTO   02B
0029:  BTFSC  0B.2
002A:  GOTO   052
002B:  MOVLW  8C
002C:  MOVWF  04
002D:  BTFSS  00.0
002E:  GOTO   031
002F:  BTFSC  0C.0
0030:  GOTO   055
0031:  MOVF   22,W
0032:  MOVWF  04
0033:  MOVF   23,W
0034:  MOVWF  77
0035:  MOVF   24,W
0036:  MOVWF  78
0037:  MOVF   25,W
0038:  MOVWF  79
0039:  MOVF   26,W
003A:  MOVWF  7A
003B:  MOVF   27,W
003C:  BSF    03.6
003D:  MOVWF  0D
003E:  BCF    03.6
003F:  MOVF   28,W
0040:  BSF    03.6
0041:  MOVWF  0F
0042:  BCF    03.6
0043:  MOVF   29,W
0044:  BSF    03.6
0045:  MOVWF  0C
0046:  BCF    03.6
0047:  MOVF   2A,W
0048:  BSF    03.6
0049:  MOVWF  0E
004A:  BCF    03.6
004B:  MOVF   20,W
004C:  MOVWF  0A
004D:  SWAPF  21,W
004E:  MOVWF  03
004F:  SWAPF  7F,F
0050:  SWAPF  7F,W
0051:  RETFIE
0052:  BCF    0A.3
0053:  BCF    0A.4
0054:  GOTO   110
0055:  BCF    0A.3
0056:  BCF    0A.4
0057:  GOTO   10C
....................  
.................... #include <16F877A.h> 
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
0058:  BCF    0A.0
0059:  BCF    0A.1
005A:  BCF    0A.2
005B:  ADDWF  02,F
005C:  RETLW  28
005D:  RETLW  0F
005E:  RETLW  01
005F:  RETLW  06
0060:  DATA 8C,2A
0061:  DATA F3,3A
0062:  DATA 61,39
0063:  DATA E9,37
0064:  DATA A0,21
0065:  DATA 61,32
0066:  DATA E1,39
0067:  DATA 74,39
0068:  DATA 61,32
0069:  DATA 6F,00
006A:  DATA 8C,24
006B:  DATA 44,10
006C:  DATA 69,37
006D:  DATA E3,37
006E:  DATA 6D,38
006F:  DATA 61,3A
0070:  DATA 69,3B
0071:  DATA 65,36
0072:  DATA 00,01
0073:  DATA 0D,05
0074:  DATA D4,32
0075:  DATA 6E,3A
0076:  DATA 65,10
0077:  DATA EE,37
0078:  DATA F6,30
0079:  DATA ED,32
007A:  DATA 6E,3A
007B:  DATA 65,00
007C:  DATA 0C,10
007D:  DATA C2,3A
007E:  DATA 74,3A
007F:  DATA 6F,37
0080:  DATA 3A,10
0081:  DATA 25,32
0082:  DATA 00,00
0083:  DATA 0D,05
0084:  DATA D0,3B
0085:  DATA BA,12
0086:  DATA E4,12
0087:  DATA E4,12
0088:  DATA E4,12
0089:  DATA 64,10
008A:  DATA 53,3A
008B:  DATA BA,12
008C:  DATA 64,10
008D:  DATA 25,32
008E:  DATA 00,00
008F:  DATA 8C,24
0090:  DATA 44,10
0091:  DATA 45,37
0092:  DATA E3,37
0093:  DATA 6E,3A
0094:  DATA F2,30
0095:  DATA E4,37
0096:  DATA BA,12
0097:  DATA F5,12
0098:  DATA 75,00
0099:  DATA 0C,10
009A:  DATA 49,22
009B:  DATA 20,27
009C:  DATA A0,22
009D:  DATA EE,31
009E:  DATA 6F,37
009F:  DATA 74,39
00A0:  DATA 61,32
00A1:  DATA 6F,00
00A2:  DATA 0C,10
00A3:  DATA D5,39
00A4:  DATA 65,39
00A5:  DATA A0,32
00A6:  DATA F2,30
00A7:  DATA F3,32
00A8:  DATA 64,10
00A9:  DATA 00,00
00AA:  DATA 8C,20
00AB:  DATA 64,32
00AC:  DATA F2,32
00AD:  DATA F3,39
00AE:  DATA 3A,10
00AF:  DATA 25,32
00B0:  DATA 00,00
00B1:  DATA 8C,24
00B2:  DATA 44,1D
00B3:  DATA A5,3A
00B4:  DATA 2C,10
00B5:  DATA 45,3C
00B6:  DATA E9,39
00B7:  DATA F4,32
00B8:  DATA 00,01
00B9:  DATA 8C,24
00BA:  DATA 44,1D
00BB:  DATA A5,3A
00BC:  DATA 2C,10
00BD:  DATA 4E,10
00BE:  DATA 45,3C
00BF:  DATA E9,39
00C0:  DATA F4,32
00C1:  DATA 00,00
00C2:  DATA 0C,10
00C3:  DATA 4F,38
00C4:  DATA F4,34
00C5:  DATA 6F,37
00C6:  DATA 3A,10
00C7:  DATA A5,31
00C8:  DATA 00,00
00C9:  DATA 0C,10
00CA:  DATA 20,10
00CB:  DATA D4,22
00CC:  DATA 43,26
00CD:  DATA 41,22
00CE:  DATA 4F,10
00CF:  DATA 20,00
00D0:  DATA 8C,20
00D1:  DATA E4,36
00D2:  DATA 69,37
00D3:  DATA A0,22
00D4:  DATA EE,31
00D5:  DATA 6F,37
00D6:  DATA 74,39
00D7:  DATA 61,32
00D8:  DATA 6F,00
00D9:  DATA 0C,10
00DA:  DATA 61,32
00DB:  DATA ED,34
00DC:  DATA EE,39
00DD:  DATA 5B,18
00DE:  DATA 5D,1D
00DF:  DATA A0,12
00E0:  DATA 64,00
00E1:  DATA 8C,34
00E2:  DATA 64,3F
00E3:  DATA BA,12
00E4:  DATA F5,12
00E5:  DATA 75,00
00E6:  DATA 0C,22
00E7:  DATA E9,33
00E8:  DATA 69,3A
00E9:  DATA 65,10
00EA:  DATA 6F,10
00EB:  DATA 49,22
00EC:  DATA 00,01
00ED:  DATA 0C,2A
00EE:  DATA 79,38
00EF:  DATA 65,32
00F0:  DATA BA,12
00F1:  DATA 63,00
00F2:  DATA 0C,2A
00F3:  DATA 79,38
00F4:  DATA 65,32
00F5:  DATA BA,12
00F6:  DATA 63,00
00F7:  DATA 8C,34
00F8:  DATA 64,1D
00F9:  DATA A0,12
00FA:  DATA F5,12
00FB:  DATA 75,00
00FC:  DATA 0C,28
00FD:  DATA C1,29
00FE:  DATA 53,14
00FF:  DATA B4,14
0100:  DATA 3A,10
0101:  DATA A5,3A
0102:  DATA A5,3A
0103:  DATA A5,3A
0104:  DATA A5,3A
0105:  DATA 00,01
0106:  DATA 8C,29
0107:  DATA D4,20
0108:  DATA D4,2A
0109:  DATA 53,1D
010A:  DATA A0,12
010B:  DATA 75,00
*
0114:  DATA 0C,10
0115:  DATA A0,34
0116:  DATA EE,34
0117:  DATA E3,34
0118:  DATA 61,37
0119:  DATA E4,37
011A:  DATA 2E,17
011B:  DATA 2E,10
011C:  DATA 00,00
*
0224:  MOVF   0B,W
0225:  BSF    03.5
0226:  MOVWF  45
0227:  BCF    03.5
0228:  BCF    0B.7
0229:  BSF    03.5
022A:  BSF    03.6
022B:  BSF    0C.7
022C:  BSF    0C.0
022D:  NOP
022E:  NOP
022F:  BCF    03.6
0230:  BTFSS  45.7
0231:  GOTO   235
0232:  BCF    03.5
0233:  BSF    0B.7
0234:  BSF    03.5
0235:  BCF    03.5
0236:  BSF    03.6
0237:  MOVF   0C,W
0238:  ANDLW  7F
0239:  BTFSC  03.2
023A:  GOTO   296
023B:  BSF    03.5
023C:  BCF    03.6
023D:  MOVWF  45
023E:  BCF    03.5
023F:  BSF    03.6
0240:  MOVF   0D,W
0241:  BSF    03.5
0242:  BCF    03.6
0243:  MOVWF  46
0244:  BCF    03.5
0245:  BSF    03.6
0246:  MOVF   0F,W
0247:  BSF    03.5
0248:  BCF    03.6
0249:  MOVWF  47
024A:  MOVF   45,W
024B:  MOVWF  48
024C:  BCF    03.5
024D:  CALL   1E1
024E:  BSF    03.5
024F:  MOVF   46,W
0250:  BCF    03.5
0251:  BSF    03.6
0252:  MOVWF  0D
0253:  BSF    03.5
0254:  BCF    03.6
0255:  MOVF   47,W
0256:  BCF    03.5
0257:  BSF    03.6
0258:  MOVWF  0F
0259:  BCF    03.6
025A:  MOVF   0B,W
025B:  BSF    03.5
025C:  MOVWF  48
025D:  BCF    03.5
025E:  BCF    0B.7
025F:  BSF    03.5
0260:  BSF    03.6
0261:  BSF    0C.7
0262:  BSF    0C.0
0263:  NOP
0264:  NOP
0265:  BCF    03.6
0266:  BTFSS  48.7
0267:  GOTO   26B
0268:  BCF    03.5
0269:  BSF    0B.7
026A:  BSF    03.5
026B:  BCF    03.5
026C:  BSF    03.6
026D:  RLF    0C,W
026E:  RLF    0E,W
026F:  ANDLW  7F
0270:  BTFSC  03.2
0271:  GOTO   296
0272:  BSF    03.5
0273:  BCF    03.6
0274:  MOVWF  45
0275:  BCF    03.5
0276:  BSF    03.6
0277:  MOVF   0D,W
0278:  BSF    03.5
0279:  BCF    03.6
027A:  MOVWF  46
027B:  BCF    03.5
027C:  BSF    03.6
027D:  MOVF   0F,W
027E:  BSF    03.5
027F:  BCF    03.6
0280:  MOVWF  47
0281:  MOVF   45,W
0282:  MOVWF  48
0283:  BCF    03.5
0284:  CALL   1E1
0285:  BSF    03.5
0286:  MOVF   46,W
0287:  BCF    03.5
0288:  BSF    03.6
0289:  MOVWF  0D
028A:  BSF    03.5
028B:  BCF    03.6
028C:  MOVF   47,W
028D:  BCF    03.5
028E:  BSF    03.6
028F:  MOVWF  0F
0290:  INCF   0D,F
0291:  BTFSC  03.2
0292:  INCF   0F,F
0293:  BCF    03.6
0294:  GOTO   224
0295:  BSF    03.6
0296:  BCF    03.6
0297:  RETURN
*
05F7:  MOVF   0B,W
05F8:  BSF    03.5
05F9:  MOVWF  44
05FA:  BCF    03.5
05FB:  BCF    0B.7
05FC:  BSF    03.5
05FD:  BSF    03.6
05FE:  BSF    0C.7
05FF:  BSF    0C.0
0600:  NOP
0601:  NOP
0602:  BCF    03.6
0603:  BTFSS  44.7
0604:  GOTO   608
0605:  BCF    03.5
0606:  BSF    0B.7
0607:  BSF    03.5
0608:  BTFSC  03.0
0609:  GOTO   641
060A:  BCF    03.5
060B:  BSF    03.6
060C:  MOVF   0C,W
060D:  ANDLW  7F
060E:  BSF    03.5
060F:  BCF    03.6
0610:  MOVWF  44
0611:  BCF    03.5
0612:  BSF    03.6
0613:  MOVF   0D,W
0614:  BSF    03.5
0615:  BCF    03.6
0616:  MOVWF  45
0617:  BCF    03.5
0618:  BSF    03.6
0619:  MOVF   0F,W
061A:  BSF    03.5
061B:  BCF    03.6
061C:  MOVWF  46
061D:  MOVF   44,W
061E:  MOVWF  48
061F:  BCF    03.5
0620:  CALL   1E1
0621:  BSF    03.5
0622:  MOVF   45,W
0623:  BCF    03.5
0624:  BSF    03.6
0625:  MOVWF  0D
0626:  BSF    03.5
0627:  BCF    03.6
0628:  MOVF   46,W
0629:  BCF    03.5
062A:  BSF    03.6
062B:  MOVWF  0F
062C:  BCF    03.6
062D:  MOVF   0B,W
062E:  BSF    03.5
062F:  MOVWF  47
0630:  BCF    03.5
0631:  BCF    0B.7
0632:  BSF    03.5
0633:  BSF    03.6
0634:  BSF    0C.7
0635:  BSF    0C.0
0636:  NOP
0637:  NOP
0638:  BCF    03.6
0639:  BTFSS  47.7
063A:  GOTO   63E
063B:  BCF    03.5
063C:  BSF    0B.7
063D:  BSF    03.5
063E:  DECFSZ 43,F
063F:  GOTO   641
0640:  GOTO   66F
0641:  BCF    03.5
0642:  BSF    03.6
0643:  RLF    0C,W
0644:  RLF    0E,W
0645:  ANDLW  7F
0646:  BSF    03.5
0647:  BCF    03.6
0648:  MOVWF  44
0649:  BCF    03.5
064A:  BSF    03.6
064B:  MOVF   0D,W
064C:  BSF    03.5
064D:  BCF    03.6
064E:  MOVWF  45
064F:  BCF    03.5
0650:  BSF    03.6
0651:  MOVF   0F,W
0652:  BSF    03.5
0653:  BCF    03.6
0654:  MOVWF  46
0655:  MOVF   44,W
0656:  MOVWF  48
0657:  BCF    03.5
0658:  CALL   1E1
0659:  BSF    03.5
065A:  MOVF   45,W
065B:  BCF    03.5
065C:  BSF    03.6
065D:  MOVWF  0D
065E:  BSF    03.5
065F:  BCF    03.6
0660:  MOVF   46,W
0661:  BCF    03.5
0662:  BSF    03.6
0663:  MOVWF  0F
0664:  INCF   0D,F
0665:  BTFSC  03.2
0666:  INCF   0F,F
0667:  BCF    03.0
0668:  BSF    03.5
0669:  BCF    03.6
066A:  DECFSZ 43,F
066B:  GOTO   66D
066C:  GOTO   66F
066D:  BCF    03.5
066E:  GOTO   5F7
066F:  BCF    03.5
0670:  RETURN
*
06DC:  BSF    03.5
06DD:  MOVF   47,W
06DE:  CLRF   78
06DF:  SUBWF  46,W
06E0:  BTFSC  03.0
06E1:  GOTO   6E5
06E2:  MOVF   46,W
06E3:  MOVWF  77
06E4:  GOTO   6F1
06E5:  CLRF   77
06E6:  MOVLW  08
06E7:  MOVWF  48
06E8:  RLF    46,F
06E9:  RLF    77,F
06EA:  MOVF   47,W
06EB:  SUBWF  77,W
06EC:  BTFSC  03.0
06ED:  MOVWF  77
06EE:  RLF    78,F
06EF:  DECFSZ 48,F
06F0:  GOTO   6E8
06F1:  BCF    03.5
06F2:  RETURN
06F3:  MOVF   78,W
06F4:  BSF    03.5
06F5:  MOVF   43,W
06F6:  MOVWF  46
06F7:  MOVLW  64
06F8:  MOVWF  47
06F9:  BCF    03.5
06FA:  CALL   6DC
06FB:  MOVF   77,W
06FC:  BSF    03.5
06FD:  MOVWF  43
06FE:  MOVF   78,W
06FF:  MOVLW  30
0700:  BTFSS  03.2
0701:  GOTO   709
0702:  BTFSS  44.1
0703:  GOTO   712
0704:  BTFSC  44.3
0705:  GOTO   712
0706:  BTFSC  44.4
0707:  MOVLW  20
0708:  GOTO   70C
0709:  BCF    44.3
070A:  BCF    44.4
070B:  BSF    44.0
070C:  ADDWF  78,F
070D:  MOVF   78,W
070E:  MOVWF  48
070F:  BCF    03.5
0710:  CALL   1E1
0711:  BSF    03.5
0712:  MOVF   43,W
0713:  MOVWF  46
0714:  MOVLW  0A
0715:  MOVWF  47
0716:  BCF    03.5
0717:  CALL   6DC
0718:  MOVF   77,W
0719:  BSF    03.5
071A:  MOVWF  43
071B:  MOVF   78,W
071C:  MOVLW  30
071D:  BTFSS  03.2
071E:  GOTO   725
071F:  BTFSC  44.3
0720:  GOTO   72B
0721:  BTFSS  44.0
0722:  GOTO   72B
0723:  BTFSC  44.4
0724:  MOVLW  20
0725:  ADDWF  78,F
0726:  MOVF   78,W
0727:  MOVWF  48
0728:  BCF    03.5
0729:  CALL   1E1
072A:  BSF    03.5
072B:  MOVLW  30
072C:  ADDWF  43,F
072D:  MOVF   43,W
072E:  MOVWF  48
072F:  BCF    03.5
0730:  CALL   1E1
0731:  RETURN
*
0742:  MOVF   00,F
0743:  BTFSC  03.2
0744:  GOTO   75C
0745:  CLRF   42
0746:  MOVF   04,W
0747:  MOVWF  41
0748:  BCF    42.0
0749:  BTFSC  03.7
074A:  BSF    42.0
074B:  MOVF   00,W
074C:  MOVWF  48
074D:  BCF    03.5
074E:  CALL   1E1
074F:  BSF    03.5
0750:  MOVF   41,W
0751:  MOVWF  04
0752:  BCF    03.7
0753:  BTFSC  42.0
0754:  BSF    03.7
0755:  INCF   04,F
0756:  BTFSS  03.2
0757:  GOTO   75B
0758:  BCF    03.5
0759:  INCF   05,F
075A:  BSF    03.5
075B:  GOTO   742
*
0994:  MOVF   37,W
0995:  XORWF  39,W
0996:  ANDLW  80
0997:  MOVWF  3B
0998:  BTFSS  37.7
0999:  GOTO   19F
099A:  COMF   36,F
099B:  COMF   37,F
099C:  INCF   36,F
099D:  BTFSC  03.2
099E:  INCF   37,F
099F:  BTFSS  39.7
09A0:  GOTO   1A6
09A1:  COMF   38,F
09A2:  COMF   39,F
09A3:  INCF   38,F
09A4:  BTFSC  03.2
09A5:  INCF   39,F
09A6:  MOVLW  10
09A7:  MOVWF  3A
09A8:  CLRF   77
09A9:  CLRF   7A
09AA:  RRF    37,F
09AB:  RRF    36,F
09AC:  BTFSS  03.0
09AD:  GOTO   1B4
09AE:  MOVF   38,W
09AF:  ADDWF  77,F
09B0:  BTFSC  03.0
09B1:  INCF   7A,F
09B2:  MOVF   39,W
09B3:  ADDWF  7A,F
09B4:  RRF    7A,F
09B5:  RRF    77,F
09B6:  RRF    79,F
09B7:  RRF    78,F
09B8:  DECFSZ 3A,F
09B9:  GOTO   1AA
09BA:  BTFSS  3B.7
09BB:  GOTO   1C1
09BC:  COMF   78,F
09BD:  COMF   79,F
09BE:  INCF   78,F
09BF:  BTFSC  03.2
09C0:  INCF   79,F
*
0CAE:  MOVLW  20
0CAF:  BTFSS  41.4
0CB0:  MOVLW  30
0CB1:  MOVWF  42
0CB2:  MOVF   40,W
0CB3:  MOVWF  77
0CB4:  BTFSS  40.7
0CB5:  GOTO   4BE
0CB6:  COMF   77,F
0CB7:  INCF   77,F
0CB8:  MOVF   77,W
0CB9:  MOVWF  40
0CBA:  MOVLW  2D
0CBB:  MOVWF  42
0CBC:  BSF    41.7
0CBD:  BSF    41.0
0CBE:  MOVF   40,W
0CBF:  MOVWF  46
0CC0:  MOVLW  64
0CC1:  MOVWF  47
0CC2:  BCF    0A.3
0CC3:  BCF    03.5
0CC4:  CALL   6DC
0CC5:  BSF    0A.3
0CC6:  MOVF   77,W
0CC7:  BSF    03.5
0CC8:  MOVWF  40
0CC9:  MOVLW  30
0CCA:  ADDWF  78,W
0CCB:  MOVWF  43
0CCC:  MOVF   40,W
0CCD:  MOVWF  46
0CCE:  MOVLW  0A
0CCF:  MOVWF  47
0CD0:  BCF    0A.3
0CD1:  BCF    03.5
0CD2:  CALL   6DC
0CD3:  BSF    0A.3
0CD4:  MOVLW  30
0CD5:  ADDWF  77,W
0CD6:  BSF    03.5
0CD7:  MOVWF  45
0CD8:  MOVLW  30
0CD9:  ADDWF  78,W
0CDA:  MOVWF  44
0CDB:  MOVF   42,W
0CDC:  MOVWF  77
0CDD:  MOVLW  30
0CDE:  SUBWF  43,W
0CDF:  BTFSC  03.2
0CE0:  GOTO   4E5
0CE1:  BSF    41.1
0CE2:  BTFSC  41.7
0CE3:  BSF    41.2
0CE4:  GOTO   4F9
0CE5:  MOVF   42,W
0CE6:  MOVWF  43
0CE7:  MOVLW  20
0CE8:  MOVWF  42
0CE9:  MOVLW  30
0CEA:  SUBWF  44,W
0CEB:  BTFSC  03.2
0CEC:  GOTO   4F1
0CED:  BSF    41.0
0CEE:  BTFSC  41.7
0CEF:  BSF    41.1
0CF0:  GOTO   4F9
0CF1:  BTFSS  03.2
0CF2:  BSF    41.0
0CF3:  BTFSS  03.2
0CF4:  GOTO   4F9
0CF5:  MOVF   43,W
0CF6:  MOVWF  44
0CF7:  MOVLW  20
0CF8:  MOVWF  43
0CF9:  BTFSC  41.2
0CFA:  GOTO   500
0CFB:  BTFSC  41.1
0CFC:  GOTO   507
0CFD:  BTFSC  41.0
0CFE:  GOTO   50E
0CFF:  GOTO   515
0D00:  MOVF   42,W
0D01:  MOVWF  48
0D02:  BCF    0A.3
0D03:  BCF    03.5
0D04:  CALL   1E1
0D05:  BSF    0A.3
0D06:  BSF    03.5
0D07:  MOVF   43,W
0D08:  MOVWF  48
0D09:  BCF    0A.3
0D0A:  BCF    03.5
0D0B:  CALL   1E1
0D0C:  BSF    0A.3
0D0D:  BSF    03.5
0D0E:  MOVF   44,W
0D0F:  MOVWF  48
0D10:  BCF    0A.3
0D11:  BCF    03.5
0D12:  CALL   1E1
0D13:  BSF    0A.3
0D14:  BSF    03.5
0D15:  MOVF   45,W
0D16:  MOVWF  48
0D17:  BCF    0A.3
0D18:  BCF    03.5
0D19:  CALL   1E1
0D1A:  BSF    0A.3
....................  
.................... #list 
....................  
.................... #device ADC=8 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES HS  
....................  
.................... #use delay(crystal=20000000) 
*
012A:  MOVLW  C9
012B:  MOVWF  04
012C:  BCF    03.7
012D:  MOVF   00,W
012E:  BTFSC  03.2
012F:  GOTO   13D
0130:  MOVLW  06
0131:  MOVWF  78
0132:  CLRF   77
0133:  DECFSZ 77,F
0134:  GOTO   133
0135:  DECFSZ 78,F
0136:  GOTO   132
0137:  MOVLW  7B
0138:  MOVWF  77
0139:  DECFSZ 77,F
013A:  GOTO   139
013B:  DECFSZ 00,F
013C:  GOTO   130
013D:  RETURN
.................... //#use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=PORT1) 
....................  
....................  
.................... // -------Variables' Declaration 
.................... #define RX_BUFFER_SIZE 10 
.................... #define BLOCK_SIZE sizeof(User)  
.................... signed int8 address_data_delete; 
.................... int8 rx_wr_index = 0; 
.................... int8 lock_pos = 0, rxd, read, valid_data_count; 
.................... int data_avail = FALSE, got_id = FALSE; 
.................... unsigned int8 rx_buffer[RX_BUFFER_SIZE]; 
.................... #include "functions.c" 
.................... #include "functions.h" 
....................  
.................... //Define the default pins before calling the LCD driver 
.................... #ifndef lcd_enable  
....................    #define lcd_enable     pin_e1 
....................    #define lcd_rs         pin_e2 
....................    //#define lcd_rw       pin_e2   
....................    #define lcd_d4         pin_d4 
....................    #define lcd_d5         pin_d5 
....................    #define lcd_d6         pin_d6 
....................    #define lcd_d7         pin_d7 
.................... #endif 
....................  
.................... #include "mod_lcd.c" 
.................... /************************************************************************/ 
.................... /*  MOD_LCD.C - Biblioteca de manipulaï¿½ï¿½o de mï¿½dulo LCD                 */ 
.................... /*                                                                      */ 
.................... /*  Autor: Fï¿½bio Pereira                                                */ 
.................... /*                                                                      */ 
.................... /************************************************************************/ 
....................  
.................... // As definiï¿½ï¿½es a seguir sï¿½o utilizadas para acesso aos pinos do display 
.................... // caso o pino RW nï¿½o seja utilizado, comente a definiï¿½ï¿½o lcd_rw 
.................... #ifndef lcd_enable 
.................... 	#define lcd_enable 		pin_e1		// pino enable do LCD 
.................... 	#define lcd_rs			pin_e0		// pino rs do LCD 
.................... 	//#define lcd_rw		pin_e2		// pino rw do LCD 
.................... 	#define lcd_d4			pin_d4		// pino de dados d4 do LCD 
.................... 	#define lcd_d5			pin_d5		// pino de dados d5 do LCD 
.................... 	#define lcd_d6			pin_d6		// pino de dados d6 do LCD 
.................... 	#define lcd_d7			pin_d7		// pino de dados d7 do LCD 
.................... #endif 
....................  
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 linhas 
.................... #define lcd_seg_lin 0x40    // Endereï¿½o da segunda linha na RAM do LCD 
....................  
.................... // a constante abaixo define a seqï¿½ï¿½ncia de inicializaï¿½ï¿½o do mï¿½dulo LCD 
.................... byte CONST INI_LCD[4] = {0x20 | (lcd_type << 2), 0xf, 1, 6}; 
....................  
.................... byte lcd_le_byte() 
.................... // lï¿½ um byte do LCD (somente com pino RW) 
.................... { 
.................... 	byte dado; 
.................... 	// configura os pinos de dados como entradas 
.................... 	input(lcd_d4); 
.................... 	input(lcd_d5); 
.................... 	input(lcd_d6); 
.................... 	input(lcd_d7); 
.................... 	// se o pino rw for utilizado, coloca em 1 
.................... 	#ifdef lcd_rw 
.................... 		output_high(lcd_rw); 
.................... 	#endif 
....................    output_high(lcd_enable); // habilita display 
.................... 	dado = 0;	// zera a variï¿½vel de leitura 
.................... 	// lï¿½ os quatro bits mais significativos 
.................... 	if (input(lcd_d7)) bit_set(dado,7); 
.................... 	if (input(lcd_d6)) bit_set(dado,6); 
.................... 	if (input(lcd_d5)) bit_set(dado,5); 
.................... 	if (input(lcd_d4)) bit_set(dado,4); 
.................... 	// dï¿½ um pulso na linha enable 
.................... 	output_low(lcd_enable); 
.................... 	output_high(lcd_enable); 
.................... 	// lï¿½ os quatro bits menos significativos 
.................... 	if (input(lcd_d7)) bit_set(dado,3); 
.................... 	if (input(lcd_d6)) bit_set(dado,2); 
.................... 	if (input(lcd_d5)) bit_set(dado,1); 
.................... 	if (input(lcd_d4)) bit_set(dado,0); 
.................... 	output_low(lcd_enable);	// desabilita o display 
.................... 	return dado;	// retorna o byte lido 
.................... } 
....................  
.................... void lcd_envia_nibble( byte dado ) 
.................... // envia um dado de quatro bits para o display 
.................... { 
.................... 	// coloca os quatro bits nas saidas 
.................... 	output_bit(lcd_d4,bit_test(dado,0)); 
013E:  BSF    03.5
013F:  BTFSC  50.0
0140:  GOTO   145
0141:  BCF    03.5
0142:  BCF    08.4
0143:  GOTO   147
0144:  BSF    03.5
0145:  BCF    03.5
0146:  BSF    08.4
0147:  BSF    03.5
0148:  BCF    08.4
.................... 	output_bit(lcd_d5,bit_test(dado,1)); 
0149:  BTFSC  50.1
014A:  GOTO   14F
014B:  BCF    03.5
014C:  BCF    08.5
014D:  GOTO   151
014E:  BSF    03.5
014F:  BCF    03.5
0150:  BSF    08.5
0151:  BSF    03.5
0152:  BCF    08.5
.................... 	output_bit(lcd_d6,bit_test(dado,2)); 
0153:  BTFSC  50.2
0154:  GOTO   159
0155:  BCF    03.5
0156:  BCF    08.6
0157:  GOTO   15B
0158:  BSF    03.5
0159:  BCF    03.5
015A:  BSF    08.6
015B:  BSF    03.5
015C:  BCF    08.6
.................... 	output_bit(lcd_d7,bit_test(dado,3)); 
015D:  BTFSC  50.3
015E:  GOTO   163
015F:  BCF    03.5
0160:  BCF    08.7
0161:  GOTO   165
0162:  BSF    03.5
0163:  BCF    03.5
0164:  BSF    08.7
0165:  BSF    03.5
0166:  BCF    08.7
.................... 	// dï¿½ um pulso na linha enable 
.................... 	output_high(lcd_enable); 
0167:  BCF    09.1
0168:  BCF    03.5
0169:  BSF    09.1
.................... 	output_low(lcd_enable); 
016A:  BSF    03.5
016B:  BCF    09.1
016C:  BCF    03.5
016D:  BCF    09.1
016E:  RETURN
.................... } 
....................  
....................  
.................... void lcd_envia_byte( boolean endereco, byte dado ) 
.................... { 
.................... 	// coloca a linha rs em 0 
.................... 	output_low(lcd_rs); 
016F:  BSF    03.5
0170:  BCF    09.2
0171:  BCF    03.5
0172:  BCF    09.2
.................... 	// aguarda o display ficar desocupado 
.................... 	//while ( bit_test(lcd_le_byte(),7) ) ; 
.................... 	// configura a linha rs dependendo do modo selecionado 
.................... 	output_bit(lcd_rs,endereco); 
0173:  BSF    03.5
0174:  MOVF   4D,F
0175:  BTFSS  03.2
0176:  GOTO   17B
0177:  BCF    03.5
0178:  BCF    09.2
0179:  GOTO   17D
017A:  BSF    03.5
017B:  BCF    03.5
017C:  BSF    09.2
017D:  BSF    03.5
017E:  BCF    09.2
.................... 	delay_us(100);	// aguarda 100 us 
017F:  MOVLW  A6
0180:  MOVWF  77
0181:  DECFSZ 77,F
0182:  GOTO   181
0183:  NOP
.................... 	// caso a linha rw esteja definida, coloca em 0 
.................... 	#ifdef lcd_rw 
.................... 		output_low(lcd_rw); 
.................... 	#endif 
.................... 	// desativa linha enable 
.................... 	output_low(lcd_enable); 
0184:  BCF    09.1
0185:  BCF    03.5
0186:  BCF    09.1
.................... 	// envia a primeira parte do byte 
.................... 	lcd_envia_nibble(dado >> 4); 
0187:  BSF    03.5
0188:  SWAPF  4E,W
0189:  MOVWF  4F
018A:  MOVLW  0F
018B:  ANDWF  4F,F
018C:  MOVF   4F,W
018D:  MOVWF  50
018E:  BCF    03.5
018F:  CALL   13E
.................... 	// envia a segunda parte do byte 
.................... 	lcd_envia_nibble(dado & 0x0f); 
0190:  BSF    03.5
0191:  MOVF   4E,W
0192:  ANDLW  0F
0193:  MOVWF  4F
0194:  MOVWF  50
0195:  BCF    03.5
0196:  CALL   13E
0197:  RETURN
.................... } 
....................  
....................  
.................... void lcd_ini() 
.................... // rotina de inicializaï¿½ï¿½o do display 
.................... { 
.................... 	byte conta; 
.................... 	output_low(lcd_d4); 
0198:  BSF    03.5
0199:  BCF    08.4
019A:  BCF    03.5
019B:  BCF    08.4
.................... 	output_low(lcd_d5); 
019C:  BSF    03.5
019D:  BCF    08.5
019E:  BCF    03.5
019F:  BCF    08.5
.................... 	output_low(lcd_d6); 
01A0:  BSF    03.5
01A1:  BCF    08.6
01A2:  BCF    03.5
01A3:  BCF    08.6
.................... 	output_low(lcd_d7); 
01A4:  BSF    03.5
01A5:  BCF    08.7
01A6:  BCF    03.5
01A7:  BCF    08.7
.................... 	output_low(lcd_rs); 
01A8:  BSF    03.5
01A9:  BCF    09.2
01AA:  BCF    03.5
01AB:  BCF    09.2
.................... 	#ifdef lcd_rw 
.................... 		output_high(lcd_rw); 
.................... 	#endif 
.................... 	output_low(lcd_enable); 
01AC:  BSF    03.5
01AD:  BCF    09.1
01AE:  BCF    03.5
01AF:  BCF    09.1
.................... 	delay_ms(15); 
01B0:  MOVLW  0F
01B1:  BSF    03.5
01B2:  MOVWF  49
01B3:  BCF    03.5
01B4:  CALL   12A
.................... 	// envia uma seqï¿½ï¿½ncia de 3 vezes 0x03 
.................... 	// e depois 0x02 para configurar o mï¿½dulo 
.................... 	// para modo de 4 bits 
.................... 	for(conta=1;conta<=3;++conta) 
01B5:  MOVLW  01
01B6:  MOVWF  55
01B7:  MOVF   55,W
01B8:  SUBLW  03
01B9:  BTFSS  03.0
01BA:  GOTO   1C7
.................... 	{ 
.................... 		lcd_envia_nibble(3); 
01BB:  MOVLW  03
01BC:  BSF    03.5
01BD:  MOVWF  50
01BE:  BCF    03.5
01BF:  CALL   13E
.................... 		delay_ms(5); 
01C0:  MOVLW  05
01C1:  BSF    03.5
01C2:  MOVWF  49
01C3:  BCF    03.5
01C4:  CALL   12A
01C5:  INCF   55,F
01C6:  GOTO   1B7
.................... 	} 
.................... 	lcd_envia_nibble(2); 
01C7:  MOVLW  02
01C8:  BSF    03.5
01C9:  MOVWF  50
01CA:  BCF    03.5
01CB:  CALL   13E
.................... 	// envia string de inicializaï¿½ï¿½o do display 
.................... 	for(conta=0;conta<=3;++conta) lcd_envia_byte(0,INI_LCD[conta]); 
01CC:  CLRF   55
01CD:  MOVF   55,W
01CE:  SUBLW  03
01CF:  BTFSS  03.0
01D0:  GOTO   1DE
01D1:  MOVF   55,W
01D2:  CALL   058
01D3:  MOVWF  56
01D4:  BSF    03.5
01D5:  CLRF   4D
01D6:  BCF    03.5
01D7:  MOVF   56,W
01D8:  BSF    03.5
01D9:  MOVWF  4E
01DA:  BCF    03.5
01DB:  CALL   16F
01DC:  INCF   55,F
01DD:  GOTO   1CD
01DE:  BSF    0A.3
01DF:  BCF    0A.4
01E0:  GOTO   601 (RETURN)
.................... } 
....................  
.................... void lcd_pos_xy( byte x, byte y) 
.................... { 
....................    byte endereco; 
....................    if(y!=1) 
*
0202:  DECFSZ 4A,W
0203:  GOTO   205
0204:  GOTO   208
....................    	endereco = lcd_seg_lin; 
0205:  MOVLW  40
0206:  MOVWF  4B
0207:  GOTO   209
....................    else 
....................    	endereco = 0; 
0208:  CLRF   4B
....................    endereco += x-1; 
0209:  MOVLW  01
020A:  SUBWF  49,W
020B:  ADDWF  4B,F
....................    lcd_envia_byte(0,0x80|endereco); 
020C:  MOVF   4B,W
020D:  IORLW  80
020E:  MOVWF  4C
020F:  CLRF   4D
0210:  MOVF   4C,W
0211:  MOVWF  4E
0212:  BCF    03.5
0213:  CALL   16F
.................... } 
....................  
.................... void lcd_escreve( char c) 
.................... // envia caractere para o display 
.................... { 
....................    switch (c) 
*
01E1:  BSF    03.5
01E2:  MOVF   48,W
01E3:  XORLW  0C
01E4:  BCF    03.5
01E5:  BTFSC  03.2
01E6:  GOTO   1F1
01E7:  XORLW  06
01E8:  BTFSC  03.2
01E9:  GOTO   1FD
01EA:  XORLW  07
01EB:  BTFSC  03.2
01EC:  GOTO   1FD
01ED:  XORLW  05
01EE:  BTFSC  03.2
01EF:  GOTO   215
01F0:  GOTO   21C
.................... 	{ 
....................      case '\f' 	:	lcd_envia_byte(0,1); 
01F1:  BSF    03.5
01F2:  CLRF   4D
01F3:  MOVLW  01
01F4:  MOVWF  4E
01F5:  BCF    03.5
01F6:  CALL   16F
.................... 	  			delay_ms(2); 
01F7:  MOVLW  02
01F8:  BSF    03.5
01F9:  MOVWF  49
01FA:  BCF    03.5
01FB:  CALL   12A
.................... 				break; 
01FC:  GOTO   223
....................      case '\n'	: 
.................... 	   case '\r' 	:	lcd_pos_xy(1,2); 
01FD:  MOVLW  01
01FE:  BSF    03.5
01FF:  MOVWF  49
0200:  MOVLW  02
0201:  MOVWF  4A
.................... 	  			break; 
*
0214:  GOTO   223
....................      case '\b' 	:	lcd_envia_byte(0,0x10); 
0215:  BSF    03.5
0216:  CLRF   4D
0217:  MOVLW  10
0218:  MOVWF  4E
0219:  BCF    03.5
021A:  CALL   16F
.................... 	  			break; 
021B:  GOTO   223
....................      default	:	lcd_envia_byte(1,c); 
021C:  MOVLW  01
021D:  BSF    03.5
021E:  MOVWF  4D
021F:  MOVF   48,W
0220:  MOVWF  4E
0221:  BCF    03.5
0222:  CALL   16F
.................... 	  			break; 
....................    } 
0223:  RETURN
.................... } 
....................  
.................... char lcd_le( byte x, byte y) 
.................... // le caractere do display 
.................... { 
.................... 	char valor; 
.................... 	// seleciona a posiï¿½ï¿½o do caractere 
.................... 	lcd_pos_xy(x,y); 
.................... 	// ativa rs 
.................... 	output_high(lcd_rs); 
.................... 	// lï¿½ o caractere 
.................... 	valor = lcd_le_byte(); 
.................... 	// desativa rs 
.................... 	output_low(lcd_rs); 
.................... 	// retorna o valor do caractere 
.................... 	return valor; 
.................... } 
....................  
....................  
.................... #include "2401.c" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a MicroChip 24LC01B configured for a x8 org         //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);  Read the byte d from the address a     //// 
.................... ////                                                                   //// 
.................... ////   b = ext_eeprom_ready();  Returns TRUE if the eeprom is ready    //// 
.................... ////                            to receive opcodes                     //// 
.................... ////                                                                   //// 
.................... ////   The main program may define EEPROM_SDA                          //// 
.................... ////   and EEPROM_SCL to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... ////                            Pin Layout                             //// 
.................... ////   -----------------------------------------------------------     //// 
.................... ////   |                                                         |     //// 
.................... ////   | 1: NC   Not Connected | 8: VCC   +5V                    |     //// 
.................... ////   |                       |                                 |     //// 
.................... ////   | 2: NC   Not Connected | 7: WP    GND                    |     //// 
.................... ////   |                       |                                 |     //// 
.................... ////   | 3: NC   Not Connected | 6: SCL   EEPROM_SCL and Pull-Up |     //// 
.................... ////   |                       |                                 |     //// 
.................... ////   | 4: VSS  GND           | 5: SDA   EEPROM_SDA and Pull-Up |     //// 
.................... ////   -----------------------------------------------------------     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2003 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef EEPROM_SDA 
....................  
.................... #define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C3 
....................  
.................... #endif 
....................  
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
0298:  MOVLW  08
0299:  MOVWF  78
029A:  MOVLW  04
029B:  MOVWF  77
029C:  DECFSZ 77,F
029D:  GOTO   29C
029E:  BCF    07.3
029F:  BCF    3D.3
02A0:  MOVF   3D,W
02A1:  BSF    03.5
02A2:  MOVWF  07
02A3:  MOVLW  03
02A4:  MOVWF  77
02A5:  DECFSZ 77,F
02A6:  GOTO   2A5
02A7:  RLF    47,F
02A8:  BCF    03.5
02A9:  BCF    07.4
02AA:  BTFSS  03.0
02AB:  GOTO   2B2
02AC:  BSF    3D.4
02AD:  MOVF   3D,W
02AE:  BSF    03.5
02AF:  MOVWF  07
02B0:  GOTO   2B6
02B1:  BCF    03.5
02B2:  BCF    3D.4
02B3:  MOVF   3D,W
02B4:  BSF    03.5
02B5:  MOVWF  07
02B6:  NOP
02B7:  BCF    03.5
02B8:  BSF    3D.3
02B9:  MOVF   3D,W
02BA:  BSF    03.5
02BB:  MOVWF  07
02BC:  BCF    03.5
02BD:  BTFSS  07.3
02BE:  GOTO   2BD
02BF:  DECFSZ 78,F
02C0:  GOTO   29A
02C1:  MOVLW  04
02C2:  MOVWF  77
02C3:  DECFSZ 77,F
02C4:  GOTO   2C3
02C5:  BCF    07.3
02C6:  BCF    3D.3
02C7:  MOVF   3D,W
02C8:  BSF    03.5
02C9:  MOVWF  07
02CA:  NOP
02CB:  BCF    03.5
02CC:  BSF    3D.4
02CD:  MOVF   3D,W
02CE:  BSF    03.5
02CF:  MOVWF  07
02D0:  MOVLW  03
02D1:  MOVWF  77
02D2:  DECFSZ 77,F
02D3:  GOTO   2D2
02D4:  MOVLW  03
02D5:  MOVWF  77
02D6:  DECFSZ 77,F
02D7:  GOTO   2D6
02D8:  BCF    03.5
02D9:  BSF    3D.3
02DA:  MOVF   3D,W
02DB:  BSF    03.5
02DC:  MOVWF  07
02DD:  BCF    03.5
02DE:  BTFSS  07.3
02DF:  GOTO   2DE
02E0:  CLRF   78
02E1:  MOVLW  03
02E2:  MOVWF  77
02E3:  DECFSZ 77,F
02E4:  GOTO   2E3
02E5:  BTFSC  07.4
02E6:  BSF    78.0
02E7:  BCF    07.3
02E8:  BCF    3D.3
02E9:  MOVF   3D,W
02EA:  BSF    03.5
02EB:  MOVWF  07
02EC:  BCF    03.5
02ED:  BCF    07.4
02EE:  BCF    3D.4
02EF:  MOVF   3D,W
02F0:  BSF    03.5
02F1:  MOVWF  07
02F2:  BCF    03.5
02F3:  RETURN
*
0396:  MOVLW  08
0397:  BSF    03.5
0398:  MOVWF  47
0399:  MOVF   77,W
039A:  MOVWF  48
039B:  BCF    03.5
039C:  BSF    3D.4
039D:  MOVF   3D,W
039E:  BSF    03.5
039F:  MOVWF  07
03A0:  MOVLW  03
03A1:  MOVWF  77
03A2:  DECFSZ 77,F
03A3:  GOTO   3A2
03A4:  BCF    03.5
03A5:  BSF    3D.3
03A6:  MOVF   3D,W
03A7:  BSF    03.5
03A8:  MOVWF  07
03A9:  BCF    03.5
03AA:  BTFSS  07.3
03AB:  GOTO   3AA
03AC:  BTFSC  07.4
03AD:  BSF    03.0
03AE:  BTFSS  07.4
03AF:  BCF    03.0
03B0:  RLF    78,F
03B1:  MOVLW  04
03B2:  MOVWF  77
03B3:  DECFSZ 77,F
03B4:  GOTO   3B3
03B5:  BCF    3D.3
03B6:  MOVF   3D,W
03B7:  BSF    03.5
03B8:  MOVWF  07
03B9:  BCF    03.5
03BA:  BCF    07.3
03BB:  BSF    03.5
03BC:  DECFSZ 47,F
03BD:  GOTO   39B
03BE:  BCF    03.5
03BF:  BSF    3D.4
03C0:  MOVF   3D,W
03C1:  BSF    03.5
03C2:  MOVWF  07
03C3:  MOVLW  03
03C4:  MOVWF  77
03C5:  DECFSZ 77,F
03C6:  GOTO   3C5
03C7:  BCF    03.5
03C8:  BCF    07.4
03C9:  BSF    03.5
03CA:  MOVF   48,W
03CB:  BTFSC  03.2
03CC:  GOTO   3D2
03CD:  BCF    03.5
03CE:  BCF    3D.4
03CF:  MOVF   3D,W
03D0:  BSF    03.5
03D1:  MOVWF  07
03D2:  NOP
03D3:  BCF    03.5
03D4:  BSF    3D.3
03D5:  MOVF   3D,W
03D6:  BSF    03.5
03D7:  MOVWF  07
03D8:  BCF    03.5
03D9:  BTFSS  07.3
03DA:  GOTO   3D9
03DB:  MOVLW  04
03DC:  MOVWF  77
03DD:  DECFSZ 77,F
03DE:  GOTO   3DD
03DF:  BCF    07.3
03E0:  BCF    3D.3
03E1:  MOVF   3D,W
03E2:  BSF    03.5
03E3:  MOVWF  07
03E4:  MOVLW  03
03E5:  MOVWF  77
03E6:  DECFSZ 77,F
03E7:  GOTO   3E6
03E8:  BCF    03.5
03E9:  BCF    07.4
03EA:  BCF    3D.4
03EB:  MOVF   3D,W
03EC:  BSF    03.5
03ED:  MOVWF  07
....................  
.................... #define EEPROM_ADDRESS BYTE 
.................... #define EEPROM_SIZE    128 
....................  
.................... void init_ext_eeprom() { 
....................    output_float(EEPROM_SCL); 
*
011D:  BSF    3D.3
011E:  MOVF   3D,W
011F:  BSF    03.5
0120:  MOVWF  07
....................    output_float(EEPROM_SDA); 
0121:  BCF    03.5
0122:  BSF    3D.4
0123:  MOVF   3D,W
0124:  BSF    03.5
0125:  MOVWF  07
0126:  BCF    03.5
0127:  BSF    0A.3
0128:  BCF    0A.4
0129:  GOTO   5F8 (RETURN)
.................... } 
....................  
.................... BOOLEAN ext_eeprom_ready() { 
....................    int1 ack; 
....................    i2c_start();            // If the write command is acknowledged, 
*
02F4:  BSF    3D.4
02F5:  MOVF   3D,W
02F6:  BSF    03.5
02F7:  MOVWF  07
02F8:  MOVLW  04
02F9:  MOVWF  77
02FA:  DECFSZ 77,F
02FB:  GOTO   2FA
02FC:  BCF    03.5
02FD:  BSF    3D.3
02FE:  MOVF   3D,W
02FF:  BSF    03.5
0300:  MOVWF  07
0301:  MOVLW  03
0302:  MOVWF  77
0303:  DECFSZ 77,F
0304:  GOTO   303
0305:  BCF    03.5
0306:  BCF    07.4
0307:  BCF    3D.4
0308:  MOVF   3D,W
0309:  BSF    03.5
030A:  MOVWF  07
030B:  MOVLW  04
030C:  MOVWF  77
030D:  DECFSZ 77,F
030E:  GOTO   30D
030F:  BCF    03.5
0310:  BCF    07.3
0311:  BCF    3D.3
0312:  MOVF   3D,W
0313:  BSF    03.5
0314:  MOVWF  07
....................    ack = i2c_write(0xa0);  // then the device is ready. 
0315:  MOVLW  A0
0316:  MOVWF  47
0317:  BCF    03.5
0318:  CALL   298
0319:  MOVF   78,W
031A:  BSF    03.5
031B:  BCF    46.0
031C:  BTFSC  78.0
031D:  BSF    46.0
....................    i2c_stop(); 
031E:  BCF    03.5
031F:  BCF    3D.4
0320:  MOVF   3D,W
0321:  BSF    03.5
0322:  MOVWF  07
0323:  NOP
0324:  BCF    03.5
0325:  BSF    3D.3
0326:  MOVF   3D,W
0327:  BSF    03.5
0328:  MOVWF  07
0329:  BCF    03.5
032A:  BTFSS  07.3
032B:  GOTO   32A
032C:  MOVLW  04
032D:  MOVWF  77
032E:  DECFSZ 77,F
032F:  GOTO   32E
0330:  GOTO   331
0331:  NOP
0332:  BSF    3D.4
0333:  MOVF   3D,W
0334:  BSF    03.5
0335:  MOVWF  07
0336:  MOVLW  04
0337:  MOVWF  77
0338:  DECFSZ 77,F
0339:  GOTO   338
....................    return !ack; 
033A:  MOVLW  00
033B:  BTFSS  46.0
033C:  MOVLW  01
033D:  MOVWF  78
033E:  BCF    03.5
033F:  RETURN
.................... } 
....................  
.................... void write_ext_eeprom(BYTE address, BYTE data) { 
....................    while(!ext_eeprom_ready()); 
*
0410:  CALL   2F4
0411:  MOVF   78,F
0412:  BTFSC  03.2
0413:  GOTO   410
....................    i2c_start(); 
0414:  BSF    3D.4
0415:  MOVF   3D,W
0416:  BSF    03.5
0417:  MOVWF  07
0418:  MOVLW  04
0419:  MOVWF  77
041A:  DECFSZ 77,F
041B:  GOTO   41A
041C:  BCF    03.5
041D:  BSF    3D.3
041E:  MOVF   3D,W
041F:  BSF    03.5
0420:  MOVWF  07
0421:  MOVLW  03
0422:  MOVWF  77
0423:  DECFSZ 77,F
0424:  GOTO   423
0425:  BCF    03.5
0426:  BCF    07.4
0427:  BCF    3D.4
0428:  MOVF   3D,W
0429:  BSF    03.5
042A:  MOVWF  07
042B:  MOVLW  04
042C:  MOVWF  77
042D:  DECFSZ 77,F
042E:  GOTO   42D
042F:  BCF    03.5
0430:  BCF    07.3
0431:  BCF    3D.3
0432:  MOVF   3D,W
0433:  BSF    03.5
0434:  MOVWF  07
....................    i2c_write(0xa0); 
0435:  MOVLW  A0
0436:  MOVWF  47
0437:  BCF    03.5
0438:  CALL   298
....................    i2c_write(address); 
0439:  BSF    03.5
043A:  MOVF   3F,W
043B:  MOVWF  47
043C:  BCF    03.5
043D:  CALL   298
....................    i2c_write(data); 
043E:  BSF    03.5
043F:  MOVF   40,W
0440:  MOVWF  47
0441:  BCF    03.5
0442:  CALL   298
....................    i2c_stop(); 
0443:  BCF    3D.4
0444:  MOVF   3D,W
0445:  BSF    03.5
0446:  MOVWF  07
0447:  NOP
0448:  BCF    03.5
0449:  BSF    3D.3
044A:  MOVF   3D,W
044B:  BSF    03.5
044C:  MOVWF  07
044D:  BCF    03.5
044E:  BTFSS  07.3
044F:  GOTO   44E
0450:  MOVLW  04
0451:  MOVWF  77
0452:  DECFSZ 77,F
0453:  GOTO   452
0454:  GOTO   455
0455:  NOP
0456:  BSF    3D.4
0457:  MOVF   3D,W
0458:  BSF    03.5
0459:  MOVWF  07
045A:  MOVLW  04
045B:  MOVWF  77
045C:  DECFSZ 77,F
045D:  GOTO   45C
045E:  BCF    03.5
045F:  RETURN
.................... } 
....................  
....................  
.................... BYTE read_ext_eeprom(BYTE address) { 
....................    BYTE data; 
....................  
....................    while(!ext_eeprom_ready()); 
*
0340:  CALL   2F4
0341:  MOVF   78,F
0342:  BTFSC  03.2
0343:  GOTO   340
....................    i2c_start(); 
0344:  BSF    3D.4
0345:  MOVF   3D,W
0346:  BSF    03.5
0347:  MOVWF  07
0348:  MOVLW  04
0349:  MOVWF  77
034A:  DECFSZ 77,F
034B:  GOTO   34A
034C:  BCF    03.5
034D:  BSF    3D.3
034E:  MOVF   3D,W
034F:  BSF    03.5
0350:  MOVWF  07
0351:  MOVLW  03
0352:  MOVWF  77
0353:  DECFSZ 77,F
0354:  GOTO   353
0355:  BCF    03.5
0356:  BCF    07.4
0357:  BCF    3D.4
0358:  MOVF   3D,W
0359:  BSF    03.5
035A:  MOVWF  07
035B:  MOVLW  04
035C:  MOVWF  77
035D:  DECFSZ 77,F
035E:  GOTO   35D
035F:  BCF    03.5
0360:  BCF    07.3
0361:  BCF    3D.3
0362:  MOVF   3D,W
0363:  BSF    03.5
0364:  MOVWF  07
....................    i2c_write(0xa0); 
0365:  MOVLW  A0
0366:  MOVWF  47
0367:  BCF    03.5
0368:  CALL   298
....................    i2c_write(address); 
0369:  BSF    03.5
036A:  MOVF   44,W
036B:  MOVWF  47
036C:  BCF    03.5
036D:  CALL   298
....................    i2c_start(); 
036E:  BSF    3D.4
036F:  MOVF   3D,W
0370:  BSF    03.5
0371:  MOVWF  07
0372:  MOVLW  04
0373:  MOVWF  77
0374:  DECFSZ 77,F
0375:  GOTO   374
0376:  BCF    03.5
0377:  BSF    3D.3
0378:  MOVF   3D,W
0379:  BSF    03.5
037A:  MOVWF  07
037B:  MOVLW  03
037C:  MOVWF  77
037D:  DECFSZ 77,F
037E:  GOTO   37D
037F:  BCF    03.5
0380:  BTFSS  07.3
0381:  GOTO   380
0382:  BCF    07.4
0383:  BCF    3D.4
0384:  MOVF   3D,W
0385:  BSF    03.5
0386:  MOVWF  07
0387:  MOVLW  04
0388:  MOVWF  77
0389:  DECFSZ 77,F
038A:  GOTO   389
038B:  BCF    03.5
038C:  BCF    07.3
038D:  BCF    3D.3
038E:  MOVF   3D,W
038F:  BSF    03.5
0390:  MOVWF  07
....................    i2c_write(0xa1); 
0391:  MOVLW  A1
0392:  MOVWF  47
0393:  BCF    03.5
0394:  CALL   298
....................    data=i2c_read(0); 
0395:  CLRF   77
*
03EE:  MOVF   78,W
03EF:  MOVWF  45
....................    i2c_stop(); 
03F0:  BCF    03.5
03F1:  BCF    3D.4
03F2:  MOVF   3D,W
03F3:  BSF    03.5
03F4:  MOVWF  07
03F5:  NOP
03F6:  BCF    03.5
03F7:  BSF    3D.3
03F8:  MOVF   3D,W
03F9:  BSF    03.5
03FA:  MOVWF  07
03FB:  BCF    03.5
03FC:  BTFSS  07.3
03FD:  GOTO   3FC
03FE:  MOVLW  04
03FF:  MOVWF  77
0400:  DECFSZ 77,F
0401:  GOTO   400
0402:  GOTO   403
0403:  NOP
0404:  BSF    3D.4
0405:  MOVF   3D,W
0406:  BSF    03.5
0407:  MOVWF  07
0408:  MOVLW  04
0409:  MOVWF  77
040A:  DECFSZ 77,F
040B:  GOTO   40A
....................    return(data); 
040C:  MOVF   45,W
040D:  MOVWF  78
040E:  BCF    03.5
040F:  RETURN
.................... } 
....................  
.................... #include "kbd_board4.c" 
.................... /*######################################################################  
....................    Rotina utilização do teclado da placa PicSim board4 
....................    Adaptada para o compilador CCS 
....................    Autor: Alberto Willia Mascarenhas (adaptou para o compilador) 
....................    For e-mail suggestions :  awmascarenhas@gmail.com 
.................... ######################################################################## */ 
.................... unsigned char tc_tecla(unsigned int timeout) 
*
0495:  CLRF   46
0496:  CLRF   47
.................... { 
....................   unsigned int to=0; 
....................   unsigned char k = 0;   
....................   while(((to < timeout)||(!timeout))&&(!k)){ 
0497:  MOVF   45,W
0498:  SUBWF  46,W
0499:  BTFSS  03.0
049A:  GOTO   49E
049B:  MOVF   45,F
049C:  BTFSS  03.2
049D:  GOTO   5DD
049E:  MOVF   47,F
049F:  BTFSS  03.2
04A0:  GOTO   5DD
....................       
....................        
....................       //------------------------------------------------------------------------- 
....................       //inicio do programa de varredura do teclado matricial 
....................       //-------------------------------------------------------------------------- 
....................       //habilita primeira coluna do teclado 
....................       output_low(PIN_B0);output_high(PIN_B1);output_high(PIN_B2);output_high(PIN_B3); 
04A1:  BCF    06.0
04A2:  BCF    03.5
04A3:  BCF    06.0
04A4:  BSF    03.5
04A5:  BCF    06.1
04A6:  BCF    03.5
04A7:  BSF    06.1
04A8:  BSF    03.5
04A9:  BCF    06.2
04AA:  BCF    03.5
04AB:  BSF    06.2
04AC:  BSF    03.5
04AD:  BCF    06.3
04AE:  BCF    03.5
04AF:  BSF    06.3
....................       delay_ms(20); 
04B0:  MOVLW  14
04B1:  BSF    03.5
04B2:  MOVWF  49
04B3:  BCF    03.5
04B4:  CALL   12A
....................       if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='1';}; 
04B5:  BSF    03.5
04B6:  BSF    08.0
04B7:  BCF    03.5
04B8:  BTFSC  08.0
04B9:  GOTO   4C3
04BA:  BSF    03.5
04BB:  BSF    08.0
04BC:  BCF    03.5
04BD:  BTFSS  08.0
04BE:  GOTO   4BA
04BF:  MOVLW  31
04C0:  BSF    03.5
04C1:  MOVWF  47
04C2:  BCF    03.5
....................       if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='4';}; 
04C3:  BSF    03.5
04C4:  BSF    08.1
04C5:  BCF    03.5
04C6:  BTFSC  08.1
04C7:  GOTO   4D1
04C8:  BSF    03.5
04C9:  BSF    08.1
04CA:  BCF    03.5
04CB:  BTFSS  08.1
04CC:  GOTO   4C8
04CD:  MOVLW  34
04CE:  BSF    03.5
04CF:  MOVWF  47
04D0:  BCF    03.5
....................       if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='7';}; 
04D1:  BSF    03.5
04D2:  BSF    08.2
04D3:  BCF    03.5
04D4:  BTFSC  08.2
04D5:  GOTO   4DF
04D6:  BSF    03.5
04D7:  BSF    08.2
04D8:  BCF    03.5
04D9:  BTFSS  08.2
04DA:  GOTO   4D6
04DB:  MOVLW  37
04DC:  BSF    03.5
04DD:  MOVWF  47
04DE:  BCF    03.5
....................       if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='*';}; 
04DF:  BSF    03.5
04E0:  BSF    08.3
04E1:  BCF    03.5
04E2:  BTFSC  08.3
04E3:  GOTO   4ED
04E4:  BSF    03.5
04E5:  BSF    08.3
04E6:  BCF    03.5
04E7:  BTFSS  08.3
04E8:  GOTO   4E4
04E9:  MOVLW  2A
04EA:  BSF    03.5
04EB:  MOVWF  47
04EC:  BCF    03.5
....................       //habilita segunda coluna do teclado 
....................       output_high(PIN_B0);output_low(PIN_B1);output_high(PIN_B2);output_high(PIN_B3); 
04ED:  BSF    03.5
04EE:  BCF    06.0
04EF:  BCF    03.5
04F0:  BSF    06.0
04F1:  BSF    03.5
04F2:  BCF    06.1
04F3:  BCF    03.5
04F4:  BCF    06.1
04F5:  BSF    03.5
04F6:  BCF    06.2
04F7:  BCF    03.5
04F8:  BSF    06.2
04F9:  BSF    03.5
04FA:  BCF    06.3
04FB:  BCF    03.5
04FC:  BSF    06.3
....................       delay_ms(20);       
04FD:  MOVLW  14
04FE:  BSF    03.5
04FF:  MOVWF  49
0500:  BCF    03.5
0501:  CALL   12A
....................       if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='2';}; 
0502:  BSF    03.5
0503:  BSF    08.0
0504:  BCF    03.5
0505:  BTFSC  08.0
0506:  GOTO   510
0507:  BSF    03.5
0508:  BSF    08.0
0509:  BCF    03.5
050A:  BTFSS  08.0
050B:  GOTO   507
050C:  MOVLW  32
050D:  BSF    03.5
050E:  MOVWF  47
050F:  BCF    03.5
....................       if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='5';}; 
0510:  BSF    03.5
0511:  BSF    08.1
0512:  BCF    03.5
0513:  BTFSC  08.1
0514:  GOTO   51E
0515:  BSF    03.5
0516:  BSF    08.1
0517:  BCF    03.5
0518:  BTFSS  08.1
0519:  GOTO   515
051A:  MOVLW  35
051B:  BSF    03.5
051C:  MOVWF  47
051D:  BCF    03.5
....................       if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='8';}; 
051E:  BSF    03.5
051F:  BSF    08.2
0520:  BCF    03.5
0521:  BTFSC  08.2
0522:  GOTO   52C
0523:  BSF    03.5
0524:  BSF    08.2
0525:  BCF    03.5
0526:  BTFSS  08.2
0527:  GOTO   523
0528:  MOVLW  38
0529:  BSF    03.5
052A:  MOVWF  47
052B:  BCF    03.5
....................       if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='0';}; 
052C:  BSF    03.5
052D:  BSF    08.3
052E:  BCF    03.5
052F:  BTFSC  08.3
0530:  GOTO   53A
0531:  BSF    03.5
0532:  BSF    08.3
0533:  BCF    03.5
0534:  BTFSS  08.3
0535:  GOTO   531
0536:  MOVLW  30
0537:  BSF    03.5
0538:  MOVWF  47
0539:  BCF    03.5
....................        
....................       //habilita terceira coluna do teclado 
....................       output_high(PIN_B0);output_high(PIN_B1);output_low(PIN_B2);output_high(PIN_B3); 
053A:  BSF    03.5
053B:  BCF    06.0
053C:  BCF    03.5
053D:  BSF    06.0
053E:  BSF    03.5
053F:  BCF    06.1
0540:  BCF    03.5
0541:  BSF    06.1
0542:  BSF    03.5
0543:  BCF    06.2
0544:  BCF    03.5
0545:  BCF    06.2
0546:  BSF    03.5
0547:  BCF    06.3
0548:  BCF    03.5
0549:  BSF    06.3
....................       delay_ms(20);       
054A:  MOVLW  14
054B:  BSF    03.5
054C:  MOVWF  49
054D:  BCF    03.5
054E:  CALL   12A
....................       if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='3';}; 
054F:  BSF    03.5
0550:  BSF    08.0
0551:  BCF    03.5
0552:  BTFSC  08.0
0553:  GOTO   55D
0554:  BSF    03.5
0555:  BSF    08.0
0556:  BCF    03.5
0557:  BTFSS  08.0
0558:  GOTO   554
0559:  MOVLW  33
055A:  BSF    03.5
055B:  MOVWF  47
055C:  BCF    03.5
....................       if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='6';}; 
055D:  BSF    03.5
055E:  BSF    08.1
055F:  BCF    03.5
0560:  BTFSC  08.1
0561:  GOTO   56B
0562:  BSF    03.5
0563:  BSF    08.1
0564:  BCF    03.5
0565:  BTFSS  08.1
0566:  GOTO   562
0567:  MOVLW  36
0568:  BSF    03.5
0569:  MOVWF  47
056A:  BCF    03.5
....................       if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='9';}; 
056B:  BSF    03.5
056C:  BSF    08.2
056D:  BCF    03.5
056E:  BTFSC  08.2
056F:  GOTO   579
0570:  BSF    03.5
0571:  BSF    08.2
0572:  BCF    03.5
0573:  BTFSS  08.2
0574:  GOTO   570
0575:  MOVLW  39
0576:  BSF    03.5
0577:  MOVWF  47
0578:  BCF    03.5
....................       if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='#';}; 
0579:  BSF    03.5
057A:  BSF    08.3
057B:  BCF    03.5
057C:  BTFSC  08.3
057D:  GOTO   587
057E:  BSF    03.5
057F:  BSF    08.3
0580:  BCF    03.5
0581:  BTFSS  08.3
0582:  GOTO   57E
0583:  MOVLW  23
0584:  BSF    03.5
0585:  MOVWF  47
0586:  BCF    03.5
....................   
....................        //habilita quarta coluna do teclado 
....................       output_high(PIN_B0);output_high(PIN_B1);output_high(PIN_B2);output_low(PIN_B3); 
0587:  BSF    03.5
0588:  BCF    06.0
0589:  BCF    03.5
058A:  BSF    06.0
058B:  BSF    03.5
058C:  BCF    06.1
058D:  BCF    03.5
058E:  BSF    06.1
058F:  BSF    03.5
0590:  BCF    06.2
0591:  BCF    03.5
0592:  BSF    06.2
0593:  BSF    03.5
0594:  BCF    06.3
0595:  BCF    03.5
0596:  BCF    06.3
....................       delay_ms(20);       
0597:  MOVLW  14
0598:  BSF    03.5
0599:  MOVWF  49
059A:  BCF    03.5
059B:  CALL   12A
....................       if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='A';}; 
059C:  BSF    03.5
059D:  BSF    08.0
059E:  BCF    03.5
059F:  BTFSC  08.0
05A0:  GOTO   5AA
05A1:  BSF    03.5
05A2:  BSF    08.0
05A3:  BCF    03.5
05A4:  BTFSS  08.0
05A5:  GOTO   5A1
05A6:  MOVLW  41
05A7:  BSF    03.5
05A8:  MOVWF  47
05A9:  BCF    03.5
....................       if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='B';}; 
05AA:  BSF    03.5
05AB:  BSF    08.1
05AC:  BCF    03.5
05AD:  BTFSC  08.1
05AE:  GOTO   5B8
05AF:  BSF    03.5
05B0:  BSF    08.1
05B1:  BCF    03.5
05B2:  BTFSS  08.1
05B3:  GOTO   5AF
05B4:  MOVLW  42
05B5:  BSF    03.5
05B6:  MOVWF  47
05B7:  BCF    03.5
....................       if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='C';}; 
05B8:  BSF    03.5
05B9:  BSF    08.2
05BA:  BCF    03.5
05BB:  BTFSC  08.2
05BC:  GOTO   5C6
05BD:  BSF    03.5
05BE:  BSF    08.2
05BF:  BCF    03.5
05C0:  BTFSS  08.2
05C1:  GOTO   5BD
05C2:  MOVLW  43
05C3:  BSF    03.5
05C4:  MOVWF  47
05C5:  BCF    03.5
....................       if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='D';}; 
05C6:  BSF    03.5
05C7:  BSF    08.3
05C8:  BCF    03.5
05C9:  BTFSC  08.3
05CA:  GOTO   5D4
05CB:  BSF    03.5
05CC:  BSF    08.3
05CD:  BCF    03.5
05CE:  BTFSS  08.3
05CF:  GOTO   5CB
05D0:  MOVLW  44
05D1:  BSF    03.5
05D2:  MOVWF  47
05D3:  BCF    03.5
....................   
....................       //printf (lcd_escreve,"\f saiu geral %u",k); 
....................       //delay_ms(1000); 
....................       delay_ms(5); 
05D4:  MOVLW  05
05D5:  BSF    03.5
05D6:  MOVWF  49
05D7:  BCF    03.5
05D8:  CALL   12A
....................       to+=5; 
05D9:  MOVLW  05
05DA:  BSF    03.5
05DB:  ADDWF  46,F
05DC:  GOTO   497
....................   } 
....................    if(!k)k=255; 
05DD:  MOVF   47,F
05DE:  BTFSS  03.2
05DF:  GOTO   5E2
05E0:  MOVLW  FF
05E1:  MOVWF  47
....................   return k;   
05E2:  MOVF   47,W
05E3:  MOVWF  78
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... // -----------------Functions 
.................... void saveUser(int * id, int * pass, int status); 
.................... int getAddressByID(int * id);    
.................... int deleteUser(int address); 
....................  
.................... int isIdAvailable(int id);     
.................... void printUser(); 
.................... void erase_program_eeprom(int addrr); 
.................... int incrementID(); 
.................... int lastNewUserPosition(); 
.................... void resetMemory(); 
.................... void adminMenu(); 
.................... unsigned char readKeyboard();  
.................... int * getAdminsID(); 
.................... void listAdmins(); 
.................... int * strToInt(char * str); 
.................... char * strfromchar(char destination[], char source); 
.................... int * inputId(); 
.................... int * inputToKeyboard(char * msg, int max); 
.................... void inputKeyboardUser(); 
....................  
....................  
.................... typedef struct {  
....................    int id[2]; 
....................    int pass[4]; //password 
....................    int status; //0 - Unpaid, 1 - Paid, 3 - Admin 
.................... }User; 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
*
0671:  BSF    03.6
0672:  MOVF   37,W
0673:  MOVWF  3A
....................    for(su=s;0<n;++su,--n) 
0674:  MOVF   36,W
0675:  MOVWF  3C
0676:  MOVF   35,W
0677:  MOVWF  3B
0678:  MOVF   39,F
0679:  BTFSS  03.2
067A:  GOTO   67F
067B:  MOVF   38,W
067C:  SUBLW  00
067D:  BTFSC  03.0
067E:  GOTO   697
....................       if(*su==uc) 
067F:  MOVF   3C,W
0680:  MOVWF  7A
0681:  MOVF   3B,W
0682:  MOVWF  04
0683:  BCF    03.7
0684:  BTFSC  7A.0
0685:  BSF    03.7
0686:  MOVF   3A,W
0687:  SUBWF  00,W
0688:  BTFSS  03.2
0689:  GOTO   68F
....................       return su; 
068A:  MOVF   3B,W
068B:  MOVWF  78
068C:  MOVF   3C,W
068D:  MOVWF  79
068E:  GOTO   69A
068F:  INCF   3B,F
0690:  BTFSC  03.2
0691:  INCF   3C,F
0692:  MOVF   38,W
0693:  BTFSC  03.2
0694:  DECF   39,F
0695:  DECF   38,F
0696:  GOTO   678
....................    return NULL; 
0697:  MOVLW  00
0698:  MOVWF  78
0699:  MOVWF  79
069A:  BCF    03.6
069B:  RETURN
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
0DDC:  BCF    03.5
0DDD:  CLRF   3E
0DDE:  CLRF   3F
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
*
0800:  BSF    03.5
0801:  CLRF   57
0802:  CLRF   56
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
0803:  MOVLW  30
0804:  BCF    03.5
0805:  BSF    03.6
0806:  MOVWF  10
0807:  MOVLW  31
0808:  MOVWF  11
0809:  MOVLW  32
080A:  MOVWF  12
080B:  MOVLW  33
080C:  MOVWF  13
080D:  MOVLW  34
080E:  MOVWF  14
080F:  MOVLW  35
0810:  MOVWF  15
0811:  MOVLW  36
0812:  MOVWF  16
0813:  MOVLW  37
0814:  MOVWF  17
0815:  MOVLW  38
0816:  MOVWF  18
0817:  MOVLW  39
0818:  MOVWF  19
0819:  MOVLW  61
081A:  MOVWF  1A
081B:  MOVLW  62
081C:  MOVWF  1B
081D:  MOVLW  63
081E:  MOVWF  1C
081F:  MOVLW  64
0820:  MOVWF  1D
0821:  MOVLW  65
0822:  MOVWF  1E
0823:  MOVLW  66
0824:  MOVWF  1F
0825:  MOVLW  67
0826:  MOVWF  20
0827:  MOVLW  68
0828:  MOVWF  21
0829:  MOVLW  69
082A:  MOVWF  22
082B:  MOVLW  6A
082C:  MOVWF  23
082D:  MOVLW  6B
082E:  MOVWF  24
082F:  MOVLW  6C
0830:  MOVWF  25
0831:  MOVLW  6D
0832:  MOVWF  26
0833:  MOVLW  6E
0834:  MOVWF  27
0835:  MOVLW  6F
0836:  MOVWF  28
0837:  MOVLW  70
0838:  MOVWF  29
0839:  MOVLW  71
083A:  MOVWF  2A
083B:  MOVLW  73
083C:  MOVWF  2B
083D:  MOVLW  74
083E:  MOVWF  2C
083F:  MOVLW  75
0840:  MOVWF  2D
0841:  MOVLW  76
0842:  MOVWF  2E
0843:  MOVLW  77
0844:  MOVWF  2F
0845:  MOVLW  78
0846:  MOVWF  30
0847:  MOVLW  79
0848:  MOVWF  31
0849:  MOVLW  7A
084A:  MOVWF  32
084B:  CLRF   33
....................    for(sc=s;isspace(*sc);++sc); 
084C:  BSF    03.5
084D:  BCF    03.6
084E:  MOVF   4C,W
084F:  MOVWF  51
0850:  MOVF   4B,W
0851:  MOVWF  50
0852:  MOVF   51,W
0853:  MOVWF  7A
0854:  MOVF   50,W
0855:  MOVWF  04
0856:  BCF    03.7
0857:  BTFSC  7A.0
0858:  BSF    03.7
0859:  MOVF   00,W
085A:  SUBLW  20
085B:  BTFSS  03.2
085C:  GOTO   061
085D:  INCF   50,F
085E:  BTFSC  03.2
085F:  INCF   51,F
0860:  GOTO   052
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
0861:  MOVF   51,W
0862:  MOVWF  7A
0863:  MOVF   50,W
0864:  MOVWF  04
0865:  BCF    03.7
0866:  BTFSC  51.0
0867:  BSF    03.7
0868:  MOVF   00,W
0869:  SUBLW  2D
086A:  BTFSC  03.2
086B:  GOTO   077
086C:  MOVF   51,W
086D:  MOVWF  7A
086E:  MOVF   50,W
086F:  MOVWF  04
0870:  BCF    03.7
0871:  BTFSC  51.0
0872:  BSF    03.7
0873:  MOVF   00,W
0874:  SUBLW  2B
0875:  BTFSS  03.2
0876:  GOTO   083
0877:  MOVF   51,W
0878:  MOVWF  7A
0879:  MOVF   50,W
087A:  INCF   50,F
087B:  BTFSC  03.2
087C:  INCF   51,F
087D:  MOVWF  04
087E:  BCF    03.7
087F:  BTFSC  7A.0
0880:  BSF    03.7
0881:  MOVF   00,W
0882:  GOTO   084
0883:  MOVLW  2B
0884:  MOVWF  58
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
0885:  MOVF   58,W
0886:  SUBLW  2D
0887:  BTFSC  03.2
0888:  GOTO   094
0889:  BTFSC  4F.7
088A:  GOTO   094
088B:  DECFSZ 4F,W
088C:  GOTO   08E
088D:  GOTO   094
088E:  BTFSC  4F.7
088F:  GOTO   096
0890:  MOVF   4F,W
0891:  SUBLW  24
0892:  BTFSC  03.0
0893:  GOTO   096
....................    goto StrtoulGO; 
0894:  GOTO   216
0895:  GOTO   12C
....................  
....................    else if (base) 
0896:  MOVF   4F,F
0897:  BTFSC  03.2
0898:  GOTO   0F1
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
0899:  MOVF   4F,W
089A:  SUBLW  10
089B:  BTFSS  03.2
089C:  GOTO   0C0
089D:  MOVF   51,W
089E:  MOVWF  7A
089F:  MOVF   50,W
08A0:  MOVWF  04
08A1:  BCF    03.7
08A2:  BTFSC  7A.0
08A3:  BSF    03.7
08A4:  MOVF   00,W
08A5:  SUBLW  30
08A6:  BTFSS  03.2
08A7:  GOTO   0C0
08A8:  MOVLW  01
08A9:  ADDWF  50,W
08AA:  MOVWF  04
08AB:  BCF    03.7
08AC:  BTFSC  51.0
08AD:  BSF    03.7
08AE:  MOVF   00,W
08AF:  SUBLW  78
08B0:  BTFSC  03.2
08B1:  GOTO   0BC
08B2:  MOVLW  01
08B3:  ADDWF  50,W
08B4:  MOVWF  04
08B5:  BCF    03.7
08B6:  BTFSC  51.0
08B7:  BSF    03.7
08B8:  MOVF   00,W
08B9:  SUBLW  58
08BA:  BTFSS  03.2
08BB:  GOTO   0C0
....................          sc+=2; 
08BC:  MOVLW  02
08BD:  ADDWF  50,F
08BE:  BTFSC  03.0
08BF:  INCF   51,F
....................       if(base==8 && *sc =='0') 
08C0:  MOVF   4F,W
08C1:  SUBLW  08
08C2:  BTFSS  03.2
08C3:  GOTO   0D3
08C4:  MOVF   51,W
08C5:  MOVWF  7A
08C6:  MOVF   50,W
08C7:  MOVWF  04
08C8:  BCF    03.7
08C9:  BTFSC  7A.0
08CA:  BSF    03.7
08CB:  MOVF   00,W
08CC:  SUBLW  30
08CD:  BTFSS  03.2
08CE:  GOTO   0D3
....................          sc+=1; 
08CF:  MOVLW  01
08D0:  ADDWF  50,F
08D1:  BTFSC  03.0
08D2:  INCF   51,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
08D3:  MOVF   4F,W
08D4:  SUBLW  02
08D5:  BTFSS  03.2
08D6:  GOTO   0F0
08D7:  MOVF   51,W
08D8:  MOVWF  7A
08D9:  MOVF   50,W
08DA:  MOVWF  04
08DB:  BCF    03.7
08DC:  BTFSC  7A.0
08DD:  BSF    03.7
08DE:  MOVF   00,W
08DF:  SUBLW  30
08E0:  BTFSS  03.2
08E1:  GOTO   0F0
08E2:  MOVLW  01
08E3:  ADDWF  50,W
08E4:  MOVWF  04
08E5:  BCF    03.7
08E6:  BTFSC  51.0
08E7:  BSF    03.7
08E8:  MOVF   00,W
08E9:  SUBLW  62
08EA:  BTFSS  03.2
08EB:  GOTO   0F0
....................          sc+=2; 
08EC:  MOVLW  02
08ED:  ADDWF  50,F
08EE:  BTFSC  03.0
08EF:  INCF   51,F
....................  
....................    } 
08F0:  GOTO   12C
....................    else if(*sc!='0') // base is 0, find base 
08F1:  MOVF   51,W
08F2:  MOVWF  7A
08F3:  MOVF   50,W
08F4:  MOVWF  04
08F5:  BCF    03.7
08F6:  BTFSC  7A.0
08F7:  BSF    03.7
08F8:  MOVF   00,W
08F9:  SUBLW  30
08FA:  BTFSC  03.2
08FB:  GOTO   0FF
....................       base=10; 
08FC:  MOVLW  0A
08FD:  MOVWF  4F
08FE:  GOTO   12C
....................    else if (sc[1]=='x' || sc[1]=='X') 
08FF:  MOVLW  01
0900:  ADDWF  50,W
0901:  MOVWF  04
0902:  BCF    03.7
0903:  BTFSC  51.0
0904:  BSF    03.7
0905:  MOVF   00,W
0906:  SUBLW  78
0907:  BTFSC  03.2
0908:  GOTO   113
0909:  MOVLW  01
090A:  ADDWF  50,W
090B:  MOVWF  04
090C:  BCF    03.7
090D:  BTFSC  51.0
090E:  BSF    03.7
090F:  MOVF   00,W
0910:  SUBLW  58
0911:  BTFSS  03.2
0912:  GOTO   11A
....................       base =16,sc+=2; 
0913:  MOVLW  10
0914:  MOVWF  4F
0915:  MOVLW  02
0916:  ADDWF  50,F
0917:  BTFSC  03.0
0918:  INCF   51,F
0919:  GOTO   12C
....................    else if(sc[1]=='b') 
091A:  MOVLW  01
091B:  ADDWF  50,W
091C:  MOVWF  04
091D:  BCF    03.7
091E:  BTFSC  51.0
091F:  BSF    03.7
0920:  MOVF   00,W
0921:  SUBLW  62
0922:  BTFSS  03.2
0923:  GOTO   12A
....................       base=2,sc+=2; 
0924:  MOVLW  02
0925:  MOVWF  4F
0926:  ADDWF  50,F
0927:  BTFSC  03.0
0928:  INCF   51,F
0929:  GOTO   12C
....................    else 
....................       base=8; 
092A:  MOVLW  08
092B:  MOVWF  4F
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
092C:  MOVF   51,W
092D:  MOVWF  53
092E:  MOVF   50,W
092F:  MOVWF  52
0930:  MOVF   51,W
0931:  MOVWF  7A
0932:  MOVF   50,W
0933:  MOVWF  04
0934:  BCF    03.7
0935:  BTFSC  7A.0
0936:  BSF    03.7
0937:  MOVF   00,W
0938:  SUBLW  30
0939:  BTFSS  03.2
093A:  GOTO   13F
093B:  INCF   50,F
093C:  BTFSC  03.2
093D:  INCF   51,F
093E:  GOTO   130
....................    sd=memchr(digits,tolower(*sc),base); 
093F:  MOVF   51,W
0940:  MOVWF  7A
0941:  MOVF   50,W
0942:  MOVWF  04
0943:  BCF    03.7
0944:  BTFSC  51.0
0945:  BSF    03.7
0946:  MOVF   00,W
0947:  MOVWF  59
0948:  SUBLW  40
0949:  BTFSC  03.0
094A:  GOTO   152
094B:  MOVF   59,W
094C:  SUBLW  5A
094D:  BTFSS  03.0
094E:  GOTO   152
094F:  MOVF   59,W
0950:  IORLW  20
0951:  GOTO   153
0952:  MOVF   59,W
0953:  MOVWF  59
0954:  MOVLW  01
0955:  BCF    03.5
0956:  BSF    03.6
0957:  MOVWF  36
0958:  MOVLW  10
0959:  MOVWF  35
095A:  BSF    03.5
095B:  BCF    03.6
095C:  MOVF   59,W
095D:  BCF    03.5
095E:  BSF    03.6
095F:  MOVWF  37
0960:  CLRF   39
0961:  BSF    03.5
0962:  BCF    03.6
0963:  MOVF   4F,W
0964:  BCF    03.5
0965:  BSF    03.6
0966:  MOVWF  38
0967:  BCF    0A.3
0968:  BCF    03.6
0969:  CALL   671
096A:  BSF    0A.3
096B:  MOVF   79,W
096C:  BSF    03.5
096D:  MOVWF  55
096E:  MOVF   78,W
096F:  MOVWF  54
....................    for(; sd!=0; ) 
0970:  MOVF   54,F
0971:  BTFSS  03.2
0972:  GOTO   176
0973:  MOVF   55,F
0974:  BTFSC  03.2
0975:  GOTO   20E
....................    { 
....................       x=x*base+(int16)(sd-digits); 
0976:  CLRF   7A
0977:  MOVF   4F,W
0978:  MOVWF  77
0979:  BTFSC  77.7
097A:  DECF   7A,F
097B:  MOVWF  59
097C:  MOVF   7A,W
097D:  MOVWF  5A
097E:  MOVF   57,W
097F:  BCF    03.5
0980:  BSF    03.6
0981:  MOVWF  37
0982:  BSF    03.5
0983:  BCF    03.6
0984:  MOVF   56,W
0985:  BCF    03.5
0986:  BSF    03.6
0987:  MOVWF  36
0988:  BSF    03.5
0989:  BCF    03.6
098A:  MOVF   5A,W
098B:  BCF    03.5
098C:  BSF    03.6
098D:  MOVWF  39
098E:  BSF    03.5
098F:  BCF    03.6
0990:  MOVF   59,W
0991:  BCF    03.5
0992:  BSF    03.6
0993:  MOVWF  38
*
09C1:  MOVF   79,W
09C2:  BSF    03.5
09C3:  BCF    03.6
09C4:  MOVWF  5A
09C5:  MOVF   78,W
09C6:  MOVWF  59
09C7:  MOVLW  10
09C8:  SUBWF  54,W
09C9:  MOVWF  77
09CA:  MOVF   55,W
09CB:  MOVWF  7A
09CC:  MOVLW  01
09CD:  BTFSS  03.0
09CE:  MOVLW  02
09CF:  SUBWF  7A,F
09D0:  MOVF   77,W
09D1:  ADDWF  59,W
09D2:  MOVWF  56
09D3:  MOVF   5A,W
09D4:  MOVWF  57
09D5:  MOVF   7A,W
09D6:  BTFSC  03.0
09D7:  INCFSZ 7A,W
09D8:  ADDWF  57,F
....................       ++sc; 
09D9:  INCF   50,F
09DA:  BTFSC  03.2
09DB:  INCF   51,F
....................       sd=memchr(digits,tolower(*sc),base); 
09DC:  MOVF   51,W
09DD:  MOVWF  7A
09DE:  MOVF   50,W
09DF:  MOVWF  04
09E0:  BCF    03.7
09E1:  BTFSC  51.0
09E2:  BSF    03.7
09E3:  MOVF   00,W
09E4:  MOVWF  59
09E5:  SUBLW  40
09E6:  BTFSC  03.0
09E7:  GOTO   1EF
09E8:  MOVF   59,W
09E9:  SUBLW  5A
09EA:  BTFSS  03.0
09EB:  GOTO   1EF
09EC:  MOVF   59,W
09ED:  IORLW  20
09EE:  GOTO   1F0
09EF:  MOVF   59,W
09F0:  MOVWF  59
09F1:  MOVLW  01
09F2:  BCF    03.5
09F3:  BSF    03.6
09F4:  MOVWF  36
09F5:  MOVLW  10
09F6:  MOVWF  35
09F7:  BSF    03.5
09F8:  BCF    03.6
09F9:  MOVF   59,W
09FA:  BCF    03.5
09FB:  BSF    03.6
09FC:  MOVWF  37
09FD:  CLRF   39
09FE:  BSF    03.5
09FF:  BCF    03.6
0A00:  MOVF   4F,W
0A01:  BCF    03.5
0A02:  BSF    03.6
0A03:  MOVWF  38
0A04:  BCF    0A.3
0A05:  BCF    03.6
0A06:  CALL   671
0A07:  BSF    0A.3
0A08:  MOVF   79,W
0A09:  BSF    03.5
0A0A:  MOVWF  55
0A0B:  MOVF   78,W
0A0C:  MOVWF  54
0A0D:  GOTO   170
....................    } 
....................    if(s1==sc) 
0A0E:  MOVF   50,W
0A0F:  SUBWF  52,W
0A10:  BTFSS  03.2
0A11:  GOTO   229
0A12:  MOVF   51,W
0A13:  SUBWF  53,W
0A14:  BTFSS  03.2
0A15:  GOTO   229
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
0A16:  MOVF   4D,W
0A17:  IORWF  4E,W
0A18:  BTFSC  03.2
0A19:  GOTO   225
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
0A1A:  MOVF   4D,W
0A1B:  MOVWF  04
0A1C:  BCF    03.7
0A1D:  BTFSC  4E.0
0A1E:  BSF    03.7
0A1F:  INCF   04,F
0A20:  MOVF   4C,W
0A21:  MOVWF  00
0A22:  DECF   04,F
0A23:  MOVF   4B,W
0A24:  MOVWF  00
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
0A25:  MOVLW  00
0A26:  MOVWF  78
0A27:  MOVWF  79
0A28:  GOTO   23C
....................    } 
....................    if (endptr) 
0A29:  MOVF   4D,W
0A2A:  IORWF  4E,W
0A2B:  BTFSC  03.2
0A2C:  GOTO   238
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
0A2D:  MOVF   4D,W
0A2E:  MOVWF  04
0A2F:  BCF    03.7
0A30:  BTFSC  4E.0
0A31:  BSF    03.7
0A32:  INCF   04,F
0A33:  MOVF   51,W
0A34:  MOVWF  00
0A35:  DECF   04,F
0A36:  MOVF   50,W
0A37:  MOVWF  00
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
0A38:  MOVF   56,W
0A39:  MOVWF  78
0A3A:  MOVF   57,W
0A3B:  MOVWF  79
0A3C:  BCF    03.5
0A3D:  RETURN
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... void saveUser(int * id, int * pass, int status){ 
....................    if( id[0] < 256 && id[1] < 256 && getAddressByID(id) > -1 ){ 
*
0C09:  MOVF   31,W
0C0A:  MOVWF  04
0C0B:  BCF    03.7
0C0C:  BTFSC  32.0
0C0D:  BSF    03.7
0C0E:  MOVLW  01
0C0F:  ADDWF  31,W
0C10:  MOVWF  04
0C11:  BCF    03.7
0C12:  BTFSC  32.0
0C13:  BSF    03.7
0C14:  MOVF   32,W
0C15:  MOVWF  3F
0C16:  MOVF   31,W
0C17:  MOVWF  3E
....................       int address = lastNewUserPosition(); 
....................       //recebe os parÃ¢metros do usuÃ¡rio 
....................       User user; 
*
0D29:  MOVF   78,W
0D2A:  MOVWF  36
....................       user.id[0] = id[0]; 
0D2B:  MOVF   31,W
0D2C:  MOVWF  04
0D2D:  BCF    03.7
0D2E:  BTFSC  32.0
0D2F:  BSF    03.7
0D30:  MOVF   00,W
0D31:  MOVWF  37
....................       user.id[1] = id[1]; 
0D32:  MOVLW  01
0D33:  ADDWF  31,W
0D34:  MOVWF  04
0D35:  BCF    03.7
0D36:  BTFSC  32.0
0D37:  BSF    03.7
0D38:  MOVF   00,W
0D39:  MOVWF  38
....................       user.pass[0] = pass[0]; 
0D3A:  MOVF   33,W
0D3B:  MOVWF  04
0D3C:  BCF    03.7
0D3D:  BTFSC  34.0
0D3E:  BSF    03.7
0D3F:  MOVF   00,W
0D40:  MOVWF  39
....................       user.pass[1] = pass[1]; 
0D41:  MOVLW  01
0D42:  ADDWF  33,W
0D43:  MOVWF  04
0D44:  BCF    03.7
0D45:  BTFSC  34.0
0D46:  BSF    03.7
0D47:  MOVF   00,W
0D48:  MOVWF  3A
....................       user.pass[2] = pass[2]; 
0D49:  MOVLW  02
0D4A:  ADDWF  33,W
0D4B:  MOVWF  04
0D4C:  BCF    03.7
0D4D:  BTFSC  34.0
0D4E:  BSF    03.7
0D4F:  MOVF   00,W
0D50:  MOVWF  3B
....................       user.pass[3] = pass[3]; 
0D51:  MOVLW  03
0D52:  ADDWF  33,W
0D53:  MOVWF  04
0D54:  BCF    03.7
0D55:  BTFSC  34.0
0D56:  BSF    03.7
0D57:  MOVF   00,W
0D58:  MOVWF  3C
....................       user.status = status; 
0D59:  MOVF   35,W
0D5A:  MOVWF  3D
....................        
....................  
....................       //Corrigir isso, o endereÃ§o tem que ser "dinÃ¢mico" 
....................        
....................       write_ext_eeprom(address, user.id[0]); 
0D5B:  MOVF   36,W
0D5C:  MOVWF  3F
0D5D:  MOVF   37,W
0D5E:  MOVWF  40
0D5F:  BCF    0A.3
0D60:  BCF    03.5
0D61:  CALL   410
0D62:  BSF    0A.3
....................       write_ext_eeprom(address+1, user.id[1]); 
0D63:  MOVLW  01
0D64:  BSF    03.5
0D65:  ADDWF  36,W
0D66:  MOVWF  3E
0D67:  MOVWF  3F
0D68:  MOVF   38,W
0D69:  MOVWF  40
0D6A:  BCF    0A.3
0D6B:  BCF    03.5
0D6C:  CALL   410
0D6D:  BSF    0A.3
....................       write_ext_eeprom(address+2, user.pass[0]); 
0D6E:  MOVLW  02
0D6F:  BSF    03.5
0D70:  ADDWF  36,W
0D71:  MOVWF  3E
0D72:  MOVWF  3F
0D73:  MOVF   39,W
0D74:  MOVWF  40
0D75:  BCF    0A.3
0D76:  BCF    03.5
0D77:  CALL   410
0D78:  BSF    0A.3
....................       write_ext_eeprom(address+3, user.pass[1]); 
0D79:  MOVLW  03
0D7A:  BSF    03.5
0D7B:  ADDWF  36,W
0D7C:  MOVWF  3E
0D7D:  MOVWF  3F
0D7E:  MOVF   3A,W
0D7F:  MOVWF  40
0D80:  BCF    0A.3
0D81:  BCF    03.5
0D82:  CALL   410
0D83:  BSF    0A.3
....................       write_ext_eeprom(address+4, user.pass[2]); 
0D84:  MOVLW  04
0D85:  BSF    03.5
0D86:  ADDWF  36,W
0D87:  MOVWF  3E
0D88:  MOVWF  3F
0D89:  MOVF   3B,W
0D8A:  MOVWF  40
0D8B:  BCF    0A.3
0D8C:  BCF    03.5
0D8D:  CALL   410
0D8E:  BSF    0A.3
....................       write_ext_eeprom(address+5, user.pass[3]);        
0D8F:  MOVLW  05
0D90:  BSF    03.5
0D91:  ADDWF  36,W
0D92:  MOVWF  3E
0D93:  MOVWF  3F
0D94:  MOVF   3C,W
0D95:  MOVWF  40
0D96:  BCF    0A.3
0D97:  BCF    03.5
0D98:  CALL   410
0D99:  BSF    0A.3
....................       write_ext_eeprom(address+6, user.status); 
0D9A:  MOVLW  06
0D9B:  BSF    03.5
0D9C:  ADDWF  36,W
0D9D:  MOVWF  3E
0D9E:  MOVWF  3F
0D9F:  MOVF   3D,W
0DA0:  MOVWF  40
0DA1:  BCF    0A.3
0DA2:  BCF    03.5
0DA3:  CALL   410
0DA4:  BSF    0A.3
....................     
....................  
....................       printf (lcd_escreve,"\fUsuario Cadastrado"); 
0DA5:  MOVLW  60
0DA6:  BSF    03.6
0DA7:  MOVWF  0D
0DA8:  MOVLW  00
0DA9:  MOVWF  0F
0DAA:  BCF    0A.3
0DAB:  BCF    03.6
0DAC:  CALL   224
0DAD:  BSF    0A.3
....................       delay_ms(500); 
0DAE:  MOVLW  02
0DAF:  BSF    03.5
0DB0:  MOVWF  3E
0DB1:  MOVLW  FA
0DB2:  MOVWF  49
0DB3:  BCF    0A.3
0DB4:  BCF    03.5
0DB5:  CALL   12A
0DB6:  BSF    0A.3
0DB7:  BSF    03.5
0DB8:  DECFSZ 3E,F
0DB9:  GOTO   5B1
....................  
....................    }else{ 
....................       printf (lcd_escreve,"\fID incompativel"); 
....................       printf (lcd_escreve,"\r\nTente novamente"); 
....................       delay_ms(1000); 
....................  
....................    } 
.................... } 
....................  
.................... void printUser(){ 
....................    //delay_ms(50); 
....................    int tmp_result = read_ext_eeprom(0);   
....................     
....................    delay_ms(50);   
....................     
....................    printf (lcd_escreve,"\f Button: %d", tmp_result); 
....................    printf(lcd_escreve, "\r\nPw:%d%d%d%d St:%d %d", read_ext_eeprom(1), read_ext_eeprom(2), read_ext_eeprom(3), read_ext_eeprom(4), read_ext_eeprom(5), read_ext_eeprom(6)); 
....................     
....................    //printf(lcd_escreve, "\f Client () elseÂ´{}{} 
....................    // printf(lcd_escreve, "\r\nPw:%c%c%c%c St:%c %c", U1.pass[0], U1.pass[1], U1.pass[2], U1.pass[3], U1.status, U1.type_usr); 
.................... } 
....................  
.................... int getAddressByID(int * id){ 
*
0C18:  CLRF   42
....................    int id_temp[2]; 
....................    int address = 0; 
....................     
....................    while( read_ext_eeprom(address) != -1){ 
0C19:  MOVF   42,W
0C1A:  MOVWF  44
0C1B:  BCF    0A.3
0C1C:  BCF    03.5
0C1D:  CALL   340
0C1E:  BSF    0A.3
0C1F:  MOVF   78,W
0C20:  SUBLW  FF
0C21:  BTFSC  03.2
0C22:  GOTO   47F
....................       id_temp[0] = read_ext_eeprom(address); 
0C23:  BSF    03.5
0C24:  MOVF   42,W
0C25:  MOVWF  44
0C26:  BCF    0A.3
0C27:  BCF    03.5
0C28:  CALL   340
0C29:  BSF    0A.3
0C2A:  MOVF   78,W
0C2B:  BSF    03.5
0C2C:  MOVWF  40
....................       id_temp[1] = read_ext_eeprom(address+1); 
0C2D:  MOVLW  01
0C2E:  ADDWF  42,W
0C2F:  MOVWF  43
0C30:  MOVWF  44
0C31:  BCF    0A.3
0C32:  BCF    03.5
0C33:  CALL   340
0C34:  BSF    0A.3
0C35:  MOVF   78,W
0C36:  BSF    03.5
0C37:  MOVWF  41
....................        
....................       if (id_temp[0] == id[0] && id_temp[1] == id[1]){ 
0C38:  MOVF   3E,W
0C39:  MOVWF  04
0C3A:  BCF    03.7
0C3B:  BTFSC  3F.0
0C3C:  BSF    03.7
0C3D:  MOVF   00,W
0C3E:  SUBWF  40,W
0C3F:  BTFSS  03.2
0C40:  GOTO   47B
0C41:  MOVLW  01
0C42:  ADDWF  3E,W
0C43:  MOVWF  04
0C44:  BCF    03.7
0C45:  BTFSC  3F.0
0C46:  BSF    03.7
0C47:  MOVF   00,W
0C48:  SUBWF  41,W
0C49:  BTFSS  03.2
0C4A:  GOTO   47B
....................          printf (lcd_escreve,"\fID Encontrado:%u%u", id_temp[0],id_temp[1]); 
0C4B:  MOVLW  8F
0C4C:  BCF    03.5
0C4D:  BSF    03.6
0C4E:  MOVWF  0D
0C4F:  MOVLW  00
0C50:  MOVWF  0F
0C51:  BCF    03.0
0C52:  MOVLW  0F
0C53:  BSF    03.5
0C54:  BCF    03.6
0C55:  MOVWF  43
0C56:  BCF    0A.3
0C57:  BCF    03.5
0C58:  CALL   5F7
0C59:  BSF    0A.3
0C5A:  BSF    03.5
0C5B:  MOVF   40,W
0C5C:  MOVWF  43
0C5D:  MOVLW  1B
0C5E:  MOVWF  44
0C5F:  BCF    0A.3
0C60:  BCF    03.5
0C61:  CALL   6F3
0C62:  BSF    0A.3
0C63:  BSF    03.5
0C64:  MOVF   41,W
0C65:  MOVWF  43
0C66:  MOVLW  1B
0C67:  MOVWF  44
0C68:  BCF    0A.3
0C69:  BCF    03.5
0C6A:  CALL   6F3
0C6B:  BSF    0A.3
....................          delay_ms(1000); 
0C6C:  MOVLW  04
0C6D:  BSF    03.5
0C6E:  MOVWF  43
0C6F:  MOVLW  FA
0C70:  MOVWF  49
0C71:  BCF    0A.3
0C72:  BCF    03.5
0C73:  CALL   12A
0C74:  BSF    0A.3
0C75:  BSF    03.5
0C76:  DECFSZ 43,F
0C77:  GOTO   46F
....................          return address; 
0C78:  MOVF   42,W
0C79:  MOVWF  78
0C7A:  GOTO   48B
....................       } 
....................  
....................       address += BLOCK_SIZE;  
0C7B:  MOVLW  07
0C7C:  ADDWF  42,F
0C7D:  GOTO   419
0C7E:  BCF    03.5
....................    } 
....................    printf (lcd_escreve,"\f ID N Encontrado"); 
0C7F:  MOVLW  99
0C80:  BSF    03.6
0C81:  MOVWF  0D
0C82:  MOVLW  00
0C83:  MOVWF  0F
0C84:  BCF    0A.3
0C85:  BCF    03.6
0C86:  CALL   224
0C87:  BSF    0A.3
....................    return -1; 
0C88:  MOVLW  FF
0C89:  MOVWF  78
0C8A:  BSF    03.5
....................     
.................... } 
....................  
.................... void erase_program_eeprom(int addrr){ 
....................    for(int i=0; i < BLOCK_SIZE; i++){ 
*
046C:  CLRF   57
046D:  MOVF   57,W
046E:  SUBLW  06
046F:  BTFSS  03.0
0470:  GOTO   47C
....................          write_ext_eeprom(addrr + i, -1); 
0471:  MOVF   57,W
0472:  ADDWF  56,W
0473:  MOVWF  58
0474:  BSF    03.5
0475:  MOVWF  3F
0476:  MOVLW  FF
0477:  MOVWF  40
0478:  BCF    03.5
0479:  CALL   410
047A:  INCF   57,F
047B:  GOTO   46D
....................    }   
....................    printf (lcd_escreve,"\f User erased "); 
047C:  MOVLW  A2
047D:  BSF    03.6
047E:  MOVWF  0D
047F:  MOVLW  00
0480:  MOVWF  0F
0481:  BCF    03.6
0482:  CALL   224
....................    delay_ms(500); 
0483:  MOVLW  02
0484:  MOVWF  58
0485:  MOVLW  FA
0486:  BSF    03.5
0487:  MOVWF  49
0488:  BCF    03.5
0489:  CALL   12A
048A:  DECFSZ 58,F
048B:  GOTO   485
.................... } 
....................  
.................... int deleteUser(int8 address){ 
....................     
....................    int data_temp; 
....................    int previous_block = address; 
....................    int next_block = address + BLOCK_SIZE; 
....................  
....................    //Case 1: without next block 
....................    if (read_ext_eeprom(next_block) == -1){ 
....................       erase_program_eeprom(previous_block);       
....................       return 1; 
....................    } 
....................  
....................    //Case 2: Check whether the data in the address is empty 
....................    while(read_ext_eeprom(next_block) != -1){ 
....................       //data_temp[index] = read_ext_eeprom(address); 
....................       for(int i=0; i < BLOCK_SIZE; i++){ 
....................          data_temp = read_ext_eeprom(next_block + i);            
....................          write_ext_eeprom(previous_block + i, data_temp);    //overwrite delete block 
....................       }   
....................  
....................       previous_block = next_block; 
....................       next_block += BLOCK_SIZE; 
....................    } 
....................     
....................    next_block -= BLOCK_SIZE; 
....................     
....................    //Erase last block   
....................    erase_program_eeprom(next_block); 
....................     
....................    return 1; 
....................  
.................... } 
....................  
.................... int lastNewUserPosition(){ 
*
0C8B:  CLRF   3E
....................    int address = 0; 
....................    int id_temp; 
....................  
....................    while( read_ext_eeprom(address) != -1){ 
0C8C:  MOVF   3E,W
0C8D:  MOVWF  44
0C8E:  BCF    0A.3
0C8F:  BCF    03.5
0C90:  CALL   340
0C91:  BSF    0A.3
0C92:  MOVF   78,W
0C93:  SUBLW  FF
0C94:  BTFSC  03.2
0C95:  GOTO   49B
....................       address += BLOCK_SIZE;  
0C96:  MOVLW  07
0C97:  BSF    03.5
0C98:  ADDWF  3E,F
0C99:  GOTO   48C
0C9A:  BCF    03.5
....................    } 
....................    printf (lcd_escreve,"\fAddress: %d", address); 
0C9B:  MOVLW  AA
0C9C:  BSF    03.6
0C9D:  MOVWF  0D
0C9E:  MOVLW  00
0C9F:  MOVWF  0F
0CA0:  BCF    03.0
0CA1:  MOVLW  0A
0CA2:  BSF    03.5
0CA3:  BCF    03.6
0CA4:  MOVWF  43
0CA5:  BCF    0A.3
0CA6:  BCF    03.5
0CA7:  CALL   5F7
0CA8:  BSF    0A.3
0CA9:  BSF    03.5
0CAA:  MOVF   3E,W
0CAB:  MOVWF  40
0CAC:  MOVLW  18
0CAD:  MOVWF  41
....................    delay_ms(1000); 
*
0D1B:  MOVLW  04
0D1C:  BSF    03.5
0D1D:  MOVWF  40
0D1E:  MOVLW  FA
0D1F:  MOVWF  49
0D20:  BCF    0A.3
0D21:  BCF    03.5
0D22:  CALL   12A
0D23:  BSF    0A.3
0D24:  BSF    03.5
0D25:  DECFSZ 40,F
0D26:  GOTO   51E
....................     
....................    return address; 
0D27:  MOVF   3E,W
0D28:  MOVWF  78
....................  
.................... } 
....................  
.................... int isIdAvailable(int * id){ 
....................    unsigned int address = 0; 
....................    int id_temp; 
....................    while( read_ext_eeprom(address) != -1){ 
....................       id_temp = read_ext_eeprom(address); 
....................       if (id_temp == id){ 
....................           printf (lcd_escreve,"\fID:%u, Existe", id_temp); 
....................           delay_ms(1000); 
....................          return 0;//Sucessful 
....................       } 
....................  
....................       address += BLOCK_SIZE;  
....................    } 
....................    printf (lcd_escreve,"\fID:%u, N Existe", id_temp); 
....................    delay_ms(1000); 
....................    return -1; 
.................... } 
....................  
.................... void resetMemory(){ 
*
0460:  CLRF   55
....................    int address = 0; 
....................    for(; read_ext_eeprom(address) != -1; 
0461:  MOVF   55,W
0462:  BSF    03.5
0463:  MOVWF  44
0464:  BCF    03.5
0465:  CALL   340
0466:  MOVF   78,W
0467:  SUBLW  FF
0468:  BTFSC  03.2
0469:  GOTO   48F
....................     erase_program_eeprom(address), address += BLOCK_SIZE); 
046A:  MOVF   55,W
046B:  MOVWF  56
*
048C:  MOVLW  07
048D:  ADDWF  55,F
048E:  GOTO   461
048F:  BSF    0A.3
0490:  BCF    0A.4
0491:  GOTO   61A (RETURN)
.................... } 
....................  
.................... void adminMenu(){ 
....................  
....................  
....................   unsigned char option; 
....................    // printf(lcd_escreve,"\f1: CAD Cliente "); 
....................    // delay_ms(500); 
....................    // printf(lcd_escreve,"\r\n2: DEL Cliente"); 
....................    // delay_ms(500); 
....................    // printf(lcd_escreve,"\f3: Buscar Cliente "); 
....................    // delay_ms(500); 
....................    // printf(lcd_escreve,"\r\n4: Editar Cliente"); 
....................    // delay_ms(500); 
....................    // printf(lcd_escreve,"\f5: SAIR do Menu "); 
....................    // delay_ms(500); 
....................   do{ 
....................      
....................    option = readKeyboard(); 
*
0A3E:  BCF    0A.3
0A3F:  CALL   492
0A40:  BSF    0A.3
0A41:  MOVF   78,W
0A42:  MOVWF  55
....................    printf(lcd_escreve,"\f Option: %c", option); 
0A43:  MOVLW  C2
0A44:  BSF    03.6
0A45:  MOVWF  0D
0A46:  MOVLW  00
0A47:  MOVWF  0F
0A48:  BCF    03.0
0A49:  MOVLW  0A
0A4A:  BSF    03.5
0A4B:  BCF    03.6
0A4C:  MOVWF  43
0A4D:  BCF    0A.3
0A4E:  BCF    03.5
0A4F:  CALL   5F7
0A50:  BSF    0A.3
0A51:  MOVF   55,W
0A52:  BSF    03.5
0A53:  MOVWF  48
0A54:  BCF    0A.3
0A55:  BCF    03.5
0A56:  CALL   1E1
0A57:  BSF    0A.3
....................    delay_ms(500); 
0A58:  MOVLW  02
0A59:  MOVWF  56
0A5A:  MOVLW  FA
0A5B:  BSF    03.5
0A5C:  MOVWF  49
0A5D:  BCF    0A.3
0A5E:  BCF    03.5
0A5F:  CALL   12A
0A60:  BSF    0A.3
0A61:  DECFSZ 56,F
0A62:  GOTO   25A
....................  
....................  
....................    switch(option){ 
0A63:  MOVF   55,W
0A64:  XORLW  31
0A65:  BTFSC  03.2
0A66:  GOTO   271
0A67:  XORLW  33
0A68:  BTFSC  03.2
0A69:  GOTO   5BB
0A6A:  XORLW  01
0A6B:  BTFSC  03.2
0A6C:  GOTO   5BD
0A6D:  XORLW  07
0A6E:  BTFSC  03.2
0A6F:  GOTO   5BF
0A70:  GOTO   5C2
....................       case '1': 
....................          inputKeyboardUser(); 
....................          break; 
*
0DBA:  GOTO   5C3
....................       case 2: 
....................          // listar(); 
....................          break; 
0DBB:  BSF    03.5
0DBC:  GOTO   5C3
....................       case 3: 
....................          // mostrarMes(); 
....................          break; 
0DBD:  BSF    03.5
0DBE:  GOTO   5C3
....................       case 4: 
....................          //  printf("\nTENHA UM BOM DIA\n"); 
....................          break; 
0DBF:  BSF    03.5
0DC0:  GOTO   5C3
0DC1:  BCF    03.5
....................       default: 
....................          // printf("\nDIGITE UM VALOR VÃLIDO\n"); 
....................          break; 
0DC2:  BSF    03.5
....................  
....................    } 
....................    }while(option != 4);//sÃ³ termina quando for 4  
0DC3:  BCF    03.5
0DC4:  MOVF   55,W
0DC5:  SUBLW  04
0DC6:  BTFSS  03.2
0DC7:  GOTO   23E
0DC8:  BSF    0A.3
0DC9:  BCF    0A.4
0DCA:  GOTO   61C (RETURN)
....................     
....................   
....................  
....................     
.................... } 
....................  
.................... unsigned char readKeyboard(){ 
....................    unsigned char tmp; 
....................    unsigned char tmp_result; 
....................     
....................    tmp = tc_tecla(1500); // ms 
*
0492:  MOVLW  DC
0493:  BSF    03.5
0494:  MOVWF  45
*
05E4:  MOVF   78,W
05E5:  MOVWF  43
....................    if(tmp != 255){ 
05E6:  INCFSZ 43,W
05E7:  GOTO   5E9
05E8:  GOTO   5EA
....................       // write_ext_eeprom(0, tmp); 
....................       // delay_ms(50); 
....................       // tmp_result = read_ext_eeprom(0); 
....................       // delay_ms(50); 
....................       // tmp_result = tmp; 
....................       // printf(lcd_escreve,"\f Button: %c", tmp); 
....................       // delay_ms(50); 
....................    }else{  
05E9:  GOTO   5F3
....................       printf(lcd_escreve,"\f   TECLADO  "); 
05EA:  MOVLW  C9
05EB:  BCF    03.5
05EC:  BSF    03.6
05ED:  MOVWF  0D
05EE:  MOVLW  00
05EF:  MOVWF  0F
05F0:  BCF    03.6
05F1:  CALL   224
05F2:  BSF    03.5
....................    } 
....................  
....................    return tmp; 
05F3:  MOVF   43,W
05F4:  MOVWF  78
05F5:  BCF    03.5
05F6:  RETURN
.................... } 
....................  
....................  
.................... int * getAdminsID(){ 
....................  
....................    int address = 0; 
....................    int temp_status; 
....................    int index= 0; 
....................    static int admins[BLOCK_SIZE]; 
*
0DDF:  CLRF   44
0DE0:  CLRF   45
0DE1:  CLRF   46
0DE2:  CLRF   47
0DE3:  CLRF   48
0DE4:  CLRF   49
0DE5:  CLRF   4A
....................    admins[0] = -1; 
....................    while( read_ext_eeprom(address) != -1){ 
....................       temp_status = read_ext_eeprom(address + (BLOCK_SIZE - 1));//status of the user 
....................       if (temp_status == 3){ 
....................          printf (lcd_escreve,"\fAdmin Encontrado"); 
....................          delay_ms(1000); 
....................          for(int i=0; i < 2; i++){ 
....................             int id = read_ext_eeprom(address+i);    
....................             admins[index] = id; 
....................             index++; 
....................          } 
....................  
....................       } 
....................  
....................       address += BLOCK_SIZE;  
....................    } 
....................  
....................    return admins; 
....................  
.................... } 
....................  
.................... void listAdmins(){ 
....................    int * admins; 
....................  
....................    admins = getAdminsID(); 
....................    printf(lcd_escreve,"\f admins[0]: %d", admins[0]); 
....................    delay_ms(1000); 
....................    if(admins[0] != -1){ 
....................       for (int16 i=0; i < sizeof(admins); i+=2){ 
....................          printf(lcd_escreve, "\fid~:%u%u",admins[i], admins[i+1]); 
....................          delay_ms(1000); 
....................       }  
....................    } 
.................... } 
....................  
....................  
.................... int * strToInt(char * str){ 
*
069C:  BSF    03.5
069D:  MOVF   44,W
069E:  MOVWF  46
069F:  MOVF   43,W
06A0:  MOVWF  45
06A1:  CLRF   49
....................  
....................   char *p = str; 
....................   //https://flaviocopes.com/c-array-length/ 
.................... //   int size = (sizeof str) / (sizeof * str); 
....................   static unsigned int buffer[BLOCK_SIZE];   
*
0DE6:  CLRF   4B
0DE7:  CLRF   4C
0DE8:  CLRF   4D
0DE9:  CLRF   4E
0DEA:  CLRF   4F
0DEB:  CLRF   50
0DEC:  CLRF   51
.................... //   printf(lcd_escreve,"\fParsing: %s",p); 
.................... //   delay_ms(1000); 
....................   char * end; 
....................   int index = 0; 
....................  
....................   for (unsigned int number = strtoul(p, &end, 10); 
*
06A2:  MOVF   46,W
06A3:  MOVWF  4C
06A4:  MOVF   45,W
06A5:  MOVWF  4B
06A6:  CLRF   4E
06A7:  MOVLW  C7
06A8:  MOVWF  4D
06A9:  MOVLW  0A
06AA:  MOVWF  4F
06AB:  BSF    0A.3
06AC:  BCF    03.5
06AD:  CALL   000
06AE:  BCF    0A.3
06AF:  MOVF   78,W
06B0:  BSF    03.5
06B1:  MOVWF  4A
....................         p != end; 
06B2:  MOVF   47,W
06B3:  SUBWF  45,W
06B4:  BTFSS  03.2
06B5:  GOTO   6BA
06B6:  MOVF   48,W
06B7:  SUBWF  46,W
06B8:  BTFSC  03.2
06B9:  GOTO   6D6
....................         number = strtoul(p, &end, 10)) 
....................   { 
....................    //  printf(lcd_escreve,"\n%u",number ); 
....................    //  delay_ms(50); 
....................     p = end; 
06BA:  MOVF   48,W
06BB:  MOVWF  46
06BC:  MOVF   47,W
06BD:  MOVWF  45
....................  
....................     buffer[index] = number;  
06BE:  MOVLW  4B
06BF:  ADDWF  49,W
06C0:  MOVWF  04
06C1:  BCF    03.7
06C2:  MOVF   4A,W
06C3:  MOVWF  00
....................     index++; 
06C4:  INCF   49,F
06C5:  MOVF   46,W
06C6:  MOVWF  4C
06C7:  MOVF   45,W
06C8:  MOVWF  4B
06C9:  CLRF   4E
06CA:  MOVLW  C7
06CB:  MOVWF  4D
06CC:  MOVLW  0A
06CD:  MOVWF  4F
06CE:  BSF    0A.3
06CF:  BCF    03.5
06D0:  CALL   000
06D1:  BCF    0A.3
06D2:  MOVF   78,W
06D3:  BSF    03.5
06D4:  MOVWF  4A
06D5:  GOTO   6B2
....................   } 
....................  
....................    return buffer; 
06D6:  MOVLW  4B
06D7:  MOVWF  78
06D8:  MOVLW  00
06D9:  MOVWF  79
06DA:  BCF    03.5
06DB:  RETURN
.................... } 
....................  
.................... char * strfromchar(char destination[], char source)  
.................... {  
....................    destination[0] = source;   // copy the character into the string  
*
0788:  MOVF   41,W
0789:  MOVWF  04
078A:  BCF    03.7
078B:  BTFSC  42.0
078C:  BSF    03.7
078D:  MOVF   43,W
078E:  MOVWF  00
....................    destination[1] = '\0';      // null-terminate the string  
078F:  MOVLW  01
0790:  ADDWF  41,W
0791:  MOVWF  04
0792:  BCF    03.7
0793:  BTFSC  42.0
0794:  BSF    03.7
0795:  CLRF   00
....................   
....................    return destination;         // common convention for str functions  
0796:  MOVF   41,W
0797:  MOVWF  78
0798:  MOVF   42,W
0799:  MOVWF  79
.................... }  
....................  
....................  
.................... int * inputId(){ 
*
0A71:  BSF    03.5
0A72:  CLRF   42
....................    unsigned char keyboard_buffer[BLOCK_SIZE * 2]; 
....................    unsigned char option; 
....................  
....................    int * temp; 
....................    int i = 0; 
....................    //The user needs to type 4 digits 
....................    //For example, even if it's just 9 
....................    //He/she will type: 0009 
....................    while(i < 5){ 
0A73:  MOVF   42,W
0A74:  SUBLW  04
0A75:  BTFSS  03.0
0A76:  GOTO   2C6
....................       printf(lcd_escreve,"\fDigite o ID"); 
0A77:  MOVLW  E6
0A78:  BCF    03.5
0A79:  BSF    03.6
0A7A:  MOVWF  0D
0A7B:  MOVLW  00
0A7C:  MOVWF  0F
0A7D:  BCF    0A.3
0A7E:  BCF    03.6
0A7F:  CALL   224
0A80:  BSF    0A.3
....................       delay_ms(50); 
0A81:  MOVLW  32
0A82:  BSF    03.5
0A83:  MOVWF  49
0A84:  BCF    0A.3
0A85:  BCF    03.5
0A86:  CALL   12A
0A87:  BSF    0A.3
....................       option = readKeyboard(); 
0A88:  BCF    0A.3
0A89:  CALL   492
0A8A:  BSF    0A.3
0A8B:  MOVF   78,W
0A8C:  BSF    03.5
0A8D:  MOVWF  3F
....................       printf(lcd_escreve,"\fTyped:%c", option); 
0A8E:  MOVLW  ED
0A8F:  BCF    03.5
0A90:  BSF    03.6
0A91:  MOVWF  0D
0A92:  MOVLW  00
0A93:  MOVWF  0F
0A94:  BCF    03.0
0A95:  MOVLW  07
0A96:  BSF    03.5
0A97:  BCF    03.6
0A98:  MOVWF  43
0A99:  BCF    0A.3
0A9A:  BCF    03.5
0A9B:  CALL   5F7
0A9C:  BSF    0A.3
0A9D:  BSF    03.5
0A9E:  MOVF   3F,W
0A9F:  MOVWF  48
0AA0:  BCF    0A.3
0AA1:  BCF    03.5
0AA2:  CALL   1E1
0AA3:  BSF    0A.3
....................       delay_ms(500); 
0AA4:  MOVLW  02
0AA5:  BSF    03.5
0AA6:  MOVWF  43
0AA7:  MOVLW  FA
0AA8:  MOVWF  49
0AA9:  BCF    0A.3
0AAA:  BCF    03.5
0AAB:  CALL   12A
0AAC:  BSF    0A.3
0AAD:  BSF    03.5
0AAE:  DECFSZ 43,F
0AAF:  GOTO   2A7
....................       if(option != 255){ 
0AB0:  INCFSZ 3F,W
0AB1:  GOTO   2B3
0AB2:  GOTO   2C5
....................          if(i == 2){ 
0AB3:  MOVF   42,W
0AB4:  SUBLW  02
0AB5:  BTFSS  03.2
0AB6:  GOTO   2BE
....................             //To convert to int will be easier with space between them 
....................             keyboard_buffer[i] = ' '; 
0AB7:  MOVLW  B1
0AB8:  ADDWF  42,W
0AB9:  MOVWF  04
0ABA:  BCF    03.7
0ABB:  MOVLW  20
0ABC:  MOVWF  00
....................             i++; 
0ABD:  INCF   42,F
....................          } 
....................          keyboard_buffer[i] = option; 
0ABE:  MOVLW  B1
0ABF:  ADDWF  42,W
0AC0:  MOVWF  04
0AC1:  BCF    03.7
0AC2:  MOVF   3F,W
0AC3:  MOVWF  00
....................          i++; 
0AC4:  INCF   42,F
....................       } 
0AC5:  GOTO   273
....................    } 
....................    // unsigned char *id; 
....................    // id = keyboard_buffer; 
....................    temp = strToInt(keyboard_buffer); 
0AC6:  CLRF   44
0AC7:  MOVLW  B1
0AC8:  MOVWF  43
0AC9:  BCF    0A.3
0ACA:  BCF    03.5
0ACB:  CALL   69C
0ACC:  BSF    0A.3
0ACD:  MOVF   79,W
0ACE:  BSF    03.5
0ACF:  MOVWF  41
0AD0:  MOVF   78,W
0AD1:  MOVWF  40
....................    return temp; 
0AD2:  MOVF   40,W
0AD3:  MOVWF  78
0AD4:  MOVF   41,W
0AD5:  MOVWF  79
....................    // id[0] = temp[0]; 
....................    // id[1] = temp[1]; 
....................    // //https://www.tutorialspoint.com/cprogramming/c_pointer_to_an_array.htm 
....................    // //*(id+1) == id[1] 
....................    // printf(lcd_escreve,"\fid: %u%u",id[0],id[1]); 
....................    // delay_ms(1000); 
.................... } 
....................  
.................... int * inputToKeyboard(char * msg, int max){ 
*
0732:  BSF    03.5
0733:  CLRF   3E
....................    unsigned char option; 
....................    int data[BLOCK_SIZE]; 
....................    int * temp; 
....................    int i = 0; 
....................  
....................    while(i < max){ 
0734:  MOVF   33,W
0735:  SUBWF  3E,W
0736:  BTFSC  03.0
0737:  GOTO   7BE
....................  
....................       printf(lcd_escreve,"\f%s", msg); 
0738:  MOVLW  0C
0739:  MOVWF  48
073A:  BCF    03.5
073B:  CALL   1E1
073C:  BSF    03.5
073D:  MOVF   31,W
073E:  MOVWF  04
073F:  BCF    03.7
0740:  BTFSC  32.0
0741:  BSF    03.7
....................       delay_ms(50); 
*
075C:  MOVLW  32
075D:  MOVWF  49
075E:  BCF    03.5
075F:  CALL   12A
....................       option = readKeyboard(); 
0760:  CALL   492
0761:  MOVF   78,W
0762:  BSF    03.5
0763:  MOVWF  34
....................       printf(lcd_escreve,"\fTyped:%c", option); 
0764:  MOVLW  F2
0765:  BCF    03.5
0766:  BSF    03.6
0767:  MOVWF  0D
0768:  MOVLW  00
0769:  MOVWF  0F
076A:  BCF    03.0
076B:  MOVLW  07
076C:  BSF    03.5
076D:  BCF    03.6
076E:  MOVWF  43
076F:  BCF    03.5
0770:  CALL   5F7
0771:  BSF    03.5
0772:  MOVF   34,W
0773:  MOVWF  48
0774:  BCF    03.5
0775:  CALL   1E1
....................       delay_ms(400); 
0776:  MOVLW  02
0777:  BSF    03.5
0778:  MOVWF  41
0779:  MOVLW  C8
077A:  MOVWF  49
077B:  BCF    03.5
077C:  CALL   12A
077D:  BSF    03.5
077E:  DECFSZ 41,F
077F:  GOTO   779
....................       if(option != 255){ 
0780:  INCFSZ 34,W
0781:  GOTO   783
0782:  GOTO   7BD
....................          unsigned char destination[2]; 
....................          //Convert string from char and return  
....................          //to the left array of char(str_pass) 
....................          strfromchar(destination,option); 
0783:  CLRF   42
0784:  MOVLW  BF
0785:  MOVWF  41
0786:  MOVF   34,W
0787:  MOVWF  43
....................          temp = strToInt(destination); 
*
079A:  CLRF   44
079B:  MOVLW  BF
079C:  MOVWF  43
079D:  BCF    03.5
079E:  CALL   69C
079F:  MOVF   79,W
07A0:  BSF    03.5
07A1:  MOVWF  3D
07A2:  MOVF   78,W
07A3:  MOVWF  3C
....................          data[i] = temp[0]; 
07A4:  MOVLW  B5
07A5:  ADDWF  3E,W
07A6:  MOVWF  78
07A7:  CLRF   7A
07A8:  BTFSC  03.0
07A9:  INCF   7A,F
07AA:  MOVF   78,W
07AB:  MOVWF  41
07AC:  MOVF   7A,W
07AD:  MOVWF  42
07AE:  MOVF   3C,W
07AF:  MOVWF  04
07B0:  BCF    03.7
07B1:  BTFSC  3D.0
07B2:  BSF    03.7
07B3:  MOVF   00,W
07B4:  MOVWF  43
07B5:  MOVF   41,W
07B6:  MOVWF  04
07B7:  BCF    03.7
07B8:  BTFSC  42.0
07B9:  BSF    03.7
07BA:  MOVF   43,W
07BB:  MOVWF  00
....................          i++; 
07BC:  INCF   3E,F
....................       } 
07BD:  GOTO   734
....................    } 
....................  
....................    temp = data; 
07BE:  CLRF   3D
07BF:  MOVLW  B5
07C0:  MOVWF  3C
....................    return temp; 
07C1:  MOVF   3C,W
07C2:  MOVWF  78
07C3:  MOVF   3D,W
07C4:  MOVWF  79
07C5:  BCF    03.5
07C6:  RETURN
....................    // printf(lcd_escreve,"\fPASS(4): %u%u%u%u",pass[0],pass[1],pass[2],pass[3]); 
....................    // delay_ms(1000); 
....................  
.................... } 
.................... void inputKeyboardUser(){ 
....................  
....................    unsigned int * temp; 
....................    unsigned int id [2]; 
....................    unsigned int pass[4]; 
....................    unsigned int status; 
....................  
....................    temp = inputId(); 
*
0AD6:  MOVF   79,W
0AD7:  BCF    03.5
0AD8:  MOVWF  57
0AD9:  MOVF   78,W
0ADA:  MOVWF  56
....................    id[0] = temp[0]; 
0ADB:  MOVF   56,W
0ADC:  MOVWF  04
0ADD:  BCF    03.7
0ADE:  BTFSC  57.0
0ADF:  BSF    03.7
0AE0:  MOVF   00,W
0AE1:  MOVWF  58
....................    id[1] = temp[1]; 
0AE2:  MOVLW  01
0AE3:  ADDWF  56,W
0AE4:  MOVWF  04
0AE5:  BCF    03.7
0AE6:  BTFSC  57.0
0AE7:  BSF    03.7
0AE8:  MOVF   00,W
0AE9:  MOVWF  59
....................    printf(lcd_escreve,"\fid: %u%u",id[0],id[1]); 
0AEA:  MOVLW  F7
0AEB:  BSF    03.6
0AEC:  MOVWF  0D
0AED:  MOVLW  00
0AEE:  MOVWF  0F
0AEF:  BCF    03.0
0AF0:  MOVLW  05
0AF1:  BSF    03.5
0AF2:  BCF    03.6
0AF3:  MOVWF  43
0AF4:  BCF    0A.3
0AF5:  BCF    03.5
0AF6:  CALL   5F7
0AF7:  BSF    0A.3
0AF8:  MOVF   58,W
0AF9:  BSF    03.5
0AFA:  MOVWF  43
0AFB:  MOVLW  1B
0AFC:  MOVWF  44
0AFD:  BCF    0A.3
0AFE:  BCF    03.5
0AFF:  CALL   6F3
0B00:  BSF    0A.3
0B01:  MOVF   59,W
0B02:  BSF    03.5
0B03:  MOVWF  43
0B04:  MOVLW  1B
0B05:  MOVWF  44
0B06:  BCF    0A.3
0B07:  BCF    03.5
0B08:  CALL   6F3
0B09:  BSF    0A.3
....................    delay_ms(800); 
0B0A:  MOVLW  04
0B0B:  MOVWF  6F
0B0C:  MOVLW  C8
0B0D:  BSF    03.5
0B0E:  MOVWF  49
0B0F:  BCF    0A.3
0B10:  BCF    03.5
0B11:  CALL   12A
0B12:  BSF    0A.3
0B13:  DECFSZ 6F,F
0B14:  GOTO   30C
....................  
....................    char msg [] = "Digite a senha"; 
0B15:  MOVLW  44
0B16:  MOVWF  5F
0B17:  MOVLW  69
0B18:  MOVWF  60
0B19:  MOVLW  67
0B1A:  MOVWF  61
0B1B:  MOVLW  69
0B1C:  MOVWF  62
0B1D:  MOVLW  74
0B1E:  MOVWF  63
0B1F:  MOVLW  65
0B20:  MOVWF  64
0B21:  MOVLW  20
0B22:  MOVWF  65
0B23:  MOVLW  61
0B24:  MOVWF  66
0B25:  MOVLW  20
0B26:  MOVWF  67
0B27:  MOVLW  73
0B28:  MOVWF  68
0B29:  MOVLW  65
0B2A:  MOVWF  69
0B2B:  MOVLW  6E
0B2C:  MOVWF  6A
0B2D:  MOVLW  68
0B2E:  MOVWF  6B
0B2F:  MOVLW  61
0B30:  MOVWF  6C
0B31:  CLRF   6D
....................    int max = 4; 
0B32:  MOVLW  04
0B33:  MOVWF  6E
....................    temp = inputToKeyboard(msg, max); 
0B34:  BSF    03.5
0B35:  CLRF   32
0B36:  MOVLW  5F
0B37:  MOVWF  31
0B38:  BCF    03.5
0B39:  MOVF   6E,W
0B3A:  BSF    03.5
0B3B:  MOVWF  33
0B3C:  BCF    0A.3
0B3D:  BCF    03.5
0B3E:  CALL   732
0B3F:  BSF    0A.3
0B40:  MOVF   79,W
0B41:  MOVWF  57
0B42:  MOVF   78,W
0B43:  MOVWF  56
....................    pass[0] = temp[0]; 
0B44:  MOVF   56,W
0B45:  MOVWF  04
0B46:  BCF    03.7
0B47:  BTFSC  57.0
0B48:  BSF    03.7
0B49:  MOVF   00,W
0B4A:  MOVWF  5A
....................    pass[1] = temp[1]; 
0B4B:  MOVLW  01
0B4C:  ADDWF  56,W
0B4D:  MOVWF  04
0B4E:  BCF    03.7
0B4F:  BTFSC  57.0
0B50:  BSF    03.7
0B51:  MOVF   00,W
0B52:  MOVWF  5B
....................    pass[2] = temp[2]; 
0B53:  MOVLW  02
0B54:  ADDWF  56,W
0B55:  MOVWF  04
0B56:  BCF    03.7
0B57:  BTFSC  57.0
0B58:  BSF    03.7
0B59:  MOVF   00,W
0B5A:  MOVWF  5C
....................    pass[3] = temp[3]; 
0B5B:  MOVLW  03
0B5C:  ADDWF  56,W
0B5D:  MOVWF  04
0B5E:  BCF    03.7
0B5F:  BTFSC  57.0
0B60:  BSF    03.7
0B61:  MOVF   00,W
0B62:  MOVWF  5D
....................    printf(lcd_escreve,"\fPASS(4): %u%u%u%u",pass[0],pass[1],pass[2],pass[3]); 
0B63:  MOVLW  FC
0B64:  BSF    03.6
0B65:  MOVWF  0D
0B66:  MOVLW  00
0B67:  MOVWF  0F
0B68:  BCF    03.0
0B69:  MOVLW  0A
0B6A:  BSF    03.5
0B6B:  BCF    03.6
0B6C:  MOVWF  43
0B6D:  BCF    0A.3
0B6E:  BCF    03.5
0B6F:  CALL   5F7
0B70:  BSF    0A.3
0B71:  MOVF   5A,W
0B72:  BSF    03.5
0B73:  MOVWF  43
0B74:  MOVLW  1B
0B75:  MOVWF  44
0B76:  BCF    0A.3
0B77:  BCF    03.5
0B78:  CALL   6F3
0B79:  BSF    0A.3
0B7A:  MOVF   5B,W
0B7B:  BSF    03.5
0B7C:  MOVWF  43
0B7D:  MOVLW  1B
0B7E:  MOVWF  44
0B7F:  BCF    0A.3
0B80:  BCF    03.5
0B81:  CALL   6F3
0B82:  BSF    0A.3
0B83:  MOVF   5C,W
0B84:  BSF    03.5
0B85:  MOVWF  43
0B86:  MOVLW  1B
0B87:  MOVWF  44
0B88:  BCF    0A.3
0B89:  BCF    03.5
0B8A:  CALL   6F3
0B8B:  BSF    0A.3
0B8C:  MOVF   5D,W
0B8D:  BSF    03.5
0B8E:  MOVWF  43
0B8F:  MOVLW  1B
0B90:  MOVWF  44
0B91:  BCF    0A.3
0B92:  BCF    03.5
0B93:  CALL   6F3
0B94:  BSF    0A.3
....................    delay_ms(800); 
0B95:  MOVLW  04
0B96:  MOVWF  6F
0B97:  MOVLW  C8
0B98:  BSF    03.5
0B99:  MOVWF  49
0B9A:  BCF    0A.3
0B9B:  BCF    03.5
0B9C:  CALL   12A
0B9D:  BSF    0A.3
0B9E:  DECFSZ 6F,F
0B9F:  GOTO   397
....................  
....................    char msg2 [] = "Status (0,1,3): "; 
0BA0:  MOVLW  53
0BA1:  BSF    03.5
0BA2:  MOVWF  20
0BA3:  MOVLW  74
0BA4:  MOVWF  21
0BA5:  MOVLW  61
0BA6:  MOVWF  22
0BA7:  MOVLW  74
0BA8:  MOVWF  23
0BA9:  MOVLW  75
0BAA:  MOVWF  24
0BAB:  MOVLW  73
0BAC:  MOVWF  25
0BAD:  MOVLW  20
0BAE:  MOVWF  26
0BAF:  MOVLW  28
0BB0:  MOVWF  27
0BB1:  MOVLW  30
0BB2:  MOVWF  28
0BB3:  MOVLW  2C
0BB4:  MOVWF  29
0BB5:  MOVLW  31
0BB6:  MOVWF  2A
0BB7:  MOVLW  2C
0BB8:  MOVWF  2B
0BB9:  MOVLW  33
0BBA:  MOVWF  2C
0BBB:  MOVLW  29
0BBC:  MOVWF  2D
0BBD:  MOVLW  3A
0BBE:  MOVWF  2E
0BBF:  MOVLW  20
0BC0:  MOVWF  2F
0BC1:  CLRF   30
....................    max = 1; 
0BC2:  MOVLW  01
0BC3:  BCF    03.5
0BC4:  MOVWF  6E
....................    temp = inputToKeyboard(msg2, max); 
0BC5:  BSF    03.5
0BC6:  CLRF   32
0BC7:  MOVLW  A0
0BC8:  MOVWF  31
0BC9:  BCF    03.5
0BCA:  MOVF   6E,W
0BCB:  BSF    03.5
0BCC:  MOVWF  33
0BCD:  BCF    0A.3
0BCE:  BCF    03.5
0BCF:  CALL   732
0BD0:  BSF    0A.3
0BD1:  MOVF   79,W
0BD2:  MOVWF  57
0BD3:  MOVF   78,W
0BD4:  MOVWF  56
....................    status = temp[0]; 
0BD5:  MOVF   56,W
0BD6:  MOVWF  04
0BD7:  BCF    03.7
0BD8:  BTFSC  57.0
0BD9:  BSF    03.7
0BDA:  MOVF   00,W
0BDB:  MOVWF  5E
....................    printf(lcd_escreve,"\fSTATUS: %u",status); 
0BDC:  MOVLW  06
0BDD:  BSF    03.6
0BDE:  MOVWF  0D
0BDF:  MOVLW  01
0BE0:  MOVWF  0F
0BE1:  BCF    03.0
0BE2:  MOVLW  09
0BE3:  BSF    03.5
0BE4:  BCF    03.6
0BE5:  MOVWF  43
0BE6:  BCF    0A.3
0BE7:  BCF    03.5
0BE8:  CALL   5F7
0BE9:  BSF    0A.3
0BEA:  MOVF   5E,W
0BEB:  BSF    03.5
0BEC:  MOVWF  43
0BED:  MOVLW  1B
0BEE:  MOVWF  44
0BEF:  BCF    0A.3
0BF0:  BCF    03.5
0BF1:  CALL   6F3
0BF2:  BSF    0A.3
....................    delay_ms(800); 
0BF3:  MOVLW  04
0BF4:  MOVWF  6F
0BF5:  MOVLW  C8
0BF6:  BSF    03.5
0BF7:  MOVWF  49
0BF8:  BCF    0A.3
0BF9:  BCF    03.5
0BFA:  CALL   12A
0BFB:  BSF    0A.3
0BFC:  DECFSZ 6F,F
0BFD:  GOTO   3F5
....................  
....................    saveUser(id,pass,status); 
0BFE:  BSF    03.5
0BFF:  CLRF   32
0C00:  MOVLW  58
0C01:  MOVWF  31
0C02:  CLRF   34
0C03:  MOVLW  5A
0C04:  MOVWF  33
0C05:  BCF    03.5
0C06:  MOVF   5E,W
0C07:  BSF    03.5
0C08:  MOVWF  35
.................... } 
....................  
....................  
.................... /* 
.................... // ---- MSG from serial communication 
.................... #int_RDA 
.................... void RDA_isr(void){ 
....................    rx_buffer[rx_wr_index] = getc(); 
....................    rxd = rx_buffer[rx_wr_index]; 
....................    rx_wr_index++; 
....................  
....................    if(rx_wr_index > RX_BUFFER_SIZE){ 
....................       rx_wr_index = 0; 
....................    } 
....................  
....................    //Look for unique ID: "IFMT" 
....................    if(rxd == 'I' && lock_pos == 0){ 
....................       lock_pos++; 
....................    } 
....................    else if(rxd == 'F' && lock_pos == 1){ 
....................       lock_pos++; 
....................    } 
....................    else if(rxd == 'M' && lock_pos == 2){ 
....................       lock_pos++; 
....................    } 
....................    else if(rxd == 'T' && lock_pos == 3){ 
....................       lock_pos=0; //Reset the "combination lock" 
....................       got_id = TRUE; 
....................       read = rxd; 
....................       //get ready to count the number of data bytes 
....................       valid_data_count = 0xff;  
....................  
....................       //buffer is reset to index 0 
....................       rx_wr_index = 0; 
....................    }else { 
....................       lock_pos = 0; 
....................    } 
....................  
....................    if(got_id && ++valid_data_count >= 6){ 
....................       data_avail = TRUE; 
....................       got_id = FALSE; 
....................    } 
....................     
.................... } 
.................... */ 
....................  
....................  
....................  
....................  
.................... #int_TIMER1 
.................... void TIMER1_isr(void) 
.................... { 
.................... } 
....................  
*
010C:  BCF    0C.0
010D:  BCF    0A.3
010E:  BCF    0A.4
010F:  GOTO   031
.................... #int_RTCC 
.................... void RTCC_isr(void) 
.................... { 
....................  
....................        
0110:  BCF    0B.2
0111:  BCF    0A.3
0112:  BCF    0A.4
0113:  GOTO   031
.................... } 
....................  
.................... void main() 
*
0DCB:  MOVF   03,W
0DCC:  ANDLW  1F
0DCD:  MOVWF  03
0DCE:  CLRF   2C
0DCF:  CLRF   2D
0DD0:  CLRF   31
0DD1:  CLRF   32
0DD2:  MOVLW  FF
0DD3:  MOVWF  3D
0DD4:  BSF    03.5
0DD5:  BSF    1F.0
0DD6:  BSF    1F.1
0DD7:  BSF    1F.2
0DD8:  BCF    1F.3
0DD9:  MOVLW  07
0DDA:  MOVWF  1C
0DDB:  BCF    03.7
*
0DED:  CLRF   54
.................... { 
....................    //VARIAVEIS 
....................    byte result; 
....................    unsigned char option; 
....................     
....................    eeprom_address address = 0; 
....................  
....................    // unsigned char tmp_result; 
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_256|RTCC_8_bit);      //13.1ms overflow 
0DEE:  BSF    03.5
0DEF:  MOVF   01,W
0DF0:  ANDLW  C0
0DF1:  IORLW  07
0DF2:  MOVWF  01
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); //Overflow in 104ms | Resolution 1.6 us 
0DF3:  MOVLW  B5
0DF4:  BCF    03.5
0DF5:  MOVWF  10
....................  
....................    init_ext_eeprom(); 
0DF6:  BCF    0A.3
0DF7:  GOTO   11D
0DF8:  BSF    0A.3
....................  
....................    enable_interrupts(INT_TIMER0); 
0DF9:  BSF    0B.5
....................    enable_interrupts(INT_TIMER1); 
0DFA:  BSF    03.5
0DFB:  BSF    0C.0
....................  
....................    enable_interrupts(GLOBAL); 
0DFC:  MOVLW  C0
0DFD:  BCF    03.5
0DFE:  IORWF  0B,F
....................  
....................  
....................    lcd_ini(); 
0DFF:  BCF    0A.3
0E00:  GOTO   198
0E01:  BSF    0A.3
....................    delay_us(50); 
0E02:  MOVLW  52
0E03:  MOVWF  77
0E04:  DECFSZ 77,F
0E05:  GOTO   604
0E06:  GOTO   607
0E07:  NOP
....................    printf(lcd_escreve, "\f  iniciando... "); 
0E08:  MOVLW  14
0E09:  BSF    03.6
0E0A:  MOVWF  0D
0E0B:  MOVLW  01
0E0C:  MOVWF  0F
0E0D:  BCF    0A.3
0E0E:  BCF    03.6
0E0F:  CALL   224
0E10:  BSF    0A.3
....................    delay_ms(200); 
0E11:  MOVLW  C8
0E12:  BSF    03.5
0E13:  MOVWF  49
0E14:  BCF    0A.3
0E15:  BCF    03.5
0E16:  CALL   12A
0E17:  BSF    0A.3
....................  
....................    // printf(lcd_escreve, "\fIFMT - Serial"); 
....................    // delay_ms(50); 
....................  
....................    // int size = BLOCK_SIZE; 
....................    // printf(lcd_escreve, "\fBlock_Size:%u", size); 
....................    // delay_ms(500); 
....................  
....................    resetMemory(); 
0E18:  BCF    0A.3
0E19:  GOTO   460
0E1A:  BSF    0A.3
....................  
....................    // data_avail = FALSE; 
....................    // int id [2] = {12,34}; 
....................    // int pass [4] = {1,2,3,4}; 
....................    // saveUser(id, pass, 1); 
....................    // int id1 [2] = {14,0}; 
....................    // saveuser(id1, pass, 0); 
....................    // int id2 [2] = {5,5}; 
....................    // saveuser(id2, pass, 1); 
....................    // int id3 [2] = {70,00}; 
....................    // saveuser(id3, pass, 1); 
....................    // int id4 [2] = {254,254}; 
....................    // saveuser(id4, pass, 3);//admin 
....................    // adminMenu(); 
....................     
....................    //// listAdmins(); 
....................    adminMenu(); 
0E1B:  GOTO   23E
....................  
....................  
....................  
....................  
....................    // char keyboard_buffer[]= '6'; 
....................    // char n = '9'; 
....................    // unsigned char temp_pass[2]; 
....................    // unsigned int * buffer; 
....................    // unsigned int pass[4]; 
....................    // strfromchar(temp_pass,n); 
....................    // buffer = strToInt(temp_pass); 
....................    // pass[0] = buffer[0]; 
....................  
....................    // printf(lcd_escreve,"\foutside:%u", pass[0]); 
....................    // delay_ms(800); 
....................  
....................  
....................    // int index = 2; 
....................    // if(index>0){//for testing purposes 
....................    //    for(int i=0; i < index; i++){ 
....................    //       printf(lcd_escreve,"\foutside:%u", buffer[i]); 
....................    //       delay_ms(800); 
....................    //    } 
....................    // } 
....................   
....................   
....................   // address_data_delete = getAddressByID(6); 
....................   // printf(lcd_escreve, "\f Address ID = %d", address_data_delete); 
....................  //  deleteBlock(address_data_delete); 
....................    delay_ms(50); 
0E1C:  MOVLW  32
0E1D:  BSF    03.5
0E1E:  MOVWF  49
0E1F:  BCF    0A.3
0E20:  BCF    03.5
0E21:  CALL   12A
0E22:  BSF    0A.3
....................     
....................    while(TRUE) 
....................    { 
0E23:  GOTO   623
....................    } 
....................  
.................... } 
....................  
0E24:  SLEEP

Configuration Fuses:
   Word  1: 3F32   HS NOWDT PUT NOBROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT

CCS PCM C Compiler, Version 5.025, 7201               22-Nov-21 11:46

               Filename:   E:\University\Microcontrollers\PCW Projects\eletronic-lock-system\PIC controller\main.lst

               ROM used:   3465 words (42%)
                           Largest free fragment is 2048
               RAM used:   55 (15%) at main() level
                           181 (49%) worst case
               Stack used: 6 locations (5 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  0D
0001:  MOVWF  0A
0002:  GOTO   52B
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  BTFSS  0B.5
0028:  GOTO   02B
0029:  BTFSC  0B.2
002A:  GOTO   052
002B:  MOVLW  8C
002C:  MOVWF  04
002D:  BTFSS  00.0
002E:  GOTO   031
002F:  BTFSC  0C.0
0030:  GOTO   055
0031:  MOVF   22,W
0032:  MOVWF  04
0033:  MOVF   23,W
0034:  MOVWF  77
0035:  MOVF   24,W
0036:  MOVWF  78
0037:  MOVF   25,W
0038:  MOVWF  79
0039:  MOVF   26,W
003A:  MOVWF  7A
003B:  MOVF   27,W
003C:  BSF    03.6
003D:  MOVWF  0D
003E:  BCF    03.6
003F:  MOVF   28,W
0040:  BSF    03.6
0041:  MOVWF  0F
0042:  BCF    03.6
0043:  MOVF   29,W
0044:  BSF    03.6
0045:  MOVWF  0C
0046:  BCF    03.6
0047:  MOVF   2A,W
0048:  BSF    03.6
0049:  MOVWF  0E
004A:  BCF    03.6
004B:  MOVF   20,W
004C:  MOVWF  0A
004D:  SWAPF  21,W
004E:  MOVWF  03
004F:  SWAPF  7F,F
0050:  SWAPF  7F,W
0051:  RETFIE
0052:  BCF    0A.3
0053:  BCF    0A.4
0054:  GOTO   219
0055:  BCF    0A.3
0056:  BCF    0A.4
0057:  GOTO   215
....................  
.................... #include <16F877A.h> 
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
0058:  BCF    0A.0
0059:  BCF    0A.1
005A:  BCF    0A.2
005B:  ADDWF  02,F
005C:  RETLW  28
005D:  RETLW  0F
005E:  RETLW  01
005F:  RETLW  06
0060:  BCF    0A.0
0061:  BCF    0A.1
0062:  BCF    0A.2
0063:  ADDWF  02,F
0064:  RETLW  4E
0065:  RETLW  41
0066:  RETLW  4F
0067:  RETLW  20
0068:  RETLW  50
0069:  RETLW  41
006A:  RETLW  47
006B:  RETLW  4F
006C:  RETLW  00
006D:  BCF    0A.0
006E:  BCF    0A.1
006F:  BCF    0A.2
0070:  ADDWF  02,F
0071:  RETLW  50
0072:  RETLW  41
0073:  RETLW  47
0074:  RETLW  4F
0075:  RETLW  00
0076:  DATA 8C,2A
0077:  DATA F3,3A
0078:  DATA 61,39
0079:  DATA E9,37
007A:  DATA A0,21
007B:  DATA 61,32
007C:  DATA E1,39
007D:  DATA 74,39
007E:  DATA 61,32
007F:  DATA 6F,00
0080:  DATA 8C,24
0081:  DATA 44,10
0082:  DATA 69,37
0083:  DATA E3,37
0084:  DATA 6D,38
0085:  DATA 61,3A
0086:  DATA 69,3B
0087:  DATA 65,36
0088:  DATA 00,01
0089:  DATA 0D,05
008A:  DATA D4,32
008B:  DATA 6E,3A
008C:  DATA 65,10
008D:  DATA EE,37
008E:  DATA F6,30
008F:  DATA ED,32
0090:  DATA 6E,3A
0091:  DATA 65,00
0092:  DATA 8C,2A
0093:  DATA F3,3A
0094:  DATA 61,39
0095:  DATA E9,37
0096:  DATA A0,20
0097:  DATA F4,3A
0098:  DATA 61,36
0099:  DATA 69,3D
009A:  DATA 61,32
009B:  DATA 6F,00
009C:  DATA 8C,24
009D:  DATA 44,10
009E:  DATA 69,37
009F:  DATA E3,37
00A0:  DATA 6D,38
00A1:  DATA 61,3A
00A2:  DATA 69,3B
00A3:  DATA 65,36
00A4:  DATA 00,01
00A5:  DATA 0D,05
00A6:  DATA D4,32
00A7:  DATA 6E,3A
00A8:  DATA 65,10
00A9:  DATA EE,37
00AA:  DATA F6,30
00AB:  DATA ED,32
00AC:  DATA 6E,3A
00AD:  DATA 65,00
00AE:  DATA 0C,10
00AF:  DATA C2,3A
00B0:  DATA 74,3A
00B1:  DATA 6F,37
00B2:  DATA 3A,10
00B3:  DATA 25,32
00B4:  DATA 00,00
00B5:  DATA 0D,05
00B6:  DATA D0,3B
00B7:  DATA BA,12
00B8:  DATA E4,12
00B9:  DATA E4,12
00BA:  DATA E4,12
00BB:  DATA 64,10
00BC:  DATA 53,3A
00BD:  DATA BA,12
00BE:  DATA 64,10
00BF:  DATA 25,32
00C0:  DATA 00,00
00C1:  DATA 8C,24
00C2:  DATA 44,10
00C3:  DATA 45,3C
00C4:  DATA E9,39
00C5:  DATA F4,32
00C6:  DATA BA,12
00C7:  DATA F5,12
00C8:  DATA 75,00
00C9:  DATA 8C,24
00CA:  DATA 44,1D
00CB:  DATA A5,3A
00CC:  DATA A5,3A
00CD:  DATA A0,06
00CE:  DATA 0A,22
00CF:  DATA E9,39
00D0:  DATA F0,37
00D1:  DATA EE,34
00D2:  DATA F6,32
00D3:  DATA 6C,00
00D4:  DATA 8C,24
00D5:  DATA 44,1D
00D6:  DATA A5,3A
00D7:  DATA A5,3A
00D8:  DATA 00,01
00D9:  DATA 8C,2A
00DA:  DATA F3,3A
00DB:  DATA 61,39
00DC:  DATA E9,37
00DD:  DATA 20,27
00DE:  DATA A0,22
00DF:  DATA F8,34
00E0:  DATA 73,3A
00E1:  DATA 65,00
00E2:  DATA 0C,10
00E3:  DATA D5,39
00E4:  DATA 65,39
00E5:  DATA A0,32
00E6:  DATA F2,30
00E7:  DATA F3,32
00E8:  DATA 64,10
00E9:  DATA 00,00
00EA:  DATA 0D,05
00EB:  DATA 53,3A
00EC:  DATA 61,3A
00ED:  DATA F5,39
00EE:  DATA BA,12
00EF:  DATA 73,00
00F0:  DATA 8C,18
00F1:  DATA 3A,10
00F2:  DATA C3,20
00F3:  DATA 44,10
00F4:  DATA 43,36
00F5:  DATA E9,32
00F6:  DATA 6E,3A
00F7:  DATA 65,10
00F8:  DATA 00,01
00F9:  DATA 0D,05
00FA:  DATA 32,1D
00FB:  DATA 20,21
00FC:  DATA F5,39
00FD:  DATA E3,30
00FE:  DATA 72,10
00FF:  DATA 43,36
0100:  DATA E9,32
0101:  DATA 6E,3A
0102:  DATA 65,00
0103:  DATA 8C,19
0104:  DATA 3A,10
0105:  DATA C4,22
0106:  DATA 4C,10
0107:  DATA 43,36
0108:  DATA E9,32
0109:  DATA 6E,3A
010A:  DATA 65,10
010B:  DATA 00,01
010C:  DATA 0D,05
010D:  DATA 34,1D
010E:  DATA A0,22
010F:  DATA E4,34
0110:  DATA F4,30
0111:  DATA 72,10
0112:  DATA 43,36
0113:  DATA E9,32
0114:  DATA 6E,3A
0115:  DATA 65,00
0116:  DATA 8C,1A
0117:  DATA 3A,10
0118:  DATA D3,20
0119:  DATA 49,29
011A:  DATA 20,32
011B:  DATA 6F,10
011C:  DATA CD,32
011D:  DATA EE,3A
011E:  DATA 20,00
011F:  DATA 0C,10
0120:  DATA 4F,38
0121:  DATA F4,34
0122:  DATA 6F,37
0123:  DATA 3A,10
0124:  DATA A5,31
0125:  DATA 00,01
0126:  DATA 8C,29
0127:  DATA F5,31
0128:  DATA E3,32
0129:  DATA F3,39
012A:  DATA A0,16
012B:  DATA 3E,10
012C:  DATA 25,32
012D:  DATA 00,01
012E:  DATA 8C,3A
012F:  DATA F3,3A
0130:  DATA 61,39
0131:  DATA E9,37
0132:  DATA 20,32
0133:  DATA 65,36
0134:  DATA 65,3A
0135:  DATA 61,32
0136:  DATA 6F,00
0137:  DATA 8C,3A
0138:  DATA F3,3A
0139:  DATA 61,39
013A:  DATA E9,37
013B:  DATA 20,27
013C:  DATA A0,22
013D:  DATA F8,34
013E:  DATA 73,3A
013F:  DATA 65,00
0140:  DATA 0C,22
0141:  DATA E9,33
0142:  DATA 69,3A
0143:  DATA 65,10
0144:  DATA F5,36
0145:  DATA 20,3B
0146:  DATA 61,36
0147:  DATA 6F,39
0148:  DATA 00,01
0149:  DATA 0D,05
014A:  DATA D6,30
014B:  DATA EC,34
014C:  DATA E4,37
014D:  DATA 21,00
014E:  DATA 8C,18
014F:  DATA 3A,26
0150:  DATA EF,33
0151:  DATA 69,37
0152:  DATA 20,3E
0153:  DATA A0,1A
0154:  DATA BA,29
0155:  DATA E1,34
0156:  DATA 72,00
0157:  DATA 0D,05
0158:  DATA A0,27
0159:  DATA 70,3A
015A:  DATA E9,37
015B:  DATA 6E,1D
015C:  DATA A0,12
015D:  DATA 63,00
015E:  DATA 0C,22
015F:  DATA E9,33
0160:  DATA 69,3A
0161:  DATA 65,10
0162:  DATA F5,36
0163:  DATA 20,3B
0164:  DATA 61,36
0165:  DATA 6F,39
0166:  DATA 00,01
0167:  DATA 0D,05
0168:  DATA D6,30
0169:  DATA EC,34
016A:  DATA E4,37
016B:  DATA 21,00
016C:  DATA 0C,21
016D:  DATA E5,36
016E:  DATA 20,2B
016F:  DATA 69,37
0170:  DATA E4,37
0171:  DATA A8,30
0172:  DATA A9,10
0173:  DATA 00,01
0174:  DATA 0C,26
0175:  DATA E9,33
0176:  DATA 61,10
0177:  DATA CC,32
0178:  DATA 64,10
0179:  DATA 65,10
017A:  DATA D2,32
017B:  DATA EC,32
017C:  DATA 00,01
017D:  DATA 8C,21
017E:  DATA 6F,37
017F:  DATA F4,30
0180:  DATA A0,22
0181:  DATA F8,34
0182:  DATA 73,3A
0183:  DATA 65,00
0184:  DATA 0C,16
0185:  DATA CD,30
0186:  DATA 73,10
0187:  DATA C6,30
0188:  DATA 6C,3A
0189:  DATA 61,10
018A:  DATA D0,30
018B:  DATA E7,30
018C:  DATA F2,10
018D:  DATA 00,01
018E:  DATA 0C,28
018F:  DATA F2,37
0190:  DATA E3,3A
0191:  DATA F2,32
0192:  DATA A0,30
0193:  DATA A0,39
0194:  DATA E5,31
0195:  DATA F2,32
0196:  DATA F4,30
0197:  DATA F2,34
0198:  DATA 61,00
0199:  DATA 0D,05
019A:  DATA D0,17
019B:  DATA 20,39
019C:  DATA E5,39
019D:  DATA 6F,36
019E:  DATA F6,32
019F:  DATA 72,00
01A0:  DATA 0C,27
01A1:  DATA 41,22
01A2:  DATA 41,10
01A3:  DATA 65,34
01A4:  DATA 20,26
01A5:  DATA E9,33
01A6:  DATA 61,32
01A7:  DATA EF,10
01A8:  DATA 00,01
01A9:  DATA 8C,24
01AA:  DATA 44,10
01AB:  DATA 4E,10
01AC:  DATA 45,3C
01AD:  DATA E9,39
01AE:  DATA F4,32
01AF:  DATA 00,01
01B0:  DATA 0D,05
01B1:  DATA D4,32
01B2:  DATA 6E,3A
01B3:  DATA 65,10
01B4:  DATA E4,32
01B5:  DATA 20,37
01B6:  DATA 6F,3B
01B7:  DATA 6F,00
01B8:  DATA 0C,10
01B9:  DATA 20,10
01BA:  DATA D4,22
01BB:  DATA 43,26
01BC:  DATA 41,22
01BD:  DATA 4F,10
01BE:  DATA 20,00
01BF:  DATA 8C,20
01C0:  DATA E4,36
01C1:  DATA 69,37
01C2:  DATA A0,22
01C3:  DATA EE,31
01C4:  DATA 6F,37
01C5:  DATA 74,39
01C6:  DATA 61,32
01C7:  DATA 6F,00
01C8:  DATA 0C,10
01C9:  DATA 61,32
01CA:  DATA ED,34
01CB:  DATA EE,39
01CC:  DATA 5B,18
01CD:  DATA 5D,1D
01CE:  DATA A0,12
01CF:  DATA 64,00
01D0:  DATA 8C,34
01D1:  DATA 64,1D
01D2:  DATA A5,3A
01D3:  DATA A5,3A
01D4:  DATA 00,00
01D5:  DATA 0C,22
01D6:  DATA E9,33
01D7:  DATA 69,3A
01D8:  DATA 65,10
01D9:  DATA 6F,10
01DA:  DATA 49,22
01DB:  DATA 3A,10
01DC:  DATA 00,01
01DD:  DATA 8A,06
01DE:  DATA D4,3C
01DF:  DATA F0,32
01E0:  DATA 64,1D
01E1:  DATA A5,31
01E2:  DATA 00,00
01E3:  DATA 8A,06
01E4:  DATA D4,3C
01E5:  DATA F0,32
01E6:  DATA 64,1D
01E7:  DATA A5,31
01E8:  DATA 00,00
01E9:  DATA 8C,34
01EA:  DATA 64,1D
01EB:  DATA A0,12
01EC:  DATA F5,12
01ED:  DATA 75,00
01EE:  DATA 0C,28
01EF:  DATA C1,29
01F0:  DATA 53,14
01F1:  DATA B4,14
01F2:  DATA 3A,10
01F3:  DATA A5,3A
01F4:  DATA A5,3A
01F5:  DATA A5,3A
01F6:  DATA A5,3A
01F7:  DATA 00,01
01F8:  DATA 8C,29
01F9:  DATA D4,20
01FA:  DATA D4,2A
01FB:  DATA 53,1D
01FC:  DATA A0,12
01FD:  DATA 75,00
01FE:  DATA 0C,28
01FF:  DATA C1,29
0200:  DATA 53,14
0201:  DATA B4,14
0202:  DATA 3A,10
0203:  DATA A5,3A
0204:  DATA A5,3A
0205:  DATA A5,3A
0206:  DATA A5,3A
0207:  DATA 00,01
0208:  DATA 8C,29
0209:  DATA D4,20
020A:  DATA D4,2A
020B:  DATA 53,1D
020C:  DATA A0,12
020D:  DATA 75,00
020E:  DATA 8C,24
020F:  DATA 44,10
0210:  DATA 4E,10
0211:  DATA 45,3C
0212:  DATA E9,39
0213:  DATA F4,32
0214:  DATA 00,00
*
021D:  DATA 0C,10
021E:  DATA A0,34
021F:  DATA EE,34
0220:  DATA E3,34
0221:  DATA 61,37
0222:  DATA E4,37
0223:  DATA 2E,17
0224:  DATA 2E,10
0225:  DATA 00,00
*
032D:  MOVF   0B,W
032E:  BSF    03.5
032F:  MOVWF  2E
0330:  BCF    03.5
0331:  BCF    0B.7
0332:  BSF    03.5
0333:  BSF    03.6
0334:  BSF    0C.7
0335:  BSF    0C.0
0336:  NOP
0337:  NOP
0338:  BCF    03.6
0339:  BTFSS  2E.7
033A:  GOTO   33E
033B:  BCF    03.5
033C:  BSF    0B.7
033D:  BSF    03.5
033E:  BCF    03.5
033F:  BSF    03.6
0340:  MOVF   0C,W
0341:  ANDLW  7F
0342:  BTFSC  03.2
0343:  GOTO   39F
0344:  BSF    03.5
0345:  BCF    03.6
0346:  MOVWF  2E
0347:  BCF    03.5
0348:  BSF    03.6
0349:  MOVF   0D,W
034A:  BSF    03.5
034B:  BCF    03.6
034C:  MOVWF  2F
034D:  BCF    03.5
034E:  BSF    03.6
034F:  MOVF   0F,W
0350:  BSF    03.5
0351:  BCF    03.6
0352:  MOVWF  30
0353:  MOVF   2E,W
0354:  MOVWF  31
0355:  BCF    03.5
0356:  CALL   2EA
0357:  BSF    03.5
0358:  MOVF   2F,W
0359:  BCF    03.5
035A:  BSF    03.6
035B:  MOVWF  0D
035C:  BSF    03.5
035D:  BCF    03.6
035E:  MOVF   30,W
035F:  BCF    03.5
0360:  BSF    03.6
0361:  MOVWF  0F
0362:  BCF    03.6
0363:  MOVF   0B,W
0364:  BSF    03.5
0365:  MOVWF  31
0366:  BCF    03.5
0367:  BCF    0B.7
0368:  BSF    03.5
0369:  BSF    03.6
036A:  BSF    0C.7
036B:  BSF    0C.0
036C:  NOP
036D:  NOP
036E:  BCF    03.6
036F:  BTFSS  31.7
0370:  GOTO   374
0371:  BCF    03.5
0372:  BSF    0B.7
0373:  BSF    03.5
0374:  BCF    03.5
0375:  BSF    03.6
0376:  RLF    0C,W
0377:  RLF    0E,W
0378:  ANDLW  7F
0379:  BTFSC  03.2
037A:  GOTO   39F
037B:  BSF    03.5
037C:  BCF    03.6
037D:  MOVWF  2E
037E:  BCF    03.5
037F:  BSF    03.6
0380:  MOVF   0D,W
0381:  BSF    03.5
0382:  BCF    03.6
0383:  MOVWF  2F
0384:  BCF    03.5
0385:  BSF    03.6
0386:  MOVF   0F,W
0387:  BSF    03.5
0388:  BCF    03.6
0389:  MOVWF  30
038A:  MOVF   2E,W
038B:  MOVWF  31
038C:  BCF    03.5
038D:  CALL   2EA
038E:  BSF    03.5
038F:  MOVF   2F,W
0390:  BCF    03.5
0391:  BSF    03.6
0392:  MOVWF  0D
0393:  BSF    03.5
0394:  BCF    03.6
0395:  MOVF   30,W
0396:  BCF    03.5
0397:  BSF    03.6
0398:  MOVWF  0F
0399:  INCF   0D,F
039A:  BTFSC  03.2
039B:  INCF   0F,F
039C:  BCF    03.6
039D:  GOTO   32D
039E:  BSF    03.6
039F:  BCF    03.6
03A0:  RETURN
*
0506:  MOVF   0B,W
0507:  BSF    03.5
0508:  MOVWF  2D
0509:  BCF    03.5
050A:  BCF    0B.7
050B:  BSF    03.5
050C:  BSF    03.6
050D:  BSF    0C.7
050E:  BSF    0C.0
050F:  NOP
0510:  NOP
0511:  BCF    03.6
0512:  BTFSS  2D.7
0513:  GOTO   517
0514:  BCF    03.5
0515:  BSF    0B.7
0516:  BSF    03.5
0517:  BTFSC  03.0
0518:  GOTO   550
0519:  BCF    03.5
051A:  BSF    03.6
051B:  MOVF   0C,W
051C:  ANDLW  7F
051D:  BSF    03.5
051E:  BCF    03.6
051F:  MOVWF  2D
0520:  BCF    03.5
0521:  BSF    03.6
0522:  MOVF   0D,W
0523:  BSF    03.5
0524:  BCF    03.6
0525:  MOVWF  2E
0526:  BCF    03.5
0527:  BSF    03.6
0528:  MOVF   0F,W
0529:  BSF    03.5
052A:  BCF    03.6
052B:  MOVWF  2F
052C:  MOVF   2D,W
052D:  MOVWF  31
052E:  BCF    03.5
052F:  CALL   2EA
0530:  BSF    03.5
0531:  MOVF   2E,W
0532:  BCF    03.5
0533:  BSF    03.6
0534:  MOVWF  0D
0535:  BSF    03.5
0536:  BCF    03.6
0537:  MOVF   2F,W
0538:  BCF    03.5
0539:  BSF    03.6
053A:  MOVWF  0F
053B:  BCF    03.6
053C:  MOVF   0B,W
053D:  BSF    03.5
053E:  MOVWF  30
053F:  BCF    03.5
0540:  BCF    0B.7
0541:  BSF    03.5
0542:  BSF    03.6
0543:  BSF    0C.7
0544:  BSF    0C.0
0545:  NOP
0546:  NOP
0547:  BCF    03.6
0548:  BTFSS  30.7
0549:  GOTO   54D
054A:  BCF    03.5
054B:  BSF    0B.7
054C:  BSF    03.5
054D:  DECFSZ 2C,F
054E:  GOTO   550
054F:  GOTO   57E
0550:  BCF    03.5
0551:  BSF    03.6
0552:  RLF    0C,W
0553:  RLF    0E,W
0554:  ANDLW  7F
0555:  BSF    03.5
0556:  BCF    03.6
0557:  MOVWF  2D
0558:  BCF    03.5
0559:  BSF    03.6
055A:  MOVF   0D,W
055B:  BSF    03.5
055C:  BCF    03.6
055D:  MOVWF  2E
055E:  BCF    03.5
055F:  BSF    03.6
0560:  MOVF   0F,W
0561:  BSF    03.5
0562:  BCF    03.6
0563:  MOVWF  2F
0564:  MOVF   2D,W
0565:  MOVWF  31
0566:  BCF    03.5
0567:  CALL   2EA
0568:  BSF    03.5
0569:  MOVF   2E,W
056A:  BCF    03.5
056B:  BSF    03.6
056C:  MOVWF  0D
056D:  BSF    03.5
056E:  BCF    03.6
056F:  MOVF   2F,W
0570:  BCF    03.5
0571:  BSF    03.6
0572:  MOVWF  0F
0573:  INCF   0D,F
0574:  BTFSC  03.2
0575:  INCF   0F,F
0576:  BCF    03.0
0577:  BSF    03.5
0578:  BCF    03.6
0579:  DECFSZ 2C,F
057A:  GOTO   57C
057B:  GOTO   57E
057C:  BCF    03.5
057D:  GOTO   506
057E:  BCF    03.5
057F:  RETURN
*
0720:  MOVF   69,W
0721:  XORWF  6B,W
0722:  ANDLW  80
0723:  MOVWF  6D
0724:  BTFSS  69.7
0725:  GOTO   72B
0726:  COMF   68,F
0727:  COMF   69,F
0728:  INCF   68,F
0729:  BTFSC  03.2
072A:  INCF   69,F
072B:  BTFSS  6B.7
072C:  GOTO   732
072D:  COMF   6A,F
072E:  COMF   6B,F
072F:  INCF   6A,F
0730:  BTFSC  03.2
0731:  INCF   6B,F
0732:  MOVLW  10
0733:  MOVWF  6C
0734:  CLRF   77
0735:  CLRF   7A
0736:  RRF    69,F
0737:  RRF    68,F
0738:  BTFSS  03.0
0739:  GOTO   740
073A:  MOVF   6A,W
073B:  ADDWF  77,F
073C:  BTFSC  03.0
073D:  INCF   7A,F
073E:  MOVF   6B,W
073F:  ADDWF  7A,F
0740:  RRF    7A,F
0741:  RRF    77,F
0742:  RRF    79,F
0743:  RRF    78,F
0744:  DECFSZ 6C,F
0745:  GOTO   736
0746:  BTFSS  6D.7
0747:  GOTO   74D
0748:  COMF   78,F
0749:  COMF   79,F
074A:  INCF   78,F
074B:  BTFSC  03.2
074C:  INCF   79,F
*
09DB:  BSF    03.5
09DC:  MOVF   25,W
09DD:  CLRF   78
09DE:  SUBWF  24,W
09DF:  BTFSC  03.0
09E0:  GOTO   1E4
09E1:  MOVF   24,W
09E2:  MOVWF  77
09E3:  GOTO   1F0
09E4:  CLRF   77
09E5:  MOVLW  08
09E6:  MOVWF  26
09E7:  RLF    24,F
09E8:  RLF    77,F
09E9:  MOVF   25,W
09EA:  SUBWF  77,W
09EB:  BTFSC  03.0
09EC:  MOVWF  77
09ED:  RLF    78,F
09EE:  DECFSZ 26,F
09EF:  GOTO   1E7
09F0:  BCF    03.5
09F1:  RETURN
09F2:  MOVF   78,W
09F3:  BSF    03.5
09F4:  MOVF   22,W
09F5:  MOVWF  24
09F6:  MOVLW  64
09F7:  MOVWF  25
09F8:  BCF    03.5
09F9:  CALL   1DB
09FA:  MOVF   77,W
09FB:  BSF    03.5
09FC:  MOVWF  22
09FD:  MOVF   78,W
09FE:  MOVLW  30
09FF:  BTFSS  03.2
0A00:  GOTO   208
0A01:  BTFSS  23.1
0A02:  GOTO   213
0A03:  BTFSC  23.3
0A04:  GOTO   213
0A05:  BTFSC  23.4
0A06:  MOVLW  20
0A07:  GOTO   20B
0A08:  BCF    23.3
0A09:  BCF    23.4
0A0A:  BSF    23.0
0A0B:  ADDWF  78,F
0A0C:  MOVF   78,W
0A0D:  MOVWF  31
0A0E:  BCF    0A.3
0A0F:  BCF    03.5
0A10:  CALL   2EA
0A11:  BSF    0A.3
0A12:  BSF    03.5
0A13:  MOVF   22,W
0A14:  MOVWF  24
0A15:  MOVLW  0A
0A16:  MOVWF  25
0A17:  BCF    03.5
0A18:  CALL   1DB
0A19:  MOVF   77,W
0A1A:  BSF    03.5
0A1B:  MOVWF  22
0A1C:  MOVF   78,W
0A1D:  MOVLW  30
0A1E:  BTFSS  03.2
0A1F:  GOTO   226
0A20:  BTFSC  23.3
0A21:  GOTO   22E
0A22:  BTFSS  23.0
0A23:  GOTO   22E
0A24:  BTFSC  23.4
0A25:  MOVLW  20
0A26:  ADDWF  78,F
0A27:  MOVF   78,W
0A28:  MOVWF  31
0A29:  BCF    0A.3
0A2A:  BCF    03.5
0A2B:  CALL   2EA
0A2C:  BSF    0A.3
0A2D:  BSF    03.5
0A2E:  MOVLW  30
0A2F:  ADDWF  22,F
0A30:  MOVF   22,W
0A31:  MOVWF  31
0A32:  BCF    0A.3
0A33:  BCF    03.5
0A34:  CALL   2EA
0A35:  BSF    0A.3
0A36:  RETURN
0A37:  MOVF   00,F
0A38:  BTFSC  03.2
0A39:  GOTO   255
0A3A:  BSF    03.5
0A3B:  CLRF   2D
0A3C:  MOVF   04,W
0A3D:  MOVWF  2C
0A3E:  BCF    2D.0
0A3F:  BTFSC  03.7
0A40:  BSF    2D.0
0A41:  MOVF   00,W
0A42:  MOVWF  31
0A43:  BCF    0A.3
0A44:  BCF    03.5
0A45:  CALL   2EA
0A46:  BSF    0A.3
0A47:  BSF    03.5
0A48:  MOVF   2C,W
0A49:  MOVWF  04
0A4A:  BCF    03.7
0A4B:  BTFSC  2D.0
0A4C:  BSF    03.7
0A4D:  INCF   04,F
0A4E:  BTFSS  03.2
0A4F:  GOTO   253
0A50:  BCF    03.5
0A51:  INCF   05,F
0A52:  BSF    03.5
0A53:  BCF    03.5
0A54:  GOTO   237
0A55:  RETURN
....................  
.................... #list 
....................  
.................... #device ADC=8 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES HS  
....................  
.................... #use delay(crystal=20000000) 
*
0233:  MOVLW  B2
0234:  MOVWF  04
0235:  BCF    03.7
0236:  MOVF   00,W
0237:  BTFSC  03.2
0238:  GOTO   246
0239:  MOVLW  06
023A:  MOVWF  78
023B:  CLRF   77
023C:  DECFSZ 77,F
023D:  GOTO   23C
023E:  DECFSZ 78,F
023F:  GOTO   23B
0240:  MOVLW  7B
0241:  MOVWF  77
0242:  DECFSZ 77,F
0243:  GOTO   242
0244:  DECFSZ 00,F
0245:  GOTO   239
0246:  RETURN
.................... //#use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=PORT1) 
....................  
....................  
.................... // -------Variables' Declaration 
.................... #define RX_BUFFER_SIZE 10 
.................... #define BLOCK_SIZE sizeof(User)  
.................... signed int8 address_data_delete; 
.................... int8 rx_wr_index = 0; 
.................... int8 lock_pos = 0, rxd, read, valid_data_count; 
.................... int data_avail = FALSE, got_id = FALSE; 
.................... unsigned int8 rx_buffer[RX_BUFFER_SIZE]; 
.................... #include "functions.c" 
.................... #include "functions.h" 
....................  
.................... //Define the default pins before calling the LCD driver 
.................... #ifndef lcd_enable  
....................    #define lcd_enable     pin_e1 
....................    #define lcd_rs         pin_e2 
....................    //#define lcd_rw       pin_e2   
....................    #define lcd_d4         pin_d4 
....................    #define lcd_d5         pin_d5 
....................    #define lcd_d6         pin_d6 
....................    #define lcd_d7         pin_d7 
.................... #endif 
....................  
.................... #include "mod_lcd.c" 
.................... /************************************************************************/ 
.................... /*  MOD_LCD.C - Biblioteca de manipulaï¿½ï¿½o de mï¿½dulo LCD                 */ 
.................... /*                                                                      */ 
.................... /*  Autor: Fï¿½bio Pereira                                                */ 
.................... /*                                                                      */ 
.................... /************************************************************************/ 
....................  
.................... // As definiï¿½ï¿½es a seguir sï¿½o utilizadas para acesso aos pinos do display 
.................... // caso o pino RW nï¿½o seja utilizado, comente a definiï¿½ï¿½o lcd_rw 
.................... #ifndef lcd_enable 
.................... 	#define lcd_enable 		pin_e1		// pino enable do LCD 
.................... 	#define lcd_rs			pin_e0		// pino rs do LCD 
.................... 	//#define lcd_rw		pin_e2		// pino rw do LCD 
.................... 	#define lcd_d4			pin_d4		// pino de dados d4 do LCD 
.................... 	#define lcd_d5			pin_d5		// pino de dados d5 do LCD 
.................... 	#define lcd_d6			pin_d6		// pino de dados d6 do LCD 
.................... 	#define lcd_d7			pin_d7		// pino de dados d7 do LCD 
.................... #endif 
....................  
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 linhas 
.................... #define lcd_seg_lin 0x40    // Endereï¿½o da segunda linha na RAM do LCD 
....................  
.................... // a constante abaixo define a seqï¿½ï¿½ncia de inicializaï¿½ï¿½o do mï¿½dulo LCD 
.................... byte CONST INI_LCD[4] = {0x20 | (lcd_type << 2), 0xf, 1, 6}; 
....................  
.................... byte lcd_le_byte() 
.................... // lï¿½ um byte do LCD (somente com pino RW) 
.................... { 
.................... 	byte dado; 
.................... 	// configura os pinos de dados como entradas 
.................... 	input(lcd_d4); 
.................... 	input(lcd_d5); 
.................... 	input(lcd_d6); 
.................... 	input(lcd_d7); 
.................... 	// se o pino rw for utilizado, coloca em 1 
.................... 	#ifdef lcd_rw 
.................... 		output_high(lcd_rw); 
.................... 	#endif 
....................    output_high(lcd_enable); // habilita display 
.................... 	dado = 0;	// zera a variï¿½vel de leitura 
.................... 	// lï¿½ os quatro bits mais significativos 
.................... 	if (input(lcd_d7)) bit_set(dado,7); 
.................... 	if (input(lcd_d6)) bit_set(dado,6); 
.................... 	if (input(lcd_d5)) bit_set(dado,5); 
.................... 	if (input(lcd_d4)) bit_set(dado,4); 
.................... 	// dï¿½ um pulso na linha enable 
.................... 	output_low(lcd_enable); 
.................... 	output_high(lcd_enable); 
.................... 	// lï¿½ os quatro bits menos significativos 
.................... 	if (input(lcd_d7)) bit_set(dado,3); 
.................... 	if (input(lcd_d6)) bit_set(dado,2); 
.................... 	if (input(lcd_d5)) bit_set(dado,1); 
.................... 	if (input(lcd_d4)) bit_set(dado,0); 
.................... 	output_low(lcd_enable);	// desabilita o display 
.................... 	return dado;	// retorna o byte lido 
.................... } 
....................  
.................... void lcd_envia_nibble( byte dado ) 
.................... // envia um dado de quatro bits para o display 
.................... { 
.................... 	// coloca os quatro bits nas saidas 
.................... 	output_bit(lcd_d4,bit_test(dado,0)); 
0247:  BSF    03.5
0248:  BTFSC  39.0
0249:  GOTO   24E
024A:  BCF    03.5
024B:  BCF    08.4
024C:  GOTO   250
024D:  BSF    03.5
024E:  BCF    03.5
024F:  BSF    08.4
0250:  BSF    03.5
0251:  BCF    08.4
.................... 	output_bit(lcd_d5,bit_test(dado,1)); 
0252:  BTFSC  39.1
0253:  GOTO   258
0254:  BCF    03.5
0255:  BCF    08.5
0256:  GOTO   25A
0257:  BSF    03.5
0258:  BCF    03.5
0259:  BSF    08.5
025A:  BSF    03.5
025B:  BCF    08.5
.................... 	output_bit(lcd_d6,bit_test(dado,2)); 
025C:  BTFSC  39.2
025D:  GOTO   262
025E:  BCF    03.5
025F:  BCF    08.6
0260:  GOTO   264
0261:  BSF    03.5
0262:  BCF    03.5
0263:  BSF    08.6
0264:  BSF    03.5
0265:  BCF    08.6
.................... 	output_bit(lcd_d7,bit_test(dado,3)); 
0266:  BTFSC  39.3
0267:  GOTO   26C
0268:  BCF    03.5
0269:  BCF    08.7
026A:  GOTO   26E
026B:  BSF    03.5
026C:  BCF    03.5
026D:  BSF    08.7
026E:  BSF    03.5
026F:  BCF    08.7
.................... 	// dï¿½ um pulso na linha enable 
.................... 	output_high(lcd_enable); 
0270:  BCF    09.1
0271:  BCF    03.5
0272:  BSF    09.1
.................... 	output_low(lcd_enable); 
0273:  BSF    03.5
0274:  BCF    09.1
0275:  BCF    03.5
0276:  BCF    09.1
0277:  RETURN
.................... } 
....................  
....................  
.................... void lcd_envia_byte( boolean endereco, byte dado ) 
.................... { 
.................... 	// coloca a linha rs em 0 
.................... 	output_low(lcd_rs); 
0278:  BSF    03.5
0279:  BCF    09.2
027A:  BCF    03.5
027B:  BCF    09.2
.................... 	// aguarda o display ficar desocupado 
.................... 	//while ( bit_test(lcd_le_byte(),7) ) ; 
.................... 	// configura a linha rs dependendo do modo selecionado 
.................... 	output_bit(lcd_rs,endereco); 
027C:  BSF    03.5
027D:  MOVF   36,F
027E:  BTFSS  03.2
027F:  GOTO   284
0280:  BCF    03.5
0281:  BCF    09.2
0282:  GOTO   286
0283:  BSF    03.5
0284:  BCF    03.5
0285:  BSF    09.2
0286:  BSF    03.5
0287:  BCF    09.2
.................... 	delay_us(100);	// aguarda 100 us 
0288:  MOVLW  A6
0289:  MOVWF  77
028A:  DECFSZ 77,F
028B:  GOTO   28A
028C:  NOP
.................... 	// caso a linha rw esteja definida, coloca em 0 
.................... 	#ifdef lcd_rw 
.................... 		output_low(lcd_rw); 
.................... 	#endif 
.................... 	// desativa linha enable 
.................... 	output_low(lcd_enable); 
028D:  BCF    09.1
028E:  BCF    03.5
028F:  BCF    09.1
.................... 	// envia a primeira parte do byte 
.................... 	lcd_envia_nibble(dado >> 4); 
0290:  BSF    03.5
0291:  SWAPF  37,W
0292:  MOVWF  38
0293:  MOVLW  0F
0294:  ANDWF  38,F
0295:  MOVF   38,W
0296:  MOVWF  39
0297:  BCF    03.5
0298:  CALL   247
.................... 	// envia a segunda parte do byte 
.................... 	lcd_envia_nibble(dado & 0x0f); 
0299:  BSF    03.5
029A:  MOVF   37,W
029B:  ANDLW  0F
029C:  MOVWF  38
029D:  MOVWF  39
029E:  BCF    03.5
029F:  CALL   247
02A0:  RETURN
.................... } 
....................  
....................  
.................... void lcd_ini() 
.................... // rotina de inicializaï¿½ï¿½o do display 
.................... { 
.................... 	byte conta; 
.................... 	output_low(lcd_d4); 
02A1:  BSF    03.5
02A2:  BCF    08.4
02A3:  BCF    03.5
02A4:  BCF    08.4
.................... 	output_low(lcd_d5); 
02A5:  BSF    03.5
02A6:  BCF    08.5
02A7:  BCF    03.5
02A8:  BCF    08.5
.................... 	output_low(lcd_d6); 
02A9:  BSF    03.5
02AA:  BCF    08.6
02AB:  BCF    03.5
02AC:  BCF    08.6
.................... 	output_low(lcd_d7); 
02AD:  BSF    03.5
02AE:  BCF    08.7
02AF:  BCF    03.5
02B0:  BCF    08.7
.................... 	output_low(lcd_rs); 
02B1:  BSF    03.5
02B2:  BCF    09.2
02B3:  BCF    03.5
02B4:  BCF    09.2
.................... 	#ifdef lcd_rw 
.................... 		output_high(lcd_rw); 
.................... 	#endif 
.................... 	output_low(lcd_enable); 
02B5:  BSF    03.5
02B6:  BCF    09.1
02B7:  BCF    03.5
02B8:  BCF    09.1
.................... 	delay_ms(15); 
02B9:  MOVLW  0F
02BA:  BSF    03.5
02BB:  MOVWF  32
02BC:  BCF    03.5
02BD:  CALL   233
.................... 	// envia uma seqï¿½ï¿½ncia de 3 vezes 0x03 
.................... 	// e depois 0x02 para configurar o mï¿½dulo 
.................... 	// para modo de 4 bits 
.................... 	for(conta=1;conta<=3;++conta) 
02BE:  MOVLW  01
02BF:  MOVWF  56
02C0:  MOVF   56,W
02C1:  SUBLW  03
02C2:  BTFSS  03.0
02C3:  GOTO   2D0
.................... 	{ 
.................... 		lcd_envia_nibble(3); 
02C4:  MOVLW  03
02C5:  BSF    03.5
02C6:  MOVWF  39
02C7:  BCF    03.5
02C8:  CALL   247
.................... 		delay_ms(5); 
02C9:  MOVLW  05
02CA:  BSF    03.5
02CB:  MOVWF  32
02CC:  BCF    03.5
02CD:  CALL   233
02CE:  INCF   56,F
02CF:  GOTO   2C0
.................... 	} 
.................... 	lcd_envia_nibble(2); 
02D0:  MOVLW  02
02D1:  BSF    03.5
02D2:  MOVWF  39
02D3:  BCF    03.5
02D4:  CALL   247
.................... 	// envia string de inicializaï¿½ï¿½o do display 
.................... 	for(conta=0;conta<=3;++conta) lcd_envia_byte(0,INI_LCD[conta]); 
02D5:  CLRF   56
02D6:  MOVF   56,W
02D7:  SUBLW  03
02D8:  BTFSS  03.0
02D9:  GOTO   2E7
02DA:  MOVF   56,W
02DB:  CALL   058
02DC:  MOVWF  57
02DD:  BSF    03.5
02DE:  CLRF   36
02DF:  BCF    03.5
02E0:  MOVF   57,W
02E1:  BSF    03.5
02E2:  MOVWF  37
02E3:  BCF    03.5
02E4:  CALL   278
02E5:  INCF   56,F
02E6:  GOTO   2D6
02E7:  BSF    0A.3
02E8:  BCF    0A.4
02E9:  GOTO   560 (RETURN)
.................... } 
....................  
.................... void lcd_pos_xy( byte x, byte y) 
.................... { 
....................    byte endereco; 
....................    if(y!=1) 
*
030B:  DECFSZ 33,W
030C:  GOTO   30E
030D:  GOTO   311
....................    	endereco = lcd_seg_lin; 
030E:  MOVLW  40
030F:  MOVWF  34
0310:  GOTO   312
....................    else 
....................    	endereco = 0; 
0311:  CLRF   34
....................    endereco += x-1; 
0312:  MOVLW  01
0313:  SUBWF  32,W
0314:  ADDWF  34,F
....................    lcd_envia_byte(0,0x80|endereco); 
0315:  MOVF   34,W
0316:  IORLW  80
0317:  MOVWF  35
0318:  CLRF   36
0319:  MOVF   35,W
031A:  MOVWF  37
031B:  BCF    03.5
031C:  CALL   278
.................... } 
....................  
.................... void lcd_escreve( char c) 
.................... // envia caractere para o display 
.................... { 
....................    switch (c) 
*
02EA:  BSF    03.5
02EB:  MOVF   31,W
02EC:  XORLW  0C
02ED:  BCF    03.5
02EE:  BTFSC  03.2
02EF:  GOTO   2FA
02F0:  XORLW  06
02F1:  BTFSC  03.2
02F2:  GOTO   306
02F3:  XORLW  07
02F4:  BTFSC  03.2
02F5:  GOTO   306
02F6:  XORLW  05
02F7:  BTFSC  03.2
02F8:  GOTO   31E
02F9:  GOTO   325
.................... 	{ 
....................      case '\f' 	:	lcd_envia_byte(0,1); 
02FA:  BSF    03.5
02FB:  CLRF   36
02FC:  MOVLW  01
02FD:  MOVWF  37
02FE:  BCF    03.5
02FF:  CALL   278
.................... 	  			delay_ms(2); 
0300:  MOVLW  02
0301:  BSF    03.5
0302:  MOVWF  32
0303:  BCF    03.5
0304:  CALL   233
.................... 				break; 
0305:  GOTO   32C
....................      case '\n'	: 
.................... 	   case '\r' 	:	lcd_pos_xy(1,2); 
0306:  MOVLW  01
0307:  BSF    03.5
0308:  MOVWF  32
0309:  MOVLW  02
030A:  MOVWF  33
.................... 	  			break; 
*
031D:  GOTO   32C
....................      case '\b' 	:	lcd_envia_byte(0,0x10); 
031E:  BSF    03.5
031F:  CLRF   36
0320:  MOVLW  10
0321:  MOVWF  37
0322:  BCF    03.5
0323:  CALL   278
.................... 	  			break; 
0324:  GOTO   32C
....................      default	:	lcd_envia_byte(1,c); 
0325:  MOVLW  01
0326:  BSF    03.5
0327:  MOVWF  36
0328:  MOVF   31,W
0329:  MOVWF  37
032A:  BCF    03.5
032B:  CALL   278
.................... 	  			break; 
....................    } 
032C:  RETURN
.................... } 
....................  
.................... char lcd_le( byte x, byte y) 
.................... // le caractere do display 
.................... { 
.................... 	char valor; 
.................... 	// seleciona a posiï¿½ï¿½o do caractere 
.................... 	lcd_pos_xy(x,y); 
.................... 	// ativa rs 
.................... 	output_high(lcd_rs); 
.................... 	// lï¿½ o caractere 
.................... 	valor = lcd_le_byte(); 
.................... 	// desativa rs 
.................... 	output_low(lcd_rs); 
.................... 	// retorna o valor do caractere 
.................... 	return valor; 
.................... } 
....................  
....................  
.................... #include "2401.c" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a MicroChip 24LC01B configured for a x8 org         //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);  Read the byte d from the address a     //// 
.................... ////                                                                   //// 
.................... ////   b = ext_eeprom_ready();  Returns TRUE if the eeprom is ready    //// 
.................... ////                            to receive opcodes                     //// 
.................... ////                                                                   //// 
.................... ////   The main program may define EEPROM_SDA                          //// 
.................... ////   and EEPROM_SCL to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... ////                            Pin Layout                             //// 
.................... ////   -----------------------------------------------------------     //// 
.................... ////   |                                                         |     //// 
.................... ////   | 1: NC   Not Connected | 8: VCC   +5V                    |     //// 
.................... ////   |                       |                                 |     //// 
.................... ////   | 2: NC   Not Connected | 7: WP    GND                    |     //// 
.................... ////   |                       |                                 |     //// 
.................... ////   | 3: NC   Not Connected | 6: SCL   EEPROM_SCL and Pull-Up |     //// 
.................... ////   |                       |                                 |     //// 
.................... ////   | 4: VSS  GND           | 5: SDA   EEPROM_SDA and Pull-Up |     //// 
.................... ////   -----------------------------------------------------------     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2003 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef EEPROM_SDA 
....................  
.................... #define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C3 
....................  
.................... #endif 
....................  
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
0863:  MOVLW  08
0864:  MOVWF  78
0865:  MOVLW  04
0866:  MOVWF  77
0867:  DECFSZ 77,F
0868:  GOTO   067
0869:  BCF    07.3
086A:  BCF    3D.3
086B:  MOVF   3D,W
086C:  BSF    03.5
086D:  MOVWF  07
086E:  MOVLW  03
086F:  MOVWF  77
0870:  DECFSZ 77,F
0871:  GOTO   070
0872:  RLF    2E,F
0873:  BCF    03.5
0874:  BCF    07.4
0875:  BTFSS  03.0
0876:  GOTO   07D
0877:  BSF    3D.4
0878:  MOVF   3D,W
0879:  BSF    03.5
087A:  MOVWF  07
087B:  GOTO   081
087C:  BCF    03.5
087D:  BCF    3D.4
087E:  MOVF   3D,W
087F:  BSF    03.5
0880:  MOVWF  07
0881:  NOP
0882:  BCF    03.5
0883:  BSF    3D.3
0884:  MOVF   3D,W
0885:  BSF    03.5
0886:  MOVWF  07
0887:  BCF    03.5
0888:  BTFSS  07.3
0889:  GOTO   088
088A:  DECFSZ 78,F
088B:  GOTO   065
088C:  MOVLW  04
088D:  MOVWF  77
088E:  DECFSZ 77,F
088F:  GOTO   08E
0890:  BCF    07.3
0891:  BCF    3D.3
0892:  MOVF   3D,W
0893:  BSF    03.5
0894:  MOVWF  07
0895:  NOP
0896:  BCF    03.5
0897:  BSF    3D.4
0898:  MOVF   3D,W
0899:  BSF    03.5
089A:  MOVWF  07
089B:  MOVLW  03
089C:  MOVWF  77
089D:  DECFSZ 77,F
089E:  GOTO   09D
089F:  MOVLW  03
08A0:  MOVWF  77
08A1:  DECFSZ 77,F
08A2:  GOTO   0A1
08A3:  BCF    03.5
08A4:  BSF    3D.3
08A5:  MOVF   3D,W
08A6:  BSF    03.5
08A7:  MOVWF  07
08A8:  BCF    03.5
08A9:  BTFSS  07.3
08AA:  GOTO   0A9
08AB:  CLRF   78
08AC:  MOVLW  03
08AD:  MOVWF  77
08AE:  DECFSZ 77,F
08AF:  GOTO   0AE
08B0:  BTFSC  07.4
08B1:  BSF    78.0
08B2:  BCF    07.3
08B3:  BCF    3D.3
08B4:  MOVF   3D,W
08B5:  BSF    03.5
08B6:  MOVWF  07
08B7:  BCF    03.5
08B8:  BCF    07.4
08B9:  BCF    3D.4
08BA:  MOVF   3D,W
08BB:  BSF    03.5
08BC:  MOVWF  07
08BD:  BCF    03.5
08BE:  RETURN
*
0961:  MOVLW  08
0962:  BSF    03.5
0963:  MOVWF  2E
0964:  MOVF   77,W
0965:  MOVWF  2F
0966:  BCF    03.5
0967:  BSF    3D.4
0968:  MOVF   3D,W
0969:  BSF    03.5
096A:  MOVWF  07
096B:  MOVLW  03
096C:  MOVWF  77
096D:  DECFSZ 77,F
096E:  GOTO   16D
096F:  BCF    03.5
0970:  BSF    3D.3
0971:  MOVF   3D,W
0972:  BSF    03.5
0973:  MOVWF  07
0974:  BCF    03.5
0975:  BTFSS  07.3
0976:  GOTO   175
0977:  BTFSC  07.4
0978:  BSF    03.0
0979:  BTFSS  07.4
097A:  BCF    03.0
097B:  RLF    78,F
097C:  MOVLW  04
097D:  MOVWF  77
097E:  DECFSZ 77,F
097F:  GOTO   17E
0980:  BCF    3D.3
0981:  MOVF   3D,W
0982:  BSF    03.5
0983:  MOVWF  07
0984:  BCF    03.5
0985:  BCF    07.3
0986:  BSF    03.5
0987:  DECFSZ 2E,F
0988:  GOTO   166
0989:  BCF    03.5
098A:  BSF    3D.4
098B:  MOVF   3D,W
098C:  BSF    03.5
098D:  MOVWF  07
098E:  MOVLW  03
098F:  MOVWF  77
0990:  DECFSZ 77,F
0991:  GOTO   190
0992:  BCF    03.5
0993:  BCF    07.4
0994:  BSF    03.5
0995:  MOVF   2F,W
0996:  BTFSC  03.2
0997:  GOTO   19D
0998:  BCF    03.5
0999:  BCF    3D.4
099A:  MOVF   3D,W
099B:  BSF    03.5
099C:  MOVWF  07
099D:  NOP
099E:  BCF    03.5
099F:  BSF    3D.3
09A0:  MOVF   3D,W
09A1:  BSF    03.5
09A2:  MOVWF  07
09A3:  BCF    03.5
09A4:  BTFSS  07.3
09A5:  GOTO   1A4
09A6:  MOVLW  04
09A7:  MOVWF  77
09A8:  DECFSZ 77,F
09A9:  GOTO   1A8
09AA:  BCF    07.3
09AB:  BCF    3D.3
09AC:  MOVF   3D,W
09AD:  BSF    03.5
09AE:  MOVWF  07
09AF:  MOVLW  03
09B0:  MOVWF  77
09B1:  DECFSZ 77,F
09B2:  GOTO   1B1
09B3:  BCF    03.5
09B4:  BCF    07.4
09B5:  BCF    3D.4
09B6:  MOVF   3D,W
09B7:  BSF    03.5
09B8:  MOVWF  07
....................  
.................... #define EEPROM_ADDRESS BYTE 
.................... #define EEPROM_SIZE    128 
....................  
.................... void init_ext_eeprom() { 
....................    output_float(EEPROM_SCL); 
*
0226:  BSF    3D.3
0227:  MOVF   3D,W
0228:  BSF    03.5
0229:  MOVWF  07
....................    output_float(EEPROM_SDA); 
022A:  BCF    03.5
022B:  BSF    3D.4
022C:  MOVF   3D,W
022D:  BSF    03.5
022E:  MOVWF  07
022F:  BCF    03.5
0230:  BSF    0A.3
0231:  BCF    0A.4
0232:  GOTO   557 (RETURN)
.................... } 
....................  
.................... BOOLEAN ext_eeprom_ready() { 
....................    int1 ack; 
....................    i2c_start();            // If the write command is acknowledged, 
*
08BF:  BSF    3D.4
08C0:  MOVF   3D,W
08C1:  BSF    03.5
08C2:  MOVWF  07
08C3:  MOVLW  04
08C4:  MOVWF  77
08C5:  DECFSZ 77,F
08C6:  GOTO   0C5
08C7:  BCF    03.5
08C8:  BSF    3D.3
08C9:  MOVF   3D,W
08CA:  BSF    03.5
08CB:  MOVWF  07
08CC:  MOVLW  03
08CD:  MOVWF  77
08CE:  DECFSZ 77,F
08CF:  GOTO   0CE
08D0:  BCF    03.5
08D1:  BCF    07.4
08D2:  BCF    3D.4
08D3:  MOVF   3D,W
08D4:  BSF    03.5
08D5:  MOVWF  07
08D6:  MOVLW  04
08D7:  MOVWF  77
08D8:  DECFSZ 77,F
08D9:  GOTO   0D8
08DA:  BCF    03.5
08DB:  BCF    07.3
08DC:  BCF    3D.3
08DD:  MOVF   3D,W
08DE:  BSF    03.5
08DF:  MOVWF  07
....................    ack = i2c_write(0xa0);  // then the device is ready. 
08E0:  MOVLW  A0
08E1:  MOVWF  2E
08E2:  BCF    03.5
08E3:  CALL   063
08E4:  MOVF   78,W
08E5:  BSF    03.5
08E6:  BCF    2D.0
08E7:  BTFSC  78.0
08E8:  BSF    2D.0
....................    i2c_stop(); 
08E9:  BCF    03.5
08EA:  BCF    3D.4
08EB:  MOVF   3D,W
08EC:  BSF    03.5
08ED:  MOVWF  07
08EE:  NOP
08EF:  BCF    03.5
08F0:  BSF    3D.3
08F1:  MOVF   3D,W
08F2:  BSF    03.5
08F3:  MOVWF  07
08F4:  BCF    03.5
08F5:  BTFSS  07.3
08F6:  GOTO   0F5
08F7:  MOVLW  04
08F8:  MOVWF  77
08F9:  DECFSZ 77,F
08FA:  GOTO   0F9
08FB:  GOTO   0FC
08FC:  NOP
08FD:  BSF    3D.4
08FE:  MOVF   3D,W
08FF:  BSF    03.5
0900:  MOVWF  07
0901:  MOVLW  04
0902:  MOVWF  77
0903:  DECFSZ 77,F
0904:  GOTO   103
....................    return !ack; 
0905:  MOVLW  00
0906:  BTFSS  2D.0
0907:  MOVLW  01
0908:  MOVWF  78
.................... } 
....................  
.................... void write_ext_eeprom(BYTE address, BYTE data) { 
....................    while(!ext_eeprom_ready()); 
....................    i2c_start(); 
....................    i2c_write(0xa0); 
....................    i2c_write(address); 
....................    i2c_write(data); 
....................    i2c_stop(); 
.................... } 
....................  
....................  
.................... BYTE read_ext_eeprom(BYTE address) { 
....................    BYTE data; 
....................  
....................    while(!ext_eeprom_ready()); 
0909:  MOVF   78,F
090A:  BTFSS  03.2
090B:  GOTO   10E
090C:  BCF    03.5
090D:  GOTO   0BF
....................    i2c_start(); 
090E:  BCF    03.5
090F:  BSF    3D.4
0910:  MOVF   3D,W
0911:  BSF    03.5
0912:  MOVWF  07
0913:  MOVLW  04
0914:  MOVWF  77
0915:  DECFSZ 77,F
0916:  GOTO   115
0917:  BCF    03.5
0918:  BSF    3D.3
0919:  MOVF   3D,W
091A:  BSF    03.5
091B:  MOVWF  07
091C:  MOVLW  03
091D:  MOVWF  77
091E:  DECFSZ 77,F
091F:  GOTO   11E
0920:  BCF    03.5
0921:  BCF    07.4
0922:  BCF    3D.4
0923:  MOVF   3D,W
0924:  BSF    03.5
0925:  MOVWF  07
0926:  MOVLW  04
0927:  MOVWF  77
0928:  DECFSZ 77,F
0929:  GOTO   128
092A:  BCF    03.5
092B:  BCF    07.3
092C:  BCF    3D.3
092D:  MOVF   3D,W
092E:  BSF    03.5
092F:  MOVWF  07
....................    i2c_write(0xa0); 
0930:  MOVLW  A0
0931:  MOVWF  2E
0932:  BCF    03.5
0933:  CALL   063
....................    i2c_write(address); 
0934:  BSF    03.5
0935:  MOVF   2B,W
0936:  MOVWF  2E
0937:  BCF    03.5
0938:  CALL   063
....................    i2c_start(); 
0939:  BSF    3D.4
093A:  MOVF   3D,W
093B:  BSF    03.5
093C:  MOVWF  07
093D:  MOVLW  04
093E:  MOVWF  77
093F:  DECFSZ 77,F
0940:  GOTO   13F
0941:  BCF    03.5
0942:  BSF    3D.3
0943:  MOVF   3D,W
0944:  BSF    03.5
0945:  MOVWF  07
0946:  MOVLW  03
0947:  MOVWF  77
0948:  DECFSZ 77,F
0949:  GOTO   148
094A:  BCF    03.5
094B:  BTFSS  07.3
094C:  GOTO   14B
094D:  BCF    07.4
094E:  BCF    3D.4
094F:  MOVF   3D,W
0950:  BSF    03.5
0951:  MOVWF  07
0952:  MOVLW  04
0953:  MOVWF  77
0954:  DECFSZ 77,F
0955:  GOTO   154
0956:  BCF    03.5
0957:  BCF    07.3
0958:  BCF    3D.3
0959:  MOVF   3D,W
095A:  BSF    03.5
095B:  MOVWF  07
....................    i2c_write(0xa1); 
095C:  MOVLW  A1
095D:  MOVWF  2E
095E:  BCF    03.5
095F:  CALL   063
....................    data=i2c_read(0); 
0960:  CLRF   77
*
09B9:  MOVF   78,W
09BA:  MOVWF  2C
....................    i2c_stop(); 
09BB:  BCF    03.5
09BC:  BCF    3D.4
09BD:  MOVF   3D,W
09BE:  BSF    03.5
09BF:  MOVWF  07
09C0:  NOP
09C1:  BCF    03.5
09C2:  BSF    3D.3
09C3:  MOVF   3D,W
09C4:  BSF    03.5
09C5:  MOVWF  07
09C6:  BCF    03.5
09C7:  BTFSS  07.3
09C8:  GOTO   1C7
09C9:  MOVLW  04
09CA:  MOVWF  77
09CB:  DECFSZ 77,F
09CC:  GOTO   1CB
09CD:  GOTO   1CE
09CE:  NOP
09CF:  BSF    3D.4
09D0:  MOVF   3D,W
09D1:  BSF    03.5
09D2:  MOVWF  07
09D3:  MOVLW  04
09D4:  MOVWF  77
09D5:  DECFSZ 77,F
09D6:  GOTO   1D5
....................    return(data); 
09D7:  MOVF   2C,W
09D8:  MOVWF  78
09D9:  BCF    03.5
09DA:  RETURN
.................... } 
....................  
.................... #include "kbd_board4.c" 
.................... /*######################################################################  
....................    Rotina utilização do teclado da placa PicSim board4 
....................    Adaptada para o compilador CCS 
....................    Autor: Alberto Willia Mascarenhas (adaptou para o compilador) 
....................    For e-mail suggestions :  awmascarenhas@gmail.com 
.................... ######################################################################## */ 
.................... unsigned char tc_tecla(unsigned int timeout) 
*
03A4:  CLRF   2F
03A5:  CLRF   30
.................... { 
....................   unsigned int to=0; 
....................   unsigned char k = 0;   
....................   while(((to < timeout)||(!timeout))&&(!k)){ 
03A6:  MOVF   2E,W
03A7:  SUBWF  2F,W
03A8:  BTFSS  03.0
03A9:  GOTO   3AD
03AA:  MOVF   2E,F
03AB:  BTFSS  03.2
03AC:  GOTO   4EC
03AD:  MOVF   30,F
03AE:  BTFSS  03.2
03AF:  GOTO   4EC
....................       
....................        
....................       //------------------------------------------------------------------------- 
....................       //inicio do programa de varredura do teclado matricial 
....................       //-------------------------------------------------------------------------- 
....................       //habilita primeira coluna do teclado 
....................       output_low(PIN_B0);output_high(PIN_B1);output_high(PIN_B2);output_high(PIN_B3); 
03B0:  BCF    06.0
03B1:  BCF    03.5
03B2:  BCF    06.0
03B3:  BSF    03.5
03B4:  BCF    06.1
03B5:  BCF    03.5
03B6:  BSF    06.1
03B7:  BSF    03.5
03B8:  BCF    06.2
03B9:  BCF    03.5
03BA:  BSF    06.2
03BB:  BSF    03.5
03BC:  BCF    06.3
03BD:  BCF    03.5
03BE:  BSF    06.3
....................       delay_ms(20); 
03BF:  MOVLW  14
03C0:  BSF    03.5
03C1:  MOVWF  32
03C2:  BCF    03.5
03C3:  CALL   233
....................       if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='1';}; 
03C4:  BSF    03.5
03C5:  BSF    08.0
03C6:  BCF    03.5
03C7:  BTFSC  08.0
03C8:  GOTO   3D2
03C9:  BSF    03.5
03CA:  BSF    08.0
03CB:  BCF    03.5
03CC:  BTFSS  08.0
03CD:  GOTO   3C9
03CE:  MOVLW  31
03CF:  BSF    03.5
03D0:  MOVWF  30
03D1:  BCF    03.5
....................       if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='4';}; 
03D2:  BSF    03.5
03D3:  BSF    08.1
03D4:  BCF    03.5
03D5:  BTFSC  08.1
03D6:  GOTO   3E0
03D7:  BSF    03.5
03D8:  BSF    08.1
03D9:  BCF    03.5
03DA:  BTFSS  08.1
03DB:  GOTO   3D7
03DC:  MOVLW  34
03DD:  BSF    03.5
03DE:  MOVWF  30
03DF:  BCF    03.5
....................       if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='7';}; 
03E0:  BSF    03.5
03E1:  BSF    08.2
03E2:  BCF    03.5
03E3:  BTFSC  08.2
03E4:  GOTO   3EE
03E5:  BSF    03.5
03E6:  BSF    08.2
03E7:  BCF    03.5
03E8:  BTFSS  08.2
03E9:  GOTO   3E5
03EA:  MOVLW  37
03EB:  BSF    03.5
03EC:  MOVWF  30
03ED:  BCF    03.5
....................       if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='*';}; 
03EE:  BSF    03.5
03EF:  BSF    08.3
03F0:  BCF    03.5
03F1:  BTFSC  08.3
03F2:  GOTO   3FC
03F3:  BSF    03.5
03F4:  BSF    08.3
03F5:  BCF    03.5
03F6:  BTFSS  08.3
03F7:  GOTO   3F3
03F8:  MOVLW  2A
03F9:  BSF    03.5
03FA:  MOVWF  30
03FB:  BCF    03.5
....................       //habilita segunda coluna do teclado 
....................       output_high(PIN_B0);output_low(PIN_B1);output_high(PIN_B2);output_high(PIN_B3); 
03FC:  BSF    03.5
03FD:  BCF    06.0
03FE:  BCF    03.5
03FF:  BSF    06.0
0400:  BSF    03.5
0401:  BCF    06.1
0402:  BCF    03.5
0403:  BCF    06.1
0404:  BSF    03.5
0405:  BCF    06.2
0406:  BCF    03.5
0407:  BSF    06.2
0408:  BSF    03.5
0409:  BCF    06.3
040A:  BCF    03.5
040B:  BSF    06.3
....................       delay_ms(20);       
040C:  MOVLW  14
040D:  BSF    03.5
040E:  MOVWF  32
040F:  BCF    03.5
0410:  CALL   233
....................       if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='2';}; 
0411:  BSF    03.5
0412:  BSF    08.0
0413:  BCF    03.5
0414:  BTFSC  08.0
0415:  GOTO   41F
0416:  BSF    03.5
0417:  BSF    08.0
0418:  BCF    03.5
0419:  BTFSS  08.0
041A:  GOTO   416
041B:  MOVLW  32
041C:  BSF    03.5
041D:  MOVWF  30
041E:  BCF    03.5
....................       if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='5';}; 
041F:  BSF    03.5
0420:  BSF    08.1
0421:  BCF    03.5
0422:  BTFSC  08.1
0423:  GOTO   42D
0424:  BSF    03.5
0425:  BSF    08.1
0426:  BCF    03.5
0427:  BTFSS  08.1
0428:  GOTO   424
0429:  MOVLW  35
042A:  BSF    03.5
042B:  MOVWF  30
042C:  BCF    03.5
....................       if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='8';}; 
042D:  BSF    03.5
042E:  BSF    08.2
042F:  BCF    03.5
0430:  BTFSC  08.2
0431:  GOTO   43B
0432:  BSF    03.5
0433:  BSF    08.2
0434:  BCF    03.5
0435:  BTFSS  08.2
0436:  GOTO   432
0437:  MOVLW  38
0438:  BSF    03.5
0439:  MOVWF  30
043A:  BCF    03.5
....................       if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='0';}; 
043B:  BSF    03.5
043C:  BSF    08.3
043D:  BCF    03.5
043E:  BTFSC  08.3
043F:  GOTO   449
0440:  BSF    03.5
0441:  BSF    08.3
0442:  BCF    03.5
0443:  BTFSS  08.3
0444:  GOTO   440
0445:  MOVLW  30
0446:  BSF    03.5
0447:  MOVWF  30
0448:  BCF    03.5
....................        
....................       //habilita terceira coluna do teclado 
....................       output_high(PIN_B0);output_high(PIN_B1);output_low(PIN_B2);output_high(PIN_B3); 
0449:  BSF    03.5
044A:  BCF    06.0
044B:  BCF    03.5
044C:  BSF    06.0
044D:  BSF    03.5
044E:  BCF    06.1
044F:  BCF    03.5
0450:  BSF    06.1
0451:  BSF    03.5
0452:  BCF    06.2
0453:  BCF    03.5
0454:  BCF    06.2
0455:  BSF    03.5
0456:  BCF    06.3
0457:  BCF    03.5
0458:  BSF    06.3
....................       delay_ms(20);       
0459:  MOVLW  14
045A:  BSF    03.5
045B:  MOVWF  32
045C:  BCF    03.5
045D:  CALL   233
....................       if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='3';}; 
045E:  BSF    03.5
045F:  BSF    08.0
0460:  BCF    03.5
0461:  BTFSC  08.0
0462:  GOTO   46C
0463:  BSF    03.5
0464:  BSF    08.0
0465:  BCF    03.5
0466:  BTFSS  08.0
0467:  GOTO   463
0468:  MOVLW  33
0469:  BSF    03.5
046A:  MOVWF  30
046B:  BCF    03.5
....................       if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='6';}; 
046C:  BSF    03.5
046D:  BSF    08.1
046E:  BCF    03.5
046F:  BTFSC  08.1
0470:  GOTO   47A
0471:  BSF    03.5
0472:  BSF    08.1
0473:  BCF    03.5
0474:  BTFSS  08.1
0475:  GOTO   471
0476:  MOVLW  36
0477:  BSF    03.5
0478:  MOVWF  30
0479:  BCF    03.5
....................       if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='9';}; 
047A:  BSF    03.5
047B:  BSF    08.2
047C:  BCF    03.5
047D:  BTFSC  08.2
047E:  GOTO   488
047F:  BSF    03.5
0480:  BSF    08.2
0481:  BCF    03.5
0482:  BTFSS  08.2
0483:  GOTO   47F
0484:  MOVLW  39
0485:  BSF    03.5
0486:  MOVWF  30
0487:  BCF    03.5
....................       if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='#';}; 
0488:  BSF    03.5
0489:  BSF    08.3
048A:  BCF    03.5
048B:  BTFSC  08.3
048C:  GOTO   496
048D:  BSF    03.5
048E:  BSF    08.3
048F:  BCF    03.5
0490:  BTFSS  08.3
0491:  GOTO   48D
0492:  MOVLW  23
0493:  BSF    03.5
0494:  MOVWF  30
0495:  BCF    03.5
....................   
....................        //habilita quarta coluna do teclado 
....................       output_high(PIN_B0);output_high(PIN_B1);output_high(PIN_B2);output_low(PIN_B3); 
0496:  BSF    03.5
0497:  BCF    06.0
0498:  BCF    03.5
0499:  BSF    06.0
049A:  BSF    03.5
049B:  BCF    06.1
049C:  BCF    03.5
049D:  BSF    06.1
049E:  BSF    03.5
049F:  BCF    06.2
04A0:  BCF    03.5
04A1:  BSF    06.2
04A2:  BSF    03.5
04A3:  BCF    06.3
04A4:  BCF    03.5
04A5:  BCF    06.3
....................       delay_ms(20);       
04A6:  MOVLW  14
04A7:  BSF    03.5
04A8:  MOVWF  32
04A9:  BCF    03.5
04AA:  CALL   233
....................       if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='A';}; 
04AB:  BSF    03.5
04AC:  BSF    08.0
04AD:  BCF    03.5
04AE:  BTFSC  08.0
04AF:  GOTO   4B9
04B0:  BSF    03.5
04B1:  BSF    08.0
04B2:  BCF    03.5
04B3:  BTFSS  08.0
04B4:  GOTO   4B0
04B5:  MOVLW  41
04B6:  BSF    03.5
04B7:  MOVWF  30
04B8:  BCF    03.5
....................       if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='B';}; 
04B9:  BSF    03.5
04BA:  BSF    08.1
04BB:  BCF    03.5
04BC:  BTFSC  08.1
04BD:  GOTO   4C7
04BE:  BSF    03.5
04BF:  BSF    08.1
04C0:  BCF    03.5
04C1:  BTFSS  08.1
04C2:  GOTO   4BE
04C3:  MOVLW  42
04C4:  BSF    03.5
04C5:  MOVWF  30
04C6:  BCF    03.5
....................       if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='C';}; 
04C7:  BSF    03.5
04C8:  BSF    08.2
04C9:  BCF    03.5
04CA:  BTFSC  08.2
04CB:  GOTO   4D5
04CC:  BSF    03.5
04CD:  BSF    08.2
04CE:  BCF    03.5
04CF:  BTFSS  08.2
04D0:  GOTO   4CC
04D1:  MOVLW  43
04D2:  BSF    03.5
04D3:  MOVWF  30
04D4:  BCF    03.5
....................       if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='D';}; 
04D5:  BSF    03.5
04D6:  BSF    08.3
04D7:  BCF    03.5
04D8:  BTFSC  08.3
04D9:  GOTO   4E3
04DA:  BSF    03.5
04DB:  BSF    08.3
04DC:  BCF    03.5
04DD:  BTFSS  08.3
04DE:  GOTO   4DA
04DF:  MOVLW  44
04E0:  BSF    03.5
04E1:  MOVWF  30
04E2:  BCF    03.5
....................   
....................       //printf (lcd_escreve,"\f saiu geral %u",k); 
....................       //delay_ms(1000); 
....................       delay_ms(5); 
04E3:  MOVLW  05
04E4:  BSF    03.5
04E5:  MOVWF  32
04E6:  BCF    03.5
04E7:  CALL   233
....................       to+=5; 
04E8:  MOVLW  05
04E9:  BSF    03.5
04EA:  ADDWF  2F,F
04EB:  GOTO   3A6
....................   } 
....................    if(!k)k=255; 
04EC:  MOVF   30,F
04ED:  BTFSS  03.2
04EE:  GOTO   4F1
04EF:  MOVLW  FF
04F0:  MOVWF  30
....................   return k;   
04F1:  MOVF   30,W
04F2:  MOVWF  78
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /* 
.................... int status -> 0 - Unpaid, 1 - Paid, 3 - Admin 
.................... int chooseAddr: 
....................          Param < 0 - SAVE in a available address to CREATE  
....................          Param >= 0 - SAVE in a existing address to OVERWRITE (edit) 
.................... */ 
.................... void saveUser(int * id, int * pass, int status); 
.................... int getAddressByID(int * id);    
.................... void searchUser(int * id); 
.................... int deleteUser(int * id); 
.................... void editUser(); 
.................... void updateUser(int * id, int * pass, int status); 
....................  
.................... // int isIdAvailable(int id);     
.................... void printUser(); 
.................... void erase_program_eeprom(int addrr); 
.................... int incrementID(); 
.................... int lastNewUserPosition(); 
.................... void resetMemory(); 
.................... void adminMenu(); 
.................... void userMenu(); 
.................... void login(int * id); 
.................... int checkPassword(int initBlockAddr, int * pass); 
.................... //show = 1 -> Print(Paid/Unpaid) 
.................... int getUserStatus(int address, int show); 
.................... unsigned char readKeyboard();  
.................... int * getAdminsID(); 
.................... void listAdmins(); 
.................... int * strToInt(char * str); 
.................... char * strfromchar(char destination[], char source); 
.................... int * inputId(); 
.................... int * inputToKeyboard(char * msg, int max); 
.................... void inputKeyboardUser(); 
....................  
....................  
.................... typedef struct {  
....................    int id[2];   
....................    int pass[4]; //password 
....................    int status; //0 - Unpaid, 1 - Paid, 3 - Admin 
.................... }User; 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
*
0580:  BSF    03.5
0581:  MOVF   69,W
0582:  MOVWF  6C
....................    for(su=s;0<n;++su,--n) 
0583:  MOVF   68,W
0584:  MOVWF  6E
0585:  MOVF   67,W
0586:  MOVWF  6D
0587:  MOVF   6B,F
0588:  BTFSS  03.2
0589:  GOTO   58E
058A:  MOVF   6A,W
058B:  SUBLW  00
058C:  BTFSC  03.0
058D:  GOTO   5A6
....................       if(*su==uc) 
058E:  MOVF   6E,W
058F:  MOVWF  7A
0590:  MOVF   6D,W
0591:  MOVWF  04
0592:  BCF    03.7
0593:  BTFSC  7A.0
0594:  BSF    03.7
0595:  MOVF   6C,W
0596:  SUBWF  00,W
0597:  BTFSS  03.2
0598:  GOTO   59E
....................       return su; 
0599:  MOVF   6D,W
059A:  MOVWF  78
059B:  MOVF   6E,W
059C:  MOVWF  79
059D:  GOTO   5A9
059E:  INCF   6D,F
059F:  BTFSC  03.2
05A0:  INCF   6E,F
05A1:  MOVF   6A,W
05A2:  BTFSC  03.2
05A3:  DECF   6B,F
05A4:  DECF   6A,F
05A5:  GOTO   587
....................    return NULL; 
05A6:  MOVLW  00
05A7:  MOVWF  78
05A8:  MOVWF  79
05A9:  BCF    03.5
05AA:  RETURN
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
0D3C:  BCF    03.5
0D3D:  CLRF   3E
0D3E:  CLRF   3F
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
0BE5:  MOVF   22,W
0BE6:  MOVWF  24
0BE7:  MOVF   21,W
0BE8:  MOVWF  23
0BE9:  MOVF   24,W
0BEA:  MOVWF  7A
0BEB:  MOVF   23,W
0BEC:  MOVWF  04
0BED:  BCF    03.7
0BEE:  BTFSC  7A.0
0BEF:  BSF    03.7
0BF0:  MOVF   00,F
0BF1:  BTFSC  03.2
0BF2:  GOTO   3F7
0BF3:  INCF   23,F
0BF4:  BTFSC  03.2
0BF5:  INCF   24,F
0BF6:  GOTO   3E9
....................    return(sc - s); 
0BF7:  MOVF   21,W
0BF8:  SUBWF  23,W
0BF9:  MOVWF  77
0BFA:  MOVF   24,W
0BFB:  MOVWF  7A
0BFC:  MOVF   22,W
0BFD:  BTFSS  03.0
0BFE:  INCFSZ 22,W
0BFF:  SUBWF  7A,F
0C00:  MOVF   77,W
0C01:  MOVWF  78
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
*
05AB:  BSF    03.5
05AC:  CLRF   40
05AD:  CLRF   3F
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
05AE:  MOVLW  30
05AF:  MOVWF  42
05B0:  MOVLW  31
05B1:  MOVWF  43
05B2:  MOVLW  32
05B3:  MOVWF  44
05B4:  MOVLW  33
05B5:  MOVWF  45
05B6:  MOVLW  34
05B7:  MOVWF  46
05B8:  MOVLW  35
05B9:  MOVWF  47
05BA:  MOVLW  36
05BB:  MOVWF  48
05BC:  MOVLW  37
05BD:  MOVWF  49
05BE:  MOVLW  38
05BF:  MOVWF  4A
05C0:  MOVLW  39
05C1:  MOVWF  4B
05C2:  MOVLW  61
05C3:  MOVWF  4C
05C4:  MOVLW  62
05C5:  MOVWF  4D
05C6:  MOVLW  63
05C7:  MOVWF  4E
05C8:  MOVLW  64
05C9:  MOVWF  4F
05CA:  MOVLW  65
05CB:  MOVWF  50
05CC:  MOVLW  66
05CD:  MOVWF  51
05CE:  MOVLW  67
05CF:  MOVWF  52
05D0:  MOVLW  68
05D1:  MOVWF  53
05D2:  MOVLW  69
05D3:  MOVWF  54
05D4:  MOVLW  6A
05D5:  MOVWF  55
05D6:  MOVLW  6B
05D7:  MOVWF  56
05D8:  MOVLW  6C
05D9:  MOVWF  57
05DA:  MOVLW  6D
05DB:  MOVWF  58
05DC:  MOVLW  6E
05DD:  MOVWF  59
05DE:  MOVLW  6F
05DF:  MOVWF  5A
05E0:  MOVLW  70
05E1:  MOVWF  5B
05E2:  MOVLW  71
05E3:  MOVWF  5C
05E4:  MOVLW  73
05E5:  MOVWF  5D
05E6:  MOVLW  74
05E7:  MOVWF  5E
05E8:  MOVLW  75
05E9:  MOVWF  5F
05EA:  MOVLW  76
05EB:  MOVWF  60
05EC:  MOVLW  77
05ED:  MOVWF  61
05EE:  MOVLW  78
05EF:  MOVWF  62
05F0:  MOVLW  79
05F1:  MOVWF  63
05F2:  MOVLW  7A
05F3:  MOVWF  64
05F4:  CLRF   65
....................    for(sc=s;isspace(*sc);++sc); 
05F5:  MOVF   35,W
05F6:  MOVWF  3A
05F7:  MOVF   34,W
05F8:  MOVWF  39
05F9:  MOVF   3A,W
05FA:  MOVWF  7A
05FB:  MOVF   39,W
05FC:  MOVWF  04
05FD:  BCF    03.7
05FE:  BTFSC  7A.0
05FF:  BSF    03.7
0600:  MOVF   00,W
0601:  SUBLW  20
0602:  BTFSS  03.2
0603:  GOTO   608
0604:  INCF   39,F
0605:  BTFSC  03.2
0606:  INCF   3A,F
0607:  GOTO   5F9
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
0608:  MOVF   3A,W
0609:  MOVWF  7A
060A:  MOVF   39,W
060B:  MOVWF  04
060C:  BCF    03.7
060D:  BTFSC  3A.0
060E:  BSF    03.7
060F:  MOVF   00,W
0610:  SUBLW  2D
0611:  BTFSC  03.2
0612:  GOTO   61E
0613:  MOVF   3A,W
0614:  MOVWF  7A
0615:  MOVF   39,W
0616:  MOVWF  04
0617:  BCF    03.7
0618:  BTFSC  3A.0
0619:  BSF    03.7
061A:  MOVF   00,W
061B:  SUBLW  2B
061C:  BTFSS  03.2
061D:  GOTO   62A
061E:  MOVF   3A,W
061F:  MOVWF  7A
0620:  MOVF   39,W
0621:  INCF   39,F
0622:  BTFSC  03.2
0623:  INCF   3A,F
0624:  MOVWF  04
0625:  BCF    03.7
0626:  BTFSC  7A.0
0627:  BSF    03.7
0628:  MOVF   00,W
0629:  GOTO   62B
062A:  MOVLW  2B
062B:  MOVWF  41
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
062C:  MOVF   41,W
062D:  SUBLW  2D
062E:  BTFSC  03.2
062F:  GOTO   63B
0630:  BTFSC  38.7
0631:  GOTO   63B
0632:  DECFSZ 38,W
0633:  GOTO   635
0634:  GOTO   63B
0635:  BTFSC  38.7
0636:  GOTO   63D
0637:  MOVF   38,W
0638:  SUBLW  24
0639:  BTFSC  03.0
063A:  GOTO   63D
....................    goto StrtoulGO; 
063B:  GOTO   795
063C:  GOTO   6D3
....................  
....................    else if (base) 
063D:  MOVF   38,F
063E:  BTFSC  03.2
063F:  GOTO   698
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
0640:  MOVF   38,W
0641:  SUBLW  10
0642:  BTFSS  03.2
0643:  GOTO   667
0644:  MOVF   3A,W
0645:  MOVWF  7A
0646:  MOVF   39,W
0647:  MOVWF  04
0648:  BCF    03.7
0649:  BTFSC  7A.0
064A:  BSF    03.7
064B:  MOVF   00,W
064C:  SUBLW  30
064D:  BTFSS  03.2
064E:  GOTO   667
064F:  MOVLW  01
0650:  ADDWF  39,W
0651:  MOVWF  04
0652:  BCF    03.7
0653:  BTFSC  3A.0
0654:  BSF    03.7
0655:  MOVF   00,W
0656:  SUBLW  78
0657:  BTFSC  03.2
0658:  GOTO   663
0659:  MOVLW  01
065A:  ADDWF  39,W
065B:  MOVWF  04
065C:  BCF    03.7
065D:  BTFSC  3A.0
065E:  BSF    03.7
065F:  MOVF   00,W
0660:  SUBLW  58
0661:  BTFSS  03.2
0662:  GOTO   667
....................          sc+=2; 
0663:  MOVLW  02
0664:  ADDWF  39,F
0665:  BTFSC  03.0
0666:  INCF   3A,F
....................       if(base==8 && *sc =='0') 
0667:  MOVF   38,W
0668:  SUBLW  08
0669:  BTFSS  03.2
066A:  GOTO   67A
066B:  MOVF   3A,W
066C:  MOVWF  7A
066D:  MOVF   39,W
066E:  MOVWF  04
066F:  BCF    03.7
0670:  BTFSC  7A.0
0671:  BSF    03.7
0672:  MOVF   00,W
0673:  SUBLW  30
0674:  BTFSS  03.2
0675:  GOTO   67A
....................          sc+=1; 
0676:  MOVLW  01
0677:  ADDWF  39,F
0678:  BTFSC  03.0
0679:  INCF   3A,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
067A:  MOVF   38,W
067B:  SUBLW  02
067C:  BTFSS  03.2
067D:  GOTO   697
067E:  MOVF   3A,W
067F:  MOVWF  7A
0680:  MOVF   39,W
0681:  MOVWF  04
0682:  BCF    03.7
0683:  BTFSC  7A.0
0684:  BSF    03.7
0685:  MOVF   00,W
0686:  SUBLW  30
0687:  BTFSS  03.2
0688:  GOTO   697
0689:  MOVLW  01
068A:  ADDWF  39,W
068B:  MOVWF  04
068C:  BCF    03.7
068D:  BTFSC  3A.0
068E:  BSF    03.7
068F:  MOVF   00,W
0690:  SUBLW  62
0691:  BTFSS  03.2
0692:  GOTO   697
....................          sc+=2; 
0693:  MOVLW  02
0694:  ADDWF  39,F
0695:  BTFSC  03.0
0696:  INCF   3A,F
....................  
....................    } 
0697:  GOTO   6D3
....................    else if(*sc!='0') // base is 0, find base 
0698:  MOVF   3A,W
0699:  MOVWF  7A
069A:  MOVF   39,W
069B:  MOVWF  04
069C:  BCF    03.7
069D:  BTFSC  7A.0
069E:  BSF    03.7
069F:  MOVF   00,W
06A0:  SUBLW  30
06A1:  BTFSC  03.2
06A2:  GOTO   6A6
....................       base=10; 
06A3:  MOVLW  0A
06A4:  MOVWF  38
06A5:  GOTO   6D3
....................    else if (sc[1]=='x' || sc[1]=='X') 
06A6:  MOVLW  01
06A7:  ADDWF  39,W
06A8:  MOVWF  04
06A9:  BCF    03.7
06AA:  BTFSC  3A.0
06AB:  BSF    03.7
06AC:  MOVF   00,W
06AD:  SUBLW  78
06AE:  BTFSC  03.2
06AF:  GOTO   6BA
06B0:  MOVLW  01
06B1:  ADDWF  39,W
06B2:  MOVWF  04
06B3:  BCF    03.7
06B4:  BTFSC  3A.0
06B5:  BSF    03.7
06B6:  MOVF   00,W
06B7:  SUBLW  58
06B8:  BTFSS  03.2
06B9:  GOTO   6C1
....................       base =16,sc+=2; 
06BA:  MOVLW  10
06BB:  MOVWF  38
06BC:  MOVLW  02
06BD:  ADDWF  39,F
06BE:  BTFSC  03.0
06BF:  INCF   3A,F
06C0:  GOTO   6D3
....................    else if(sc[1]=='b') 
06C1:  MOVLW  01
06C2:  ADDWF  39,W
06C3:  MOVWF  04
06C4:  BCF    03.7
06C5:  BTFSC  3A.0
06C6:  BSF    03.7
06C7:  MOVF   00,W
06C8:  SUBLW  62
06C9:  BTFSS  03.2
06CA:  GOTO   6D1
....................       base=2,sc+=2; 
06CB:  MOVLW  02
06CC:  MOVWF  38
06CD:  ADDWF  39,F
06CE:  BTFSC  03.0
06CF:  INCF   3A,F
06D0:  GOTO   6D3
....................    else 
....................       base=8; 
06D1:  MOVLW  08
06D2:  MOVWF  38
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
06D3:  MOVF   3A,W
06D4:  MOVWF  3C
06D5:  MOVF   39,W
06D6:  MOVWF  3B
06D7:  MOVF   3A,W
06D8:  MOVWF  7A
06D9:  MOVF   39,W
06DA:  MOVWF  04
06DB:  BCF    03.7
06DC:  BTFSC  7A.0
06DD:  BSF    03.7
06DE:  MOVF   00,W
06DF:  SUBLW  30
06E0:  BTFSS  03.2
06E1:  GOTO   6E6
06E2:  INCF   39,F
06E3:  BTFSC  03.2
06E4:  INCF   3A,F
06E5:  GOTO   6D7
....................    sd=memchr(digits,tolower(*sc),base); 
06E6:  MOVF   3A,W
06E7:  MOVWF  7A
06E8:  MOVF   39,W
06E9:  MOVWF  04
06EA:  BCF    03.7
06EB:  BTFSC  3A.0
06EC:  BSF    03.7
06ED:  MOVF   00,W
06EE:  MOVWF  66
06EF:  SUBLW  40
06F0:  BTFSC  03.0
06F1:  GOTO   6F9
06F2:  MOVF   66,W
06F3:  SUBLW  5A
06F4:  BTFSS  03.0
06F5:  GOTO   6F9
06F6:  MOVF   66,W
06F7:  IORLW  20
06F8:  GOTO   6FA
06F9:  MOVF   66,W
06FA:  MOVWF  66
06FB:  CLRF   68
06FC:  MOVLW  C2
06FD:  MOVWF  67
06FE:  MOVF   66,W
06FF:  MOVWF  69
0700:  CLRF   6B
0701:  MOVF   38,W
0702:  MOVWF  6A
0703:  BCF    03.5
0704:  CALL   580
0705:  MOVF   79,W
0706:  BSF    03.5
0707:  MOVWF  3E
0708:  MOVF   78,W
0709:  MOVWF  3D
....................    for(; sd!=0; ) 
070A:  MOVF   3D,F
070B:  BTFSS  03.2
070C:  GOTO   710
070D:  MOVF   3E,F
070E:  BTFSC  03.2
070F:  GOTO   78D
....................    { 
....................       x=x*base+(int16)(sd-digits); 
0710:  CLRF   7A
0711:  MOVF   38,W
0712:  MOVWF  77
0713:  BTFSC  77.7
0714:  DECF   7A,F
0715:  MOVWF  66
0716:  MOVF   7A,W
0717:  MOVWF  67
0718:  MOVF   40,W
0719:  MOVWF  69
071A:  MOVF   3F,W
071B:  MOVWF  68
071C:  MOVF   67,W
071D:  MOVWF  6B
071E:  MOVF   66,W
071F:  MOVWF  6A
*
074D:  MOVF   79,W
074E:  MOVWF  67
074F:  MOVF   78,W
0750:  MOVWF  66
0751:  MOVLW  C2
0752:  SUBWF  3D,W
0753:  MOVWF  77
0754:  MOVF   3E,W
0755:  MOVWF  7A
0756:  MOVLW  00
0757:  BTFSS  03.0
0758:  MOVLW  01
0759:  SUBWF  7A,F
075A:  MOVF   77,W
075B:  ADDWF  66,W
075C:  MOVWF  78
075D:  MOVF   67,W
075E:  BTFSC  03.0
075F:  INCFSZ 67,W
0760:  ADDWF  7A,F
0761:  MOVF   78,W
0762:  MOVWF  3F
0763:  MOVF   7A,W
0764:  MOVWF  40
....................       ++sc; 
0765:  INCF   39,F
0766:  BTFSC  03.2
0767:  INCF   3A,F
....................       sd=memchr(digits,tolower(*sc),base); 
0768:  MOVF   3A,W
0769:  MOVWF  7A
076A:  MOVF   39,W
076B:  MOVWF  04
076C:  BCF    03.7
076D:  BTFSC  3A.0
076E:  BSF    03.7
076F:  MOVF   00,W
0770:  MOVWF  66
0771:  SUBLW  40
0772:  BTFSC  03.0
0773:  GOTO   77B
0774:  MOVF   66,W
0775:  SUBLW  5A
0776:  BTFSS  03.0
0777:  GOTO   77B
0778:  MOVF   66,W
0779:  IORLW  20
077A:  GOTO   77C
077B:  MOVF   66,W
077C:  MOVWF  66
077D:  CLRF   68
077E:  MOVLW  C2
077F:  MOVWF  67
0780:  MOVF   66,W
0781:  MOVWF  69
0782:  CLRF   6B
0783:  MOVF   38,W
0784:  MOVWF  6A
0785:  BCF    03.5
0786:  CALL   580
0787:  MOVF   79,W
0788:  BSF    03.5
0789:  MOVWF  3E
078A:  MOVF   78,W
078B:  MOVWF  3D
078C:  GOTO   70A
....................    } 
....................    if(s1==sc) 
078D:  MOVF   39,W
078E:  SUBWF  3B,W
078F:  BTFSS  03.2
0790:  GOTO   7A8
0791:  MOVF   3A,W
0792:  SUBWF  3C,W
0793:  BTFSS  03.2
0794:  GOTO   7A8
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
0795:  MOVF   36,W
0796:  IORWF  37,W
0797:  BTFSC  03.2
0798:  GOTO   7A4
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
0799:  MOVF   36,W
079A:  MOVWF  04
079B:  BCF    03.7
079C:  BTFSC  37.0
079D:  BSF    03.7
079E:  INCF   04,F
079F:  MOVF   35,W
07A0:  MOVWF  00
07A1:  DECF   04,F
07A2:  MOVF   34,W
07A3:  MOVWF  00
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
07A4:  MOVLW  00
07A5:  MOVWF  78
07A6:  MOVWF  79
07A7:  GOTO   7BB
....................    } 
....................    if (endptr) 
07A8:  MOVF   36,W
07A9:  IORWF  37,W
07AA:  BTFSC  03.2
07AB:  GOTO   7B7
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
07AC:  MOVF   36,W
07AD:  MOVWF  04
07AE:  BCF    03.7
07AF:  BTFSC  37.0
07B0:  BSF    03.7
07B1:  INCF   04,F
07B2:  MOVF   3A,W
07B3:  MOVWF  00
07B4:  DECF   04,F
07B5:  MOVF   39,W
07B6:  MOVWF  00
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
07B7:  MOVF   3F,W
07B8:  MOVWF  78
07B9:  MOVF   40,W
07BA:  MOVWF  79
07BB:  BCF    03.5
07BC:  RETURN
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... void saveUser(int * id, int * pass, int status){ 
....................    if( id[0] <= 99 && id[1] <= 99 && getAddressByID(id) == -1 ){ 
....................       int address = lastNewUserPosition(); 
....................  
....................       //recebe os parÃ¢metros do usuÃ¡rio 
....................       User user; 
....................       user.id[0] = id[0]; 
....................       user.id[1] = id[1]; 
....................       user.pass[0] = pass[0]; 
....................       user.pass[1] = pass[1]; 
....................       user.pass[2] = pass[2]; 
....................       user.pass[3] = pass[3]; 
....................       user.status = status; 
....................        
....................       write_ext_eeprom(address, user.id[0]); 
....................       write_ext_eeprom(address+1, user.id[1]); 
....................       write_ext_eeprom(address+2, user.pass[0]); 
....................       write_ext_eeprom(address+3, user.pass[1]); 
....................       write_ext_eeprom(address+4, user.pass[2]); 
....................       write_ext_eeprom(address+5, user.pass[3]);        
....................       write_ext_eeprom(address+6, user.status); 
....................  
....................       printf (lcd_escreve,"\fUsuario Cadastrado"); 
....................       delay_ms(500); 
....................  
....................    }else{ 
....................       printf (lcd_escreve,"\fID incompativel"); 
....................       printf (lcd_escreve,"\r\nTente novamente"); 
....................       delay_ms(1000); 
....................  
....................    } 
.................... } 
....................  
.................... void updateUser(int * id, int * pass, int status, int address){ 
....................    if( id[0] <= 99 && id[1] <= 99){ 
....................       //recebe os parÃ¢metros do usuÃ¡rio 
....................       User user; 
....................       user.id[0] = id[0]; 
....................       user.id[1] = id[1]; 
....................       user.pass[0] = pass[0]; 
....................       user.pass[1] = pass[1]; 
....................       user.pass[2] = pass[2]; 
....................       user.pass[3] = pass[3]; 
....................       user.status = status; 
....................        
....................       write_ext_eeprom(address, user.id[0]); 
....................       write_ext_eeprom(address+1, user.id[1]); 
....................       write_ext_eeprom(address+2, user.pass[0]); 
....................       write_ext_eeprom(address+3, user.pass[1]); 
....................       write_ext_eeprom(address+4, user.pass[2]); 
....................       write_ext_eeprom(address+5, user.pass[3]);        
....................       write_ext_eeprom(address+6, user.status); 
....................  
....................       printf (lcd_escreve,"\fUsuario Atualizado"); 
....................       delay_ms(500); 
....................  
....................    }else{ 
....................       printf (lcd_escreve,"\fID incompativel"); 
....................       printf (lcd_escreve,"\r\nTente novamente"); 
....................       delay_ms(1000); 
....................    } 
....................  
.................... } 
....................  
.................... void printUser(){ 
....................    //delay_ms(50); 
....................    int tmp_result = read_ext_eeprom(0);   
....................  
....................    delay_ms(50);   
....................     
....................    printf (lcd_escreve,"\f Button: %d", tmp_result); 
....................    printf(lcd_escreve, "\r\nPw:%d%d%d%d St:%d %d", read_ext_eeprom(1), read_ext_eeprom(2), read_ext_eeprom(3), read_ext_eeprom(4), read_ext_eeprom(5), read_ext_eeprom(6)); 
....................     
....................    //printf(lcd_escreve, "\f Client () elseÂ´{}{} 
....................    // printf(lcd_escreve, "\r\nPw:%c%c%c%c St:%c %c", U1.pass[0], U1.pass[1], U1.pass[2], U1.pass[3], U1.status, U1.type_usr); 
.................... } 
....................  
.................... int getAddressByID(int * id){ 
*
0A5A:  CLRF   7D
....................    int id_temp[2]; 
....................    int address = 0; 
....................     
....................    while( read_ext_eeprom(address) != -1){ 
0A5B:  MOVF   7D,W
0A5C:  BSF    03.5
0A5D:  MOVWF  2B
0A5E:  BCF    03.5
0A5F:  CALL   0BF
0A60:  MOVF   78,W
0A61:  SUBLW  FF
0A62:  BTFSC  03.2
0A63:  GOTO   2B6
....................       id_temp[0] = read_ext_eeprom(address); 
0A64:  MOVF   7D,W
0A65:  BSF    03.5
0A66:  MOVWF  2B
0A67:  BCF    03.5
0A68:  CALL   0BF
0A69:  MOVF   78,W
0A6A:  MOVWF  7B
....................       id_temp[1] = read_ext_eeprom(address+1); 
0A6B:  MOVLW  01
0A6C:  ADDWF  7D,W
0A6D:  BSF    03.5
0A6E:  MOVWF  20
0A6F:  MOVWF  2B
0A70:  BCF    03.5
0A71:  CALL   0BF
0A72:  MOVF   78,W
0A73:  MOVWF  7C
....................        
....................       if (id_temp[0] == id[0] && id_temp[1] == id[1]){ 
0A74:  MOVF   75,W
0A75:  MOVWF  04
0A76:  BCF    03.7
0A77:  BTFSC  76.0
0A78:  BSF    03.7
0A79:  MOVF   00,W
0A7A:  SUBWF  7B,W
0A7B:  BTFSS  03.2
0A7C:  GOTO   2B3
0A7D:  MOVLW  01
0A7E:  ADDWF  75,W
0A7F:  MOVWF  04
0A80:  BCF    03.7
0A81:  BTFSC  76.0
0A82:  BSF    03.7
0A83:  MOVF   00,W
0A84:  SUBWF  7C,W
0A85:  BTFSS  03.2
0A86:  GOTO   2B3
....................          printf (lcd_escreve,"\fID Existe:%u%u", id_temp[0],id_temp[1]); 
0A87:  MOVLW  C1
0A88:  BSF    03.6
0A89:  MOVWF  0D
0A8A:  MOVLW  00
0A8B:  MOVWF  0F
0A8C:  BCF    03.0
0A8D:  MOVLW  0B
0A8E:  BSF    03.5
0A8F:  BCF    03.6
0A90:  MOVWF  2C
0A91:  BCF    0A.3
0A92:  BCF    03.5
0A93:  CALL   506
0A94:  BSF    0A.3
0A95:  MOVF   7B,W
0A96:  BSF    03.5
0A97:  MOVWF  22
0A98:  MOVLW  1B
0A99:  MOVWF  23
0A9A:  BCF    03.5
0A9B:  CALL   1F2
0A9C:  MOVF   7C,W
0A9D:  BSF    03.5
0A9E:  MOVWF  22
0A9F:  MOVLW  1B
0AA0:  MOVWF  23
0AA1:  BCF    03.5
0AA2:  CALL   1F2
....................          delay_ms(1000); 
0AA3:  MOVLW  04
0AA4:  BSF    03.5
0AA5:  MOVWF  20
0AA6:  MOVLW  FA
0AA7:  MOVWF  32
0AA8:  BCF    0A.3
0AA9:  BCF    03.5
0AAA:  CALL   233
0AAB:  BSF    0A.3
0AAC:  BSF    03.5
0AAD:  DECFSZ 20,F
0AAE:  GOTO   2A6
....................          return address; 
0AAF:  MOVF   7D,W
0AB0:  MOVWF  78
0AB1:  GOTO   2FF
0AB2:  BCF    03.5
....................       } 
....................  
....................       address += BLOCK_SIZE;  
0AB3:  MOVLW  07
0AB4:  ADDWF  7D,F
0AB5:  GOTO   25B
....................    } 
....................    printf (lcd_escreve,"\fID:%u%u \r\nDisponivel",id[0],id[1]); 
0AB6:  MOVF   75,W
0AB7:  MOVWF  04
0AB8:  BCF    03.7
0AB9:  BTFSC  76.0
0ABA:  BSF    03.7
0ABB:  MOVF   00,W
0ABC:  BSF    03.5
0ABD:  MOVWF  20
0ABE:  MOVLW  01
0ABF:  ADDWF  75,W
0AC0:  MOVWF  04
0AC1:  BCF    03.7
0AC2:  BTFSC  76.0
0AC3:  BSF    03.7
0AC4:  MOVF   00,W
0AC5:  MOVWF  21
0AC6:  MOVLW  C9
0AC7:  BCF    03.5
0AC8:  BSF    03.6
0AC9:  MOVWF  0D
0ACA:  MOVLW  00
0ACB:  MOVWF  0F
0ACC:  BCF    03.0
0ACD:  MOVLW  04
0ACE:  BSF    03.5
0ACF:  BCF    03.6
0AD0:  MOVWF  2C
0AD1:  BCF    0A.3
0AD2:  BCF    03.5
0AD3:  CALL   506
0AD4:  BSF    0A.3
0AD5:  BSF    03.5
0AD6:  MOVF   20,W
0AD7:  MOVWF  22
0AD8:  MOVLW  1B
0AD9:  MOVWF  23
0ADA:  BCF    03.5
0ADB:  CALL   1F2
0ADC:  BSF    03.5
0ADD:  MOVF   21,W
0ADE:  MOVWF  22
0ADF:  MOVLW  1B
0AE0:  MOVWF  23
0AE1:  BCF    03.5
0AE2:  CALL   1F2
0AE3:  MOVLW  CD
0AE4:  BSF    03.6
0AE5:  MOVWF  0D
0AE6:  MOVLW  00
0AE7:  MOVWF  0F
0AE8:  BCF    03.0
0AE9:  MOVLW  0D
0AEA:  BSF    03.5
0AEB:  BCF    03.6
0AEC:  MOVWF  2C
0AED:  BCF    0A.3
0AEE:  BCF    03.5
0AEF:  CALL   506
0AF0:  BSF    0A.3
....................    delay_ms(1000); 
0AF1:  MOVLW  04
0AF2:  BSF    03.5
0AF3:  MOVWF  20
0AF4:  MOVLW  FA
0AF5:  MOVWF  32
0AF6:  BCF    0A.3
0AF7:  BCF    03.5
0AF8:  CALL   233
0AF9:  BSF    0A.3
0AFA:  BSF    03.5
0AFB:  DECFSZ 20,F
0AFC:  GOTO   2F4
....................    return -1; 
0AFD:  MOVLW  FF
0AFE:  MOVWF  78
.................... } 
....................  
.................... void searchUser(int * id){ 
....................  
....................    int address = getAddressByID(id); 
....................    if(address != -1){ 
....................       printf (lcd_escreve,"\fID:%u%u",id[0],id[1]); 
....................       int showStatus = 1; 
....................       getUserStatus(address,showStatus); 
....................    }else{ 
....................       printf(lcd_escreve,"\fUsuario N Existe"); 
....................       delay_ms(1000); 
....................    } 
.................... } 
....................  
.................... void erase_program_eeprom(int addrr){ 
....................    for(int i=0; i < BLOCK_SIZE; i++){ 
....................          write_ext_eeprom(addrr + i, -1); 
....................    }   
....................    printf (lcd_escreve,"\f User erased "); 
....................    delay_ms(200); 
.................... } 
....................  
.................... int getUserStatus(int address, int show){ 
*
0C2E:  MOVLW  07
0C2F:  ADDWF  75,W
0C30:  ADDLW  FF
0C31:  MOVWF  7C
0C32:  BSF    03.5
0C33:  MOVWF  2B
0C34:  BCF    03.5
0C35:  CALL   0BF
0C36:  MOVF   78,W
0C37:  MOVWF  7B
....................    int status = read_ext_eeprom(address+BLOCK_SIZE - 1); 
....................  
....................    if(show == 1){ 
0C38:  DECFSZ 76,W
0C39:  GOTO   47F
....................       char msg_status[10]; 
....................       if( status == 0){ 
0C3A:  MOVF   7B,F
0C3B:  BTFSS  03.2
0C3C:  GOTO   450
....................          strcpy(msg_status,"NAO PAGO"); 
0C3D:  CLRF   7C
0C3E:  CLRF   7D
0C3F:  MOVLW  A0
0C40:  MOVWF  04
0C41:  BCF    03.7
0C42:  MOVF   7C,W
0C43:  ADDWF  04,F
0C44:  MOVF   7D,W
0C45:  BCF    0A.3
0C46:  CALL   060
0C47:  BSF    0A.3
0C48:  MOVWF  00
0C49:  IORLW  00
0C4A:  BTFSC  03.2
0C4B:  GOTO   44F
0C4C:  INCF   7D,F
0C4D:  INCF   7C,F
0C4E:  GOTO   43F
....................       }else{ 
0C4F:  GOTO   462
....................          strcpy(msg_status,"PAGO"); 
0C50:  CLRF   7C
0C51:  CLRF   7D
0C52:  MOVLW  A0
0C53:  MOVWF  04
0C54:  BCF    03.7
0C55:  MOVF   7C,W
0C56:  ADDWF  04,F
0C57:  MOVF   7D,W
0C58:  BCF    0A.3
0C59:  CALL   06D
0C5A:  BSF    0A.3
0C5B:  MOVWF  00
0C5C:  IORLW  00
0C5D:  BTFSC  03.2
0C5E:  GOTO   462
0C5F:  INCF   7D,F
0C60:  INCF   7C,F
0C61:  GOTO   452
....................       } 
....................       printf (lcd_escreve,"\r\nStatus:%s",msg_status); 
0C62:  MOVLW  EA
0C63:  BSF    03.6
0C64:  MOVWF  0D
0C65:  MOVLW  00
0C66:  MOVWF  0F
0C67:  BCF    03.0
0C68:  MOVLW  09
0C69:  BSF    03.5
0C6A:  BCF    03.6
0C6B:  MOVWF  2C
0C6C:  BCF    0A.3
0C6D:  BCF    03.5
0C6E:  CALL   506
0C6F:  BSF    0A.3
0C70:  MOVLW  A0
0C71:  MOVWF  04
0C72:  BCF    03.7
0C73:  CALL   237
....................       delay_ms(1500); 
0C74:  MOVLW  06
0C75:  MOVWF  7C
0C76:  MOVLW  FA
0C77:  BSF    03.5
0C78:  MOVWF  32
0C79:  BCF    0A.3
0C7A:  BCF    03.5
0C7B:  CALL   233
0C7C:  BSF    0A.3
0C7D:  DECFSZ 7C,F
0C7E:  GOTO   476
....................    } 
....................    return status; 
0C7F:  MOVF   7B,W
0C80:  MOVWF  78
.................... } 
....................  
.................... int deleteUser(int * id){ 
....................     
....................    int address = getAddressByID(id); 
....................    if(address == -1) 
....................       return -1; 
....................    int data_temp; 
....................    int previous_block = address; 
....................    int next_block = address + BLOCK_SIZE; 
....................  
....................    //Case 1: without the next block 
....................    if (read_ext_eeprom(next_block) == -1){ 
....................       erase_program_eeprom(previous_block);       
....................       return 1; 
....................    } 
....................  
....................    //Case 2: Check whether the data in the next block address is empty 
....................    while(read_ext_eeprom(next_block) != -1){ 
....................       //data_temp[index] = read_ext_eeprom(address); 
....................       for(int i=0; i < BLOCK_SIZE; i++){ 
....................          //Read the data from the next block  
....................          data_temp = read_ext_eeprom(next_block + i);            
....................          //overwrite the previous block with the data from the next 
....................          write_ext_eeprom(previous_block + i, data_temp);   
....................       }   
....................       previous_block = next_block; 
....................       next_block += BLOCK_SIZE; 
....................    } 
....................    //Go back to erase the block that's duplicated  
....................    next_block -= BLOCK_SIZE; 
....................    //Erase the last block since everything  
....................    //moved a block_size to the left 
....................    erase_program_eeprom(next_block); 
....................     
....................    return 1; 
....................  
.................... } 
....................  
.................... int lastNewUserPosition(){ 
....................    int address = 0; 
....................    int id_temp; 
....................  
....................    while( read_ext_eeprom(address) != -1){ 
....................       address += BLOCK_SIZE;  
....................    } 
....................    // printf (lcd_escreve,"\fAddress: %u", address); 
....................    // delay_ms(500); 
....................     
....................    return address; 
....................  
.................... } 
....................  
.................... void resetMemory(){ 
....................    int address = 0; 
....................    for(; read_ext_eeprom(address) != -1; 
....................     erase_program_eeprom(address), address += BLOCK_SIZE); 
.................... } 
....................  
.................... void adminMenu(){ 
....................    unsigned char option; 
....................    unsigned int * temp; 
....................    unsigned int id [2]; 
....................    printf(lcd_escreve,"\f1: CAD Cliente "); 
....................    delay_ms(500); 
....................    printf(lcd_escreve,"\r\n2: Buscar Cliente"); 
....................    delay_ms(500); 
....................    printf(lcd_escreve,"\f3: DEL Cliente "); 
....................    delay_ms(500); 
....................    printf(lcd_escreve,"\r\n4: Editar Cliente"); 
....................    delay_ms(500); 
....................    printf(lcd_escreve,"\f5: SAIR do Menu "); 
....................    delay_ms(500); 
....................    do{ 
....................      
....................       option = readKeyboard(); 
....................       printf(lcd_escreve,"\f Option: %c", option); 
....................       delay_ms(500); 
....................  
....................  
....................       switch(option){ 
....................          case '1': 
....................             inputKeyboardUser(); 
....................             break; 
....................          case '2': 
....................             temp = inputId(); 
....................             id[0] = temp[0]; 
....................             id[1] = temp[1]; 
....................             searchUser(id); 
....................             break; 
....................          case '3': 
....................             temp = inputId(); 
....................             id[0] = temp[0]; 
....................             id[1] = temp[1]; 
....................             signed int success = deleteUser(id); 
....................             printf(lcd_escreve,"\fSuccess -> %d", success); 
....................             delay_ms(500); 
....................             (success >= 1)?  
....................             printf(lcd_escreve,"\fusuario deletado"): 
....................             printf(lcd_escreve,"\fusuario N Existe"); 
....................             delay_ms(500); 
....................             break; 
....................          case '4': 
....................             editUser(); 
....................             break; 
....................          default: 
....................             printf(lcd_escreve,"\fDigite um valor"); 
....................             printf(lcd_escreve,"\r\nValido!"); 
....................             delay_ms(500); 
....................             break; 
....................       } 
....................    }while(option != '5'); 
.................... } 
....................  
.................... void userMenu(){ 
....................  
....................    unsigned char option; 
....................    do{ 
....................       printf(lcd_escreve,"\f1:Login | 5:Sair"); 
....................       delay_ms(50); 
....................       option = readKeyboard(); 
....................       printf(lcd_escreve,"\r\n Option: %c", option); 
....................       delay_ms(500); 
....................  
....................  
....................       switch(option){ 
....................          case '1': 
....................             unsigned int * temp; 
....................             unsigned int id [2]; 
....................             temp = inputId(); 
....................             id[0] = temp[0]; 
....................             id[1] = temp[1]; 
....................             login(id); 
....................             break; 
....................          default: 
....................             printf(lcd_escreve,"\fDigite um valor"); 
....................             printf(lcd_escreve,"\r\nValido!"); 
....................             delay_ms(500); 
....................             break; 
....................       } 
....................    }while(option != '5'); 
.................... } 
....................  
.................... void login(int * id){ 
*
0A56:  MOVF   57,W
0A57:  MOVWF  76
0A58:  MOVF   56,W
0A59:  MOVWF  75
*
0AFF:  MOVF   78,W
0B00:  BCF    03.5
0B01:  MOVWF  58
....................  
....................    int address = getAddressByID(id); 
....................    if(address != -1){//User exists 
0B02:  MOVF   58,W
0B03:  SUBLW  FF
0B04:  BTFSC  03.2
0B05:  GOTO   50B
....................       unsigned int * temp; 
....................       unsigned int pass[4]; 
....................       unsigned int status; 
....................  
....................  
....................       char msg [] = "Digite a senha: "; 
0B06:  MOVLW  44
0B07:  MOVWF  60
0B08:  MOVLW  69
0B09:  MOVWF  61
0B0A:  MOVLW  67
0B0B:  MOVWF  62
0B0C:  MOVLW  69
0B0D:  MOVWF  63
0B0E:  MOVLW  74
0B0F:  MOVWF  64
0B10:  MOVLW  65
0B11:  MOVWF  65
0B12:  MOVLW  20
0B13:  MOVWF  66
0B14:  MOVLW  61
0B15:  MOVWF  67
0B16:  MOVLW  20
0B17:  MOVWF  68
0B18:  MOVLW  73
0B19:  MOVWF  69
0B1A:  MOVLW  65
0B1B:  MOVWF  6A
0B1C:  MOVLW  6E
0B1D:  MOVWF  6B
0B1E:  MOVLW  68
0B1F:  MOVWF  6C
0B20:  MOVLW  61
0B21:  MOVWF  6D
0B22:  MOVLW  3A
0B23:  MOVWF  6E
0B24:  MOVLW  20
0B25:  MOVWF  6F
0B26:  CLRF   70
....................       int max = 4; 
0B27:  MOVLW  04
0B28:  MOVWF  71
....................       temp = inputToKeyboard(msg, max); 
0B29:  CLRF   76
0B2A:  MOVLW  60
0B2B:  MOVWF  75
0B2C:  MOVF   71,W
0B2D:  MOVWF  7B
*
0BB4:  MOVF   79,W
0BB5:  BCF    03.5
0BB6:  MOVWF  5A
0BB7:  MOVF   78,W
0BB8:  MOVWF  59
....................       pass[0] = temp[0]; 
0BB9:  MOVF   59,W
0BBA:  MOVWF  04
0BBB:  BCF    03.7
0BBC:  BTFSC  5A.0
0BBD:  BSF    03.7
0BBE:  MOVF   00,W
0BBF:  MOVWF  5B
....................       pass[1] = temp[1]; 
0BC0:  MOVLW  01
0BC1:  ADDWF  59,W
0BC2:  MOVWF  04
0BC3:  BCF    03.7
0BC4:  BTFSC  5A.0
0BC5:  BSF    03.7
0BC6:  MOVF   00,W
0BC7:  MOVWF  5C
....................       pass[2] = temp[2]; 
0BC8:  MOVLW  02
0BC9:  ADDWF  59,W
0BCA:  MOVWF  04
0BCB:  BCF    03.7
0BCC:  BTFSC  5A.0
0BCD:  BSF    03.7
0BCE:  MOVF   00,W
0BCF:  MOVWF  5D
....................       pass[3] = temp[3]; 
0BD0:  MOVLW  03
0BD1:  ADDWF  59,W
0BD2:  MOVWF  04
0BD3:  BCF    03.7
0BD4:  BTFSC  5A.0
0BD5:  BSF    03.7
0BD6:  MOVF   00,W
0BD7:  MOVWF  5E
....................       int result_pass = checkPassword(address,pass); 
0BD8:  MOVF   58,W
0BD9:  MOVWF  75
0BDA:  CLRF   7C
0BDB:  MOVLW  5B
0BDC:  MOVWF  7B
*
0C23:  MOVF   78,W
0C24:  MOVWF  72
....................       if(result_pass == 0){ 
0C25:  MOVF   72,F
0C26:  BTFSS  03.2
0C27:  GOTO   4D8
....................          int show = 0; 
....................          int status = getUserStatus(address,show); 
0C28:  CLRF   73
0C29:  BCF    03.5
0C2A:  MOVF   58,W
0C2B:  MOVWF  75
0C2C:  MOVF   73,W
0C2D:  MOVWF  76
*
0C81:  MOVF   78,W
0C82:  MOVWF  74
....................          if(status == 1){//Paid 
0C83:  DECFSZ 74,W
0C84:  GOTO   4AE
....................             printf(lcd_escreve,"\fBem Vindo(a)!"); 
0C85:  MOVLW  6C
0C86:  BSF    03.6
0C87:  MOVWF  0D
0C88:  MOVLW  01
0C89:  MOVWF  0F
0C8A:  BCF    0A.3
0C8B:  BCF    03.6
0C8C:  CALL   32D
0C8D:  BSF    0A.3
....................             delay_ms(1000); 
0C8E:  MOVLW  04
0C8F:  MOVWF  75
0C90:  MOVLW  FA
0C91:  BSF    03.5
0C92:  MOVWF  32
0C93:  BCF    0A.3
0C94:  BCF    03.5
0C95:  CALL   233
0C96:  BSF    0A.3
0C97:  DECFSZ 75,F
0C98:  GOTO   490
....................             printf(lcd_escreve,"\fLiga Led e Rele"); 
0C99:  MOVLW  74
0C9A:  BSF    03.6
0C9B:  MOVWF  0D
0C9C:  MOVLW  01
0C9D:  MOVWF  0F
0C9E:  BCF    0A.3
0C9F:  BCF    03.6
0CA0:  CALL   32D
0CA1:  BSF    0A.3
....................             delay_ms(500); 
0CA2:  MOVLW  02
0CA3:  MOVWF  75
0CA4:  MOVLW  FA
0CA5:  BSF    03.5
0CA6:  MOVWF  32
0CA7:  BCF    0A.3
0CA8:  BCF    03.5
0CA9:  CALL   233
0CAA:  BSF    0A.3
0CAB:  DECFSZ 75,F
0CAC:  GOTO   4A4
....................          } 
0CAD:  GOTO   4D6
....................          else{//Unpaid 
....................             printf(lcd_escreve,"\fConta Existe"); 
0CAE:  MOVLW  7D
0CAF:  BSF    03.6
0CB0:  MOVWF  0D
0CB1:  MOVLW  01
0CB2:  MOVWF  0F
0CB3:  BCF    0A.3
0CB4:  BCF    03.6
0CB5:  CALL   32D
0CB6:  BSF    0A.3
....................             delay_ms(1000); 
0CB7:  MOVLW  04
0CB8:  MOVWF  75
0CB9:  MOVLW  FA
0CBA:  BSF    03.5
0CBB:  MOVWF  32
0CBC:  BCF    0A.3
0CBD:  BCF    03.5
0CBE:  CALL   233
0CBF:  BSF    0A.3
0CC0:  DECFSZ 75,F
0CC1:  GOTO   4B9
....................             printf(lcd_escreve,"\f,Mas Falta Pagar!"); 
0CC2:  MOVLW  84
0CC3:  BSF    03.6
0CC4:  MOVWF  0D
0CC5:  MOVLW  01
0CC6:  MOVWF  0F
0CC7:  BCF    0A.3
0CC8:  BCF    03.6
0CC9:  CALL   32D
0CCA:  BSF    0A.3
....................             delay_ms(500); 
0CCB:  MOVLW  02
0CCC:  MOVWF  75
0CCD:  MOVLW  FA
0CCE:  BSF    03.5
0CCF:  MOVWF  32
0CD0:  BCF    0A.3
0CD1:  BCF    03.5
0CD2:  CALL   233
0CD3:  BSF    0A.3
0CD4:  DECFSZ 75,F
0CD5:  GOTO   4CD
....................          } 
....................       }else{ 
0CD6:  GOTO   50A
0CD7:  BSF    03.5
....................          printf(lcd_escreve,"\fProcure a secretaria"); 
0CD8:  MOVLW  8E
0CD9:  BCF    03.5
0CDA:  BSF    03.6
0CDB:  MOVWF  0D
0CDC:  MOVLW  01
0CDD:  MOVWF  0F
0CDE:  BCF    0A.3
0CDF:  BCF    03.6
0CE0:  CALL   32D
0CE1:  BSF    0A.3
....................          printf(lcd_escreve,"\r\nP/ resolver"); 
0CE2:  MOVLW  99
0CE3:  BSF    03.6
0CE4:  MOVWF  0D
0CE5:  MOVLW  01
0CE6:  MOVWF  0F
0CE7:  BCF    0A.3
0CE8:  BCF    03.6
0CE9:  CALL   32D
0CEA:  BSF    0A.3
....................          delay_ms(1000); 
0CEB:  MOVLW  04
0CEC:  MOVWF  75
0CED:  MOVLW  FA
0CEE:  BSF    03.5
0CEF:  MOVWF  32
0CF0:  BCF    0A.3
0CF1:  BCF    03.5
0CF2:  CALL   233
0CF3:  BSF    0A.3
0CF4:  DECFSZ 75,F
0CF5:  GOTO   4ED
....................          printf(lcd_escreve,"\fNADA eh Ligado!"); 
0CF6:  MOVLW  A0
0CF7:  BSF    03.6
0CF8:  MOVWF  0D
0CF9:  MOVLW  01
0CFA:  MOVWF  0F
0CFB:  BCF    0A.3
0CFC:  BCF    03.6
0CFD:  CALL   32D
0CFE:  BSF    0A.3
....................          delay_ms(500); 
0CFF:  MOVLW  02
0D00:  MOVWF  75
0D01:  MOVLW  FA
0D02:  BSF    03.5
0D03:  MOVWF  32
0D04:  BCF    0A.3
0D05:  BCF    03.5
0D06:  CALL   233
0D07:  BSF    0A.3
0D08:  DECFSZ 75,F
0D09:  GOTO   501
....................       } 
....................    } 
0D0A:  GOTO   528
....................    else{ 
....................       printf(lcd_escreve,"\fID N Existe"); 
0D0B:  MOVLW  A9
0D0C:  BSF    03.6
0D0D:  MOVWF  0D
0D0E:  MOVLW  01
0D0F:  MOVWF  0F
0D10:  BCF    0A.3
0D11:  BCF    03.6
0D12:  CALL   32D
0D13:  BSF    0A.3
....................       printf(lcd_escreve,"\r\nTente de novo"); 
0D14:  MOVLW  B0
0D15:  BSF    03.6
0D16:  MOVWF  0D
0D17:  MOVLW  01
0D18:  MOVWF  0F
0D19:  BCF    0A.3
0D1A:  BCF    03.6
0D1B:  CALL   32D
0D1C:  BSF    0A.3
....................       delay_ms(1000); 
0D1D:  MOVLW  04
0D1E:  MOVWF  75
0D1F:  MOVLW  FA
0D20:  BSF    03.5
0D21:  MOVWF  32
0D22:  BCF    0A.3
0D23:  BCF    03.5
0D24:  CALL   233
0D25:  BSF    0A.3
0D26:  DECFSZ 75,F
0D27:  GOTO   51F
....................    } 
0D28:  BSF    0A.3
0D29:  BCF    0A.4
0D2A:  GOTO   58F (RETURN)
....................  
.................... } 
....................  
.................... int checkPassword(int initBlockAddr, int * pass){ 
*
0BDD:  MOVLW  02
0BDE:  ADDWF  75,W
0BDF:  MOVWF  76
0BE0:  MOVF   7C,W
0BE1:  BSF    03.5
0BE2:  MOVWF  22
0BE3:  MOVF   7B,W
0BE4:  MOVWF  21
*
0C02:  MOVF   78,W
0C03:  MOVWF  7D
....................    int pass_addr = initBlockAddr + 2; 
....................    int len = strlen(pass);  
....................    for(int i=0; i < len;i++,pass_addr++){ 
0C04:  CLRF   7E
0C05:  MOVF   7D,W
0C06:  SUBWF  7E,W
0C07:  BTFSC  03.0
0C08:  GOTO   421
....................       if(pass[i] != read_ext_eeprom(pass_addr)) 
0C09:  MOVF   7E,W
0C0A:  ADDWF  7B,W
0C0B:  MOVWF  04
0C0C:  BCF    03.7
0C0D:  BTFSC  7C.0
0C0E:  BSF    03.7
0C0F:  MOVF   00,W
0C10:  MOVWF  20
0C11:  MOVF   76,W
0C12:  MOVWF  2B
0C13:  BCF    03.5
0C14:  CALL   0BF
0C15:  MOVF   78,W
0C16:  BSF    03.5
0C17:  SUBWF  20,W
0C18:  BTFSC  03.2
0C19:  GOTO   41D
....................          return -1; 
0C1A:  MOVLW  FF
0C1B:  MOVWF  78
0C1C:  GOTO   423
0C1D:  MOVF   7E,W
0C1E:  INCF   7E,F
0C1F:  INCF   76,F
0C20:  GOTO   405
....................    } 
....................    return 0; 
0C21:  MOVLW  00
0C22:  MOVWF  78
....................  
.................... } 
.................... unsigned char readKeyboard(){ 
....................  
....................    unsigned char tmp; 
....................    unsigned char tmp_result; 
....................     
....................    tmp = tc_tecla(1500); // ms 
*
03A1:  MOVLW  DC
03A2:  BSF    03.5
03A3:  MOVWF  2E
*
04F3:  MOVF   78,W
04F4:  MOVWF  2C
....................    if(tmp != 255){ 
04F5:  INCFSZ 2C,W
04F6:  GOTO   4F8
04F7:  GOTO   4F9
....................       // write_ext_eeprom(0, tmp); 
....................       // delay_ms(50); 
....................       // tmp_result = read_ext_eeprom(0); 
....................       // delay_ms(50); 
....................       // tmp_result = tmp; 
....................       // printf(lcd_escreve,"\f Button: %c", tmp); 
....................       // delay_ms(50); 
....................    }else{  
04F8:  GOTO   502
....................       printf(lcd_escreve,"\f   TECLADO  "); 
04F9:  MOVLW  B8
04FA:  BCF    03.5
04FB:  BSF    03.6
04FC:  MOVWF  0D
04FD:  MOVLW  01
04FE:  MOVWF  0F
04FF:  BCF    03.6
0500:  CALL   32D
0501:  BSF    03.5
....................    } 
....................  
....................    return tmp; 
0502:  MOVF   2C,W
0503:  MOVWF  78
0504:  BCF    03.5
0505:  RETURN
.................... } 
....................  
....................  
.................... int * getAdminsID(){ 
....................  
....................    int address = 0; 
....................    int temp_status; 
....................    int index= 0; 
....................    static int admins[BLOCK_SIZE]; 
*
0D3F:  CLRF   44
0D40:  CLRF   45
0D41:  CLRF   46
0D42:  CLRF   47
0D43:  CLRF   48
0D44:  CLRF   49
0D45:  CLRF   4A
....................    admins[0] = -1; 
....................    while( read_ext_eeprom(address) != -1){ 
....................       temp_status = read_ext_eeprom(address + (BLOCK_SIZE - 1));//status of the user 
....................       if (temp_status == 3){ 
....................          printf (lcd_escreve,"\fAdmin Encontrado"); 
....................          delay_ms(1000); 
....................          for(int i=0; i < 2; i++){ 
....................             int id = read_ext_eeprom(address+i);    
....................             admins[index] = id; 
....................             index++; 
....................          } 
....................  
....................       } 
....................  
....................       address += BLOCK_SIZE;  
....................    } 
....................  
....................    return admins; 
....................  
.................... } 
....................  
.................... void listAdmins(){ 
....................    int * admins; 
....................  
....................    admins = getAdminsID(); 
....................    printf(lcd_escreve,"\f admins[0]: %d", admins[0]); 
....................    delay_ms(1000); 
....................    if(admins[0] != -1){ 
....................       for (int16 i=0; i < sizeof(admins); i+=2){ 
....................          printf(lcd_escreve, "\fid:%u%u",admins[i], admins[i+1]); 
....................          delay_ms(1000); 
....................       }  
....................    } 
.................... } 
....................  
....................  
.................... int * strToInt(char * str){ 
*
07BD:  BSF    03.5
07BE:  MOVF   2D,W
07BF:  MOVWF  2F
07C0:  MOVF   2C,W
07C1:  MOVWF  2E
07C2:  CLRF   32
....................  
....................   char *p = str; 
....................   //https://flaviocopes.com/c-array-length/ 
....................   static unsigned int buffer[BLOCK_SIZE];   
*
0D46:  CLRF   4B
0D47:  CLRF   4C
0D48:  CLRF   4D
0D49:  CLRF   4E
0D4A:  CLRF   4F
0D4B:  CLRF   50
0D4C:  CLRF   51
....................   char * end; 
....................   int index = 0; 
....................  
....................   for (unsigned int number = strtoul(p, &end, 10); 
*
07C3:  MOVF   2F,W
07C4:  MOVWF  35
07C5:  MOVF   2E,W
07C6:  MOVWF  34
07C7:  CLRF   37
07C8:  MOVLW  B0
07C9:  MOVWF  36
07CA:  MOVLW  0A
07CB:  MOVWF  38
07CC:  BCF    03.5
07CD:  CALL   5AB
07CE:  MOVF   78,W
07CF:  BSF    03.5
07D0:  MOVWF  33
....................         p != end; 
07D1:  MOVF   30,W
07D2:  SUBWF  2E,W
07D3:  BTFSS  03.2
07D4:  GOTO   7D9
07D5:  MOVF   31,W
07D6:  SUBWF  2F,W
07D7:  BTFSC  03.2
07D8:  GOTO   7F3
....................         number = strtoul(p, &end, 10)) 
....................   { 
....................     p = end; 
07D9:  MOVF   31,W
07DA:  MOVWF  2F
07DB:  MOVF   30,W
07DC:  MOVWF  2E
....................  
....................     buffer[index] = number;  
07DD:  MOVLW  4B
07DE:  ADDWF  32,W
07DF:  MOVWF  04
07E0:  BCF    03.7
07E1:  MOVF   33,W
07E2:  MOVWF  00
....................     index++; 
07E3:  INCF   32,F
07E4:  MOVF   2F,W
07E5:  MOVWF  35
07E6:  MOVF   2E,W
07E7:  MOVWF  34
07E8:  CLRF   37
07E9:  MOVLW  B0
07EA:  MOVWF  36
07EB:  MOVLW  0A
07EC:  MOVWF  38
07ED:  BCF    03.5
07EE:  CALL   5AB
07EF:  MOVF   78,W
07F0:  BSF    03.5
07F1:  MOVWF  33
07F2:  GOTO   7D1
....................   } 
....................  
....................    return buffer; 
07F3:  MOVLW  4B
07F4:  MOVWF  78
07F5:  MOVLW  00
07F6:  MOVWF  79
07F7:  BCF    03.5
07F8:  RETURN
.................... } 
....................  
.................... char * strfromchar(char destination[], char source)  
.................... {  
....................    destination[0] = source;   // copy the character into the string  
*
0B75:  MOVF   2C,W
0B76:  MOVWF  04
0B77:  BCF    03.7
0B78:  BTFSC  2D.0
0B79:  BSF    03.7
0B7A:  MOVF   2E,W
0B7B:  MOVWF  00
....................    destination[1] = '\0';      // null-terminate the string  
0B7C:  MOVLW  01
0B7D:  ADDWF  2C,W
0B7E:  MOVWF  04
0B7F:  BCF    03.7
0B80:  BTFSC  2D.0
0B81:  BSF    03.7
0B82:  CLRF   00
....................   
....................    return destination;         // common convention for str functions  
0B83:  MOVF   2C,W
0B84:  MOVWF  78
0B85:  MOVF   2D,W
0B86:  MOVWF  79
.................... }  
....................  
....................  
.................... int * inputId(){ 
*
0800:  CLRF   67
....................    unsigned char keyboard_buffer[BLOCK_SIZE * 2]; 
....................    unsigned char option; 
....................  
....................    int * temp; 
....................    int i = 0; 
....................    //The user needs to type 4 digits 
....................    //For example, even if it's just 9 
....................    //He/she will type: 0009 
....................    while(i < 5){ 
0801:  MOVF   67,W
0802:  SUBLW  04
0803:  BTFSS  03.0
0804:  GOTO   050
....................       printf(lcd_escreve,"\fDigite o ID: "); 
0805:  MOVLW  D5
0806:  BSF    03.6
0807:  MOVWF  0D
0808:  MOVLW  01
0809:  MOVWF  0F
080A:  BCF    0A.3
080B:  BCF    03.6
080C:  CALL   32D
080D:  BSF    0A.3
....................       delay_ms(50); 
080E:  MOVLW  32
080F:  BSF    03.5
0810:  MOVWF  32
0811:  BCF    0A.3
0812:  BCF    03.5
0813:  CALL   233
0814:  BSF    0A.3
....................       option = readKeyboard(); 
0815:  BCF    0A.3
0816:  CALL   3A1
0817:  BSF    0A.3
0818:  MOVF   78,W
0819:  MOVWF  64
....................       printf(lcd_escreve,"\n\rTyped:%c", option); 
081A:  MOVLW  DD
081B:  BSF    03.6
081C:  MOVWF  0D
081D:  MOVLW  01
081E:  MOVWF  0F
081F:  BCF    03.0
0820:  MOVLW  08
0821:  BSF    03.5
0822:  BCF    03.6
0823:  MOVWF  2C
0824:  BCF    0A.3
0825:  BCF    03.5
0826:  CALL   506
0827:  BSF    0A.3
0828:  MOVF   64,W
0829:  BSF    03.5
082A:  MOVWF  31
082B:  BCF    0A.3
082C:  BCF    03.5
082D:  CALL   2EA
082E:  BSF    0A.3
....................       delay_ms(400); 
082F:  MOVLW  02
0830:  MOVWF  68
0831:  MOVLW  C8
0832:  BSF    03.5
0833:  MOVWF  32
0834:  BCF    0A.3
0835:  BCF    03.5
0836:  CALL   233
0837:  BSF    0A.3
0838:  DECFSZ 68,F
0839:  GOTO   031
....................       if(option != 255){ 
083A:  INCFSZ 64,W
083B:  GOTO   03D
083C:  GOTO   04F
....................          if(i == 2){ 
083D:  MOVF   67,W
083E:  SUBLW  02
083F:  BTFSS  03.2
0840:  GOTO   048
....................             //To convert to int will be easier with space between them 
....................             keyboard_buffer[i] = ' '; 
0841:  MOVLW  56
0842:  ADDWF  67,W
0843:  MOVWF  04
0844:  BCF    03.7
0845:  MOVLW  20
0846:  MOVWF  00
....................             i++; 
0847:  INCF   67,F
....................          } 
....................          keyboard_buffer[i] = option; 
0848:  MOVLW  56
0849:  ADDWF  67,W
084A:  MOVWF  04
084B:  BCF    03.7
084C:  MOVF   64,W
084D:  MOVWF  00
....................          i++; 
084E:  INCF   67,F
....................       } 
084F:  GOTO   001
....................    } 
....................    // unsigned char *id; 
....................    // id = keyboard_buffer; 
....................    temp = strToInt(keyboard_buffer); 
0850:  BSF    03.5
0851:  CLRF   2D
0852:  MOVLW  56
0853:  MOVWF  2C
0854:  BCF    0A.3
0855:  BCF    03.5
0856:  CALL   7BD
0857:  BSF    0A.3
0858:  MOVF   79,W
0859:  MOVWF  66
085A:  MOVF   78,W
085B:  MOVWF  65
....................    return temp; 
085C:  MOVF   65,W
085D:  MOVWF  78
085E:  MOVF   66,W
085F:  MOVWF  79
0860:  BSF    0A.3
0861:  BCF    0A.4
0862:  GOTO   578 (RETURN)
....................    // id[0] = temp[0]; 
....................    // id[1] = temp[1]; 
....................    // //https://www.tutorialspoint.com/cprogramming/c_pointer_to_an_array.htm 
....................    // //*(id+1) == id[1] 
....................    // printf(lcd_escreve,"\fid: %u%u",id[0],id[1]); 
....................    // delay_ms(1000); 
.................... } 
....................  
.................... int * inputToKeyboard(char * msg, int max){ 
*
0B2E:  BSF    03.5
0B2F:  CLRF   27
....................    unsigned char option; 
....................    int data[BLOCK_SIZE]; 
....................    int * temp; 
....................    int i = 0; 
....................  
....................    while(i < max){ 
0B30:  MOVF   7B,W
0B31:  SUBWF  27,W
0B32:  BTFSC  03.0
0B33:  GOTO   3AD
....................  
....................       printf(lcd_escreve,"\f%s", msg); 
0B34:  MOVLW  0C
0B35:  MOVWF  31
0B36:  BCF    0A.3
0B37:  BCF    03.5
0B38:  CALL   2EA
0B39:  BSF    0A.3
0B3A:  MOVF   75,W
0B3B:  MOVWF  04
0B3C:  BCF    03.7
0B3D:  BTFSC  76.0
0B3E:  BSF    03.7
0B3F:  CALL   237
....................       delay_ms(50); 
0B40:  MOVLW  32
0B41:  BSF    03.5
0B42:  MOVWF  32
0B43:  BCF    0A.3
0B44:  BCF    03.5
0B45:  CALL   233
0B46:  BSF    0A.3
....................       option = readKeyboard(); 
0B47:  BCF    0A.3
0B48:  CALL   3A1
0B49:  BSF    0A.3
0B4A:  MOVF   78,W
0B4B:  MOVWF  7C
....................       printf(lcd_escreve,"\n\rTyped:%c", option); 
0B4C:  MOVLW  E3
0B4D:  BSF    03.6
0B4E:  MOVWF  0D
0B4F:  MOVLW  01
0B50:  MOVWF  0F
0B51:  BCF    03.0
0B52:  MOVLW  08
0B53:  BSF    03.5
0B54:  BCF    03.6
0B55:  MOVWF  2C
0B56:  BCF    0A.3
0B57:  BCF    03.5
0B58:  CALL   506
0B59:  BSF    0A.3
0B5A:  MOVF   7C,W
0B5B:  BSF    03.5
0B5C:  MOVWF  31
0B5D:  BCF    0A.3
0B5E:  BCF    03.5
0B5F:  CALL   2EA
0B60:  BSF    0A.3
....................       delay_ms(400); 
0B61:  MOVLW  02
0B62:  BSF    03.5
0B63:  MOVWF  2A
0B64:  MOVLW  C8
0B65:  MOVWF  32
0B66:  BCF    0A.3
0B67:  BCF    03.5
0B68:  CALL   233
0B69:  BSF    0A.3
0B6A:  BSF    03.5
0B6B:  DECFSZ 2A,F
0B6C:  GOTO   364
....................       if(option != 255){ 
0B6D:  INCFSZ 7C,W
0B6E:  GOTO   370
0B6F:  GOTO   3AC
....................          unsigned char destination[2]; 
....................          //Convert string from char and return  
....................          //to the left array of char(str_pass) 
....................          strfromchar(destination,option); 
0B70:  CLRF   2D
0B71:  MOVLW  A8
0B72:  MOVWF  2C
0B73:  MOVF   7C,W
0B74:  MOVWF  2E
....................          temp = strToInt(destination); 
*
0B87:  CLRF   2D
0B88:  MOVLW  A8
0B89:  MOVWF  2C
0B8A:  BCF    0A.3
0B8B:  BCF    03.5
0B8C:  CALL   7BD
0B8D:  BSF    0A.3
0B8E:  MOVF   79,W
0B8F:  MOVWF  7E
0B90:  MOVF   78,W
0B91:  MOVWF  7D
....................          data[i] = temp[0]; 
0B92:  MOVLW  A0
0B93:  BSF    03.5
0B94:  ADDWF  27,W
0B95:  MOVWF  78
0B96:  CLRF   7A
0B97:  BTFSC  03.0
0B98:  INCF   7A,F
0B99:  MOVF   78,W
0B9A:  MOVWF  2A
0B9B:  MOVF   7A,W
0B9C:  MOVWF  2B
0B9D:  MOVF   7D,W
0B9E:  MOVWF  04
0B9F:  BCF    03.7
0BA0:  BTFSC  7E.0
0BA1:  BSF    03.7
0BA2:  MOVF   00,W
0BA3:  MOVWF  2C
0BA4:  MOVF   2A,W
0BA5:  MOVWF  04
0BA6:  BCF    03.7
0BA7:  BTFSC  2B.0
0BA8:  BSF    03.7
0BA9:  MOVF   2C,W
0BAA:  MOVWF  00
....................          i++; 
0BAB:  INCF   27,F
....................       } 
0BAC:  GOTO   330
....................    } 
....................  
....................    temp = data; 
0BAD:  CLRF   7E
0BAE:  MOVLW  A0
0BAF:  MOVWF  7D
....................    return temp; 
0BB0:  MOVF   7D,W
0BB1:  MOVWF  78
0BB2:  MOVF   7E,W
0BB3:  MOVWF  79
....................    // printf(lcd_escreve,"\fPASS(4): %u%u%u%u",pass[0],pass[1],pass[2],pass[3]); 
....................    // delay_ms(1000); 
....................  
.................... } 
.................... void inputKeyboardUser(){ 
....................  
....................    unsigned int * temp; 
....................    unsigned int id [2]; 
....................    unsigned int pass[4]; 
....................    unsigned int status; 
....................  
....................    temp = inputId(); 
....................    id[0] = temp[0]; 
....................    id[1] = temp[1]; 
....................    printf(lcd_escreve,"\fid: %u%u",id[0],id[1]); 
....................    delay_ms(500); 
....................  
....................    char msg [] = "Digite a senha: "; 
....................    int max = 4; 
....................    temp = inputToKeyboard(msg, max); 
....................    pass[0] = temp[0]; 
....................    pass[1] = temp[1]; 
....................    pass[2] = temp[2]; 
....................    pass[3] = temp[3]; 
....................    printf(lcd_escreve,"\fPASS(4): %u%u%u%u",pass[0],pass[1],pass[2],pass[3]); 
....................    delay_ms(500); 
....................  
....................    char msg2 [] = "Status (0,1,3): "; 
....................    max = 1; 
....................    temp = inputToKeyboard(msg2, max); 
....................    status = temp[0]; 
....................    printf(lcd_escreve,"\fSTATUS: %u",status); 
....................    delay_ms(500); 
....................  
....................    saveUser(id,pass,status); 
.................... } 
....................  
.................... void editUser(){ 
....................    unsigned int * temp; 
....................    unsigned int id [2]; 
....................    temp = inputId(); 
....................    id[0] = temp[0]; 
....................    id[1] = temp[1]; 
....................  
....................    int address = getAddressByID(id); 
....................    if(address != -1){ 
....................       unsigned int * temp; 
....................       unsigned int pass[4]; 
....................       unsigned int status; 
....................  
....................       char msg [] = "Digite a senha: "; 
....................       int max = 4; 
....................       temp = inputToKeyboard(msg, max); 
....................       pass[0] = temp[0]; 
....................       pass[1] = temp[1]; 
....................       pass[2] = temp[2]; 
....................       pass[3] = temp[3]; 
....................       printf(lcd_escreve,"\fPASS(4): %u%u%u%u",pass[0],pass[1],pass[2],pass[3]); 
....................       delay_ms(500); 
....................  
....................       char msg2 [] = "Status (0,1,3): "; 
....................       max = 1; 
....................       temp = inputToKeyboard(msg2, max); 
....................       status = temp[0]; 
....................       printf(lcd_escreve,"\fSTATUS: %u",status); 
....................       delay_ms(500); 
....................  
....................       updateUser(id,pass,status,address); 
....................    }else{ 
....................       printf (lcd_escreve,"\fID N Existe",); 
....................       delay_ms(500); 
....................    } 
.................... } 
....................  
....................  
.................... /* 
.................... // ---- MSG from serial communication 
.................... #int_RDA 
.................... void RDA_isr(void){ 
....................    rx_buffer[rx_wr_index] = getc(); 
....................    rxd = rx_buffer[rx_wr_index]; 
....................    rx_wr_index++; 
....................  
....................    if(rx_wr_index > RX_BUFFER_SIZE){ 
....................       rx_wr_index = 0; 
....................    } 
....................  
....................    //Look for unique ID: "IFMT" 
....................    if(rxd == 'I' && lock_pos == 0){ 
....................       lock_pos++; 
....................    } 
....................    else if(rxd == 'F' && lock_pos == 1){ 
....................       lock_pos++; 
....................    } 
....................    else if(rxd == 'M' && lock_pos == 2){ 
....................       lock_pos++; 
....................    } 
....................    else if(rxd == 'T' && lock_pos == 3){ 
....................       lock_pos=0; //Reset the "combination lock" 
....................       got_id = TRUE; 
....................       read = rxd; 
....................       //get ready to count the number of data bytes 
....................       valid_data_count = 0xff;  
....................  
....................       //buffer is reset to index 0 
....................       rx_wr_index = 0; 
....................    }else { 
....................       lock_pos = 0; 
....................    } 
....................  
....................    if(got_id && ++valid_data_count >= 6){ 
....................       data_avail = TRUE; 
....................       got_id = FALSE; 
....................    } 
....................     
.................... } 
.................... */ 
....................  
....................  
....................  
....................  
.................... #int_TIMER1 
.................... void TIMER1_isr(void) 
.................... { 
.................... } 
....................  
*
0215:  BCF    0C.0
0216:  BCF    0A.3
0217:  BCF    0A.4
0218:  GOTO   031
.................... #int_RTCC 
.................... void RTCC_isr(void) 
.................... { 
....................  
....................        
0219:  BCF    0B.2
021A:  BCF    0A.3
021B:  BCF    0A.4
021C:  GOTO   031
.................... } 
....................  
.................... void main() 
*
0D2B:  MOVF   03,W
0D2C:  ANDLW  1F
0D2D:  MOVWF  03
0D2E:  CLRF   2C
0D2F:  CLRF   2D
0D30:  CLRF   31
0D31:  CLRF   32
0D32:  MOVLW  FF
0D33:  MOVWF  3D
0D34:  BSF    03.5
0D35:  BSF    1F.0
0D36:  BSF    1F.1
0D37:  BSF    1F.2
0D38:  BCF    1F.3
0D39:  MOVLW  07
0D3A:  MOVWF  1C
0D3B:  BCF    03.7
.................... { 
....................    //VARIAVEIS 
....................  
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_256|RTCC_8_bit);      //13.1ms overflow 
*
0D4D:  BSF    03.5
0D4E:  MOVF   01,W
0D4F:  ANDLW  C0
0D50:  IORLW  07
0D51:  MOVWF  01
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); //Overflow in 104ms | Resolution 1.6 us 
0D52:  MOVLW  B5
0D53:  BCF    03.5
0D54:  MOVWF  10
....................    init_ext_eeprom(); 
0D55:  BCF    0A.3
0D56:  GOTO   226
0D57:  BSF    0A.3
....................    enable_interrupts(INT_TIMER0); 
0D58:  BSF    0B.5
....................    enable_interrupts(INT_TIMER1); 
0D59:  BSF    03.5
0D5A:  BSF    0C.0
....................    enable_interrupts(GLOBAL); 
0D5B:  MOVLW  C0
0D5C:  BCF    03.5
0D5D:  IORWF  0B,F
....................  
....................    lcd_ini(); 
0D5E:  BCF    0A.3
0D5F:  GOTO   2A1
0D60:  BSF    0A.3
....................    delay_us(50); 
0D61:  MOVLW  52
0D62:  MOVWF  77
0D63:  DECFSZ 77,F
0D64:  GOTO   563
0D65:  GOTO   566
0D66:  NOP
....................  
....................    printf(lcd_escreve, "\f  iniciando... "); 
0D67:  MOVLW  1D
0D68:  BSF    03.6
0D69:  MOVWF  0D
0D6A:  MOVLW  02
0D6B:  MOVWF  0F
0D6C:  BCF    0A.3
0D6D:  BCF    03.6
0D6E:  CALL   32D
0D6F:  BSF    0A.3
....................    delay_ms(200); 
0D70:  MOVLW  C8
0D71:  BSF    03.5
0D72:  MOVWF  32
0D73:  BCF    0A.3
0D74:  BCF    03.5
0D75:  CALL   233
0D76:  BSF    0A.3
....................  
....................    // printf(lcd_escreve, "\fIFMT - Serial"); 
....................    // delay_ms(50); 
....................  
....................    // resetmemory(); 
....................  
....................    // int id [2] = {12,34}; 
....................    // int pass [4] = {1,2,3,4}; 
....................    // saveuser(id, pass, 1); 
....................    // int id1 [2] = {14,0}; 
....................    // saveuser(id1, pass, 0); 
....................    // int id2 [2] = {70,10}; 
....................    // saveuser(id2, pass, 1); 
....................    // int id3 [2] = {0,10}; 
....................    // saveuser(id3, pass, 1); 
....................    // int id4 [2] = {99,99}; 
....................    // saveuser(id4, pass, 3);//admin 
....................     
....................     
....................    // userMenu(); 
....................    unsigned int * temp; 
....................    unsigned int id [2]; 
....................    temp = inputId(); 
0D77:  GOTO   000
0D78:  MOVF   79,W
0D79:  MOVWF  53
0D7A:  MOVF   78,W
0D7B:  MOVWF  52
....................    id[0] = temp[0]; 
0D7C:  MOVF   52,W
0D7D:  MOVWF  04
0D7E:  BCF    03.7
0D7F:  BTFSC  53.0
0D80:  BSF    03.7
0D81:  MOVF   00,W
0D82:  MOVWF  54
....................    id[1] = temp[1]; 
0D83:  MOVLW  01
0D84:  ADDWF  52,W
0D85:  MOVWF  04
0D86:  BCF    03.7
0D87:  BTFSC  53.0
0D88:  BSF    03.7
0D89:  MOVF   00,W
0D8A:  MOVWF  55
....................    login(id); 
0D8B:  CLRF   57
0D8C:  MOVLW  54
0D8D:  MOVWF  56
0D8E:  GOTO   256
....................  
....................  
....................  
.................... } 
....................  
0D8F:  SLEEP

Configuration Fuses:
   Word  1: 3F32   HS NOWDT PUT NOBROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT

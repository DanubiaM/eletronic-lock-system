CCS PCM C Compiler, Version 5.025, 7201               23-Nov-21 21:43

               Filename:   E:\University\Microcontrollers\PCW Projects\eletronic-lock-system\PIC controller\main.lst

               ROM used:   2289 words (28%)
                           Largest free fragment is 2048
               RAM used:   89 (24%) at main() level
                           228 (62%) worst case
               Stack used: 5 locations (4 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  08
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  MOVLW  8C
0028:  MOVWF  04
0029:  BTFSS  00.5
002A:  GOTO   02D
002B:  BTFSC  0C.5
002C:  GOTO   04E
002D:  MOVF   22,W
002E:  MOVWF  04
002F:  MOVF   23,W
0030:  MOVWF  77
0031:  MOVF   24,W
0032:  MOVWF  78
0033:  MOVF   25,W
0034:  MOVWF  79
0035:  MOVF   26,W
0036:  MOVWF  7A
0037:  MOVF   27,W
0038:  BSF    03.6
0039:  MOVWF  0D
003A:  BCF    03.6
003B:  MOVF   28,W
003C:  BSF    03.6
003D:  MOVWF  0F
003E:  BCF    03.6
003F:  MOVF   29,W
0040:  BSF    03.6
0041:  MOVWF  0C
0042:  BCF    03.6
0043:  MOVF   2A,W
0044:  BSF    03.6
0045:  MOVWF  0E
0046:  BCF    03.6
0047:  MOVF   20,W
0048:  MOVWF  0A
0049:  SWAPF  21,W
004A:  MOVWF  03
004B:  SWAPF  7F,F
004C:  SWAPF  7F,W
004D:  RETFIE
004E:  BCF    0A.3
004F:  BCF    0A.4
0050:  GOTO   1D5
....................  
.................... #include <16F877A.h> 
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
0051:  BCF    0A.0
0052:  BCF    0A.1
0053:  BCF    0A.2
0054:  ADDWF  02,F
0055:  RETLW  28
0056:  RETLW  0F
0057:  RETLW  01
0058:  RETLW  06
0059:  DATA 8C,2A
005A:  DATA F3,3A
005B:  DATA 61,39
005C:  DATA E9,37
005D:  DATA A0,21
005E:  DATA 61,32
005F:  DATA E1,39
0060:  DATA 74,39
0061:  DATA 61,32
0062:  DATA 6F,00
0063:  DATA 8C,24
0064:  DATA 44,10
0065:  DATA 69,37
0066:  DATA E3,37
0067:  DATA 6D,38
0068:  DATA 61,3A
0069:  DATA 69,3B
006A:  DATA 65,36
006B:  DATA 00,01
006C:  DATA 0D,05
006D:  DATA D4,32
006E:  DATA 6E,3A
006F:  DATA 65,10
0070:  DATA EE,37
0071:  DATA F6,30
0072:  DATA ED,32
0073:  DATA 6E,3A
0074:  DATA 65,00
0075:  DATA 8C,2A
0076:  DATA F3,3A
0077:  DATA 61,39
0078:  DATA E9,37
0079:  DATA A0,20
007A:  DATA F4,3A
007B:  DATA 61,36
007C:  DATA 69,3D
007D:  DATA 61,32
007E:  DATA 6F,00
007F:  DATA 8C,24
0080:  DATA 44,10
0081:  DATA 69,37
0082:  DATA E3,37
0083:  DATA 6D,38
0084:  DATA 61,3A
0085:  DATA 69,3B
0086:  DATA 65,36
0087:  DATA 00,01
0088:  DATA 0D,05
0089:  DATA D4,32
008A:  DATA 6E,3A
008B:  DATA 65,10
008C:  DATA EE,37
008D:  DATA F6,30
008E:  DATA ED,32
008F:  DATA 6E,3A
0090:  DATA 65,00
0091:  DATA 0D,05
0092:  DATA D0,3B
0093:  DATA BA,12
0094:  DATA F5,12
0095:  DATA F5,12
0096:  DATA F5,12
0097:  DATA 75,10
0098:  DATA 53,3A
0099:  DATA BA,12
009A:  DATA 75,00
009B:  DATA 8C,24
009C:  DATA 44,1D
009D:  DATA A5,3A
009E:  DATA A5,3A
009F:  DATA 00,01
00A0:  DATA 8C,2A
00A1:  DATA F3,3A
00A2:  DATA 61,39
00A3:  DATA E9,37
00A4:  DATA 20,27
00A5:  DATA A0,22
00A6:  DATA F8,34
00A7:  DATA 73,3A
00A8:  DATA 65,00
00A9:  DATA 0D,05
00AA:  DATA 53,3A
00AB:  DATA 61,3A
00AC:  DATA F5,39
00AD:  DATA BA,12
00AE:  DATA 73,00
00AF:  DATA 8C,26
00B0:  DATA E5,36
00B1:  DATA 6F,39
00B2:  DATA 79,10
00B3:  DATA 43,36
00B4:  DATA E5,30
00B5:  DATA EE,32
00B6:  DATA 64,00
00B7:  DATA 8C,18
00B8:  DATA BA,21
00B9:  DATA 41,22
00BA:  DATA 7C,19
00BB:  DATA 3A,21
00BC:  DATA D5,29
00BD:  DATA C3,20
00BE:  DATA 52,00
00BF:  DATA 0D,05
00C0:  DATA 33,1D
00C1:  DATA C4,22
00C2:  DATA 4C,3E
00C3:  DATA 34,1D
00C4:  DATA 45,22
00C5:  DATA 49,2A
00C6:  DATA 41,29
00C7:  DATA 00,01
00C8:  DATA 8C,1A
00C9:  DATA BA,20
00CA:  DATA F4,3A
00CB:  DATA 61,36
00CC:  DATA 69,3D
00CD:  DATA 61,39
00CE:  DATA 20,21
00CF:  DATA E1,39
00D0:  DATA 65,10
00D1:  DATA C4,30
00D2:  DATA E4,37
00D3:  DATA 73,00
00D4:  DATA 0D,05
00D5:  DATA 36,1D
00D6:  DATA 45,37
00D7:  DATA F6,34
00D8:  DATA 61,39
00D9:  DATA 20,21
00DA:  DATA E1,39
00DB:  DATA 65,10
00DC:  DATA C4,30
00DD:  DATA E4,37
00DE:  DATA 73,00
00DF:  DATA 8A,1B
00E0:  DATA 3A,10
00E1:  DATA D3,20
00E2:  DATA 49,29
00E3:  DATA 20,32
00E4:  DATA 6F,10
00E5:  DATA CD,32
00E6:  DATA EE,3A
00E7:  DATA 20,00
00E8:  DATA 0C,10
00E9:  DATA 4F,38
00EA:  DATA F4,34
00EB:  DATA 6F,37
00EC:  DATA 3A,10
00ED:  DATA A5,31
00EE:  DATA 00,01
00EF:  DATA 8C,29
00F0:  DATA F5,31
00F1:  DATA E3,32
00F2:  DATA F3,39
00F3:  DATA A0,16
00F4:  DATA 3E,10
00F5:  DATA 25,32
00F6:  DATA 00,10
00F7:  DATA 8C,3A
00F8:  DATA F3,3A
00F9:  DATA 61,39
00FA:  DATA E9,37
00FB:  DATA 20,32
00FC:  DATA 65,36
00FD:  DATA 65,3A
00FE:  DATA 61,32
00FF:  DATA 6F,00
0100:  DATA 8C,3A
0101:  DATA F3,3A
0102:  DATA 61,39
0103:  DATA E9,37
0104:  DATA 20,27
0105:  DATA A0,22
0106:  DATA F8,34
0107:  DATA 73,3A
0108:  DATA 65,00
0109:  DATA 0C,22
010A:  DATA E9,33
010B:  DATA 69,3A
010C:  DATA 65,10
010D:  DATA F5,36
010E:  DATA 20,3B
010F:  DATA 61,36
0110:  DATA 6F,39
0111:  DATA 00,01
0112:  DATA 0D,05
0113:  DATA D6,30
0114:  DATA EC,34
0115:  DATA E4,37
0116:  DATA 21,00
0117:  DATA 8C,24
0118:  DATA 44,10
0119:  DATA 4E,10
011A:  DATA 45,3C
011B:  DATA E9,39
011C:  DATA F4,32
011D:  DATA 00,01
011E:  DATA 0D,05
011F:  DATA D4,32
0120:  DATA 6E,3A
0121:  DATA 65,10
0122:  DATA E4,32
0123:  DATA 20,37
0124:  DATA 6F,3B
0125:  DATA 6F,00
0126:  DATA 0C,28
0127:  DATA F2,37
0128:  DATA E3,3A
0129:  DATA F2,32
012A:  DATA A0,30
012B:  DATA A0,39
012C:  DATA E5,31
012D:  DATA F2,32
012E:  DATA F4,30
012F:  DATA F2,34
0130:  DATA 61,00
0131:  DATA 0D,05
0132:  DATA D0,17
0133:  DATA 20,39
0134:  DATA E5,39
0135:  DATA 6F,36
0136:  DATA F6,32
0137:  DATA 72,00
0138:  DATA 0C,27
0139:  DATA 41,22
013A:  DATA 41,10
013B:  DATA 65,34
013C:  DATA 20,26
013D:  DATA E9,33
013E:  DATA 61,32
013F:  DATA EF,10
0140:  DATA 00,00
0141:  DATA 0C,10
0142:  DATA C4,34
0143:  DATA E7,34
0144:  DATA F4,32
0145:  DATA 00,00
0146:  DATA 8C,20
0147:  DATA E4,36
0148:  DATA 69,37
0149:  DATA A0,22
014A:  DATA EE,31
014B:  DATA 6F,37
014C:  DATA 74,39
014D:  DATA 61,32
014E:  DATA 6F,00
014F:  DATA 0C,10
0150:  DATA 61,32
0151:  DATA ED,34
0152:  DATA EE,39
0153:  DATA 5B,18
0154:  DATA 5D,1D
0155:  DATA A0,12
0156:  DATA 64,00
0157:  DATA 8C,34
0158:  DATA 64,1D
0159:  DATA A5,3A
015A:  DATA A5,3A
015B:  DATA 00,00
015C:  DATA 0C,22
015D:  DATA E9,33
015E:  DATA 69,3A
015F:  DATA 65,10
0160:  DATA 6F,10
0161:  DATA 49,22
0162:  DATA 3A,10
0163:  DATA 00,01
0164:  DATA 8A,06
0165:  DATA D4,3C
0166:  DATA F0,32
0167:  DATA 64,1D
0168:  DATA A5,31
0169:  DATA 00,00
016A:  DATA 8A,06
016B:  DATA D4,3C
016C:  DATA F0,32
016D:  DATA 64,1D
016E:  DATA A5,31
016F:  DATA 00,00
0170:  DATA 8C,34
0171:  DATA 64,1D
0172:  DATA A0,12
0173:  DATA F5,12
0174:  DATA 75,00
0175:  DATA 8C,24
0176:  DATA 44,10
0177:  DATA CA,30
0178:  DATA 68,10
0179:  DATA 45,3C
017A:  DATA E9,39
017B:  DATA F4,32
017C:  DATA 00,00
017D:  DATA 0C,28
017E:  DATA C1,29
017F:  DATA 53,14
0180:  DATA B4,14
0181:  DATA 3A,10
0182:  DATA A5,3A
0183:  DATA A5,3A
0184:  DATA A5,3A
0185:  DATA A5,3A
0186:  DATA 00,01
0187:  DATA 8C,29
0188:  DATA D4,20
0189:  DATA D4,2A
018A:  DATA 53,1D
018B:  DATA A0,12
018C:  DATA 75,00
018D:  DATA 8C,24
018E:  DATA 44,10
018F:  DATA 4E,10
0190:  DATA 45,3C
0191:  DATA E9,39
0192:  DATA F4,32
0193:  DATA 00,00
0194:  DATA 8C,22
0195:  DATA 6D,10
0196:  DATA CD,37
0197:  DATA E4,37
0198:  DATA A0,22
0199:  DATA 73,38
019A:  DATA 65,39
019B:  DATA 61,00
019C:  DATA 0D,05
019D:  DATA E4,32
019E:  DATA 20,32
019F:  DATA 61,32
01A0:  DATA EF,39
01A1:  DATA 20,17
01A2:  DATA 2E,17
01A3:  DATA 00,01
01A4:  DATA 0C,23
01A5:  DATA E9,36
01A6:  DATA 20,32
01A7:  DATA 61,10
01A8:  DATA C3,37
01A9:  DATA ED,3A
01AA:  DATA EE,34
01AB:  DATA E3,30
01AC:  DATA E3,30
01AD:  DATA 6F,00
01AE:  DATA 0C,28
01AF:  DATA C9,21
01B0:  DATA A0,32
01B1:  DATA 6D,10
01B2:  DATA ED,37
01B3:  DATA E4,37
01B4:  DATA A0,22
01B5:  DATA 73,38
01B6:  DATA 65,39
01B7:  DATA 61,00
01B8:  DATA 0D,05
01B9:  DATA C5,39
01BA:  DATA F0,32
01BB:  DATA F2,30
01BC:  DATA 6E,32
01BD:  DATA 6F,10
01BE:  DATA E4,30
01BF:  DATA E4,37
01C0:  DATA 73,17
01C1:  DATA 2E,17
01C2:  DATA 00,00
01C3:  DATA 8C,24
01C4:  DATA 44,10
01C5:  DATA 69,37
01C6:  DATA E3,37
01C7:  DATA 6D,38
01C8:  DATA 61,3A
01C9:  DATA 69,3B
01CA:  DATA 65,36
01CB:  DATA 00,01
01CC:  DATA 0D,05
01CD:  DATA D4,32
01CE:  DATA 6E,3A
01CF:  DATA 65,10
01D0:  DATA EE,37
01D1:  DATA F6,30
01D2:  DATA ED,32
01D3:  DATA 6E,3A
01D4:  DATA 65,00
*
0223:  DATA 0C,10
0224:  DATA A0,34
0225:  DATA EE,34
0226:  DATA E3,34
0227:  DATA 61,37
0228:  DATA E4,37
0229:  DATA 2E,17
022A:  DATA 2E,10
022B:  DATA 00,01
022C:  DATA 8C,24
022D:  DATA C6,26
022E:  DATA 54,10
022F:  DATA 2D,10
0230:  DATA D3,32
0231:  DATA F2,34
0232:  DATA 61,36
0233:  DATA 00,01
0234:  DATA 8C,22
0235:  DATA 6D,10
0236:  DATA CD,37
0237:  DATA E4,37
0238:  DATA A0,22
0239:  DATA 73,38
023A:  DATA 65,39
023B:  DATA 61,00
023C:  DATA 0D,05
023D:  DATA E4,32
023E:  DATA 20,32
023F:  DATA 61,32
0240:  DATA EF,39
0241:  DATA 20,17
0242:  DATA 2E,17
0243:  DATA 00,01
0244:  DATA 0C,23
0245:  DATA E9,36
0246:  DATA 20,32
0247:  DATA 61,10
0248:  DATA C3,37
0249:  DATA ED,3A
024A:  DATA EE,34
024B:  DATA E3,30
024C:  DATA E3,30
024D:  DATA 6F,00
024E:  DATA 0C,28
024F:  DATA C9,21
0250:  DATA A0,32
0251:  DATA 6D,10
0252:  DATA ED,37
0253:  DATA E4,37
0254:  DATA A0,22
0255:  DATA 73,38
0256:  DATA 65,39
0257:  DATA 61,00
0258:  DATA 0D,05
0259:  DATA C5,39
025A:  DATA F0,32
025B:  DATA F2,30
025C:  DATA 6E,32
025D:  DATA 6F,10
025E:  DATA E4,30
025F:  DATA E4,37
0260:  DATA 73,17
0261:  DATA 2E,17
0262:  DATA 00,00
*
0368:  MOVF   0B,W
0369:  MOVWF  7B
036A:  BCF    0B.7
036B:  BSF    03.5
036C:  BSF    03.6
036D:  BSF    0C.7
036E:  BSF    0C.0
036F:  NOP
0370:  NOP
0371:  BTFSS  7B.7
0372:  GOTO   378
0373:  BCF    03.5
0374:  BCF    03.6
0375:  BSF    0B.7
0376:  BSF    03.5
0377:  BSF    03.6
0378:  BCF    03.5
0379:  MOVF   0C,W
037A:  ANDLW  7F
037B:  BTFSC  03.2
037C:  GOTO   3BA
037D:  MOVWF  7B
037E:  MOVF   0D,W
037F:  MOVWF  7C
0380:  MOVF   0F,W
0381:  MOVWF  7D
0382:  MOVF   7B,W
0383:  BSF    03.5
0384:  BCF    03.6
0385:  MOVWF  55
0386:  BCF    03.5
0387:  CALL   325
0388:  MOVF   7C,W
0389:  BSF    03.6
038A:  MOVWF  0D
038B:  MOVF   7D,W
038C:  MOVWF  0F
038D:  BCF    03.6
038E:  MOVF   0B,W
038F:  MOVWF  7E
0390:  BCF    0B.7
0391:  BSF    03.5
0392:  BSF    03.6
0393:  BSF    0C.7
0394:  BSF    0C.0
0395:  NOP
0396:  NOP
0397:  BTFSS  7E.7
0398:  GOTO   39E
0399:  BCF    03.5
039A:  BCF    03.6
039B:  BSF    0B.7
039C:  BSF    03.5
039D:  BSF    03.6
039E:  BCF    03.5
039F:  RLF    0C,W
03A0:  RLF    0E,W
03A1:  ANDLW  7F
03A2:  BTFSC  03.2
03A3:  GOTO   3BA
03A4:  MOVWF  7B
03A5:  MOVF   0D,W
03A6:  MOVWF  7C
03A7:  MOVF   0F,W
03A8:  MOVWF  7D
03A9:  MOVF   7B,W
03AA:  BSF    03.5
03AB:  BCF    03.6
03AC:  MOVWF  55
03AD:  BCF    03.5
03AE:  CALL   325
03AF:  MOVF   7C,W
03B0:  BSF    03.6
03B1:  MOVWF  0D
03B2:  MOVF   7D,W
03B3:  MOVWF  0F
03B4:  INCF   0D,F
03B5:  BTFSC  03.2
03B6:  INCF   0F,F
03B7:  BCF    03.6
03B8:  GOTO   368
03B9:  BSF    03.6
03BA:  BCF    03.6
03BB:  RETURN
*
0579:  MOVF   37,W
057A:  XORWF  39,W
057B:  ANDLW  80
057C:  MOVWF  3B
057D:  BTFSS  37.7
057E:  GOTO   584
057F:  COMF   36,F
0580:  COMF   37,F
0581:  INCF   36,F
0582:  BTFSC  03.2
0583:  INCF   37,F
0584:  BTFSS  39.7
0585:  GOTO   58B
0586:  COMF   38,F
0587:  COMF   39,F
0588:  INCF   38,F
0589:  BTFSC  03.2
058A:  INCF   39,F
058B:  MOVLW  10
058C:  MOVWF  3A
058D:  CLRF   77
058E:  CLRF   7A
058F:  RRF    37,F
0590:  RRF    36,F
0591:  BTFSS  03.0
0592:  GOTO   599
0593:  MOVF   38,W
0594:  ADDWF  77,F
0595:  BTFSC  03.0
0596:  INCF   7A,F
0597:  MOVF   39,W
0598:  ADDWF  7A,F
0599:  RRF    7A,F
059A:  RRF    77,F
059B:  RRF    79,F
059C:  RRF    78,F
059D:  DECFSZ 3A,F
059E:  GOTO   58F
059F:  BTFSS  3B.7
05A0:  GOTO   5A6
05A1:  COMF   78,F
05A2:  COMF   79,F
05A3:  INCF   78,F
05A4:  BTFSC  03.2
05A5:  INCF   79,F
*
0685:  MOVF   00,F
0686:  BTFSC  03.2
0687:  GOTO   6A1
0688:  BSF    03.5
0689:  CLRF   54
068A:  MOVF   04,W
068B:  MOVWF  53
068C:  BCF    54.0
068D:  BTFSC  03.7
068E:  BSF    54.0
068F:  MOVF   00,W
0690:  MOVWF  55
0691:  BCF    03.5
0692:  CALL   325
0693:  BSF    03.5
0694:  MOVF   53,W
0695:  MOVWF  04
0696:  BCF    03.7
0697:  BTFSC  54.0
0698:  BSF    03.7
0699:  INCF   04,F
069A:  BTFSS  03.2
069B:  GOTO   69F
069C:  BCF    03.5
069D:  INCF   05,F
069E:  BSF    03.5
069F:  BCF    03.5
06A0:  GOTO   685
*
06E9:  MOVF   0B,W
06EA:  BSF    03.5
06EB:  MOVWF  28
06EC:  BCF    03.5
06ED:  BCF    0B.7
06EE:  BSF    03.5
06EF:  BSF    03.6
06F0:  BSF    0C.7
06F1:  BSF    0C.0
06F2:  NOP
06F3:  NOP
06F4:  BCF    03.6
06F5:  BTFSS  28.7
06F6:  GOTO   6FA
06F7:  BCF    03.5
06F8:  BSF    0B.7
06F9:  BSF    03.5
06FA:  BTFSC  03.0
06FB:  GOTO   733
06FC:  BCF    03.5
06FD:  BSF    03.6
06FE:  MOVF   0C,W
06FF:  ANDLW  7F
0700:  BSF    03.5
0701:  BCF    03.6
0702:  MOVWF  28
0703:  BCF    03.5
0704:  BSF    03.6
0705:  MOVF   0D,W
0706:  BSF    03.5
0707:  BCF    03.6
0708:  MOVWF  29
0709:  BCF    03.5
070A:  BSF    03.6
070B:  MOVF   0F,W
070C:  BSF    03.5
070D:  BCF    03.6
070E:  MOVWF  2A
070F:  MOVF   28,W
0710:  MOVWF  55
0711:  BCF    03.5
0712:  CALL   325
0713:  BSF    03.5
0714:  MOVF   29,W
0715:  BCF    03.5
0716:  BSF    03.6
0717:  MOVWF  0D
0718:  BSF    03.5
0719:  BCF    03.6
071A:  MOVF   2A,W
071B:  BCF    03.5
071C:  BSF    03.6
071D:  MOVWF  0F
071E:  BCF    03.6
071F:  MOVF   0B,W
0720:  BSF    03.5
0721:  MOVWF  2B
0722:  BCF    03.5
0723:  BCF    0B.7
0724:  BSF    03.5
0725:  BSF    03.6
0726:  BSF    0C.7
0727:  BSF    0C.0
0728:  NOP
0729:  NOP
072A:  BCF    03.6
072B:  BTFSS  2B.7
072C:  GOTO   730
072D:  BCF    03.5
072E:  BSF    0B.7
072F:  BSF    03.5
0730:  DECFSZ 27,F
0731:  GOTO   733
0732:  GOTO   761
0733:  BCF    03.5
0734:  BSF    03.6
0735:  RLF    0C,W
0736:  RLF    0E,W
0737:  ANDLW  7F
0738:  BSF    03.5
0739:  BCF    03.6
073A:  MOVWF  28
073B:  BCF    03.5
073C:  BSF    03.6
073D:  MOVF   0D,W
073E:  BSF    03.5
073F:  BCF    03.6
0740:  MOVWF  29
0741:  BCF    03.5
0742:  BSF    03.6
0743:  MOVF   0F,W
0744:  BSF    03.5
0745:  BCF    03.6
0746:  MOVWF  2A
0747:  MOVF   28,W
0748:  MOVWF  55
0749:  BCF    03.5
074A:  CALL   325
074B:  BSF    03.5
074C:  MOVF   29,W
074D:  BCF    03.5
074E:  BSF    03.6
074F:  MOVWF  0D
0750:  BSF    03.5
0751:  BCF    03.6
0752:  MOVF   2A,W
0753:  BCF    03.5
0754:  BSF    03.6
0755:  MOVWF  0F
0756:  INCF   0D,F
0757:  BTFSC  03.2
0758:  INCF   0F,F
0759:  BCF    03.0
075A:  BSF    03.5
075B:  BCF    03.6
075C:  DECFSZ 27,F
075D:  GOTO   75F
075E:  GOTO   761
075F:  BCF    03.5
0760:  GOTO   6E9
0761:  BCF    03.5
0762:  RETURN
0763:  BSF    03.5
0764:  MOVF   2A,W
0765:  CLRF   78
0766:  SUBWF  29,W
0767:  BTFSC  03.0
0768:  GOTO   76C
0769:  MOVF   29,W
076A:  MOVWF  77
076B:  GOTO   778
076C:  CLRF   77
076D:  MOVLW  08
076E:  MOVWF  2B
076F:  RLF    29,F
0770:  RLF    77,F
0771:  MOVF   2A,W
0772:  SUBWF  77,W
0773:  BTFSC  03.0
0774:  MOVWF  77
0775:  RLF    78,F
0776:  DECFSZ 2B,F
0777:  GOTO   76F
0778:  BCF    03.5
0779:  RETURN
077A:  MOVF   78,W
077B:  BSF    03.5
077C:  MOVF   27,W
077D:  MOVWF  29
077E:  MOVLW  64
077F:  MOVWF  2A
0780:  BCF    03.5
0781:  CALL   763
0782:  MOVF   77,W
0783:  BSF    03.5
0784:  MOVWF  27
0785:  MOVF   78,W
0786:  MOVLW  30
0787:  BTFSS  03.2
0788:  GOTO   790
0789:  BTFSS  28.1
078A:  GOTO   799
078B:  BTFSC  28.3
078C:  GOTO   799
078D:  BTFSC  28.4
078E:  MOVLW  20
078F:  GOTO   793
0790:  BCF    28.3
0791:  BCF    28.4
0792:  BSF    28.0
0793:  ADDWF  78,F
0794:  MOVF   78,W
0795:  MOVWF  55
0796:  BCF    03.5
0797:  CALL   325
0798:  BSF    03.5
0799:  MOVF   27,W
079A:  MOVWF  29
079B:  MOVLW  0A
079C:  MOVWF  2A
079D:  BCF    03.5
079E:  CALL   763
079F:  MOVF   77,W
07A0:  BSF    03.5
07A1:  MOVWF  27
07A2:  MOVF   78,W
07A3:  MOVLW  30
07A4:  BTFSS  03.2
07A5:  GOTO   7AC
07A6:  BTFSC  28.3
07A7:  GOTO   7B2
07A8:  BTFSS  28.0
07A9:  GOTO   7B2
07AA:  BTFSC  28.4
07AB:  MOVLW  20
07AC:  ADDWF  78,F
07AD:  MOVF   78,W
07AE:  MOVWF  55
07AF:  BCF    03.5
07B0:  CALL   325
07B1:  BSF    03.5
07B2:  MOVLW  30
07B3:  ADDWF  27,F
07B4:  MOVF   27,W
07B5:  MOVWF  55
07B6:  BCF    03.5
07B7:  CALL   325
07B8:  RETURN
....................  
.................... #list 
....................  
.................... #device ADC=8 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES HS  
....................  
.................... #use delay(crystal=20000000) 
*
0270:  MOVLW  D6
0271:  MOVWF  04
0272:  BCF    03.7
0273:  MOVF   00,W
0274:  BTFSC  03.2
0275:  GOTO   283
0276:  MOVLW  06
0277:  MOVWF  78
0278:  CLRF   77
0279:  DECFSZ 77,F
027A:  GOTO   279
027B:  DECFSZ 78,F
027C:  GOTO   278
027D:  MOVLW  7B
027E:  MOVWF  77
027F:  DECFSZ 77,F
0280:  GOTO   27F
0281:  DECFSZ 00,F
0282:  GOTO   276
0283:  RETURN
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=Wireless) 
....................  
....................  
.................... // -------Variables' Declaration 
.................... #define BLOCK_SIZE sizeof(User)  
.................... #define RX_BUFFER_SIZE 20 
.................... int8 rx_wr_index = 0; 
.................... int8 lock_pos = 0, rxd, read, valid_data_count; 
.................... int data_avail = FALSE, got_id = FALSE; 
.................... char rx_buffer[RX_BUFFER_SIZE]; 
.................... char history[RX_BUFFER_SIZE]; 
.................... int n_bytes = 0; 
.................... // char string [RX_BUFFER_SIZE]; 
.................... #include "functions.c" 
.................... #include "functions.h" 
....................  
.................... //Define the default pins before calling the LCD driver 
.................... #ifndef lcd_enable  
....................    #define lcd_enable     pin_e1 
....................    #define lcd_rs         pin_e2 
....................    //#define lcd_rw       pin_e2   
....................    #define lcd_d4         pin_d4 
....................    #define lcd_d5         pin_d5 
....................    #define lcd_d6         pin_d6 
....................    #define lcd_d7         pin_d7 
.................... #endif 
....................  
.................... #include "mod_lcd.c" 
.................... /************************************************************************/ 
.................... /*  MOD_LCD.C - Biblioteca de manipulaï¿½ï¿½o de mï¿½dulo LCD                 */ 
.................... /*                                                                      */ 
.................... /*  Autor: Fï¿½bio Pereira                                                */ 
.................... /*                                                                      */ 
.................... /************************************************************************/ 
....................  
.................... // As definiï¿½ï¿½es a seguir sï¿½o utilizadas para acesso aos pinos do display 
.................... // caso o pino RW nï¿½o seja utilizado, comente a definiï¿½ï¿½o lcd_rw 
.................... #ifndef lcd_enable 
....................    #define lcd_enable       pin_e1      // pino enable do LCD 
....................    #define lcd_rs         pin_e0      // pino rs do LCD 
....................    //#define lcd_rw      pin_e2      // pino rw do LCD 
....................    #define lcd_d4         pin_d4      // pino de dados d4 do LCD 
....................    #define lcd_d5         pin_d5      // pino de dados d5 do LCD 
....................    #define lcd_d6         pin_d6      // pino de dados d6 do LCD 
....................    #define lcd_d7         pin_d7      // pino de dados d7 do LCD 
.................... #endif 
....................  
.................... #define lcd_type 2           
.................... #define lcd_seg_lin 0x40     
....................  
....................  
.................... byte CONST INI_LCD[4] = {0x20 | (lcd_type << 2), 0xf, 1, 6}; 
....................  
.................... byte lcd_le_byte() 
.................... // lï¿½ um byte do LCD (somente com pino RW) 
.................... { 
....................    byte dado; 
....................    // configura os pinos de dados como entradas 
....................    input(lcd_d4); 
....................    input(lcd_d5); 
....................    input(lcd_d6); 
....................    input(lcd_d7); 
....................    // se o pino rw for utilizado, coloca em 1 
....................    #ifdef lcd_rw 
....................       output_high(lcd_rw); 
....................    #endif 
....................    output_high(lcd_enable); // habilita display 
....................    dado = 0;   // zera a variï¿½vel de leitura 
....................    // lï¿½ os quatro bits mais significativos 
....................    if (input(lcd_d7)) bit_set(dado,7); 
....................    if (input(lcd_d6)) bit_set(dado,6); 
....................    if (input(lcd_d5)) bit_set(dado,5); 
....................    if (input(lcd_d4)) bit_set(dado,4); 
....................    // dï¿½ um pulso na linha enable 
....................    output_low(lcd_enable); 
....................    output_high(lcd_enable); 
....................    // lï¿½ os quatro bits menos significativos 
....................    if (input(lcd_d7)) bit_set(dado,3); 
....................    if (input(lcd_d6)) bit_set(dado,2); 
....................    if (input(lcd_d5)) bit_set(dado,1); 
....................    if (input(lcd_d4)) bit_set(dado,0); 
....................    output_low(lcd_enable);   // desabilita o display 
....................    return dado;   // retorna o byte lido 
.................... } 
....................  
.................... void lcd_envia_nibble( byte dado ) 
.................... // envia um dado de quatro bits para o display 
.................... { 
....................    // coloca os quatro bits nas saidas 
....................    output_bit(lcd_d4,bit_test(dado,0)); 
0284:  BSF    03.5
0285:  BTFSC  5D.0
0286:  GOTO   28B
0287:  BCF    03.5
0288:  BCF    08.4
0289:  GOTO   28D
028A:  BSF    03.5
028B:  BCF    03.5
028C:  BSF    08.4
028D:  BSF    03.5
028E:  BCF    08.4
....................    output_bit(lcd_d5,bit_test(dado,1)); 
028F:  BTFSC  5D.1
0290:  GOTO   295
0291:  BCF    03.5
0292:  BCF    08.5
0293:  GOTO   297
0294:  BSF    03.5
0295:  BCF    03.5
0296:  BSF    08.5
0297:  BSF    03.5
0298:  BCF    08.5
....................    output_bit(lcd_d6,bit_test(dado,2)); 
0299:  BTFSC  5D.2
029A:  GOTO   29F
029B:  BCF    03.5
029C:  BCF    08.6
029D:  GOTO   2A1
029E:  BSF    03.5
029F:  BCF    03.5
02A0:  BSF    08.6
02A1:  BSF    03.5
02A2:  BCF    08.6
....................    output_bit(lcd_d7,bit_test(dado,3)); 
02A3:  BTFSC  5D.3
02A4:  GOTO   2A9
02A5:  BCF    03.5
02A6:  BCF    08.7
02A7:  GOTO   2AB
02A8:  BSF    03.5
02A9:  BCF    03.5
02AA:  BSF    08.7
02AB:  BSF    03.5
02AC:  BCF    08.7
....................    // dï¿½ um pulso na linha enable 
....................    output_high(lcd_enable); 
02AD:  BCF    09.1
02AE:  BCF    03.5
02AF:  BSF    09.1
....................    output_low(lcd_enable); 
02B0:  BSF    03.5
02B1:  BCF    09.1
02B2:  BCF    03.5
02B3:  BCF    09.1
02B4:  RETURN
.................... } 
....................  
....................  
.................... void lcd_envia_byte( boolean endereco, byte dado ) 
.................... { 
....................    // coloca a linha rs em 0 
....................    output_low(lcd_rs); 
02B5:  BSF    03.5
02B6:  BCF    09.2
02B7:  BCF    03.5
02B8:  BCF    09.2
....................    // aguarda o display ficar desocupado 
....................    //while ( bit_test(lcd_le_byte(),7) ) ; 
....................    // configura a linha rs dependendo do modo selecionado 
....................    output_bit(lcd_rs,endereco); 
02B9:  BSF    03.5
02BA:  MOVF   5A,F
02BB:  BTFSS  03.2
02BC:  GOTO   2C1
02BD:  BCF    03.5
02BE:  BCF    09.2
02BF:  GOTO   2C3
02C0:  BSF    03.5
02C1:  BCF    03.5
02C2:  BSF    09.2
02C3:  BSF    03.5
02C4:  BCF    09.2
....................    delay_us(100);   // aguarda 100 us 
02C5:  MOVLW  A6
02C6:  MOVWF  77
02C7:  DECFSZ 77,F
02C8:  GOTO   2C7
02C9:  NOP
....................    // caso a linha rw esteja definida, coloca em 0 
....................    #ifdef lcd_rw 
....................       output_low(lcd_rw); 
....................    #endif 
....................    // desativa linha enable 
....................    output_low(lcd_enable); 
02CA:  BCF    09.1
02CB:  BCF    03.5
02CC:  BCF    09.1
....................    // envia a primeira parte do byte 
....................    lcd_envia_nibble(dado >> 4); 
02CD:  BSF    03.5
02CE:  SWAPF  5B,W
02CF:  MOVWF  5C
02D0:  MOVLW  0F
02D1:  ANDWF  5C,F
02D2:  MOVF   5C,W
02D3:  MOVWF  5D
02D4:  BCF    03.5
02D5:  CALL   284
....................    // envia a segunda parte do byte 
....................    lcd_envia_nibble(dado & 0x0f); 
02D6:  BSF    03.5
02D7:  MOVF   5B,W
02D8:  ANDLW  0F
02D9:  MOVWF  5C
02DA:  MOVWF  5D
02DB:  BCF    03.5
02DC:  CALL   284
02DD:  RETURN
.................... } 
....................  
....................  
.................... void lcd_ini() 
.................... // rotina de inicializaï¿½ï¿½o do display 
.................... { 
....................    byte conta; 
....................    output_low(lcd_d4); 
02DE:  BSF    03.5
02DF:  BCF    08.4
02E0:  BCF    03.5
02E1:  BCF    08.4
....................    output_low(lcd_d5); 
02E2:  BSF    03.5
02E3:  BCF    08.5
02E4:  BCF    03.5
02E5:  BCF    08.5
....................    output_low(lcd_d6); 
02E6:  BSF    03.5
02E7:  BCF    08.6
02E8:  BCF    03.5
02E9:  BCF    08.6
....................    output_low(lcd_d7); 
02EA:  BSF    03.5
02EB:  BCF    08.7
02EC:  BCF    03.5
02ED:  BCF    08.7
....................    output_low(lcd_rs); 
02EE:  BSF    03.5
02EF:  BCF    09.2
02F0:  BCF    03.5
02F1:  BCF    09.2
....................    #ifdef lcd_rw 
....................       output_high(lcd_rw); 
....................    #endif 
....................    output_low(lcd_enable); 
02F2:  BSF    03.5
02F3:  BCF    09.1
02F4:  BCF    03.5
02F5:  BCF    09.1
....................    delay_ms(15); 
02F6:  MOVLW  0F
02F7:  BSF    03.5
02F8:  MOVWF  56
02F9:  BCF    03.5
02FA:  CALL   270
....................    // envia uma seqï¿½ï¿½ncia de 3 vezes 0x03 
....................    // e depois 0x02 para configurar o mï¿½dulo 
....................    // para modo de 4 bits 
....................    for(conta=1;conta<=3;++conta) 
02FB:  MOVLW  01
02FC:  MOVWF  7B
02FD:  MOVF   7B,W
02FE:  SUBLW  03
02FF:  BTFSS  03.0
0300:  GOTO   30D
....................    { 
....................       lcd_envia_nibble(3); 
0301:  MOVLW  03
0302:  BSF    03.5
0303:  MOVWF  5D
0304:  BCF    03.5
0305:  CALL   284
....................       delay_ms(5); 
0306:  MOVLW  05
0307:  BSF    03.5
0308:  MOVWF  56
0309:  BCF    03.5
030A:  CALL   270
030B:  INCF   7B,F
030C:  GOTO   2FD
....................    } 
....................    lcd_envia_nibble(2); 
030D:  MOVLW  02
030E:  BSF    03.5
030F:  MOVWF  5D
0310:  BCF    03.5
0311:  CALL   284
....................    // envia string de inicializaï¿½ï¿½o do display 
....................    for(conta=0;conta<=3;++conta) lcd_envia_byte(0,INI_LCD[conta]); 
0312:  CLRF   7B
0313:  MOVF   7B,W
0314:  SUBLW  03
0315:  BTFSS  03.0
0316:  GOTO   322
0317:  MOVF   7B,W
0318:  CALL   051
0319:  MOVWF  7C
031A:  BSF    03.5
031B:  CLRF   5A
031C:  MOVF   7C,W
031D:  MOVWF  5B
031E:  BCF    03.5
031F:  CALL   2B5
0320:  INCF   7B,F
0321:  GOTO   313
0322:  BSF    0A.3
0323:  BCF    0A.4
0324:  GOTO   035 (RETURN)
.................... } 
....................  
.................... void lcd_pos_xy( byte x, byte y) 
.................... { 
....................    byte endereco; 
....................    if(y!=1) 
*
0346:  DECFSZ 57,W
0347:  GOTO   349
0348:  GOTO   34C
....................       endereco = lcd_seg_lin; 
0349:  MOVLW  40
034A:  MOVWF  58
034B:  GOTO   34D
....................    else 
....................       endereco = 0; 
034C:  CLRF   58
....................    endereco += x-1; 
034D:  MOVLW  01
034E:  SUBWF  56,W
034F:  ADDWF  58,F
....................    lcd_envia_byte(0,0x80|endereco); 
0350:  MOVF   58,W
0351:  IORLW  80
0352:  MOVWF  59
0353:  CLRF   5A
0354:  MOVF   59,W
0355:  MOVWF  5B
0356:  BCF    03.5
0357:  CALL   2B5
.................... } 
....................  
.................... void lcd_escreve( char c) 
.................... // envia caractere para o display 
.................... { 
....................    switch (c) 
*
0325:  BSF    03.5
0326:  MOVF   55,W
0327:  XORLW  0C
0328:  BCF    03.5
0329:  BTFSC  03.2
032A:  GOTO   335
032B:  XORLW  06
032C:  BTFSC  03.2
032D:  GOTO   341
032E:  XORLW  07
032F:  BTFSC  03.2
0330:  GOTO   341
0331:  XORLW  05
0332:  BTFSC  03.2
0333:  GOTO   359
0334:  GOTO   360
....................    { 
....................      case '\f'    :   lcd_envia_byte(0,1); 
0335:  BSF    03.5
0336:  CLRF   5A
0337:  MOVLW  01
0338:  MOVWF  5B
0339:  BCF    03.5
033A:  CALL   2B5
....................               delay_ms(2); 
033B:  MOVLW  02
033C:  BSF    03.5
033D:  MOVWF  56
033E:  BCF    03.5
033F:  CALL   270
....................             break; 
0340:  GOTO   367
....................      case '\n'   : 
....................       case '\r'    :   lcd_pos_xy(1,2); 
0341:  MOVLW  01
0342:  BSF    03.5
0343:  MOVWF  56
0344:  MOVLW  02
0345:  MOVWF  57
....................               break; 
*
0358:  GOTO   367
....................      case '\b'    :   lcd_envia_byte(0,0x10); 
0359:  BSF    03.5
035A:  CLRF   5A
035B:  MOVLW  10
035C:  MOVWF  5B
035D:  BCF    03.5
035E:  CALL   2B5
....................               break; 
035F:  GOTO   367
....................      default   :   lcd_envia_byte(1,c); 
0360:  MOVLW  01
0361:  BSF    03.5
0362:  MOVWF  5A
0363:  MOVF   55,W
0364:  MOVWF  5B
0365:  BCF    03.5
0366:  CALL   2B5
....................               break; 
....................    } 
0367:  RETURN
.................... } 
....................  
.................... char lcd_le( byte x, byte y) 
.................... // le caractere do display 
.................... { 
....................    char valor; 
....................    // seleciona a posiï¿½ï¿½o do caractere 
....................    lcd_pos_xy(x,y); 
....................    // ativa rs 
....................    output_high(lcd_rs); 
....................    // lï¿½ o caractere 
....................    valor = lcd_le_byte(); 
....................    // desativa rs 
....................    output_low(lcd_rs); 
....................    // retorna o valor do caractere 
....................    return valor; 
.................... } 
....................  
....................  
.................... #include "2401.c" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a MicroChip 24LC01B configured for a x8 org         //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);  Read the byte d from the address a     //// 
.................... ////                                                                   //// 
.................... ////   b = ext_eeprom_ready();  Returns TRUE if the eeprom is ready    //// 
.................... ////                            to receive opcodes                     //// 
.................... ////                                                                   //// 
.................... ////   The main program may define EEPROM_SDA                          //// 
.................... ////   and EEPROM_SCL to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... ////                            Pin Layout                             //// 
.................... ////   -----------------------------------------------------------     //// 
.................... ////   |                                                         |     //// 
.................... ////   | 1: NC   Not Connected | 8: VCC   +5V                    |     //// 
.................... ////   |                       |                                 |     //// 
.................... ////   | 2: NC   Not Connected | 7: WP    GND                    |     //// 
.................... ////   |                       |                                 |     //// 
.................... ////   | 3: NC   Not Connected | 6: SCL   EEPROM_SCL and Pull-Up |     //// 
.................... ////   |                       |                                 |     //// 
.................... ////   | 4: VSS  GND           | 5: SDA   EEPROM_SDA and Pull-Up |     //// 
.................... ////   -----------------------------------------------------------     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2003 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef EEPROM_SDA 
....................  
.................... #define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C3 
....................  
.................... #endif 
....................  
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
....................  
.................... #define EEPROM_ADDRESS BYTE 
.................... #define EEPROM_SIZE    128 
....................  
.................... void init_ext_eeprom() { 
....................    output_float(EEPROM_SCL); 
*
0263:  BSF    5B.3
0264:  MOVF   5B,W
0265:  BSF    03.5
0266:  MOVWF  07
....................    output_float(EEPROM_SDA); 
0267:  BCF    03.5
0268:  BSF    5B.4
0269:  MOVF   5B,W
026A:  BSF    03.5
026B:  MOVWF  07
026C:  BCF    03.5
026D:  BSF    0A.3
026E:  BCF    0A.4
026F:  GOTO   02D (RETURN)
.................... } 
....................  
.................... BOOLEAN ext_eeprom_ready() { 
....................    int1 ack; 
....................    i2c_start();            // If the write command is acknowledged, 
....................    ack = i2c_write(0xa0);  // then the device is ready. 
....................    i2c_stop(); 
....................    return !ack; 
.................... } 
....................  
.................... void write_ext_eeprom(BYTE address, BYTE data) { 
....................    while(!ext_eeprom_ready()); 
....................    i2c_start(); 
....................    i2c_write(0xa0); 
....................    i2c_write(address); 
....................    i2c_write(data); 
....................    i2c_stop(); 
.................... } 
....................  
....................  
.................... BYTE read_ext_eeprom(BYTE address) { 
....................    BYTE data; 
....................  
....................    while(!ext_eeprom_ready()); 
....................    i2c_start(); 
....................    i2c_write(0xa0); 
....................    i2c_write(address); 
....................    i2c_start(); 
....................    i2c_write(0xa1); 
....................    data=i2c_read(0); 
....................    i2c_stop(); 
....................    return(data); 
.................... } 
....................  
.................... #include "kbd_board4.c" 
.................... /*######################################################################  
....................    Rotina utilização do teclado da placa PicSim board4 
....................    Adaptada para o compilador CCS 
....................    Autor: Alberto Willia Mascarenhas (adaptou para o compilador) 
....................    For e-mail suggestions :  awmascarenhas@gmail.com 
.................... ######################################################################## */ 
.................... unsigned char tc_tecla(unsigned int timeout) 
.................... { 
....................   unsigned int to=0; 
....................   unsigned char k = 0;   
....................   while(((to < timeout)||(!timeout))&&(!k)){ 
....................       
....................        
....................       //------------------------------------------------------------------------- 
....................       //inicio do programa de varredura do teclado matricial 
....................       //-------------------------------------------------------------------------- 
....................       //habilita primeira coluna do teclado 
....................       output_low(PIN_B0);output_high(PIN_B1);output_high(PIN_B2);output_high(PIN_B3); 
....................       delay_ms(20); 
....................       if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='1';}; 
....................       if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='4';}; 
....................       if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='7';}; 
....................       if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='*';}; 
....................       //habilita segunda coluna do teclado 
....................       output_high(PIN_B0);output_low(PIN_B1);output_high(PIN_B2);output_high(PIN_B3); 
....................       delay_ms(20);       
....................       if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='2';}; 
....................       if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='5';}; 
....................       if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='8';}; 
....................       if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='0';}; 
....................        
....................       //habilita terceira coluna do teclado 
....................       output_high(PIN_B0);output_high(PIN_B1);output_low(PIN_B2);output_high(PIN_B3); 
....................       delay_ms(20);       
....................       if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='3';}; 
....................       if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='6';}; 
....................       if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='9';}; 
....................       if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='#';}; 
....................   
....................        //habilita quarta coluna do teclado 
....................       output_high(PIN_B0);output_high(PIN_B1);output_high(PIN_B2);output_low(PIN_B3); 
....................       delay_ms(20);       
....................       if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='A';}; 
....................       if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='B';}; 
....................       if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='C';}; 
....................       if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='D';}; 
....................   
....................       //printf (lcd_escreve,"\f saiu geral %u",k); 
....................       //delay_ms(1000); 
....................       delay_ms(5); 
....................       to+=5; 
....................   } 
....................    if(!k)k=255; 
....................   return k;   
.................... } 
....................  
....................  
.................... typedef struct {  
....................    int id[2];   
....................    int pass[4]; //password 
....................    int status; //0 - Unpaid, 1 - Paid, 3 - Admin 
.................... }User; 
....................  
....................  
....................  
....................  
.................... /* 
.................... int status -> 0 - Unpaid, 1 - Paid, 3 - Admin 
.................... int chooseAddr: 
....................          Param < 0 - SAVE in a available address to CREATE  
....................          Param >= 0 - SAVE in a existing address to OVERWRITE (edit) 
.................... */ 
.................... void saveUser(int * id, int * pass, int status); 
.................... int getAddressByID(int * id);    
.................... void searchUser(int * id); 
.................... int deleteUser(int * id); 
.................... void editUser(); 
.................... void updateUser(int * id, int * pass, int status); 
.................... User receiveUser(); 
.................... // int isIdAvailable(int id);     
.................... void printUser(User user); 
.................... void waitUpdate(); 
.................... void overwriteUser(User user); 
.................... void erase_program_eeprom(int addrr); 
.................... int incrementID(); 
.................... int lastNewUserPosition(); 
.................... void resetMemory(); 
.................... void adminMenu(); 
.................... int login(int * id); 
.................... int checkPassword(int initBlockAddr, int * pass); 
.................... //show = 1 -> Print(Paid/Unpaid) 
.................... int getUserStatus(int address, int show); 
.................... unsigned char readKeyboard();  
.................... int * getAdminsID(); 
.................... void listAdmins(); 
.................... int * strToInt(char * str); 
.................... char * strfromchar(char destination[], char source); 
.................... int * inputId(); 
.................... int * inputToKeyboard(char * msg, int max); 
.................... void inputKeyboardUser(); 
....................  
....................  
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
*
03BC:  BSF    03.6
03BD:  MOVF   37,W
03BE:  MOVWF  3A
....................    for(su=s;0<n;++su,--n) 
03BF:  MOVF   36,W
03C0:  MOVWF  3C
03C1:  MOVF   35,W
03C2:  MOVWF  3B
03C3:  MOVF   39,F
03C4:  BTFSS  03.2
03C5:  GOTO   3CA
03C6:  MOVF   38,W
03C7:  SUBLW  00
03C8:  BTFSC  03.0
03C9:  GOTO   3E2
....................       if(*su==uc) 
03CA:  MOVF   3C,W
03CB:  MOVWF  7A
03CC:  MOVF   3B,W
03CD:  MOVWF  04
03CE:  BCF    03.7
03CF:  BTFSC  7A.0
03D0:  BSF    03.7
03D1:  MOVF   3A,W
03D2:  SUBWF  00,W
03D3:  BTFSS  03.2
03D4:  GOTO   3DA
....................       return su; 
03D5:  MOVF   3B,W
03D6:  MOVWF  78
03D7:  MOVF   3C,W
03D8:  MOVWF  79
03D9:  GOTO   3E5
03DA:  INCF   3B,F
03DB:  BTFSC  03.2
03DC:  INCF   3C,F
03DD:  MOVF   38,W
03DE:  BTFSC  03.2
03DF:  DECF   39,F
03E0:  DECF   38,F
03E1:  GOTO   3C3
....................    return NULL; 
03E2:  MOVLW  00
03E3:  MOVWF  78
03E4:  MOVWF  79
03E5:  BCF    03.6
03E6:  RETURN
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
081A:  BCF    03.5
081B:  CLRF   5C
081C:  CLRF   5D
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
*
03E7:  BSF    03.5
03E8:  CLRF   67
03E9:  CLRF   66
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
03EA:  MOVLW  30
03EB:  BCF    03.5
03EC:  BSF    03.6
03ED:  MOVWF  10
03EE:  MOVLW  31
03EF:  MOVWF  11
03F0:  MOVLW  32
03F1:  MOVWF  12
03F2:  MOVLW  33
03F3:  MOVWF  13
03F4:  MOVLW  34
03F5:  MOVWF  14
03F6:  MOVLW  35
03F7:  MOVWF  15
03F8:  MOVLW  36
03F9:  MOVWF  16
03FA:  MOVLW  37
03FB:  MOVWF  17
03FC:  MOVLW  38
03FD:  MOVWF  18
03FE:  MOVLW  39
03FF:  MOVWF  19
0400:  MOVLW  61
0401:  MOVWF  1A
0402:  MOVLW  62
0403:  MOVWF  1B
0404:  MOVLW  63
0405:  MOVWF  1C
0406:  MOVLW  64
0407:  MOVWF  1D
0408:  MOVLW  65
0409:  MOVWF  1E
040A:  MOVLW  66
040B:  MOVWF  1F
040C:  MOVLW  67
040D:  MOVWF  20
040E:  MOVLW  68
040F:  MOVWF  21
0410:  MOVLW  69
0411:  MOVWF  22
0412:  MOVLW  6A
0413:  MOVWF  23
0414:  MOVLW  6B
0415:  MOVWF  24
0416:  MOVLW  6C
0417:  MOVWF  25
0418:  MOVLW  6D
0419:  MOVWF  26
041A:  MOVLW  6E
041B:  MOVWF  27
041C:  MOVLW  6F
041D:  MOVWF  28
041E:  MOVLW  70
041F:  MOVWF  29
0420:  MOVLW  71
0421:  MOVWF  2A
0422:  MOVLW  73
0423:  MOVWF  2B
0424:  MOVLW  74
0425:  MOVWF  2C
0426:  MOVLW  75
0427:  MOVWF  2D
0428:  MOVLW  76
0429:  MOVWF  2E
042A:  MOVLW  77
042B:  MOVWF  2F
042C:  MOVLW  78
042D:  MOVWF  30
042E:  MOVLW  79
042F:  MOVWF  31
0430:  MOVLW  7A
0431:  MOVWF  32
0432:  CLRF   33
....................    for(sc=s;isspace(*sc);++sc); 
0433:  BSF    03.5
0434:  BCF    03.6
0435:  MOVF   5C,W
0436:  MOVWF  61
0437:  MOVF   5B,W
0438:  MOVWF  60
0439:  MOVF   61,W
043A:  MOVWF  7A
043B:  MOVF   60,W
043C:  MOVWF  04
043D:  BCF    03.7
043E:  BTFSC  7A.0
043F:  BSF    03.7
0440:  MOVF   00,W
0441:  SUBLW  20
0442:  BTFSS  03.2
0443:  GOTO   448
0444:  INCF   60,F
0445:  BTFSC  03.2
0446:  INCF   61,F
0447:  GOTO   439
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
0448:  MOVF   61,W
0449:  MOVWF  7A
044A:  MOVF   60,W
044B:  MOVWF  04
044C:  BCF    03.7
044D:  BTFSC  61.0
044E:  BSF    03.7
044F:  MOVF   00,W
0450:  SUBLW  2D
0451:  BTFSC  03.2
0452:  GOTO   45E
0453:  MOVF   61,W
0454:  MOVWF  7A
0455:  MOVF   60,W
0456:  MOVWF  04
0457:  BCF    03.7
0458:  BTFSC  61.0
0459:  BSF    03.7
045A:  MOVF   00,W
045B:  SUBLW  2B
045C:  BTFSS  03.2
045D:  GOTO   46A
045E:  MOVF   61,W
045F:  MOVWF  7A
0460:  MOVF   60,W
0461:  INCF   60,F
0462:  BTFSC  03.2
0463:  INCF   61,F
0464:  MOVWF  04
0465:  BCF    03.7
0466:  BTFSC  7A.0
0467:  BSF    03.7
0468:  MOVF   00,W
0469:  GOTO   46B
046A:  MOVLW  2B
046B:  MOVWF  68
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
046C:  MOVF   68,W
046D:  SUBLW  2D
046E:  BTFSC  03.2
046F:  GOTO   47B
0470:  BTFSC  5F.7
0471:  GOTO   47B
0472:  DECFSZ 5F,W
0473:  GOTO   475
0474:  GOTO   47B
0475:  BTFSC  5F.7
0476:  GOTO   47D
0477:  MOVF   5F,W
0478:  SUBLW  24
0479:  BTFSC  03.0
047A:  GOTO   47D
....................    goto StrtoulGO; 
047B:  GOTO   5FB
047C:  GOTO   513
....................  
....................    else if (base) 
047D:  MOVF   5F,F
047E:  BTFSC  03.2
047F:  GOTO   4D8
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
0480:  MOVF   5F,W
0481:  SUBLW  10
0482:  BTFSS  03.2
0483:  GOTO   4A7
0484:  MOVF   61,W
0485:  MOVWF  7A
0486:  MOVF   60,W
0487:  MOVWF  04
0488:  BCF    03.7
0489:  BTFSC  7A.0
048A:  BSF    03.7
048B:  MOVF   00,W
048C:  SUBLW  30
048D:  BTFSS  03.2
048E:  GOTO   4A7
048F:  MOVLW  01
0490:  ADDWF  60,W
0491:  MOVWF  04
0492:  BCF    03.7
0493:  BTFSC  61.0
0494:  BSF    03.7
0495:  MOVF   00,W
0496:  SUBLW  78
0497:  BTFSC  03.2
0498:  GOTO   4A3
0499:  MOVLW  01
049A:  ADDWF  60,W
049B:  MOVWF  04
049C:  BCF    03.7
049D:  BTFSC  61.0
049E:  BSF    03.7
049F:  MOVF   00,W
04A0:  SUBLW  58
04A1:  BTFSS  03.2
04A2:  GOTO   4A7
....................          sc+=2; 
04A3:  MOVLW  02
04A4:  ADDWF  60,F
04A5:  BTFSC  03.0
04A6:  INCF   61,F
....................       if(base==8 && *sc =='0') 
04A7:  MOVF   5F,W
04A8:  SUBLW  08
04A9:  BTFSS  03.2
04AA:  GOTO   4BA
04AB:  MOVF   61,W
04AC:  MOVWF  7A
04AD:  MOVF   60,W
04AE:  MOVWF  04
04AF:  BCF    03.7
04B0:  BTFSC  7A.0
04B1:  BSF    03.7
04B2:  MOVF   00,W
04B3:  SUBLW  30
04B4:  BTFSS  03.2
04B5:  GOTO   4BA
....................          sc+=1; 
04B6:  MOVLW  01
04B7:  ADDWF  60,F
04B8:  BTFSC  03.0
04B9:  INCF   61,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
04BA:  MOVF   5F,W
04BB:  SUBLW  02
04BC:  BTFSS  03.2
04BD:  GOTO   4D7
04BE:  MOVF   61,W
04BF:  MOVWF  7A
04C0:  MOVF   60,W
04C1:  MOVWF  04
04C2:  BCF    03.7
04C3:  BTFSC  7A.0
04C4:  BSF    03.7
04C5:  MOVF   00,W
04C6:  SUBLW  30
04C7:  BTFSS  03.2
04C8:  GOTO   4D7
04C9:  MOVLW  01
04CA:  ADDWF  60,W
04CB:  MOVWF  04
04CC:  BCF    03.7
04CD:  BTFSC  61.0
04CE:  BSF    03.7
04CF:  MOVF   00,W
04D0:  SUBLW  62
04D1:  BTFSS  03.2
04D2:  GOTO   4D7
....................          sc+=2; 
04D3:  MOVLW  02
04D4:  ADDWF  60,F
04D5:  BTFSC  03.0
04D6:  INCF   61,F
....................  
....................    } 
04D7:  GOTO   513
....................    else if(*sc!='0') // base is 0, find base 
04D8:  MOVF   61,W
04D9:  MOVWF  7A
04DA:  MOVF   60,W
04DB:  MOVWF  04
04DC:  BCF    03.7
04DD:  BTFSC  7A.0
04DE:  BSF    03.7
04DF:  MOVF   00,W
04E0:  SUBLW  30
04E1:  BTFSC  03.2
04E2:  GOTO   4E6
....................       base=10; 
04E3:  MOVLW  0A
04E4:  MOVWF  5F
04E5:  GOTO   513
....................    else if (sc[1]=='x' || sc[1]=='X') 
04E6:  MOVLW  01
04E7:  ADDWF  60,W
04E8:  MOVWF  04
04E9:  BCF    03.7
04EA:  BTFSC  61.0
04EB:  BSF    03.7
04EC:  MOVF   00,W
04ED:  SUBLW  78
04EE:  BTFSC  03.2
04EF:  GOTO   4FA
04F0:  MOVLW  01
04F1:  ADDWF  60,W
04F2:  MOVWF  04
04F3:  BCF    03.7
04F4:  BTFSC  61.0
04F5:  BSF    03.7
04F6:  MOVF   00,W
04F7:  SUBLW  58
04F8:  BTFSS  03.2
04F9:  GOTO   501
....................       base =16,sc+=2; 
04FA:  MOVLW  10
04FB:  MOVWF  5F
04FC:  MOVLW  02
04FD:  ADDWF  60,F
04FE:  BTFSC  03.0
04FF:  INCF   61,F
0500:  GOTO   513
....................    else if(sc[1]=='b') 
0501:  MOVLW  01
0502:  ADDWF  60,W
0503:  MOVWF  04
0504:  BCF    03.7
0505:  BTFSC  61.0
0506:  BSF    03.7
0507:  MOVF   00,W
0508:  SUBLW  62
0509:  BTFSS  03.2
050A:  GOTO   511
....................       base=2,sc+=2; 
050B:  MOVLW  02
050C:  MOVWF  5F
050D:  ADDWF  60,F
050E:  BTFSC  03.0
050F:  INCF   61,F
0510:  GOTO   513
....................    else 
....................       base=8; 
0511:  MOVLW  08
0512:  MOVWF  5F
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
0513:  MOVF   61,W
0514:  MOVWF  63
0515:  MOVF   60,W
0516:  MOVWF  62
0517:  MOVF   61,W
0518:  MOVWF  7A
0519:  MOVF   60,W
051A:  MOVWF  04
051B:  BCF    03.7
051C:  BTFSC  7A.0
051D:  BSF    03.7
051E:  MOVF   00,W
051F:  SUBLW  30
0520:  BTFSS  03.2
0521:  GOTO   526
0522:  INCF   60,F
0523:  BTFSC  03.2
0524:  INCF   61,F
0525:  GOTO   517
....................    sd=memchr(digits,tolower(*sc),base); 
0526:  MOVF   61,W
0527:  MOVWF  7A
0528:  MOVF   60,W
0529:  MOVWF  04
052A:  BCF    03.7
052B:  BTFSC  61.0
052C:  BSF    03.7
052D:  MOVF   00,W
052E:  MOVWF  69
052F:  SUBLW  40
0530:  BTFSC  03.0
0531:  GOTO   539
0532:  MOVF   69,W
0533:  SUBLW  5A
0534:  BTFSS  03.0
0535:  GOTO   539
0536:  MOVF   69,W
0537:  IORLW  20
0538:  GOTO   53A
0539:  MOVF   69,W
053A:  MOVWF  69
053B:  MOVLW  01
053C:  BCF    03.5
053D:  BSF    03.6
053E:  MOVWF  36
053F:  MOVLW  10
0540:  MOVWF  35
0541:  BSF    03.5
0542:  BCF    03.6
0543:  MOVF   69,W
0544:  BCF    03.5
0545:  BSF    03.6
0546:  MOVWF  37
0547:  CLRF   39
0548:  BSF    03.5
0549:  BCF    03.6
054A:  MOVF   5F,W
054B:  BCF    03.5
054C:  BSF    03.6
054D:  MOVWF  38
054E:  BCF    03.6
054F:  CALL   3BC
0550:  MOVF   79,W
0551:  BSF    03.5
0552:  MOVWF  65
0553:  MOVF   78,W
0554:  MOVWF  64
....................    for(; sd!=0; ) 
0555:  MOVF   64,F
0556:  BTFSS  03.2
0557:  GOTO   55B
0558:  MOVF   65,F
0559:  BTFSC  03.2
055A:  GOTO   5F3
....................    { 
....................       x=x*base+(int16)(sd-digits); 
055B:  CLRF   7A
055C:  MOVF   5F,W
055D:  MOVWF  77
055E:  BTFSC  77.7
055F:  DECF   7A,F
0560:  MOVWF  69
0561:  MOVF   7A,W
0562:  MOVWF  6A
0563:  MOVF   67,W
0564:  BCF    03.5
0565:  BSF    03.6
0566:  MOVWF  37
0567:  BSF    03.5
0568:  BCF    03.6
0569:  MOVF   66,W
056A:  BCF    03.5
056B:  BSF    03.6
056C:  MOVWF  36
056D:  BSF    03.5
056E:  BCF    03.6
056F:  MOVF   6A,W
0570:  BCF    03.5
0571:  BSF    03.6
0572:  MOVWF  39
0573:  BSF    03.5
0574:  BCF    03.6
0575:  MOVF   69,W
0576:  BCF    03.5
0577:  BSF    03.6
0578:  MOVWF  38
*
05A6:  MOVF   79,W
05A7:  BSF    03.5
05A8:  BCF    03.6
05A9:  MOVWF  6A
05AA:  MOVF   78,W
05AB:  MOVWF  69
05AC:  MOVLW  10
05AD:  SUBWF  64,W
05AE:  MOVWF  77
05AF:  MOVF   65,W
05B0:  MOVWF  7A
05B1:  MOVLW  01
05B2:  BTFSS  03.0
05B3:  MOVLW  02
05B4:  SUBWF  7A,F
05B5:  MOVF   77,W
05B6:  ADDWF  69,W
05B7:  MOVWF  78
05B8:  MOVF   6A,W
05B9:  BTFSC  03.0
05BA:  INCFSZ 6A,W
05BB:  ADDWF  7A,F
05BC:  MOVF   78,W
05BD:  MOVWF  66
05BE:  MOVF   7A,W
05BF:  MOVWF  67
....................       ++sc; 
05C0:  INCF   60,F
05C1:  BTFSC  03.2
05C2:  INCF   61,F
....................       sd=memchr(digits,tolower(*sc),base); 
05C3:  MOVF   61,W
05C4:  MOVWF  7A
05C5:  MOVF   60,W
05C6:  MOVWF  04
05C7:  BCF    03.7
05C8:  BTFSC  61.0
05C9:  BSF    03.7
05CA:  MOVF   00,W
05CB:  MOVWF  69
05CC:  SUBLW  40
05CD:  BTFSC  03.0
05CE:  GOTO   5D6
05CF:  MOVF   69,W
05D0:  SUBLW  5A
05D1:  BTFSS  03.0
05D2:  GOTO   5D6
05D3:  MOVF   69,W
05D4:  IORLW  20
05D5:  GOTO   5D7
05D6:  MOVF   69,W
05D7:  MOVWF  69
05D8:  MOVLW  01
05D9:  BCF    03.5
05DA:  BSF    03.6
05DB:  MOVWF  36
05DC:  MOVLW  10
05DD:  MOVWF  35
05DE:  BSF    03.5
05DF:  BCF    03.6
05E0:  MOVF   69,W
05E1:  BCF    03.5
05E2:  BSF    03.6
05E3:  MOVWF  37
05E4:  CLRF   39
05E5:  BSF    03.5
05E6:  BCF    03.6
05E7:  MOVF   5F,W
05E8:  BCF    03.5
05E9:  BSF    03.6
05EA:  MOVWF  38
05EB:  BCF    03.6
05EC:  CALL   3BC
05ED:  MOVF   79,W
05EE:  BSF    03.5
05EF:  MOVWF  65
05F0:  MOVF   78,W
05F1:  MOVWF  64
05F2:  GOTO   555
....................    } 
....................    if(s1==sc) 
05F3:  MOVF   60,W
05F4:  SUBWF  62,W
05F5:  BTFSS  03.2
05F6:  GOTO   60E
05F7:  MOVF   61,W
05F8:  SUBWF  63,W
05F9:  BTFSS  03.2
05FA:  GOTO   60E
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
05FB:  MOVF   5D,W
05FC:  IORWF  5E,W
05FD:  BTFSC  03.2
05FE:  GOTO   60A
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
05FF:  MOVF   5D,W
0600:  MOVWF  04
0601:  BCF    03.7
0602:  BTFSC  5E.0
0603:  BSF    03.7
0604:  INCF   04,F
0605:  MOVF   5C,W
0606:  MOVWF  00
0607:  DECF   04,F
0608:  MOVF   5B,W
0609:  MOVWF  00
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
060A:  MOVLW  00
060B:  MOVWF  78
060C:  MOVWF  79
060D:  GOTO   621
....................    } 
....................    if (endptr) 
060E:  MOVF   5D,W
060F:  IORWF  5E,W
0610:  BTFSC  03.2
0611:  GOTO   61D
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
0612:  MOVF   5D,W
0613:  MOVWF  04
0614:  BCF    03.7
0615:  BTFSC  5E.0
0616:  BSF    03.7
0617:  INCF   04,F
0618:  MOVF   61,W
0619:  MOVWF  00
061A:  DECF   04,F
061B:  MOVF   60,W
061C:  MOVWF  00
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
061D:  MOVF   66,W
061E:  MOVWF  78
061F:  MOVF   67,W
0620:  MOVWF  79
0621:  BCF    03.5
0622:  RETURN
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... void saveUser(int * id, int * pass, int status){ 
....................    if( id[0] <= 99 && id[1] <= 99 && getAddressByID(id) == -1 ){ 
....................       int address = lastNewUserPosition(); 
....................  
....................       //recebe os parÃ¢metros do usuÃ¡rio 
....................       User user; 
....................       user.id[0] = id[0]; 
....................       user.id[1] = id[1]; 
....................       user.pass[0] = pass[0]; 
....................       user.pass[1] = pass[1]; 
....................       user.pass[2] = pass[2]; 
....................       user.pass[3] = pass[3]; 
....................       user.status = status; 
....................        
....................       write_ext_eeprom(address, user.id[0]); 
....................       write_ext_eeprom(address+1, user.id[1]); 
....................       write_ext_eeprom(address+2, user.pass[0]); 
....................       write_ext_eeprom(address+3, user.pass[1]); 
....................       write_ext_eeprom(address+4, user.pass[2]); 
....................       write_ext_eeprom(address+5, user.pass[3]);        
....................       write_ext_eeprom(address+6, user.status); 
....................  
....................       printf (lcd_escreve,"\fUsuario Cadastrado"); 
....................       delay_ms(500); 
....................  
....................    }else{ 
....................       printf (lcd_escreve,"\fID incompativel"); 
....................       printf (lcd_escreve,"\r\nTente novamente"); 
....................       delay_ms(1000); 
....................  
....................    } 
.................... } 
....................  
.................... void updateUser(int * id, int * pass, int status, int address){ 
....................    if( id[0] <= 99 && id[1] <= 99){ 
....................       //recebe os parÃ¢metros do usuÃ¡rio 
....................       User user; 
....................       user.id[0] = id[0]; 
....................       user.id[1] = id[1]; 
....................       user.pass[0] = pass[0]; 
....................       user.pass[1] = pass[1]; 
....................       user.pass[2] = pass[2]; 
....................       user.pass[3] = pass[3]; 
....................       user.status = status; 
....................        
....................       write_ext_eeprom(address, user.id[0]); 
....................       write_ext_eeprom(address+1, user.id[1]); 
....................       write_ext_eeprom(address+2, user.pass[0]); 
....................       write_ext_eeprom(address+3, user.pass[1]); 
....................       write_ext_eeprom(address+4, user.pass[2]); 
....................       write_ext_eeprom(address+5, user.pass[3]);        
....................       write_ext_eeprom(address+6, user.status); 
....................  
....................       printf (lcd_escreve,"\fUsuario Atualizado"); 
....................       delay_ms(500); 
....................  
....................    }else{ 
....................       printf (lcd_escreve,"\fID incompativel"); 
....................       printf (lcd_escreve,"\r\nTente novamente"); 
....................       delay_ms(1000); 
....................    } 
....................  
.................... } 
....................  
.................... void printUser(User user){ 
....................    // printf (lcd_escreve,"\fCliente ID: %u%u",user.id[0],user.id[1]); 
....................    // printf(lcd_escreve, "\r\nPw:%u%u%u%u St:%u",user.pass[0],user.pass[1],user.pass[2],user.pass[3],user.status); 
....................    // printf (lcd_escreve,"\fCliente ID: %u%u",user.id[0],user.id[1]); 
....................    printf(lcd_escreve, "\r\nPw:%u%u%u%u St:%u",user.pass[0],user.pass[1],user.pass[2],user.pass[3],user.status); 
*
07B9:  MOVLW  91
07BA:  BSF    03.6
07BB:  MOVWF  0D
07BC:  MOVLW  00
07BD:  MOVWF  0F
07BE:  BCF    03.0
07BF:  MOVLW  05
07C0:  BSF    03.5
07C1:  BCF    03.6
07C2:  MOVWF  27
07C3:  BCF    03.5
07C4:  CALL   6E9
07C5:  BSF    03.5
07C6:  MOVF   22,W
07C7:  MOVWF  27
07C8:  MOVLW  1B
07C9:  MOVWF  28
07CA:  BCF    03.5
07CB:  CALL   77A
07CC:  BSF    03.5
07CD:  MOVF   23,W
07CE:  MOVWF  27
07CF:  MOVLW  1B
07D0:  MOVWF  28
07D1:  BCF    03.5
07D2:  CALL   77A
07D3:  BSF    03.5
07D4:  MOVF   24,W
07D5:  MOVWF  27
07D6:  MOVLW  1B
07D7:  MOVWF  28
07D8:  BCF    03.5
07D9:  CALL   77A
07DA:  BSF    03.5
07DB:  MOVF   25,W
07DC:  MOVWF  27
07DD:  MOVLW  1B
07DE:  MOVWF  28
07DF:  BCF    03.5
07E0:  CALL   77A
07E1:  MOVLW  97
07E2:  BSF    03.6
07E3:  MOVWF  0D
07E4:  MOVLW  00
07E5:  MOVWF  0F
07E6:  BSF    03.0
07E7:  MOVLW  04
07E8:  BSF    03.5
07E9:  BCF    03.6
07EA:  MOVWF  27
07EB:  BCF    03.5
07EC:  CALL   6E9
07ED:  BSF    03.5
07EE:  MOVF   26,W
07EF:  MOVWF  27
07F0:  MOVLW  1B
07F1:  MOVWF  28
07F2:  BCF    03.5
07F3:  CALL   77A
....................    delay_ms(1000); 
07F4:  MOVLW  04
07F5:  MOVWF  7B
07F6:  MOVLW  FA
07F7:  BSF    03.5
07F8:  MOVWF  56
07F9:  BCF    03.5
07FA:  CALL   270
07FB:  DECFSZ 7B,F
07FC:  GOTO   7F6
07FD:  BSF    0A.3
07FE:  BCF    0A.4
07FF:  GOTO   0D4 (RETURN)
.................... } 
....................  
.................... User receiveUser(){ 
....................     
....................    int * rx_buffer_int; 
....................    char string[RX_BUFFER_SIZE]; 
....................    int numbers[RX_BUFFER_SIZE]; 
....................    strcpy(string, rx_buffer); 
*
0623:  BSF    03.5
0624:  CLRF   56
0625:  MOVLW  32
0626:  MOVWF  55
0627:  CLRF   54
0628:  MOVLW  A4
0629:  MOVWF  53
062A:  MOVF   55,W
062B:  MOVWF  04
062C:  BCF    03.7
062D:  BTFSC  56.0
062E:  BSF    03.7
062F:  MOVF   00,W
0630:  MOVWF  57
0631:  MOVF   53,W
0632:  MOVWF  04
0633:  BCF    03.7
0634:  BTFSC  54.0
0635:  BSF    03.7
0636:  MOVF   57,W
0637:  MOVWF  00
0638:  MOVF   00,F
0639:  BTFSC  03.2
063A:  GOTO   63E
063B:  INCF   53,F
063C:  INCF   55,F
063D:  GOTO   62A
....................    rx_buffer_int = strToInt(string); 
063E:  CLRF   54
063F:  MOVLW  A4
0640:  MOVWF  53
*
067A:  MOVF   79,W
067B:  MOVWF  23
067C:  MOVF   78,W
067D:  MOVWF  22
....................    // for(int i=0;i < RX_BUFFER_SIZE; i++){ 
....................    //    numbers[i] = rx_buffer_int[i]; 
....................    //    write_ext_eeprom(i, numbers[i]); 
....................    // } 
....................    printf (lcd_escreve,"\f%s",string); 
067E:  MOVLW  0C
067F:  MOVWF  55
0680:  BCF    03.5
0681:  CALL   325
0682:  MOVLW  A4
0683:  MOVWF  04
0684:  BCF    03.7
....................    delay_ms(500); 
*
06A1:  MOVLW  02
06A2:  BSF    03.5
06A3:  MOVWF  53
06A4:  MOVLW  FA
06A5:  MOVWF  56
06A6:  BCF    03.5
06A7:  CALL   270
06A8:  BSF    03.5
06A9:  DECFSZ 53,F
06AA:  GOTO   6A4
....................    // printf(lcd_escreve, "\r\nPw:%d%d%d St:%d",user.pass[0],user.pass[1],user.pass[2],user.pass[3],user.status); 
....................    // delay_ms(1000); 
....................    // for(int i =0; i < RX_BUFFER_SIZE; i++){ 
....................    //    printf (lcd_escreve,"\rPos:%d Value:%d",i,rx_buffer_int[i]); 
....................    //    printf (lcd_escreve,"Pos:%d Value:%d",i,rx_buffer_int[i]); 
....................    //    delay_ms(500); 
....................    // } 
....................  
....................    User user; 
....................    user.id[0] = rx_buffer_int[0]; 
06AB:  MOVF   22,W
06AC:  MOVWF  04
06AD:  BCF    03.7
06AE:  BTFSC  23.0
06AF:  BSF    03.7
06B0:  MOVF   00,W
06B1:  MOVWF  4C
....................    user.id[1] = rx_buffer_int[1]; 
06B2:  MOVLW  01
06B3:  ADDWF  22,W
06B4:  MOVWF  04
06B5:  BCF    03.7
06B6:  BTFSC  23.0
06B7:  BSF    03.7
06B8:  MOVF   00,W
06B9:  MOVWF  4D
....................    user.pass[0] = rx_buffer_int[2]; 
06BA:  MOVLW  02
06BB:  ADDWF  22,W
06BC:  MOVWF  04
06BD:  BCF    03.7
06BE:  BTFSC  23.0
06BF:  BSF    03.7
06C0:  MOVF   00,W
06C1:  MOVWF  4E
....................    user.pass[1] = rx_buffer_int[3]; 
06C2:  MOVLW  03
06C3:  ADDWF  22,W
06C4:  MOVWF  04
06C5:  BCF    03.7
06C6:  BTFSC  23.0
06C7:  BSF    03.7
06C8:  MOVF   00,W
06C9:  MOVWF  4F
....................    user.pass[2] = rx_buffer_int[4]; 
06CA:  MOVLW  04
06CB:  ADDWF  22,W
06CC:  MOVWF  04
06CD:  BCF    03.7
06CE:  BTFSC  23.0
06CF:  BSF    03.7
06D0:  MOVF   00,W
06D1:  MOVWF  50
....................    user.pass[3] = rx_buffer_int[5]; 
06D2:  MOVLW  05
06D3:  ADDWF  22,W
06D4:  MOVWF  04
06D5:  BCF    03.7
06D6:  BTFSC  23.0
06D7:  BSF    03.7
06D8:  MOVF   00,W
06D9:  MOVWF  51
....................    user.status = rx_buffer_int[6]; 
06DA:  MOVLW  06
06DB:  ADDWF  22,W
06DC:  MOVWF  04
06DD:  BCF    03.7
06DE:  BTFSC  23.0
06DF:  BSF    03.7
06E0:  MOVF   00,W
06E1:  MOVWF  52
....................  
....................    return user; 
06E2:  MOVLW  CC
06E3:  MOVWF  78
06E4:  CLRF   79
06E5:  BCF    03.5
06E6:  BSF    0A.3
06E7:  BCF    0A.4
06E8:  GOTO   0A0 (RETURN)
.................... } 
....................  
.................... int getAddressByID(int * id){ 
....................    int id_temp[2]; 
....................    int address = 0; 
....................     
....................    while( read_ext_eeprom(address) != -1){ 
....................       id_temp[0] = read_ext_eeprom(address); 
....................       id_temp[1] = read_ext_eeprom(address+1); 
....................        
....................       if (id_temp[0] == id[0] && id_temp[1] == id[1]){ 
....................          return address; 
....................       } 
....................  
....................       address += BLOCK_SIZE;  
....................    } 
....................    return -1; 
.................... } 
....................  
.................... void searchUser(int * id){ 
....................  
....................    int address = getAddressByID(id); 
....................    if(address != -1){ 
....................       printf (lcd_escreve,"\fID:%u%u",id[0],id[1]); 
....................       int showStatus = 1; 
....................       getUserStatus(address,showStatus); 
....................    }else{ 
....................       printf(lcd_escreve,"\fUsuario N Existe"); 
....................       delay_ms(1000); 
....................    } 
.................... } 
....................  
.................... void erase_program_eeprom(int addrr){ 
....................    for(int i=0; i < BLOCK_SIZE; i++){ 
....................          write_ext_eeprom(addrr + i, -1); 
....................    }   
.................... } 
....................  
.................... int getUserStatus(int address, int show){ 
....................    int status = read_ext_eeprom(address+BLOCK_SIZE - 1); 
....................  
....................    if(show == 1){ 
....................       char msg_status[10]; 
....................       if( status == 0){ 
....................          strcpy(msg_status,"NAO PAGO"); 
....................       }else{ 
....................          strcpy(msg_status,"PAGO"); 
....................       } 
....................       printf (lcd_escreve,"\r\nStatus:%s",msg_status); 
....................       delay_ms(1500); 
....................    } 
....................    return status; 
.................... } 
....................  
.................... int deleteUser(int * id){ 
....................     
....................    int address = getAddressByID(id); 
....................    if(address == -1) 
....................       return -1; 
....................    int data_temp; 
....................    int previous_block = address; 
....................    int next_block = address + BLOCK_SIZE; 
....................  
....................    //Case 1: without the next block 
....................    if (read_ext_eeprom(next_block) == -1){ 
....................       erase_program_eeprom(previous_block);       
....................       return 1; 
....................    } 
....................  
....................    //Case 2: Check whether the data in the next block address is empty 
....................    while(read_ext_eeprom(next_block) != -1){ 
....................       //data_temp[index] = read_ext_eeprom(address); 
....................       for(int i=0; i < BLOCK_SIZE; i++){ 
....................          //Read the data from the next block  
....................          data_temp = read_ext_eeprom(next_block + i);            
....................          //overwrite the previous block with the data from the next 
....................          write_ext_eeprom(previous_block + i, data_temp);   
....................       }   
....................       previous_block = next_block; 
....................       next_block += BLOCK_SIZE; 
....................    } 
....................    //Go back to erase the block that's duplicated  
....................    next_block -= BLOCK_SIZE; 
....................    //Erase the last block since everything  
....................    //moved a block_size to the left 
....................    erase_program_eeprom(next_block); 
....................     
....................    return 1; 
....................  
.................... } 
....................  
.................... int lastNewUserPosition(){ 
....................    int address = 0; 
....................    while( read_ext_eeprom(address) != -1){ 
....................       address += BLOCK_SIZE;  
....................    } 
....................    return address; 
.................... } 
....................  
.................... void resetMemory(){ 
....................    int address = 0; 
....................    for(; read_ext_eeprom(address) != -1; address += BLOCK_SIZE){ 
....................       erase_program_eeprom(address); 
....................     } 
....................    printf (lcd_escreve,"\fMemory Cleaned"); 
....................    delay_ms(200); 
.................... } 
....................  
.................... void adminMenu(){ 
....................    unsigned char option; 
....................    unsigned int * temp; 
....................    unsigned int id [2]; 
....................    do{ 
....................       printf(lcd_escreve,"\f1:CAD|2:BUSCAR"); 
....................       printf(lcd_escreve,"\r\n3:DEL|4:EDITAR"); 
....................       delay_ms(1000); 
....................       printf(lcd_escreve,"\f5:Atualizar Base Dados"); 
....................       printf(lcd_escreve,"\r\n6:Enviar Base Dados"); 
....................       delay_ms(500); 
....................       printf(lcd_escreve,"\n7: SAIR do Menu "); 
....................       delay_ms(100); 
....................      
....................       option = readKeyboard(); 
....................  
....................       if(option != 255){ 
....................          printf(lcd_escreve,"\f Option: %c", option); 
....................          delay_ms(500); 
....................  
....................          switch(option){ 
....................             case '1': 
....................                inputKeyboardUser(); 
....................                break; 
....................             case '2': 
....................                temp = inputId(); 
....................                id[0] = temp[0]; 
....................                id[1] = temp[1]; 
....................                searchUser(id); 
....................                break; 
....................             case '3': 
....................                temp = inputId(); 
....................                id[0] = temp[0]; 
....................                id[1] = temp[1]; 
....................                signed int success = deleteUser(id); 
....................                printf(lcd_escreve,"\fSuccess -> %d", success); 
....................                delay_ms(500); 
....................                (success >= 1)?  
....................                printf(lcd_escreve,"\fusuario deletado"): 
....................                printf(lcd_escreve,"\fusuario N Existe"); 
....................                delay_ms(500); 
....................                break; 
....................             case '4': 
....................                editUser(); 
....................                break; 
....................             case '5': 
....................                waitUpdate(); 
....................                break; 
....................             default: 
....................                printf(lcd_escreve,"\fDigite um valor"); 
....................                printf(lcd_escreve,"\r\nValido!"); 
....................                delay_ms(500); 
....................                break; 
....................          } 
....................       } 
....................    }while(option != '7'); 
.................... } 
....................  
....................  
.................... int login(int * id){ 
....................  
....................    int address = getAddressByID(id); 
....................    if(address == -1){ 
....................       printf(lcd_escreve,"\fID N Existe"); 
....................       printf(lcd_escreve,"\r\nTente de novo"); 
....................       delay_ms(1000); 
....................       return -1; 
....................    } 
....................    unsigned int * temp; 
....................    unsigned int pass[4]; 
....................  
....................    char msg [] = "Digite a senha: "; 
....................    int max = 4; 
....................    temp = inputToKeyboard(msg, max); 
....................    pass[0] = temp[0]; 
....................    pass[1] = temp[1]; 
....................    pass[2] = temp[2]; 
....................    pass[3] = temp[3]; 
....................    // printf(lcd_escreve,"\fPASS(4): %u%u%u%u",pass[0],pass[1],pass[2],pass[3]); 
....................    // delay_ms(1000); 
....................    int result_pass = checkPassword(address,pass); 
....................    if(result_pass != 0){ 
....................       printf(lcd_escreve,"\fProcure a secretaria"); 
....................       printf(lcd_escreve,"\r\nP/ resolver"); 
....................       delay_ms(1000); 
....................       printf(lcd_escreve,"\fNADA eh Ligado!"); 
....................       delay_ms(500); 
....................       return -1; 
....................    } 
....................  
....................    int show = 0; 
....................    int status = getUserStatus(address,show); 
....................    return status; 
....................  
.................... } 
....................  
.................... int checkPassword(int initBlockAddr, int * pass){ 
....................    int pass_addr = initBlockAddr + 2; 
....................    int len = 4;  
....................    for(int i=0; i < len;i++,pass_addr++){ 
....................       if(pass[i] != read_ext_eeprom(pass_addr)) 
....................          return -1; 
....................    } 
....................    return 0; 
....................  
.................... } 
.................... unsigned char readKeyboard(){ 
....................  
....................    unsigned char tmp; 
....................    unsigned char tmp_result; 
....................     
....................    tmp = tc_tecla(1300); // ms 
....................    if(tmp != 255){ 
....................       // write_ext_eeprom(0, tmp); 
....................       // delay_ms(50); 
....................       // tmp_result = read_ext_eeprom(0); 
....................       // delay_ms(50); 
....................       // tmp_result = tmp; 
....................       // printf(lcd_escreve,"\f Button: %c", tmp); 
....................       // delay_ms(50); 
....................    }else{  
....................       printf(lcd_escreve,"\f Digite"); 
....................    } 
....................  
....................    return tmp; 
.................... } 
....................  
....................  
.................... int * getAdminsID(){ 
....................  
....................    int address = 0; 
....................    int temp_status; 
....................    int index= 0; 
....................    static int admins[BLOCK_SIZE]; 
*
081D:  CLRF   62
081E:  CLRF   63
081F:  CLRF   64
0820:  CLRF   65
0821:  CLRF   66
0822:  CLRF   67
0823:  CLRF   68
....................    admins[0] = -1; 
....................    while( read_ext_eeprom(address) != -1){ 
....................       temp_status = read_ext_eeprom(address + (BLOCK_SIZE - 1));//status of the user 
....................       if (temp_status == 3){ 
....................          printf (lcd_escreve,"\fAdmin Encontrado"); 
....................          delay_ms(1000); 
....................          for(int i=0; i < 2; i++){ 
....................             int id = read_ext_eeprom(address+i);    
....................             admins[index] = id; 
....................             index++; 
....................          } 
....................  
....................       } 
....................  
....................       address += BLOCK_SIZE;  
....................    } 
....................  
....................    return admins; 
....................  
.................... } 
....................  
.................... void listAdmins(){ 
....................    int * admins; 
....................  
....................    admins = getAdminsID(); 
....................    printf(lcd_escreve,"\f admins[0]: %d", admins[0]); 
....................    delay_ms(1000); 
....................    if(admins[0] != -1){ 
....................       for (int16 i=0; i < sizeof(admins); i+=2){ 
....................          printf(lcd_escreve, "\fid:%u%u",admins[i], admins[i+1]); 
....................          delay_ms(1000); 
....................       }  
....................    } 
.................... } 
....................  
....................  
.................... int * strToInt(char * str){ 
*
0641:  MOVF   54,W
0642:  MOVWF  56
0643:  MOVF   53,W
0644:  MOVWF  55
0645:  CLRF   59
....................  
....................   char *p = str; 
....................   //https://flaviocopes.com/c-array-length/ 
....................   static unsigned int buffer[BLOCK_SIZE];   
*
0824:  CLRF   69
0825:  CLRF   6A
0826:  CLRF   6B
0827:  CLRF   6C
0828:  CLRF   6D
0829:  CLRF   6E
082A:  CLRF   6F
....................   char * end; 
....................   int index = 0; 
....................  
.................... //   printf (lcd_escreve,"\fP: %s",p); 
.................... //   delay_ms(1000); 
....................   for (unsigned int number = strtoul(p, &end, 10); 
*
0646:  MOVF   56,W
0647:  MOVWF  5C
0648:  MOVF   55,W
0649:  MOVWF  5B
064A:  CLRF   5E
064B:  MOVLW  D7
064C:  MOVWF  5D
064D:  MOVLW  0A
064E:  MOVWF  5F
064F:  BCF    03.5
0650:  CALL   3E7
0651:  MOVF   78,W
0652:  BSF    03.5
0653:  MOVWF  5A
....................         p != end; 
0654:  MOVF   57,W
0655:  SUBWF  55,W
0656:  BTFSS  03.2
0657:  GOTO   65C
0658:  MOVF   58,W
0659:  SUBWF  56,W
065A:  BTFSC  03.2
065B:  GOTO   676
....................         number = strtoul(p, &end, 10)) 
....................   { 
....................     p = end; 
065C:  MOVF   58,W
065D:  MOVWF  56
065E:  MOVF   57,W
065F:  MOVWF  55
....................  
....................     buffer[index] = number;  
0660:  MOVLW  69
0661:  ADDWF  59,W
0662:  MOVWF  04
0663:  BCF    03.7
0664:  MOVF   5A,W
0665:  MOVWF  00
....................    //  printf (lcd_escreve,"\fNumber: %u", number); 
....................    //  printf (lcd_escreve,"\r%u", number); 
....................    //  delay_ms(1000); 
....................     index++; 
0666:  INCF   59,F
0667:  MOVF   56,W
0668:  MOVWF  5C
0669:  MOVF   55,W
066A:  MOVWF  5B
066B:  CLRF   5E
066C:  MOVLW  D7
066D:  MOVWF  5D
066E:  MOVLW  0A
066F:  MOVWF  5F
0670:  BCF    03.5
0671:  CALL   3E7
0672:  MOVF   78,W
0673:  BSF    03.5
0674:  MOVWF  5A
0675:  GOTO   654
....................   } 
....................  
....................    return buffer; 
0676:  MOVLW  69
0677:  MOVWF  78
0678:  MOVLW  00
0679:  MOVWF  79
.................... } 
....................  
.................... char * strfromchar(char destination[], char source)  
.................... {  
....................    destination[0] = source;   // copy the character into the string  
....................    destination[1] = '\0';      // null-terminate the string  
....................   
....................    return destination;         // common convention for str functions  
.................... }  
....................  
....................  
.................... int * inputId(){ 
....................    unsigned char keyboard_buffer[BLOCK_SIZE * 2]; 
....................    unsigned char option; 
....................  
....................    int * temp; 
....................    int i = 0; 
....................    //The user needs to type 4 digits 
....................    //For example, even if it's just 9 
....................    //He/she will type: 0009 
....................    while(i < 5){ 
....................       printf(lcd_escreve,"\fDigite o ID: "); 
....................       delay_ms(50); 
....................       option = readKeyboard(); 
....................       if(option != 255){ 
....................          printf(lcd_escreve,"\n\rTyped:%c", option); 
....................          delay_ms(400); 
....................          if(i == 2){ 
....................             //To convert to int will be easier with space between them 
....................             keyboard_buffer[i] = ' '; 
....................             i++; 
....................          } 
....................          keyboard_buffer[i] = option; 
....................          i++; 
....................       } 
....................    } 
....................    // unsigned char *id; 
....................    // id = keyboard_buffer; 
....................    temp = strToInt(keyboard_buffer); 
....................    return temp; 
.................... } 
....................  
.................... int * inputToKeyboard(char * msg, int max){ 
....................    unsigned char option; 
....................    int data[BLOCK_SIZE]; 
....................    int * temp; 
....................    int i = 0; 
....................  
....................    while(i < max){ 
....................  
....................       printf(lcd_escreve,"\f%s", msg); 
....................       delay_ms(50); 
....................       option = readKeyboard(); 
....................       if(option != 255){ 
....................          printf(lcd_escreve,"\n\rTyped:%c", option); 
....................          delay_ms(400); 
....................          unsigned char destination[2]; 
....................          //Convert string from char and return  
....................          //to the left array of char(str_pass) 
....................          strfromchar(destination,option); 
....................          temp = strToInt(destination); 
....................          data[i] = temp[0]; 
....................          i++; 
....................       } 
....................    } 
....................  
....................    temp = data; 
....................    return temp; 
....................  
.................... } 
.................... void inputKeyboardUser(){ 
....................  
....................    unsigned int * temp; 
....................    unsigned int id [2]; 
....................    temp = inputId(); 
....................    id[0] = temp[0]; 
....................    id[1] = temp[1]; 
....................    int address = getAddressByID(id); 
....................    printf(lcd_escreve,"\fid: %u%u",id[0],id[1]); 
....................    delay_ms(500); 
....................    if(address == -1){//-1: ID is available to use 
....................       unsigned int pass[4]; 
....................       unsigned int status; 
....................  
....................       char msg [] = "Digite a senha: "; 
....................       int max = 4; 
....................       temp = inputToKeyboard(msg, max); 
....................       pass[0] = temp[0]; 
....................       pass[1] = temp[1]; 
....................       pass[2] = temp[2]; 
....................       pass[3] = temp[3]; 
....................  
....................       char msg2 [] = "Status (0,1,3): "; 
....................       max = 1; 
....................       temp = inputToKeyboard(msg2, max); 
....................       status = temp[0]; 
....................  
....................       saveUser(id,pass,status); 
....................    }else{ 
....................       printf (lcd_escreve,"\fID Jah Existe"); 
....................       delay_ms(1000); 
....................    } 
.................... } 
....................  
.................... void editUser(){ 
....................    unsigned int * temp; 
....................    unsigned int id [2]; 
....................    temp = inputId(); 
....................    id[0] = temp[0]; 
....................    id[1] = temp[1]; 
....................    int address = getAddressByID(id); 
....................    if(address != -1){ 
....................       unsigned int * temp; 
....................       unsigned int pass[4]; 
....................       unsigned int status; 
....................  
....................       char msg [] = "Nova senha: "; 
....................       int max = 4; 
....................       temp = inputToKeyboard(msg, max); 
....................       pass[0] = temp[0]; 
....................       pass[1] = temp[1]; 
....................       pass[2] = temp[2]; 
....................       pass[3] = temp[3]; 
....................       printf(lcd_escreve,"\fPASS(4): %u%u%u%u",pass[0],pass[1],pass[2],pass[3]); 
....................       delay_ms(500); 
....................  
....................       char msg2 [] = "Novo Status\r\n(0,1,3): "; 
....................       max = 1; 
....................       temp = inputToKeyboard(msg2, max); 
....................       status = temp[0]; 
....................       printf(lcd_escreve,"\fSTATUS: %u",status); 
....................       delay_ms(500); 
....................  
....................       updateUser(id,pass,status,address); 
....................    }else{ 
....................       printf (lcd_escreve,"\fID N Existe"); 
....................       delay_ms(1000); 
....................    } 
.................... } 
....................  
.................... void waitUpdate(){ 
....................    resetMemory(); 
....................    printf (lcd_escreve,"\fEm Modo Espera"); 
....................    printf (lcd_escreve,"\r\nde dados ..."); 
....................    delay_ms(100); 
....................    User user; 
....................    while(true){ 
....................       if(data_avail){ 
....................          if(rx_buffer[0] =='#' && rx_buffer[2] =='#'){ 
....................             printf (lcd_escreve,"\fFim da Comunicacao"); 
....................             delay_ms(1000); 
....................             break; 
....................          } 
....................          data_avail = FALSE; 
....................          user = receiveUser(); 
....................          printUser(user); 
....................          // overwriteUser(user); 
....................          // rx_wr_index = 0; 
....................          printf (lcd_escreve,"\fPIC em modo Espera"); 
....................          printf (lcd_escreve,"\r\nEsperando dados..."); 
....................          delay_ms(100); 
....................       } 
....................    } 
.................... } 
....................  
.................... void overwriteUser(User user){ 
....................  
....................    if(user.id[0] <= 99 && user.id[1] <= 99 && getAddressByID(user.id) == -1 ){ 
....................       int address = lastNewUserPosition(); 
....................  
....................       write_ext_eeprom(address, user.id[0]); 
....................       write_ext_eeprom(address+1, user.id[1]); 
....................       write_ext_eeprom(address+2, user.pass[0]); 
....................       write_ext_eeprom(address+3, user.pass[1]); 
....................       write_ext_eeprom(address+4, user.pass[2]); 
....................       write_ext_eeprom(address+5, user.pass[3]);        
....................       write_ext_eeprom(address+6, user.status); 
....................  
....................       // printf (lcd_escreve,"\fUsuario Cadastrado"); 
....................       // delay_ms(500); 
....................  
....................    }else{ 
....................       printf (lcd_escreve,"\fID incompativel"); 
....................       printf (lcd_escreve,"\r\nTente novamente"); 
....................       delay_ms(500); 
....................  
....................    } 
.................... } 
....................  
....................  
.................... // ---- MSG from serial communication 
.................... #int_RDA 
.................... void RDA_isr(void){ 
....................    rx_buffer[rx_wr_index] = getc(); 
*
01D5:  MOVLW  32
01D6:  ADDWF  2B,W
01D7:  MOVWF  04
01D8:  BCF    03.7
01D9:  BTFSS  0C.5
01DA:  GOTO   1D9
01DB:  MOVF   1A,W
01DC:  MOVWF  00
....................    // history[rx_wr_index] = fgetc(Wireless); 
....................    rxd = rx_buffer[rx_wr_index]; 
01DD:  MOVLW  32
01DE:  ADDWF  2B,W
01DF:  MOVWF  04
01E0:  BCF    03.7
01E1:  MOVF   00,W
01E2:  MOVWF  2D
....................    rx_wr_index++; 
01E3:  INCF   2B,F
....................    //n_bytes = rcv_buffer_bytes(Wireless); 
....................  
....................    if(rx_wr_index > RX_BUFFER_SIZE){ 
01E4:  MOVF   2B,W
01E5:  SUBLW  14
01E6:  BTFSS  03.0
....................       rx_wr_index = 0; 
01E7:  CLRF   2B
....................    } 
....................  
....................    //Look for unique ID: "IFMT" 
....................    if(rxd == 'I' && lock_pos == 0){ 
01E8:  MOVF   2D,W
01E9:  SUBLW  49
01EA:  BTFSS  03.2
01EB:  GOTO   1F1
01EC:  MOVF   2C,F
01ED:  BTFSS  03.2
01EE:  GOTO   1F1
....................       lock_pos++; 
01EF:  INCF   2C,F
....................    } 
01F0:  GOTO   214
....................    else if(rxd == 'F' && lock_pos == 1){ 
01F1:  MOVF   2D,W
01F2:  SUBLW  46
01F3:  BTFSS  03.2
01F4:  GOTO   1F9
01F5:  DECFSZ 2C,W
01F6:  GOTO   1F9
....................       lock_pos++; 
01F7:  INCF   2C,F
....................    } 
01F8:  GOTO   214
....................    else if(rxd == 'M' && lock_pos == 2){ 
01F9:  MOVF   2D,W
01FA:  SUBLW  4D
01FB:  BTFSS  03.2
01FC:  GOTO   203
01FD:  MOVF   2C,W
01FE:  SUBLW  02
01FF:  BTFSS  03.2
0200:  GOTO   203
....................       lock_pos++; 
0201:  INCF   2C,F
....................    } 
0202:  GOTO   214
....................    else if(rxd == 'T' && lock_pos == 3){ 
0203:  MOVF   2D,W
0204:  SUBLW  54
0205:  BTFSS  03.2
0206:  GOTO   213
0207:  MOVF   2C,W
0208:  SUBLW  03
0209:  BTFSS  03.2
020A:  GOTO   213
....................       lock_pos=0; //Reset the "combination lock" 
020B:  CLRF   2C
....................       got_id = TRUE; 
020C:  MOVLW  01
020D:  MOVWF  31
....................       read = rxd; 
020E:  MOVF   2D,W
020F:  MOVWF  2E
....................       //get ready to count the number of data bytes 
....................       valid_data_count = 0;  
0210:  CLRF   2F
....................  
....................       //buffer is reset to index 0 
....................       rx_wr_index = 0; 
0211:  CLRF   2B
....................    }else { 
0212:  GOTO   214
....................       lock_pos = 0; 
0213:  CLRF   2C
....................    } 
....................  
....................    if(got_id && valid_data_count++ >= BLOCK_SIZE){ 
0214:  MOVF   31,F
0215:  BTFSC  03.2
0216:  GOTO   21F
0217:  MOVF   2F,W
0218:  INCF   2F,F
0219:  SUBLW  06
021A:  BTFSC  03.0
021B:  GOTO   21F
....................       data_avail = TRUE; 
021C:  MOVLW  01
021D:  MOVWF  30
....................       got_id = FALSE; 
021E:  CLRF   31
....................    } 
....................     
021F:  BCF    0C.5
0220:  BCF    0A.3
0221:  BCF    0A.4
0222:  GOTO   02D
.................... } 
....................  
....................  
....................  
....................  
.................... // #int_TIMER1 
.................... // void TIMER1_isr(void) 
.................... // { 
.................... // } 
....................  
.................... // #int_RTCC 
.................... // void RTCC_isr(void) 
.................... // { 
....................  
....................        
.................... // } 
....................  
.................... void main() 
*
0800:  MOVF   03,W
0801:  ANDLW  1F
0802:  MOVWF  03
0803:  MOVLW  81
0804:  BSF    03.5
0805:  MOVWF  19
0806:  MOVLW  A6
0807:  MOVWF  18
0808:  MOVLW  90
0809:  BCF    03.5
080A:  MOVWF  18
080B:  CLRF   2B
080C:  CLRF   2C
080D:  CLRF   30
080E:  CLRF   31
080F:  CLRF   5A
0810:  MOVLW  FF
0811:  MOVWF  5B
0812:  BSF    03.5
0813:  BSF    1F.0
0814:  BSF    1F.1
0815:  BSF    1F.2
0816:  BCF    1F.3
0817:  MOVLW  07
0818:  MOVWF  1C
0819:  BCF    03.7
.................... { 
....................    //VARIAVEIS 
....................  
....................    // setup_timer_0(RTCC_INTERNAL|RTCC_DIV_256|RTCC_8_bit);      //13.1ms overflow 
....................    // setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); //Overflow in 104ms | Resolution 1.6 us 
....................    init_ext_eeprom(); 
*
082B:  BCF    0A.3
082C:  GOTO   263
082D:  BSF    0A.3
....................    // enable_interrupts(INT_TIMER0); 
....................    // enable_interrupts(INT_TIMER1); 
....................    enable_interrupts(INT_RDA); 
082E:  BSF    03.5
082F:  BSF    0C.5
....................    enable_interrupts(GLOBAL); 
0830:  MOVLW  C0
0831:  BCF    03.5
0832:  IORWF  0B,F
....................  
....................    lcd_ini(); 
0833:  BCF    0A.3
0834:  GOTO   2DE
0835:  BSF    0A.3
....................    delay_us(50); 
0836:  MOVLW  52
0837:  MOVWF  77
0838:  DECFSZ 77,F
0839:  GOTO   038
083A:  GOTO   03B
083B:  NOP
....................  
....................    printf(lcd_escreve, "\f  iniciando... "); 
083C:  MOVLW  23
083D:  BSF    03.6
083E:  MOVWF  0D
083F:  MOVLW  02
0840:  MOVWF  0F
0841:  BCF    0A.3
0842:  BCF    03.6
0843:  CALL   368
0844:  BSF    0A.3
....................    delay_ms(500); 
0845:  MOVLW  02
0846:  MOVWF  7B
0847:  MOVLW  FA
0848:  BSF    03.5
0849:  MOVWF  56
084A:  BCF    0A.3
084B:  BCF    03.5
084C:  CALL   270
084D:  BSF    0A.3
084E:  DECFSZ 7B,F
084F:  GOTO   047
....................  
....................    printf(lcd_escreve, "\fIFMT - Serial"); 
0850:  MOVLW  2C
0851:  BSF    03.6
0852:  MOVWF  0D
0853:  MOVLW  02
0854:  MOVWF  0F
0855:  BCF    0A.3
0856:  BCF    03.6
0857:  CALL   368
0858:  BSF    0A.3
....................    delay_ms(500); 
0859:  MOVLW  02
085A:  MOVWF  7B
085B:  MOVLW  FA
085C:  BSF    03.5
085D:  MOVWF  56
085E:  BCF    0A.3
085F:  BCF    03.5
0860:  CALL   270
0861:  BSF    0A.3
0862:  DECFSZ 7B,F
0863:  GOTO   05B
....................  
....................    // resetmemory(); 
....................    // char data[RX_BUFFER_SIZE] = "00 10 5 6 6 5 1"; 
....................    // char data[RX_BUFFER_SIZE] = ; 
....................    while (true){ 
....................  
....................       // int * rx_buffer_int; 
....................       // rx_buffer_int = strToInt(data); 
....................  
....................       // resetMemory(); 
....................  
....................       printf (lcd_escreve,"\fEm Modo Espera"); 
0864:  MOVLW  34
0865:  BSF    03.6
0866:  MOVWF  0D
0867:  MOVLW  02
0868:  MOVWF  0F
0869:  BCF    0A.3
086A:  BCF    03.6
086B:  CALL   368
086C:  BSF    0A.3
....................       printf (lcd_escreve,"\r\nde dados ..."); 
086D:  MOVLW  3C
086E:  BSF    03.6
086F:  MOVWF  0D
0870:  MOVLW  02
0871:  MOVWF  0F
0872:  BCF    0A.3
0873:  BCF    03.6
0874:  CALL   368
0875:  BSF    0A.3
....................       delay_ms(100); 
0876:  MOVLW  64
0877:  BSF    03.5
0878:  MOVWF  56
0879:  BCF    0A.3
087A:  BCF    03.5
087B:  CALL   270
087C:  BSF    0A.3
....................       User user; 
....................       while(true){ 
....................          if(data_avail){ 
087D:  MOVF   30,F
087E:  BTFSC  03.2
087F:  GOTO   0EE
....................             if(rx_buffer[0] =='#' && rx_buffer[2] =='#'){ 
0880:  MOVF   32,W
0881:  SUBLW  23
0882:  BTFSS  03.2
0883:  GOTO   09D
0884:  MOVF   34,W
0885:  SUBLW  23
0886:  BTFSS  03.2
0887:  GOTO   09D
....................                printf (lcd_escreve,"\fFim da Comunicacao"); 
0888:  MOVLW  44
0889:  BSF    03.6
088A:  MOVWF  0D
088B:  MOVLW  02
088C:  MOVWF  0F
088D:  BCF    0A.3
088E:  BCF    03.6
088F:  CALL   368
0890:  BSF    0A.3
....................                delay_ms(1000); 
0891:  MOVLW  04
0892:  MOVWF  7B
0893:  MOVLW  FA
0894:  BSF    03.5
0895:  MOVWF  56
0896:  BCF    0A.3
0897:  BCF    03.5
0898:  CALL   270
0899:  BSF    0A.3
089A:  DECFSZ 7B,F
089B:  GOTO   093
....................                break; 
089C:  GOTO   0EF
....................             } 
....................             data_avail = FALSE; 
089D:  CLRF   30
....................             user = receiveUser(); 
089E:  BCF    0A.3
089F:  GOTO   623
08A0:  BSF    0A.3
08A1:  MOVF   79,W
08A2:  MOVWF  7A
08A3:  MOVF   78,W
08A4:  MOVWF  7B
08A5:  MOVF   7A,W
08A6:  MOVWF  7C
08A7:  CLRF   7E
08A8:  MOVLW  70
08A9:  MOVWF  7D
08AA:  MOVLW  07
08AB:  MOVWF  78
08AC:  MOVF   7B,W
08AD:  MOVWF  04
08AE:  BCF    03.7
08AF:  BTFSC  7C.0
08B0:  BSF    03.7
08B1:  MOVF   00,W
08B2:  MOVWF  77
08B3:  MOVF   7D,W
08B4:  MOVWF  04
08B5:  BCF    03.7
08B6:  BTFSC  7E.0
08B7:  BSF    03.7
08B8:  MOVF   77,W
08B9:  MOVWF  00
08BA:  INCF   7D,F
08BB:  BTFSC  03.2
08BC:  INCF   7E,F
08BD:  INCF   7B,F
08BE:  BTFSC  03.2
08BF:  INCF   7C,F
08C0:  DECFSZ 78,F
08C1:  GOTO   0AC
....................             printUser(user); 
08C2:  MOVF   70,W
08C3:  BSF    03.5
08C4:  MOVWF  20
08C5:  MOVF   71,W
08C6:  MOVWF  21
08C7:  MOVF   72,W
08C8:  MOVWF  22
08C9:  MOVF   73,W
08CA:  MOVWF  23
08CB:  MOVF   74,W
08CC:  MOVWF  24
08CD:  MOVF   75,W
08CE:  MOVWF  25
08CF:  MOVF   76,W
08D0:  MOVWF  26
08D1:  BCF    0A.3
08D2:  BCF    03.5
08D3:  GOTO   7B9
08D4:  BSF    0A.3
....................             // overwriteUser(user); 
....................             // rx_wr_index = 0; 
....................             printf (lcd_escreve,"\fPIC em modo Espera"); 
08D5:  MOVLW  4E
08D6:  BSF    03.6
08D7:  MOVWF  0D
08D8:  MOVLW  02
08D9:  MOVWF  0F
08DA:  BCF    0A.3
08DB:  BCF    03.6
08DC:  CALL   368
08DD:  BSF    0A.3
....................             printf (lcd_escreve,"\r\nEsperando dados..."); 
08DE:  MOVLW  58
08DF:  BSF    03.6
08E0:  MOVWF  0D
08E1:  MOVLW  02
08E2:  MOVWF  0F
08E3:  BCF    0A.3
08E4:  BCF    03.6
08E5:  CALL   368
08E6:  BSF    0A.3
....................             delay_ms(100); 
08E7:  MOVLW  64
08E8:  BSF    03.5
08E9:  MOVWF  56
08EA:  BCF    0A.3
08EB:  BCF    03.5
08EC:  CALL   270
08ED:  BSF    0A.3
....................          } 
08EE:  GOTO   07D
....................       } 
08EF:  GOTO   064
....................  
....................    } 
....................   
....................    // unsigned int * temp; 
....................    // unsigned int id [2]; 
....................    // temp = inputId(); 
....................    // id[0] = temp[0]; 
....................    // id[1] = temp[1]; 
....................    // login(id); 
....................  
....................    // waitUpdate(); 
....................  
....................    // unsigned char option;  
....................    // unsigned int * temp; 
....................    // unsigned int id [2]; 
....................     
....................    // // int id10 [2] = {12,34}; 
....................    // // int pass [4] = {1,2,3,4}; 
....................    // // saveuser(id10, pass, 1); 
....................    // // int id1 [2] = {14,0}; 
....................    // // saveuser(id1, pass, 0); 
....................    // // int id2 [2] = {70,10}; 
....................    // // saveuser(id2, pass, 1); 
....................    // // int id3 [2] = {0,10}; 
....................    // // saveuser(id3, pass, 1); 
....................    // // int id4 [2] = {99,99}; 
....................    // // saveuser(id4, pass, 3);//admin 
....................     
....................    // int status; 
....................    // do{ 
....................    //    printf(lcd_escreve,"\f1:Login|2:Admin"); 
....................    //    delay_ms(500); 
....................    //    option = readKeyboard(); 
....................  
....................    //    if(option != 255){ 
....................    //       printf(lcd_escreve,"\r\n Option: %c", option); 
....................    //       delay_ms(500); 
....................  
....................    //       switch(option){ 
....................    //          case '1': 
....................    //             temp = inputId(); 
....................    //             id[0] = temp[0]; 
....................    //             id[1] = temp[1]; 
....................    //             status = login(id); 
....................    //             if(status == 1 || status == 3){ 
....................    //                printf(lcd_escreve,"\fBem Vindo(a)!"); 
....................    //                delay_ms(1000); 
....................    //                printf(lcd_escreve,"\fLiga Led e Rele"); 
....................    //                delay_ms(500); 
....................    //             }else{//Unpaid 
....................    //                printf(lcd_escreve,"\fConta Existe"); 
....................    //                printf(lcd_escreve,"\r\r,Mas Falta Pagar!"); 
....................    //                delay_ms(1000); 
....................    //             } 
....................    //             break; 
....................    //          case '2': 
....................    //             temp = inputId(); 
....................    //             id[0] = temp[0]; 
....................    //             id[1] = temp[1]; 
....................    //             status = login(id); 
....................    //             if(status == 3){ 
....................    //                adminMenu(); 
....................    //             } 
....................    //             else{ 
....................    //                printf(lcd_escreve,"\fN Permitido"); 
....................    //                delay_ms(500); 
....................    //             } 
....................    //             break; 
....................    //          default: 
....................    //             printf(lcd_escreve,"\fDigite um valor"); 
....................    //             printf(lcd_escreve,"\r\nValido!"); 
....................    //             delay_ms(500); 
....................    //             break; 
....................    //       } 
....................    //    } 
....................  
....................  
....................    // }while(option != '5'); 
....................  
.................... } 
....................  
08F0:  SLEEP

Configuration Fuses:
   Word  1: 3F32   HS NOWDT PUT NOBROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT

CCS PCM C Compiler, Version 5.025, 7201               25-Nov-21 09:47

               Filename:   E:\microPresentation\eletronic-lock-system\PIC controller\main.lst

               ROM used:   5961 words (73%)
                           Largest free fragment is 1528
               RAM used:   66 (18%) at main() level
                           243 (66%) worst case
               Stack used: 8 locations (7 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  18
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  MOVLW  8C
0028:  MOVWF  04
0029:  BTFSS  00.5
002A:  GOTO   02D
002B:  BTFSC  0C.5
002C:  GOTO   04E
002D:  MOVF   22,W
002E:  MOVWF  04
002F:  MOVF   23,W
0030:  MOVWF  77
0031:  MOVF   24,W
0032:  MOVWF  78
0033:  MOVF   25,W
0034:  MOVWF  79
0035:  MOVF   26,W
0036:  MOVWF  7A
0037:  MOVF   27,W
0038:  BSF    03.6
0039:  MOVWF  0D
003A:  BCF    03.6
003B:  MOVF   28,W
003C:  BSF    03.6
003D:  MOVWF  0F
003E:  BCF    03.6
003F:  MOVF   29,W
0040:  BSF    03.6
0041:  MOVWF  0C
0042:  BCF    03.6
0043:  MOVF   2A,W
0044:  BSF    03.6
0045:  MOVWF  0E
0046:  BCF    03.6
0047:  MOVF   20,W
0048:  MOVWF  0A
0049:  SWAPF  21,W
004A:  MOVWF  03
004B:  SWAPF  7F,F
004C:  SWAPF  7F,W
004D:  RETFIE
004E:  BCF    0A.3
004F:  BCF    0A.4
0050:  GOTO   1EB
....................  
.................... #include <16F877A.h> 
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
0051:  BCF    0A.0
0052:  BCF    0A.1
0053:  BCF    0A.2
0054:  ADDWF  02,F
0055:  RETLW  28
0056:  RETLW  0F
0057:  RETLW  01
0058:  RETLW  06
0059:  BCF    0A.0
005A:  BCF    0A.1
005B:  BCF    0A.2
005C:  ADDWF  02,F
005D:  RETLW  4E
005E:  RETLW  41
005F:  RETLW  4F
0060:  RETLW  20
0061:  RETLW  50
0062:  RETLW  41
0063:  RETLW  47
0064:  RETLW  4F
0065:  RETLW  00
0066:  BCF    0A.0
0067:  BCF    0A.1
0068:  BCF    0A.2
0069:  ADDWF  02,F
006A:  RETLW  50
006B:  RETLW  41
006C:  RETLW  47
006D:  RETLW  4F
006E:  RETLW  00
006F:  DATA 8C,2A
0070:  DATA F3,3A
0071:  DATA 61,39
0072:  DATA E9,37
0073:  DATA A0,21
0074:  DATA 61,32
0075:  DATA E1,39
0076:  DATA 74,39
0077:  DATA 61,32
0078:  DATA 6F,00
0079:  DATA 8C,24
007A:  DATA 44,10
007B:  DATA 69,37
007C:  DATA E3,37
007D:  DATA 6D,38
007E:  DATA 61,3A
007F:  DATA 69,3B
0080:  DATA 65,36
0081:  DATA 00,01
0082:  DATA 0D,05
0083:  DATA D4,32
0084:  DATA 6E,3A
0085:  DATA 65,10
0086:  DATA EE,37
0087:  DATA F6,30
0088:  DATA ED,32
0089:  DATA 6E,3A
008A:  DATA 65,00
008B:  DATA 8C,2A
008C:  DATA F3,3A
008D:  DATA 61,39
008E:  DATA E9,37
008F:  DATA A0,20
0090:  DATA F4,3A
0091:  DATA 61,36
0092:  DATA 69,3D
0093:  DATA 61,32
0094:  DATA 6F,00
0095:  DATA 8C,24
0096:  DATA 44,10
0097:  DATA 69,37
0098:  DATA E3,37
0099:  DATA 6D,38
009A:  DATA 61,3A
009B:  DATA 69,3B
009C:  DATA 65,36
009D:  DATA 00,01
009E:  DATA 0D,05
009F:  DATA D4,32
00A0:  DATA 6E,3A
00A1:  DATA 65,10
00A2:  DATA EE,37
00A3:  DATA F6,30
00A4:  DATA ED,32
00A5:  DATA 6E,3A
00A6:  DATA 65,00
00A7:  DATA 0D,05
00A8:  DATA D0,3B
00A9:  DATA BA,12
00AA:  DATA F5,12
00AB:  DATA F5,12
00AC:  DATA F5,12
00AD:  DATA 75,10
00AE:  DATA 53,3A
00AF:  DATA BA,12
00B0:  DATA 75,00
00B1:  DATA 8C,24
00B2:  DATA 44,1D
00B3:  DATA A5,3A
00B4:  DATA A5,3A
00B5:  DATA 00,01
00B6:  DATA 8C,2A
00B7:  DATA F3,3A
00B8:  DATA 61,39
00B9:  DATA E9,37
00BA:  DATA 20,27
00BB:  DATA A0,22
00BC:  DATA F8,34
00BD:  DATA 73,3A
00BE:  DATA 65,00
00BF:  DATA 0D,05
00C0:  DATA 53,3A
00C1:  DATA 61,3A
00C2:  DATA F5,39
00C3:  DATA BA,12
00C4:  DATA 73,00
00C5:  DATA 8C,26
00C6:  DATA E5,36
00C7:  DATA 6F,39
00C8:  DATA 79,10
00C9:  DATA 43,36
00CA:  DATA E5,30
00CB:  DATA EE,32
00CC:  DATA 64,00
00CD:  DATA 8C,18
00CE:  DATA BA,21
00CF:  DATA 41,22
00D0:  DATA 7C,19
00D1:  DATA 3A,21
00D2:  DATA D5,29
00D3:  DATA C3,20
00D4:  DATA 52,00
00D5:  DATA 0D,05
00D6:  DATA 33,1D
00D7:  DATA C4,22
00D8:  DATA 4C,3E
00D9:  DATA 34,1D
00DA:  DATA 45,22
00DB:  DATA 49,2A
00DC:  DATA 41,29
00DD:  DATA 00,01
00DE:  DATA 8C,1A
00DF:  DATA BA,20
00E0:  DATA F4,3A
00E1:  DATA 61,36
00E2:  DATA 69,3D
00E3:  DATA 61,39
00E4:  DATA 20,21
00E5:  DATA E1,39
00E6:  DATA 65,10
00E7:  DATA C4,30
00E8:  DATA E4,37
00E9:  DATA 73,00
00EA:  DATA 0D,05
00EB:  DATA 36,1D
00EC:  DATA 45,37
00ED:  DATA F6,34
00EE:  DATA 61,39
00EF:  DATA 20,21
00F0:  DATA E1,39
00F1:  DATA 65,10
00F2:  DATA C4,30
00F3:  DATA E4,37
00F4:  DATA 73,00
00F5:  DATA 8A,1B
00F6:  DATA 3A,10
00F7:  DATA D3,20
00F8:  DATA 49,29
00F9:  DATA 20,32
00FA:  DATA 6F,10
00FB:  DATA CD,32
00FC:  DATA EE,3A
00FD:  DATA 20,00
00FE:  DATA 0C,10
00FF:  DATA 4F,38
0100:  DATA F4,34
0101:  DATA 6F,37
0102:  DATA 3A,10
0103:  DATA A5,31
0104:  DATA 00,01
0105:  DATA 8C,29
0106:  DATA F5,31
0107:  DATA E3,32
0108:  DATA F3,39
0109:  DATA A0,16
010A:  DATA 3E,10
010B:  DATA 25,32
010C:  DATA 00,10
010D:  DATA 8C,3A
010E:  DATA F3,3A
010F:  DATA 61,39
0110:  DATA E9,37
0111:  DATA 20,32
0112:  DATA 65,36
0113:  DATA 65,3A
0114:  DATA 61,32
0115:  DATA 6F,00
0116:  DATA 8C,3A
0117:  DATA F3,3A
0118:  DATA 61,39
0119:  DATA E9,37
011A:  DATA 20,27
011B:  DATA A0,22
011C:  DATA F8,34
011D:  DATA 73,3A
011E:  DATA 65,00
011F:  DATA 0C,22
0120:  DATA E9,33
0121:  DATA 69,3A
0122:  DATA 65,10
0123:  DATA F5,36
0124:  DATA 20,3B
0125:  DATA 61,36
0126:  DATA 6F,39
0127:  DATA 00,01
0128:  DATA 0D,05
0129:  DATA D6,30
012A:  DATA EC,34
012B:  DATA E4,37
012C:  DATA 21,00
012D:  DATA 8C,24
012E:  DATA 44,10
012F:  DATA 4E,10
0130:  DATA 45,3C
0131:  DATA E9,39
0132:  DATA F4,32
0133:  DATA 00,01
0134:  DATA 0D,05
0135:  DATA D4,32
0136:  DATA 6E,3A
0137:  DATA 65,10
0138:  DATA E4,32
0139:  DATA 20,37
013A:  DATA 6F,3B
013B:  DATA 6F,00
013C:  DATA 0C,28
013D:  DATA F2,37
013E:  DATA E3,3A
013F:  DATA F2,32
0140:  DATA A0,30
0141:  DATA A0,39
0142:  DATA E5,31
0143:  DATA F2,32
0144:  DATA F4,30
0145:  DATA F2,34
0146:  DATA 61,00
0147:  DATA 0D,05
0148:  DATA D0,17
0149:  DATA 20,39
014A:  DATA E5,39
014B:  DATA 6F,36
014C:  DATA F6,32
014D:  DATA 72,00
014E:  DATA 0C,27
014F:  DATA 41,22
0150:  DATA 41,10
0151:  DATA 65,34
0152:  DATA 20,26
0153:  DATA E9,33
0154:  DATA 61,32
0155:  DATA EF,10
0156:  DATA 00,00
0157:  DATA 0C,10
0158:  DATA C4,34
0159:  DATA E7,34
015A:  DATA F4,32
015B:  DATA 00,00
015C:  DATA 8C,20
015D:  DATA E4,36
015E:  DATA 69,37
015F:  DATA A0,22
0160:  DATA EE,31
0161:  DATA 6F,37
0162:  DATA 74,39
0163:  DATA 61,32
0164:  DATA 6F,00
0165:  DATA 0C,10
0166:  DATA 61,32
0167:  DATA ED,34
0168:  DATA EE,39
0169:  DATA 5B,18
016A:  DATA 5D,1D
016B:  DATA A0,12
016C:  DATA 64,00
016D:  DATA 8C,34
016E:  DATA 64,1D
016F:  DATA A5,3A
0170:  DATA A5,3A
0171:  DATA 00,00
0172:  DATA 0C,22
0173:  DATA E9,33
0174:  DATA 69,3A
0175:  DATA 65,10
0176:  DATA 6F,10
0177:  DATA 49,22
0178:  DATA 3A,10
0179:  DATA 00,01
017A:  DATA 8A,06
017B:  DATA D4,3C
017C:  DATA F0,32
017D:  DATA 64,1D
017E:  DATA A5,31
017F:  DATA 00,00
0180:  DATA 8A,06
0181:  DATA D4,3C
0182:  DATA F0,32
0183:  DATA 64,1D
0184:  DATA A5,31
0185:  DATA 00,00
0186:  DATA 8C,34
0187:  DATA 64,1D
0188:  DATA A0,12
0189:  DATA F5,12
018A:  DATA 75,00
018B:  DATA 8C,24
018C:  DATA 44,10
018D:  DATA CA,30
018E:  DATA 68,10
018F:  DATA 45,3C
0190:  DATA E9,39
0191:  DATA F4,32
0192:  DATA 00,00
0193:  DATA 0C,28
0194:  DATA C1,29
0195:  DATA 53,14
0196:  DATA B4,14
0197:  DATA 3A,10
0198:  DATA A5,3A
0199:  DATA A5,3A
019A:  DATA A5,3A
019B:  DATA A5,3A
019C:  DATA 00,01
019D:  DATA 8C,29
019E:  DATA D4,20
019F:  DATA D4,2A
01A0:  DATA 53,1D
01A1:  DATA A0,12
01A2:  DATA 75,00
01A3:  DATA 8C,24
01A4:  DATA 44,10
01A5:  DATA 4E,10
01A6:  DATA 45,3C
01A7:  DATA E9,39
01A8:  DATA F4,32
01A9:  DATA 00,00
01AA:  DATA 8C,22
01AB:  DATA 6D,10
01AC:  DATA CD,37
01AD:  DATA E4,37
01AE:  DATA A0,22
01AF:  DATA 73,38
01B0:  DATA 65,39
01B1:  DATA 61,00
01B2:  DATA 0D,05
01B3:  DATA E4,32
01B4:  DATA 20,32
01B5:  DATA 61,32
01B6:  DATA EF,39
01B7:  DATA 20,17
01B8:  DATA 2E,17
01B9:  DATA 00,01
01BA:  DATA 0C,23
01BB:  DATA E9,36
01BC:  DATA 20,32
01BD:  DATA 61,10
01BE:  DATA C3,37
01BF:  DATA ED,3A
01C0:  DATA EE,34
01C1:  DATA E3,30
01C2:  DATA E3,30
01C3:  DATA 6F,00
01C4:  DATA 0C,28
01C5:  DATA C9,21
01C6:  DATA A0,32
01C7:  DATA 6D,10
01C8:  DATA ED,37
01C9:  DATA E4,37
01CA:  DATA A0,22
01CB:  DATA 73,38
01CC:  DATA 65,39
01CD:  DATA 61,00
01CE:  DATA 0D,05
01CF:  DATA C5,39
01D0:  DATA F0,32
01D1:  DATA F2,30
01D2:  DATA 6E,32
01D3:  DATA 6F,10
01D4:  DATA E4,30
01D5:  DATA E4,37
01D6:  DATA 73,17
01D7:  DATA 2E,17
01D8:  DATA 00,00
01D9:  DATA 8C,24
01DA:  DATA 44,10
01DB:  DATA 69,37
01DC:  DATA E3,37
01DD:  DATA 6D,38
01DE:  DATA 61,3A
01DF:  DATA 69,3B
01E0:  DATA 65,36
01E1:  DATA 00,01
01E2:  DATA 0D,05
01E3:  DATA D4,32
01E4:  DATA 6E,3A
01E5:  DATA 65,10
01E6:  DATA EE,37
01E7:  DATA F6,30
01E8:  DATA ED,32
01E9:  DATA 6E,3A
01EA:  DATA 65,00
*
0239:  DATA 0C,10
023A:  DATA A0,34
023B:  DATA EE,34
023C:  DATA E3,34
023D:  DATA 61,37
023E:  DATA E4,37
023F:  DATA 2E,17
0240:  DATA 2E,10
0241:  DATA 00,01
0242:  DATA 8C,24
0243:  DATA C6,26
0244:  DATA 54,10
0245:  DATA 2D,10
0246:  DATA D3,32
0247:  DATA F2,34
0248:  DATA 61,36
0249:  DATA 00,01
024A:  DATA 8C,18
024B:  DATA 3A,26
024C:  DATA EF,33
024D:  DATA 69,37
024E:  DATA 7C,19
024F:  DATA BA,20
0250:  DATA E4,36
0251:  DATA 69,37
0252:  DATA 00,01
0253:  DATA 0D,05
0254:  DATA A0,27
0255:  DATA 70,3A
0256:  DATA E9,37
0257:  DATA 6E,1D
0258:  DATA A0,12
0259:  DATA 63,00
025A:  DATA 0C,21
025B:  DATA E5,36
025C:  DATA 20,2B
025D:  DATA 69,37
025E:  DATA E4,37
025F:  DATA A8,30
0260:  DATA A9,10
0261:  DATA 00,01
0262:  DATA 0C,26
0263:  DATA E9,33
0264:  DATA 61,10
0265:  DATA CC,32
0266:  DATA 64,10
0267:  DATA 65,10
0268:  DATA D2,32
0269:  DATA EC,32
026A:  DATA 00,01
026B:  DATA 8C,21
026C:  DATA 6F,37
026D:  DATA F4,30
026E:  DATA A0,22
026F:  DATA F8,34
0270:  DATA 73,3A
0271:  DATA 65,00
0272:  DATA 8D,06
0273:  DATA AC,26
0274:  DATA E1,39
0275:  DATA 20,23
0276:  DATA 61,36
0277:  DATA F4,30
0278:  DATA 20,28
0279:  DATA E1,33
027A:  DATA 61,39
027B:  DATA 21,00
027C:  DATA 0C,27
027D:  DATA 20,28
027E:  DATA 65,39
027F:  DATA ED,34
0280:  DATA F4,34
0281:  DATA E4,37
0282:  DATA 00,01
0283:  DATA 0C,22
0284:  DATA E9,33
0285:  DATA 69,3A
0286:  DATA 65,10
0287:  DATA F5,36
0288:  DATA 20,3B
0289:  DATA 61,36
028A:  DATA 6F,39
028B:  DATA 00,01
028C:  DATA 0D,05
028D:  DATA D6,30
028E:  DATA EC,34
028F:  DATA E4,37
0290:  DATA 21,00
*
0396:  MOVF   0B,W
0397:  BSF    03.5
0398:  MOVWF  61
0399:  BCF    03.5
039A:  BCF    0B.7
039B:  BSF    03.5
039C:  BSF    03.6
039D:  BSF    0C.7
039E:  BSF    0C.0
039F:  NOP
03A0:  NOP
03A1:  BCF    03.6
03A2:  BTFSS  61.7
03A3:  GOTO   3A7
03A4:  BCF    03.5
03A5:  BSF    0B.7
03A6:  BSF    03.5
03A7:  BCF    03.5
03A8:  BSF    03.6
03A9:  MOVF   0C,W
03AA:  ANDLW  7F
03AB:  BTFSC  03.2
03AC:  GOTO   408
03AD:  BSF    03.5
03AE:  BCF    03.6
03AF:  MOVWF  61
03B0:  BCF    03.5
03B1:  BSF    03.6
03B2:  MOVF   0D,W
03B3:  BSF    03.5
03B4:  BCF    03.6
03B5:  MOVWF  62
03B6:  BCF    03.5
03B7:  BSF    03.6
03B8:  MOVF   0F,W
03B9:  BSF    03.5
03BA:  BCF    03.6
03BB:  MOVWF  63
03BC:  MOVF   61,W
03BD:  MOVWF  64
03BE:  BCF    03.5
03BF:  CALL   353
03C0:  BSF    03.5
03C1:  MOVF   62,W
03C2:  BCF    03.5
03C3:  BSF    03.6
03C4:  MOVWF  0D
03C5:  BSF    03.5
03C6:  BCF    03.6
03C7:  MOVF   63,W
03C8:  BCF    03.5
03C9:  BSF    03.6
03CA:  MOVWF  0F
03CB:  BCF    03.6
03CC:  MOVF   0B,W
03CD:  BSF    03.5
03CE:  MOVWF  64
03CF:  BCF    03.5
03D0:  BCF    0B.7
03D1:  BSF    03.5
03D2:  BSF    03.6
03D3:  BSF    0C.7
03D4:  BSF    0C.0
03D5:  NOP
03D6:  NOP
03D7:  BCF    03.6
03D8:  BTFSS  64.7
03D9:  GOTO   3DD
03DA:  BCF    03.5
03DB:  BSF    0B.7
03DC:  BSF    03.5
03DD:  BCF    03.5
03DE:  BSF    03.6
03DF:  RLF    0C,W
03E0:  RLF    0E,W
03E1:  ANDLW  7F
03E2:  BTFSC  03.2
03E3:  GOTO   408
03E4:  BSF    03.5
03E5:  BCF    03.6
03E6:  MOVWF  61
03E7:  BCF    03.5
03E8:  BSF    03.6
03E9:  MOVF   0D,W
03EA:  BSF    03.5
03EB:  BCF    03.6
03EC:  MOVWF  62
03ED:  BCF    03.5
03EE:  BSF    03.6
03EF:  MOVF   0F,W
03F0:  BSF    03.5
03F1:  BCF    03.6
03F2:  MOVWF  63
03F3:  MOVF   61,W
03F4:  MOVWF  64
03F5:  BCF    03.5
03F6:  CALL   353
03F7:  BSF    03.5
03F8:  MOVF   62,W
03F9:  BCF    03.5
03FA:  BSF    03.6
03FB:  MOVWF  0D
03FC:  BSF    03.5
03FD:  BCF    03.6
03FE:  MOVF   63,W
03FF:  BCF    03.5
0400:  BSF    03.6
0401:  MOVWF  0F
0402:  INCF   0D,F
0403:  BTFSC  03.2
0404:  INCF   0F,F
0405:  BCF    03.6
0406:  GOTO   396
0407:  BSF    03.6
0408:  BCF    03.6
0409:  RETURN
*
06F6:  MOVF   0B,W
06F7:  BSF    03.5
06F8:  MOVWF  60
06F9:  BCF    03.5
06FA:  BCF    0B.7
06FB:  BSF    03.5
06FC:  BSF    03.6
06FD:  BSF    0C.7
06FE:  BSF    0C.0
06FF:  NOP
0700:  NOP
0701:  BCF    03.6
0702:  BTFSS  60.7
0703:  GOTO   707
0704:  BCF    03.5
0705:  BSF    0B.7
0706:  BSF    03.5
0707:  BTFSC  03.0
0708:  GOTO   740
0709:  BCF    03.5
070A:  BSF    03.6
070B:  MOVF   0C,W
070C:  ANDLW  7F
070D:  BSF    03.5
070E:  BCF    03.6
070F:  MOVWF  60
0710:  BCF    03.5
0711:  BSF    03.6
0712:  MOVF   0D,W
0713:  BSF    03.5
0714:  BCF    03.6
0715:  MOVWF  61
0716:  BCF    03.5
0717:  BSF    03.6
0718:  MOVF   0F,W
0719:  BSF    03.5
071A:  BCF    03.6
071B:  MOVWF  62
071C:  MOVF   60,W
071D:  MOVWF  64
071E:  BCF    03.5
071F:  CALL   353
0720:  BSF    03.5
0721:  MOVF   61,W
0722:  BCF    03.5
0723:  BSF    03.6
0724:  MOVWF  0D
0725:  BSF    03.5
0726:  BCF    03.6
0727:  MOVF   62,W
0728:  BCF    03.5
0729:  BSF    03.6
072A:  MOVWF  0F
072B:  BCF    03.6
072C:  MOVF   0B,W
072D:  BSF    03.5
072E:  MOVWF  63
072F:  BCF    03.5
0730:  BCF    0B.7
0731:  BSF    03.5
0732:  BSF    03.6
0733:  BSF    0C.7
0734:  BSF    0C.0
0735:  NOP
0736:  NOP
0737:  BCF    03.6
0738:  BTFSS  63.7
0739:  GOTO   73D
073A:  BCF    03.5
073B:  BSF    0B.7
073C:  BSF    03.5
073D:  DECFSZ 5F,F
073E:  GOTO   740
073F:  GOTO   76E
0740:  BCF    03.5
0741:  BSF    03.6
0742:  RLF    0C,W
0743:  RLF    0E,W
0744:  ANDLW  7F
0745:  BSF    03.5
0746:  BCF    03.6
0747:  MOVWF  60
0748:  BCF    03.5
0749:  BSF    03.6
074A:  MOVF   0D,W
074B:  BSF    03.5
074C:  BCF    03.6
074D:  MOVWF  61
074E:  BCF    03.5
074F:  BSF    03.6
0750:  MOVF   0F,W
0751:  BSF    03.5
0752:  BCF    03.6
0753:  MOVWF  62
0754:  MOVF   60,W
0755:  MOVWF  64
0756:  BCF    03.5
0757:  CALL   353
0758:  BSF    03.5
0759:  MOVF   61,W
075A:  BCF    03.5
075B:  BSF    03.6
075C:  MOVWF  0D
075D:  BSF    03.5
075E:  BCF    03.6
075F:  MOVF   62,W
0760:  BCF    03.5
0761:  BSF    03.6
0762:  MOVWF  0F
0763:  INCF   0D,F
0764:  BTFSC  03.2
0765:  INCF   0F,F
0766:  BCF    03.0
0767:  BSF    03.5
0768:  BCF    03.6
0769:  DECFSZ 5F,F
076A:  GOTO   76C
076B:  GOTO   76E
076C:  BCF    03.5
076D:  GOTO   6F6
076E:  BCF    03.5
076F:  RETURN
*
07DB:  MOVF   00,F
07DC:  BTFSC  03.2
07DD:  GOTO   7F7
07DE:  BSF    03.5
07DF:  CLRF   5F
07E0:  MOVF   04,W
07E1:  MOVWF  5E
07E2:  BCF    5F.0
07E3:  BTFSC  03.7
07E4:  BSF    5F.0
07E5:  MOVF   00,W
07E6:  MOVWF  64
07E7:  BCF    03.5
07E8:  CALL   353
07E9:  BSF    03.5
07EA:  MOVF   5E,W
07EB:  MOVWF  04
07EC:  BCF    03.7
07ED:  BTFSC  5F.0
07EE:  BSF    03.7
07EF:  INCF   04,F
07F0:  BTFSS  03.2
07F1:  GOTO   7F5
07F2:  BCF    03.5
07F3:  INCF   05,F
07F4:  BSF    03.5
07F5:  BCF    03.5
07F6:  GOTO   7DB
07F7:  RETURN
*
0B08:  MOVF   3C,W
0B09:  XORWF  3E,W
0B0A:  ANDLW  80
0B0B:  MOVWF  40
0B0C:  BTFSS  3C.7
0B0D:  GOTO   313
0B0E:  COMF   3B,F
0B0F:  COMF   3C,F
0B10:  INCF   3B,F
0B11:  BTFSC  03.2
0B12:  INCF   3C,F
0B13:  BTFSS  3E.7
0B14:  GOTO   31A
0B15:  COMF   3D,F
0B16:  COMF   3E,F
0B17:  INCF   3D,F
0B18:  BTFSC  03.2
0B19:  INCF   3E,F
0B1A:  MOVLW  10
0B1B:  MOVWF  3F
0B1C:  CLRF   77
0B1D:  CLRF   7A
0B1E:  RRF    3C,F
0B1F:  RRF    3B,F
0B20:  BTFSS  03.0
0B21:  GOTO   328
0B22:  MOVF   3D,W
0B23:  ADDWF  77,F
0B24:  BTFSC  03.0
0B25:  INCF   7A,F
0B26:  MOVF   3E,W
0B27:  ADDWF  7A,F
0B28:  RRF    7A,F
0B29:  RRF    77,F
0B2A:  RRF    79,F
0B2B:  RRF    78,F
0B2C:  DECFSZ 3F,F
0B2D:  GOTO   31E
0B2E:  BTFSS  40.7
0B2F:  GOTO   335
0B30:  COMF   78,F
0B31:  COMF   79,F
0B32:  INCF   78,F
0B33:  BTFSC  03.2
0B34:  INCF   79,F
*
0DFD:  BSF    03.5
0DFE:  MOVF   50,W
0DFF:  CLRF   78
0E00:  SUBWF  4F,W
0E01:  BTFSC  03.0
0E02:  GOTO   606
0E03:  MOVF   4F,W
0E04:  MOVWF  77
0E05:  GOTO   612
0E06:  CLRF   77
0E07:  MOVLW  08
0E08:  MOVWF  51
0E09:  RLF    4F,F
0E0A:  RLF    77,F
0E0B:  MOVF   50,W
0E0C:  SUBWF  77,W
0E0D:  BTFSC  03.0
0E0E:  MOVWF  77
0E0F:  RLF    78,F
0E10:  DECFSZ 51,F
0E11:  GOTO   609
0E12:  BCF    03.5
0E13:  RETURN
0E14:  MOVF   78,W
0E15:  BSF    03.5
0E16:  MOVF   4D,W
0E17:  MOVWF  4F
0E18:  MOVLW  64
0E19:  MOVWF  50
0E1A:  BCF    03.5
0E1B:  CALL   5FD
0E1C:  MOVF   77,W
0E1D:  BSF    03.5
0E1E:  MOVWF  4D
0E1F:  MOVF   78,W
0E20:  MOVLW  30
0E21:  BTFSS  03.2
0E22:  GOTO   62A
0E23:  BTFSS  4E.1
0E24:  GOTO   635
0E25:  BTFSC  4E.3
0E26:  GOTO   635
0E27:  BTFSC  4E.4
0E28:  MOVLW  20
0E29:  GOTO   62D
0E2A:  BCF    4E.3
0E2B:  BCF    4E.4
0E2C:  BSF    4E.0
0E2D:  ADDWF  78,F
0E2E:  MOVF   78,W
0E2F:  MOVWF  64
0E30:  BCF    0A.3
0E31:  BCF    03.5
0E32:  CALL   353
0E33:  BSF    0A.3
0E34:  BSF    03.5
0E35:  MOVF   4D,W
0E36:  MOVWF  4F
0E37:  MOVLW  0A
0E38:  MOVWF  50
0E39:  BCF    03.5
0E3A:  CALL   5FD
0E3B:  MOVF   77,W
0E3C:  BSF    03.5
0E3D:  MOVWF  4D
0E3E:  MOVF   78,W
0E3F:  MOVLW  30
0E40:  BTFSS  03.2
0E41:  GOTO   648
0E42:  BTFSC  4E.3
0E43:  GOTO   650
0E44:  BTFSS  4E.0
0E45:  GOTO   650
0E46:  BTFSC  4E.4
0E47:  MOVLW  20
0E48:  ADDWF  78,F
0E49:  MOVF   78,W
0E4A:  MOVWF  64
0E4B:  BCF    0A.3
0E4C:  BCF    03.5
0E4D:  CALL   353
0E4E:  BSF    0A.3
0E4F:  BSF    03.5
0E50:  MOVLW  30
0E51:  ADDWF  4D,F
0E52:  MOVF   4D,W
0E53:  MOVWF  64
0E54:  BCF    0A.3
0E55:  BCF    03.5
0E56:  CALL   353
0E57:  BSF    0A.3
0E58:  RETURN
*
12AA:  MOVLW  20
12AB:  BTFSS  7B.4
12AC:  MOVLW  30
12AD:  BSF    03.5
12AE:  MOVWF  20
12AF:  MOVF   76,W
12B0:  MOVWF  77
12B1:  BTFSS  76.7
12B2:  GOTO   2BB
12B3:  COMF   77,F
12B4:  INCF   77,F
12B5:  MOVF   77,W
12B6:  MOVWF  76
12B7:  MOVLW  2D
12B8:  MOVWF  20
12B9:  BSF    7B.7
12BA:  BSF    7B.0
12BB:  MOVF   76,W
12BC:  MOVWF  4F
12BD:  MOVLW  64
12BE:  MOVWF  50
12BF:  BCF    0A.4
12C0:  BSF    0A.3
12C1:  BCF    03.5
12C2:  CALL   5FD
12C3:  BSF    0A.4
12C4:  BCF    0A.3
12C5:  MOVF   77,W
12C6:  MOVWF  76
12C7:  MOVLW  30
12C8:  ADDWF  78,W
12C9:  BSF    03.5
12CA:  MOVWF  21
12CB:  MOVF   76,W
12CC:  MOVWF  4F
12CD:  MOVLW  0A
12CE:  MOVWF  50
12CF:  BCF    0A.4
12D0:  BSF    0A.3
12D1:  BCF    03.5
12D2:  CALL   5FD
12D3:  BSF    0A.4
12D4:  BCF    0A.3
12D5:  MOVLW  30
12D6:  ADDWF  77,W
12D7:  BSF    03.5
12D8:  MOVWF  23
12D9:  MOVLW  30
12DA:  ADDWF  78,W
12DB:  MOVWF  22
12DC:  MOVF   20,W
12DD:  MOVWF  77
12DE:  MOVLW  30
12DF:  SUBWF  21,W
12E0:  BTFSC  03.2
12E1:  GOTO   2E6
12E2:  BSF    7B.1
12E3:  BTFSC  7B.7
12E4:  BSF    7B.2
12E5:  GOTO   2FA
12E6:  MOVF   20,W
12E7:  MOVWF  21
12E8:  MOVLW  20
12E9:  MOVWF  20
12EA:  MOVLW  30
12EB:  SUBWF  22,W
12EC:  BTFSC  03.2
12ED:  GOTO   2F2
12EE:  BSF    7B.0
12EF:  BTFSC  7B.7
12F0:  BSF    7B.1
12F1:  GOTO   2FA
12F2:  BTFSS  03.2
12F3:  BSF    7B.0
12F4:  BTFSS  03.2
12F5:  GOTO   2FA
12F6:  MOVF   21,W
12F7:  MOVWF  22
12F8:  MOVLW  20
12F9:  MOVWF  21
12FA:  BTFSC  7B.2
12FB:  GOTO   301
12FC:  BTFSC  7B.1
12FD:  GOTO   308
12FE:  BTFSC  7B.0
12FF:  GOTO   30F
1300:  GOTO   316
1301:  MOVF   20,W
1302:  MOVWF  64
1303:  BCF    0A.4
1304:  BCF    03.5
1305:  CALL   353
1306:  BSF    0A.4
1307:  BSF    03.5
1308:  MOVF   21,W
1309:  MOVWF  64
130A:  BCF    0A.4
130B:  BCF    03.5
130C:  CALL   353
130D:  BSF    0A.4
130E:  BSF    03.5
130F:  MOVF   22,W
1310:  MOVWF  64
1311:  BCF    0A.4
1312:  BCF    03.5
1313:  CALL   353
1314:  BSF    0A.4
1315:  BSF    03.5
1316:  MOVF   23,W
1317:  MOVWF  64
1318:  BCF    0A.4
1319:  BCF    03.5
131A:  CALL   353
131B:  BSF    0A.4
....................  
.................... #list 
....................  
.................... #device ADC=8 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES HS  
....................  
.................... #use delay(crystal=20000000) 
*
029E:  MOVLW  E5
029F:  MOVWF  04
02A0:  BCF    03.7
02A1:  MOVF   00,W
02A2:  BTFSC  03.2
02A3:  GOTO   2B1
02A4:  MOVLW  06
02A5:  MOVWF  78
02A6:  CLRF   77
02A7:  DECFSZ 77,F
02A8:  GOTO   2A7
02A9:  DECFSZ 78,F
02AA:  GOTO   2A6
02AB:  MOVLW  7B
02AC:  MOVWF  77
02AD:  DECFSZ 77,F
02AE:  GOTO   2AD
02AF:  DECFSZ 00,F
02B0:  GOTO   2A4
02B1:  RETURN
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=Wireless) 
....................  
....................  
.................... // -------Variables' Declaration 
.................... #define BLOCK_SIZE sizeof(User)  
.................... #define RX_BUFFER_SIZE 20 
.................... int8 rx_wr_index = 0; 
.................... int8 lock_pos = 0, rxd, read, valid_data_count; 
.................... int data_avail = FALSE, got_id = FALSE; 
.................... char rx_buffer[RX_BUFFER_SIZE]; 
.................... int turn_on = 0; 
.................... // char string [RX_BUFFER_SIZE]; 
.................... #include "functions.c" 
.................... #include "functions.h" 
....................  
.................... //Define the default pins before calling the LCD driver 
.................... #ifndef lcd_enable  
....................    #define lcd_enable     pin_e1 
....................    #define lcd_rs         pin_e2 
....................    //#define lcd_rw       pin_e2   
....................    #define lcd_d4         pin_d4 
....................    #define lcd_d5         pin_d5 
....................    #define lcd_d6         pin_d6 
....................    #define lcd_d7         pin_d7 
.................... #endif 
....................  
.................... #include "mod_lcd.c" 
.................... /************************************************************************/ 
.................... /*  MOD_LCD.C - Biblioteca de manipula��o de m�dulo LCD                 */ 
.................... /*                                                                      */ 
.................... /*  Autor: F�bio Pereira                                                */ 
.................... /*                                                                      */ 
.................... /************************************************************************/ 
....................  
.................... // As defini��es a seguir s�o utilizadas para acesso aos pinos do display 
.................... // caso o pino RW n�o seja utilizado, comente a defini��o lcd_rw 
.................... #ifndef lcd_enable 
....................    #define lcd_enable       pin_e1      // pino enable do LCD 
....................    #define lcd_rs         pin_e0      // pino rs do LCD 
....................    //#define lcd_rw      pin_e2      // pino rw do LCD 
....................    #define lcd_d4         pin_d4      // pino de dados d4 do LCD 
....................    #define lcd_d5         pin_d5      // pino de dados d5 do LCD 
....................    #define lcd_d6         pin_d6      // pino de dados d6 do LCD 
....................    #define lcd_d7         pin_d7      // pino de dados d7 do LCD 
.................... #endif 
....................  
.................... #define lcd_type 2           
.................... #define lcd_seg_lin 0x40     
....................  
....................  
.................... byte CONST INI_LCD[4] = {0x20 | (lcd_type << 2), 0xf, 1, 6}; 
....................  
.................... byte lcd_le_byte() 
.................... // l� um byte do LCD (somente com pino RW) 
.................... { 
....................    byte dado; 
....................    // configura os pinos de dados como entradas 
....................    input(lcd_d4); 
....................    input(lcd_d5); 
....................    input(lcd_d6); 
....................    input(lcd_d7); 
....................    // se o pino rw for utilizado, coloca em 1 
....................    #ifdef lcd_rw 
....................       output_high(lcd_rw); 
....................    #endif 
....................    output_high(lcd_enable); // habilita display 
....................    dado = 0;   // zera a vari�vel de leitura 
....................    // l� os quatro bits mais significativos 
....................    if (input(lcd_d7)) bit_set(dado,7); 
....................    if (input(lcd_d6)) bit_set(dado,6); 
....................    if (input(lcd_d5)) bit_set(dado,5); 
....................    if (input(lcd_d4)) bit_set(dado,4); 
....................    // d� um pulso na linha enable 
....................    output_low(lcd_enable); 
....................    output_high(lcd_enable); 
....................    // l� os quatro bits menos significativos 
....................    if (input(lcd_d7)) bit_set(dado,3); 
....................    if (input(lcd_d6)) bit_set(dado,2); 
....................    if (input(lcd_d5)) bit_set(dado,1); 
....................    if (input(lcd_d4)) bit_set(dado,0); 
....................    output_low(lcd_enable);   // desabilita o display 
....................    return dado;   // retorna o byte lido 
.................... } 
....................  
.................... void lcd_envia_nibble( byte dado ) 
.................... // envia um dado de quatro bits para o display 
.................... { 
....................    // coloca os quatro bits nas saidas 
....................    output_bit(lcd_d4,bit_test(dado,0)); 
02B2:  BSF    03.5
02B3:  BTFSC  6C.0
02B4:  GOTO   2B9
02B5:  BCF    03.5
02B6:  BCF    08.4
02B7:  GOTO   2BB
02B8:  BSF    03.5
02B9:  BCF    03.5
02BA:  BSF    08.4
02BB:  BSF    03.5
02BC:  BCF    08.4
....................    output_bit(lcd_d5,bit_test(dado,1)); 
02BD:  BTFSC  6C.1
02BE:  GOTO   2C3
02BF:  BCF    03.5
02C0:  BCF    08.5
02C1:  GOTO   2C5
02C2:  BSF    03.5
02C3:  BCF    03.5
02C4:  BSF    08.5
02C5:  BSF    03.5
02C6:  BCF    08.5
....................    output_bit(lcd_d6,bit_test(dado,2)); 
02C7:  BTFSC  6C.2
02C8:  GOTO   2CD
02C9:  BCF    03.5
02CA:  BCF    08.6
02CB:  GOTO   2CF
02CC:  BSF    03.5
02CD:  BCF    03.5
02CE:  BSF    08.6
02CF:  BSF    03.5
02D0:  BCF    08.6
....................    output_bit(lcd_d7,bit_test(dado,3)); 
02D1:  BTFSC  6C.3
02D2:  GOTO   2D7
02D3:  BCF    03.5
02D4:  BCF    08.7
02D5:  GOTO   2D9
02D6:  BSF    03.5
02D7:  BCF    03.5
02D8:  BSF    08.7
02D9:  BSF    03.5
02DA:  BCF    08.7
....................    // d� um pulso na linha enable 
....................    output_high(lcd_enable); 
02DB:  BCF    09.1
02DC:  BCF    03.5
02DD:  BSF    09.1
....................    output_low(lcd_enable); 
02DE:  BSF    03.5
02DF:  BCF    09.1
02E0:  BCF    03.5
02E1:  BCF    09.1
02E2:  RETURN
.................... } 
....................  
....................  
.................... void lcd_envia_byte( boolean endereco, byte dado ) 
.................... { 
....................    // coloca a linha rs em 0 
....................    output_low(lcd_rs); 
02E3:  BSF    03.5
02E4:  BCF    09.2
02E5:  BCF    03.5
02E6:  BCF    09.2
....................    // aguarda o display ficar desocupado 
....................    //while ( bit_test(lcd_le_byte(),7) ) ; 
....................    // configura a linha rs dependendo do modo selecionado 
....................    output_bit(lcd_rs,endereco); 
02E7:  BSF    03.5
02E8:  MOVF   69,F
02E9:  BTFSS  03.2
02EA:  GOTO   2EF
02EB:  BCF    03.5
02EC:  BCF    09.2
02ED:  GOTO   2F1
02EE:  BSF    03.5
02EF:  BCF    03.5
02F0:  BSF    09.2
02F1:  BSF    03.5
02F2:  BCF    09.2
....................    delay_us(100);   // aguarda 100 us 
02F3:  MOVLW  A6
02F4:  MOVWF  77
02F5:  DECFSZ 77,F
02F6:  GOTO   2F5
02F7:  NOP
....................    // caso a linha rw esteja definida, coloca em 0 
....................    #ifdef lcd_rw 
....................       output_low(lcd_rw); 
....................    #endif 
....................    // desativa linha enable 
....................    output_low(lcd_enable); 
02F8:  BCF    09.1
02F9:  BCF    03.5
02FA:  BCF    09.1
....................    // envia a primeira parte do byte 
....................    lcd_envia_nibble(dado >> 4); 
02FB:  BSF    03.5
02FC:  SWAPF  6A,W
02FD:  MOVWF  6B
02FE:  MOVLW  0F
02FF:  ANDWF  6B,F
0300:  MOVF   6B,W
0301:  MOVWF  6C
0302:  BCF    03.5
0303:  CALL   2B2
....................    // envia a segunda parte do byte 
....................    lcd_envia_nibble(dado & 0x0f); 
0304:  BSF    03.5
0305:  MOVF   6A,W
0306:  ANDLW  0F
0307:  MOVWF  6B
0308:  MOVWF  6C
0309:  BCF    03.5
030A:  CALL   2B2
030B:  RETURN
.................... } 
....................  
....................  
.................... void lcd_ini() 
.................... // rotina de inicializa��o do display 
.................... { 
....................    byte conta; 
....................    output_low(lcd_d4); 
030C:  BSF    03.5
030D:  BCF    08.4
030E:  BCF    03.5
030F:  BCF    08.4
....................    output_low(lcd_d5); 
0310:  BSF    03.5
0311:  BCF    08.5
0312:  BCF    03.5
0313:  BCF    08.5
....................    output_low(lcd_d6); 
0314:  BSF    03.5
0315:  BCF    08.6
0316:  BCF    03.5
0317:  BCF    08.6
....................    output_low(lcd_d7); 
0318:  BSF    03.5
0319:  BCF    08.7
031A:  BCF    03.5
031B:  BCF    08.7
....................    output_low(lcd_rs); 
031C:  BSF    03.5
031D:  BCF    09.2
031E:  BCF    03.5
031F:  BCF    09.2
....................    #ifdef lcd_rw 
....................       output_high(lcd_rw); 
....................    #endif 
....................    output_low(lcd_enable); 
0320:  BSF    03.5
0321:  BCF    09.1
0322:  BCF    03.5
0323:  BCF    09.1
....................    delay_ms(15); 
0324:  MOVLW  0F
0325:  BSF    03.5
0326:  MOVWF  65
0327:  BCF    03.5
0328:  CALL   29E
....................    // envia uma seq��ncia de 3 vezes 0x03 
....................    // e depois 0x02 para configurar o m�dulo 
....................    // para modo de 4 bits 
....................    for(conta=1;conta<=3;++conta) 
0329:  MOVLW  01
032A:  MOVWF  70
032B:  MOVF   70,W
032C:  SUBLW  03
032D:  BTFSS  03.0
032E:  GOTO   33B
....................    { 
....................       lcd_envia_nibble(3); 
032F:  MOVLW  03
0330:  BSF    03.5
0331:  MOVWF  6C
0332:  BCF    03.5
0333:  CALL   2B2
....................       delay_ms(5); 
0334:  MOVLW  05
0335:  BSF    03.5
0336:  MOVWF  65
0337:  BCF    03.5
0338:  CALL   29E
0339:  INCF   70,F
033A:  GOTO   32B
....................    } 
....................    lcd_envia_nibble(2); 
033B:  MOVLW  02
033C:  BSF    03.5
033D:  MOVWF  6C
033E:  BCF    03.5
033F:  CALL   2B2
....................    // envia string de inicializa��o do display 
....................    for(conta=0;conta<=3;++conta) lcd_envia_byte(0,INI_LCD[conta]); 
0340:  CLRF   70
0341:  MOVF   70,W
0342:  SUBLW  03
0343:  BTFSS  03.0
0344:  GOTO   350
0345:  MOVF   70,W
0346:  CALL   051
0347:  MOVWF  71
0348:  BSF    03.5
0349:  CLRF   69
034A:  MOVF   71,W
034B:  MOVWF  6A
034C:  BCF    03.5
034D:  CALL   2E3
034E:  INCF   70,F
034F:  GOTO   341
0350:  BSF    0A.3
0351:  BSF    0A.4
0352:  GOTO   039 (RETURN)
.................... } 
....................  
.................... void lcd_pos_xy( byte x, byte y) 
.................... { 
....................    byte endereco; 
....................    if(y!=1) 
*
0374:  DECFSZ 66,W
0375:  GOTO   377
0376:  GOTO   37A
....................       endereco = lcd_seg_lin; 
0377:  MOVLW  40
0378:  MOVWF  67
0379:  GOTO   37B
....................    else 
....................       endereco = 0; 
037A:  CLRF   67
....................    endereco += x-1; 
037B:  MOVLW  01
037C:  SUBWF  65,W
037D:  ADDWF  67,F
....................    lcd_envia_byte(0,0x80|endereco); 
037E:  MOVF   67,W
037F:  IORLW  80
0380:  MOVWF  68
0381:  CLRF   69
0382:  MOVF   68,W
0383:  MOVWF  6A
0384:  BCF    03.5
0385:  CALL   2E3
.................... } 
....................  
.................... void lcd_escreve( char c) 
.................... // envia caractere para o display 
.................... { 
....................    switch (c) 
*
0353:  BSF    03.5
0354:  MOVF   64,W
0355:  XORLW  0C
0356:  BCF    03.5
0357:  BTFSC  03.2
0358:  GOTO   363
0359:  XORLW  06
035A:  BTFSC  03.2
035B:  GOTO   36F
035C:  XORLW  07
035D:  BTFSC  03.2
035E:  GOTO   36F
035F:  XORLW  05
0360:  BTFSC  03.2
0361:  GOTO   387
0362:  GOTO   38E
....................    { 
....................      case '\f'    :   lcd_envia_byte(0,1); 
0363:  BSF    03.5
0364:  CLRF   69
0365:  MOVLW  01
0366:  MOVWF  6A
0367:  BCF    03.5
0368:  CALL   2E3
....................               delay_ms(2); 
0369:  MOVLW  02
036A:  BSF    03.5
036B:  MOVWF  65
036C:  BCF    03.5
036D:  CALL   29E
....................             break; 
036E:  GOTO   395
....................      case '\n'   : 
....................       case '\r'    :   lcd_pos_xy(1,2); 
036F:  MOVLW  01
0370:  BSF    03.5
0371:  MOVWF  65
0372:  MOVLW  02
0373:  MOVWF  66
....................               break; 
*
0386:  GOTO   395
....................      case '\b'    :   lcd_envia_byte(0,0x10); 
0387:  BSF    03.5
0388:  CLRF   69
0389:  MOVLW  10
038A:  MOVWF  6A
038B:  BCF    03.5
038C:  CALL   2E3
....................               break; 
038D:  GOTO   395
....................      default   :   lcd_envia_byte(1,c); 
038E:  MOVLW  01
038F:  BSF    03.5
0390:  MOVWF  69
0391:  MOVF   64,W
0392:  MOVWF  6A
0393:  BCF    03.5
0394:  CALL   2E3
....................               break; 
....................    } 
0395:  RETURN
.................... } 
....................  
.................... char lcd_le( byte x, byte y) 
.................... // le caractere do display 
.................... { 
....................    char valor; 
....................    // seleciona a posi��o do caractere 
....................    lcd_pos_xy(x,y); 
....................    // ativa rs 
....................    output_high(lcd_rs); 
....................    // l� o caractere 
....................    valor = lcd_le_byte(); 
....................    // desativa rs 
....................    output_low(lcd_rs); 
....................    // retorna o valor do caractere 
....................    return valor; 
.................... } 
....................  
....................  
.................... #include "2401.c" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a MicroChip 24LC01B configured for a x8 org         //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);  Read the byte d from the address a     //// 
.................... ////                                                                   //// 
.................... ////   b = ext_eeprom_ready();  Returns TRUE if the eeprom is ready    //// 
.................... ////                            to receive opcodes                     //// 
.................... ////                                                                   //// 
.................... ////   The main program may define EEPROM_SDA                          //// 
.................... ////   and EEPROM_SCL to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... ////                            Pin Layout                             //// 
.................... ////   -----------------------------------------------------------     //// 
.................... ////   |                                                         |     //// 
.................... ////   | 1: NC   Not Connected | 8: VCC   +5V                    |     //// 
.................... ////   |                       |                                 |     //// 
.................... ////   | 2: NC   Not Connected | 7: WP    GND                    |     //// 
.................... ////   |                       |                                 |     //// 
.................... ////   | 3: NC   Not Connected | 6: SCL   EEPROM_SCL and Pull-Up |     //// 
.................... ////   |                       |                                 |     //// 
.................... ////   | 4: VSS  GND           | 5: SDA   EEPROM_SDA and Pull-Up |     //// 
.................... ////   -----------------------------------------------------------     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2003 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef EEPROM_SDA 
....................  
.................... #define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C3 
....................  
.................... #endif 
....................  
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
040A:  MOVLW  08
040B:  MOVWF  78
040C:  MOVLW  04
040D:  MOVWF  77
040E:  DECFSZ 77,F
040F:  GOTO   40E
0410:  BCF    07.3
0411:  BCF    47.3
0412:  MOVF   47,W
0413:  BSF    03.5
0414:  MOVWF  07
0415:  MOVLW  03
0416:  MOVWF  77
0417:  DECFSZ 77,F
0418:  GOTO   417
0419:  RLF    63,F
041A:  BCF    03.5
041B:  BCF    07.4
041C:  BTFSS  03.0
041D:  GOTO   424
041E:  BSF    47.4
041F:  MOVF   47,W
0420:  BSF    03.5
0421:  MOVWF  07
0422:  GOTO   428
0423:  BCF    03.5
0424:  BCF    47.4
0425:  MOVF   47,W
0426:  BSF    03.5
0427:  MOVWF  07
0428:  NOP
0429:  BCF    03.5
042A:  BSF    47.3
042B:  MOVF   47,W
042C:  BSF    03.5
042D:  MOVWF  07
042E:  BCF    03.5
042F:  BTFSS  07.3
0430:  GOTO   42F
0431:  DECFSZ 78,F
0432:  GOTO   40C
0433:  MOVLW  04
0434:  MOVWF  77
0435:  DECFSZ 77,F
0436:  GOTO   435
0437:  BCF    07.3
0438:  BCF    47.3
0439:  MOVF   47,W
043A:  BSF    03.5
043B:  MOVWF  07
043C:  NOP
043D:  BCF    03.5
043E:  BSF    47.4
043F:  MOVF   47,W
0440:  BSF    03.5
0441:  MOVWF  07
0442:  MOVLW  03
0443:  MOVWF  77
0444:  DECFSZ 77,F
0445:  GOTO   444
0446:  MOVLW  03
0447:  MOVWF  77
0448:  DECFSZ 77,F
0449:  GOTO   448
044A:  BCF    03.5
044B:  BSF    47.3
044C:  MOVF   47,W
044D:  BSF    03.5
044E:  MOVWF  07
044F:  BCF    03.5
0450:  BTFSS  07.3
0451:  GOTO   450
0452:  CLRF   78
0453:  MOVLW  03
0454:  MOVWF  77
0455:  DECFSZ 77,F
0456:  GOTO   455
0457:  BTFSC  07.4
0458:  BSF    78.0
0459:  BCF    07.3
045A:  BCF    47.3
045B:  MOVF   47,W
045C:  BSF    03.5
045D:  MOVWF  07
045E:  BCF    03.5
045F:  BCF    07.4
0460:  BCF    47.4
0461:  MOVF   47,W
0462:  BSF    03.5
0463:  MOVWF  07
0464:  BCF    03.5
0465:  RETURN
*
0575:  MOVLW  08
0576:  BSF    03.5
0577:  MOVWF  5F
0578:  MOVF   77,W
0579:  MOVWF  60
057A:  BCF    03.5
057B:  BSF    47.4
057C:  MOVF   47,W
057D:  BSF    03.5
057E:  MOVWF  07
057F:  MOVLW  03
0580:  MOVWF  77
0581:  DECFSZ 77,F
0582:  GOTO   581
0583:  BCF    03.5
0584:  BSF    47.3
0585:  MOVF   47,W
0586:  BSF    03.5
0587:  MOVWF  07
0588:  BCF    03.5
0589:  BTFSS  07.3
058A:  GOTO   589
058B:  BTFSC  07.4
058C:  BSF    03.0
058D:  BTFSS  07.4
058E:  BCF    03.0
058F:  RLF    78,F
0590:  MOVLW  04
0591:  MOVWF  77
0592:  DECFSZ 77,F
0593:  GOTO   592
0594:  BCF    47.3
0595:  MOVF   47,W
0596:  BSF    03.5
0597:  MOVWF  07
0598:  BCF    03.5
0599:  BCF    07.3
059A:  BSF    03.5
059B:  DECFSZ 5F,F
059C:  GOTO   57A
059D:  BCF    03.5
059E:  BSF    47.4
059F:  MOVF   47,W
05A0:  BSF    03.5
05A1:  MOVWF  07
05A2:  MOVLW  03
05A3:  MOVWF  77
05A4:  DECFSZ 77,F
05A5:  GOTO   5A4
05A6:  BCF    03.5
05A7:  BCF    07.4
05A8:  BSF    03.5
05A9:  MOVF   60,W
05AA:  BTFSC  03.2
05AB:  GOTO   5B1
05AC:  BCF    03.5
05AD:  BCF    47.4
05AE:  MOVF   47,W
05AF:  BSF    03.5
05B0:  MOVWF  07
05B1:  NOP
05B2:  BCF    03.5
05B3:  BSF    47.3
05B4:  MOVF   47,W
05B5:  BSF    03.5
05B6:  MOVWF  07
05B7:  BCF    03.5
05B8:  BTFSS  07.3
05B9:  GOTO   5B8
05BA:  MOVLW  04
05BB:  MOVWF  77
05BC:  DECFSZ 77,F
05BD:  GOTO   5BC
05BE:  BCF    07.3
05BF:  BCF    47.3
05C0:  MOVF   47,W
05C1:  BSF    03.5
05C2:  MOVWF  07
05C3:  MOVLW  03
05C4:  MOVWF  77
05C5:  DECFSZ 77,F
05C6:  GOTO   5C5
05C7:  BCF    03.5
05C8:  BCF    07.4
05C9:  BCF    47.4
05CA:  MOVF   47,W
05CB:  BSF    03.5
05CC:  MOVWF  07
....................  
.................... #define EEPROM_ADDRESS BYTE 
.................... #define EEPROM_SIZE    128 
....................  
.................... void init_ext_eeprom() { 
....................    output_float(EEPROM_SCL); 
*
0291:  BSF    47.3
0292:  MOVF   47,W
0293:  BSF    03.5
0294:  MOVWF  07
....................    output_float(EEPROM_SDA); 
0295:  BCF    03.5
0296:  BSF    47.4
0297:  MOVF   47,W
0298:  BSF    03.5
0299:  MOVWF  07
029A:  BCF    03.5
029B:  BSF    0A.3
029C:  BSF    0A.4
029D:  GOTO   02E (RETURN)
.................... } 
....................  
.................... BOOLEAN ext_eeprom_ready() { 
....................    int1 ack; 
....................    i2c_start();            // If the write command is acknowledged, 
*
0466:  BSF    47.4
0467:  MOVF   47,W
0468:  BSF    03.5
0469:  MOVWF  07
046A:  MOVLW  04
046B:  MOVWF  77
046C:  DECFSZ 77,F
046D:  GOTO   46C
046E:  BCF    03.5
046F:  BSF    47.3
0470:  MOVF   47,W
0471:  BSF    03.5
0472:  MOVWF  07
0473:  MOVLW  03
0474:  MOVWF  77
0475:  DECFSZ 77,F
0476:  GOTO   475
0477:  BCF    03.5
0478:  BCF    07.4
0479:  BCF    47.4
047A:  MOVF   47,W
047B:  BSF    03.5
047C:  MOVWF  07
047D:  MOVLW  04
047E:  MOVWF  77
047F:  DECFSZ 77,F
0480:  GOTO   47F
0481:  BCF    03.5
0482:  BCF    07.3
0483:  BCF    47.3
0484:  MOVF   47,W
0485:  BSF    03.5
0486:  MOVWF  07
....................    ack = i2c_write(0xa0);  // then the device is ready. 
0487:  MOVLW  A0
0488:  MOVWF  63
0489:  BCF    03.5
048A:  CALL   40A
048B:  MOVF   78,W
048C:  BSF    03.5
048D:  BCF    62.0
048E:  BTFSC  78.0
048F:  BSF    62.0
....................    i2c_stop(); 
0490:  BCF    03.5
0491:  BCF    47.4
0492:  MOVF   47,W
0493:  BSF    03.5
0494:  MOVWF  07
0495:  NOP
0496:  BCF    03.5
0497:  BSF    47.3
0498:  MOVF   47,W
0499:  BSF    03.5
049A:  MOVWF  07
049B:  BCF    03.5
049C:  BTFSS  07.3
049D:  GOTO   49C
049E:  MOVLW  04
049F:  MOVWF  77
04A0:  DECFSZ 77,F
04A1:  GOTO   4A0
04A2:  GOTO   4A3
04A3:  NOP
04A4:  BSF    47.4
04A5:  MOVF   47,W
04A6:  BSF    03.5
04A7:  MOVWF  07
04A8:  MOVLW  04
04A9:  MOVWF  77
04AA:  DECFSZ 77,F
04AB:  GOTO   4AA
....................    return !ack; 
04AC:  MOVLW  00
04AD:  BTFSS  62.0
04AE:  MOVLW  01
04AF:  MOVWF  78
04B0:  BCF    03.5
04B1:  RETURN
.................... } 
....................  
.................... void write_ext_eeprom(BYTE address, BYTE data) { 
....................    while(!ext_eeprom_ready()); 
04B2:  CALL   466
04B3:  MOVF   78,F
04B4:  BTFSC  03.2
04B5:  GOTO   4B2
....................    i2c_start(); 
04B6:  BSF    47.4
04B7:  MOVF   47,W
04B8:  BSF    03.5
04B9:  MOVWF  07
04BA:  MOVLW  04
04BB:  MOVWF  77
04BC:  DECFSZ 77,F
04BD:  GOTO   4BC
04BE:  BCF    03.5
04BF:  BSF    47.3
04C0:  MOVF   47,W
04C1:  BSF    03.5
04C2:  MOVWF  07
04C3:  MOVLW  03
04C4:  MOVWF  77
04C5:  DECFSZ 77,F
04C6:  GOTO   4C5
04C7:  BCF    03.5
04C8:  BCF    07.4
04C9:  BCF    47.4
04CA:  MOVF   47,W
04CB:  BSF    03.5
04CC:  MOVWF  07
04CD:  MOVLW  04
04CE:  MOVWF  77
04CF:  DECFSZ 77,F
04D0:  GOTO   4CF
04D1:  BCF    03.5
04D2:  BCF    07.3
04D3:  BCF    47.3
04D4:  MOVF   47,W
04D5:  BSF    03.5
04D6:  MOVWF  07
....................    i2c_write(0xa0); 
04D7:  MOVLW  A0
04D8:  MOVWF  63
04D9:  BCF    03.5
04DA:  CALL   40A
....................    i2c_write(address); 
04DB:  BSF    03.5
04DC:  MOVF   60,W
04DD:  MOVWF  63
04DE:  BCF    03.5
04DF:  CALL   40A
....................    i2c_write(data); 
04E0:  BSF    03.5
04E1:  MOVF   61,W
04E2:  MOVWF  63
04E3:  BCF    03.5
04E4:  CALL   40A
....................    i2c_stop(); 
04E5:  BCF    47.4
04E6:  MOVF   47,W
04E7:  BSF    03.5
04E8:  MOVWF  07
04E9:  NOP
04EA:  BCF    03.5
04EB:  BSF    47.3
04EC:  MOVF   47,W
04ED:  BSF    03.5
04EE:  MOVWF  07
04EF:  BCF    03.5
04F0:  BTFSS  07.3
04F1:  GOTO   4F0
04F2:  MOVLW  04
04F3:  MOVWF  77
04F4:  DECFSZ 77,F
04F5:  GOTO   4F4
04F6:  GOTO   4F7
04F7:  NOP
04F8:  BSF    47.4
04F9:  MOVF   47,W
04FA:  BSF    03.5
04FB:  MOVWF  07
04FC:  MOVLW  04
04FD:  MOVWF  77
04FE:  DECFSZ 77,F
04FF:  GOTO   4FE
0500:  BCF    03.5
0501:  RETURN
.................... } 
....................  
....................  
.................... BYTE read_ext_eeprom(BYTE address) { 
....................    BYTE data; 
....................  
....................    while(!ext_eeprom_ready()); 
*
051F:  CALL   466
0520:  MOVF   78,F
0521:  BTFSC  03.2
0522:  GOTO   51F
....................    i2c_start(); 
0523:  BSF    47.4
0524:  MOVF   47,W
0525:  BSF    03.5
0526:  MOVWF  07
0527:  MOVLW  04
0528:  MOVWF  77
0529:  DECFSZ 77,F
052A:  GOTO   529
052B:  BCF    03.5
052C:  BSF    47.3
052D:  MOVF   47,W
052E:  BSF    03.5
052F:  MOVWF  07
0530:  MOVLW  03
0531:  MOVWF  77
0532:  DECFSZ 77,F
0533:  GOTO   532
0534:  BCF    03.5
0535:  BCF    07.4
0536:  BCF    47.4
0537:  MOVF   47,W
0538:  BSF    03.5
0539:  MOVWF  07
053A:  MOVLW  04
053B:  MOVWF  77
053C:  DECFSZ 77,F
053D:  GOTO   53C
053E:  BCF    03.5
053F:  BCF    07.3
0540:  BCF    47.3
0541:  MOVF   47,W
0542:  BSF    03.5
0543:  MOVWF  07
....................    i2c_write(0xa0); 
0544:  MOVLW  A0
0545:  MOVWF  63
0546:  BCF    03.5
0547:  CALL   40A
....................    i2c_write(address); 
0548:  BSF    03.5
0549:  MOVF   5C,W
054A:  MOVWF  63
054B:  BCF    03.5
054C:  CALL   40A
....................    i2c_start(); 
054D:  BSF    47.4
054E:  MOVF   47,W
054F:  BSF    03.5
0550:  MOVWF  07
0551:  MOVLW  04
0552:  MOVWF  77
0553:  DECFSZ 77,F
0554:  GOTO   553
0555:  BCF    03.5
0556:  BSF    47.3
0557:  MOVF   47,W
0558:  BSF    03.5
0559:  MOVWF  07
055A:  MOVLW  03
055B:  MOVWF  77
055C:  DECFSZ 77,F
055D:  GOTO   55C
055E:  BCF    03.5
055F:  BTFSS  07.3
0560:  GOTO   55F
0561:  BCF    07.4
0562:  BCF    47.4
0563:  MOVF   47,W
0564:  BSF    03.5
0565:  MOVWF  07
0566:  MOVLW  04
0567:  MOVWF  77
0568:  DECFSZ 77,F
0569:  GOTO   568
056A:  BCF    03.5
056B:  BCF    07.3
056C:  BCF    47.3
056D:  MOVF   47,W
056E:  BSF    03.5
056F:  MOVWF  07
....................    i2c_write(0xa1); 
0570:  MOVLW  A1
0571:  MOVWF  63
0572:  BCF    03.5
0573:  CALL   40A
....................    data=i2c_read(0); 
0574:  CLRF   77
*
05CD:  MOVF   78,W
05CE:  MOVWF  5D
....................    i2c_stop(); 
05CF:  BCF    03.5
05D0:  BCF    47.4
05D1:  MOVF   47,W
05D2:  BSF    03.5
05D3:  MOVWF  07
05D4:  NOP
05D5:  BCF    03.5
05D6:  BSF    47.3
05D7:  MOVF   47,W
05D8:  BSF    03.5
05D9:  MOVWF  07
05DA:  BCF    03.5
05DB:  BTFSS  07.3
05DC:  GOTO   5DB
05DD:  MOVLW  04
05DE:  MOVWF  77
05DF:  DECFSZ 77,F
05E0:  GOTO   5DF
05E1:  GOTO   5E2
05E2:  NOP
05E3:  BSF    47.4
05E4:  MOVF   47,W
05E5:  BSF    03.5
05E6:  MOVWF  07
05E7:  MOVLW  04
05E8:  MOVWF  77
05E9:  DECFSZ 77,F
05EA:  GOTO   5E9
....................    return(data); 
05EB:  MOVF   5D,W
05EC:  MOVWF  78
05ED:  BCF    03.5
05EE:  RETURN
.................... } 
....................  
.................... #include "kbd_board4.c" 
.................... /*######################################################################  
....................    Rotina utilizao do teclado da placa PicSim board4 
....................    Adaptada para o compilador CCS 
....................    Autor: Alberto Willia Mascarenhas (adaptou para o compilador) 
....................    For e-mail suggestions :  awmascarenhas@gmail.com 
.................... ######################################################################## */ 
.................... unsigned char tc_tecla(unsigned int timeout) 
*
0803:  CLRF   62
0804:  CLRF   63
.................... { 
....................   unsigned int to=0; 
....................   unsigned char k = 0;   
....................   while(((to < timeout)||(!timeout))&&(!k)){ 
0805:  MOVF   61,W
0806:  SUBWF  62,W
0807:  BTFSS  03.0
0808:  GOTO   00C
0809:  MOVF   61,F
080A:  BTFSS  03.2
080B:  GOTO   155
080C:  MOVF   63,F
080D:  BTFSS  03.2
080E:  GOTO   155
....................       
....................        
....................       //------------------------------------------------------------------------- 
....................       //inicio do programa de varredura do teclado matricial 
....................       //-------------------------------------------------------------------------- 
....................       //habilita primeira coluna do teclado 
....................       output_low(PIN_B0);output_high(PIN_B1);output_high(PIN_B2);output_high(PIN_B3); 
080F:  BCF    06.0
0810:  BCF    03.5
0811:  BCF    06.0
0812:  BSF    03.5
0813:  BCF    06.1
0814:  BCF    03.5
0815:  BSF    06.1
0816:  BSF    03.5
0817:  BCF    06.2
0818:  BCF    03.5
0819:  BSF    06.2
081A:  BSF    03.5
081B:  BCF    06.3
081C:  BCF    03.5
081D:  BSF    06.3
....................       delay_ms(20); 
081E:  MOVLW  14
081F:  BSF    03.5
0820:  MOVWF  65
0821:  BCF    0A.3
0822:  BCF    03.5
0823:  CALL   29E
0824:  BSF    0A.3
....................       if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='1';}; 
0825:  BSF    03.5
0826:  BSF    08.0
0827:  BCF    03.5
0828:  BTFSC  08.0
0829:  GOTO   033
082A:  BSF    03.5
082B:  BSF    08.0
082C:  BCF    03.5
082D:  BTFSS  08.0
082E:  GOTO   02A
082F:  MOVLW  31
0830:  BSF    03.5
0831:  MOVWF  63
0832:  BCF    03.5
....................       if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='4';}; 
0833:  BSF    03.5
0834:  BSF    08.1
0835:  BCF    03.5
0836:  BTFSC  08.1
0837:  GOTO   041
0838:  BSF    03.5
0839:  BSF    08.1
083A:  BCF    03.5
083B:  BTFSS  08.1
083C:  GOTO   038
083D:  MOVLW  34
083E:  BSF    03.5
083F:  MOVWF  63
0840:  BCF    03.5
....................       if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='7';}; 
0841:  BSF    03.5
0842:  BSF    08.2
0843:  BCF    03.5
0844:  BTFSC  08.2
0845:  GOTO   04F
0846:  BSF    03.5
0847:  BSF    08.2
0848:  BCF    03.5
0849:  BTFSS  08.2
084A:  GOTO   046
084B:  MOVLW  37
084C:  BSF    03.5
084D:  MOVWF  63
084E:  BCF    03.5
....................       if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='*';}; 
084F:  BSF    03.5
0850:  BSF    08.3
0851:  BCF    03.5
0852:  BTFSC  08.3
0853:  GOTO   05D
0854:  BSF    03.5
0855:  BSF    08.3
0856:  BCF    03.5
0857:  BTFSS  08.3
0858:  GOTO   054
0859:  MOVLW  2A
085A:  BSF    03.5
085B:  MOVWF  63
085C:  BCF    03.5
....................       //habilita segunda coluna do teclado 
....................       output_high(PIN_B0);output_low(PIN_B1);output_high(PIN_B2);output_high(PIN_B3); 
085D:  BSF    03.5
085E:  BCF    06.0
085F:  BCF    03.5
0860:  BSF    06.0
0861:  BSF    03.5
0862:  BCF    06.1
0863:  BCF    03.5
0864:  BCF    06.1
0865:  BSF    03.5
0866:  BCF    06.2
0867:  BCF    03.5
0868:  BSF    06.2
0869:  BSF    03.5
086A:  BCF    06.3
086B:  BCF    03.5
086C:  BSF    06.3
....................       delay_ms(20);       
086D:  MOVLW  14
086E:  BSF    03.5
086F:  MOVWF  65
0870:  BCF    0A.3
0871:  BCF    03.5
0872:  CALL   29E
0873:  BSF    0A.3
....................       if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='2';}; 
0874:  BSF    03.5
0875:  BSF    08.0
0876:  BCF    03.5
0877:  BTFSC  08.0
0878:  GOTO   082
0879:  BSF    03.5
087A:  BSF    08.0
087B:  BCF    03.5
087C:  BTFSS  08.0
087D:  GOTO   079
087E:  MOVLW  32
087F:  BSF    03.5
0880:  MOVWF  63
0881:  BCF    03.5
....................       if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='5';}; 
0882:  BSF    03.5
0883:  BSF    08.1
0884:  BCF    03.5
0885:  BTFSC  08.1
0886:  GOTO   090
0887:  BSF    03.5
0888:  BSF    08.1
0889:  BCF    03.5
088A:  BTFSS  08.1
088B:  GOTO   087
088C:  MOVLW  35
088D:  BSF    03.5
088E:  MOVWF  63
088F:  BCF    03.5
....................       if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='8';}; 
0890:  BSF    03.5
0891:  BSF    08.2
0892:  BCF    03.5
0893:  BTFSC  08.2
0894:  GOTO   09E
0895:  BSF    03.5
0896:  BSF    08.2
0897:  BCF    03.5
0898:  BTFSS  08.2
0899:  GOTO   095
089A:  MOVLW  38
089B:  BSF    03.5
089C:  MOVWF  63
089D:  BCF    03.5
....................       if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='0';}; 
089E:  BSF    03.5
089F:  BSF    08.3
08A0:  BCF    03.5
08A1:  BTFSC  08.3
08A2:  GOTO   0AC
08A3:  BSF    03.5
08A4:  BSF    08.3
08A5:  BCF    03.5
08A6:  BTFSS  08.3
08A7:  GOTO   0A3
08A8:  MOVLW  30
08A9:  BSF    03.5
08AA:  MOVWF  63
08AB:  BCF    03.5
....................        
....................       //habilita terceira coluna do teclado 
....................       output_high(PIN_B0);output_high(PIN_B1);output_low(PIN_B2);output_high(PIN_B3); 
08AC:  BSF    03.5
08AD:  BCF    06.0
08AE:  BCF    03.5
08AF:  BSF    06.0
08B0:  BSF    03.5
08B1:  BCF    06.1
08B2:  BCF    03.5
08B3:  BSF    06.1
08B4:  BSF    03.5
08B5:  BCF    06.2
08B6:  BCF    03.5
08B7:  BCF    06.2
08B8:  BSF    03.5
08B9:  BCF    06.3
08BA:  BCF    03.5
08BB:  BSF    06.3
....................       delay_ms(20);       
08BC:  MOVLW  14
08BD:  BSF    03.5
08BE:  MOVWF  65
08BF:  BCF    0A.3
08C0:  BCF    03.5
08C1:  CALL   29E
08C2:  BSF    0A.3
....................       if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='3';}; 
08C3:  BSF    03.5
08C4:  BSF    08.0
08C5:  BCF    03.5
08C6:  BTFSC  08.0
08C7:  GOTO   0D1
08C8:  BSF    03.5
08C9:  BSF    08.0
08CA:  BCF    03.5
08CB:  BTFSS  08.0
08CC:  GOTO   0C8
08CD:  MOVLW  33
08CE:  BSF    03.5
08CF:  MOVWF  63
08D0:  BCF    03.5
....................       if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='6';}; 
08D1:  BSF    03.5
08D2:  BSF    08.1
08D3:  BCF    03.5
08D4:  BTFSC  08.1
08D5:  GOTO   0DF
08D6:  BSF    03.5
08D7:  BSF    08.1
08D8:  BCF    03.5
08D9:  BTFSS  08.1
08DA:  GOTO   0D6
08DB:  MOVLW  36
08DC:  BSF    03.5
08DD:  MOVWF  63
08DE:  BCF    03.5
....................       if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='9';}; 
08DF:  BSF    03.5
08E0:  BSF    08.2
08E1:  BCF    03.5
08E2:  BTFSC  08.2
08E3:  GOTO   0ED
08E4:  BSF    03.5
08E5:  BSF    08.2
08E6:  BCF    03.5
08E7:  BTFSS  08.2
08E8:  GOTO   0E4
08E9:  MOVLW  39
08EA:  BSF    03.5
08EB:  MOVWF  63
08EC:  BCF    03.5
....................       if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='#';}; 
08ED:  BSF    03.5
08EE:  BSF    08.3
08EF:  BCF    03.5
08F0:  BTFSC  08.3
08F1:  GOTO   0FB
08F2:  BSF    03.5
08F3:  BSF    08.3
08F4:  BCF    03.5
08F5:  BTFSS  08.3
08F6:  GOTO   0F2
08F7:  MOVLW  23
08F8:  BSF    03.5
08F9:  MOVWF  63
08FA:  BCF    03.5
....................   
....................        //habilita quarta coluna do teclado 
....................       output_high(PIN_B0);output_high(PIN_B1);output_high(PIN_B2);output_low(PIN_B3); 
08FB:  BSF    03.5
08FC:  BCF    06.0
08FD:  BCF    03.5
08FE:  BSF    06.0
08FF:  BSF    03.5
0900:  BCF    06.1
0901:  BCF    03.5
0902:  BSF    06.1
0903:  BSF    03.5
0904:  BCF    06.2
0905:  BCF    03.5
0906:  BSF    06.2
0907:  BSF    03.5
0908:  BCF    06.3
0909:  BCF    03.5
090A:  BCF    06.3
....................       delay_ms(20);       
090B:  MOVLW  14
090C:  BSF    03.5
090D:  MOVWF  65
090E:  BCF    0A.3
090F:  BCF    03.5
0910:  CALL   29E
0911:  BSF    0A.3
....................       if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='A';}; 
0912:  BSF    03.5
0913:  BSF    08.0
0914:  BCF    03.5
0915:  BTFSC  08.0
0916:  GOTO   120
0917:  BSF    03.5
0918:  BSF    08.0
0919:  BCF    03.5
091A:  BTFSS  08.0
091B:  GOTO   117
091C:  MOVLW  41
091D:  BSF    03.5
091E:  MOVWF  63
091F:  BCF    03.5
....................       if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='B';}; 
0920:  BSF    03.5
0921:  BSF    08.1
0922:  BCF    03.5
0923:  BTFSC  08.1
0924:  GOTO   12E
0925:  BSF    03.5
0926:  BSF    08.1
0927:  BCF    03.5
0928:  BTFSS  08.1
0929:  GOTO   125
092A:  MOVLW  42
092B:  BSF    03.5
092C:  MOVWF  63
092D:  BCF    03.5
....................       if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='C';}; 
092E:  BSF    03.5
092F:  BSF    08.2
0930:  BCF    03.5
0931:  BTFSC  08.2
0932:  GOTO   13C
0933:  BSF    03.5
0934:  BSF    08.2
0935:  BCF    03.5
0936:  BTFSS  08.2
0937:  GOTO   133
0938:  MOVLW  43
0939:  BSF    03.5
093A:  MOVWF  63
093B:  BCF    03.5
....................       if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='D';}; 
093C:  BSF    03.5
093D:  BSF    08.3
093E:  BCF    03.5
093F:  BTFSC  08.3
0940:  GOTO   14A
0941:  BSF    03.5
0942:  BSF    08.3
0943:  BCF    03.5
0944:  BTFSS  08.3
0945:  GOTO   141
0946:  MOVLW  44
0947:  BSF    03.5
0948:  MOVWF  63
0949:  BCF    03.5
....................   
....................       //printf (lcd_escreve,"\f saiu geral %u",k); 
....................       //delay_ms(1000); 
....................       delay_ms(5); 
094A:  MOVLW  05
094B:  BSF    03.5
094C:  MOVWF  65
094D:  BCF    0A.3
094E:  BCF    03.5
094F:  CALL   29E
0950:  BSF    0A.3
....................       to+=5; 
0951:  MOVLW  05
0952:  BSF    03.5
0953:  ADDWF  62,F
0954:  GOTO   005
....................   } 
....................    if(!k)k=255; 
0955:  MOVF   63,F
0956:  BTFSS  03.2
0957:  GOTO   15A
0958:  MOVLW  FF
0959:  MOVWF  63
....................   return k;   
095A:  MOVF   63,W
095B:  MOVWF  78
.................... } 
....................  
....................  
.................... typedef struct {  
....................    int id[2];   
....................    int pass[4]; //password 
....................    int status; //0 - Unpaid, 1 - Paid, 3 - Admin 
.................... }User; 
....................  
....................  
....................  
....................  
.................... /* 
.................... int status -> 0 - Unpaid, 1 - Paid, 3 - Admin 
.................... int chooseAddr: 
....................          Param < 0 - SAVE in a available address to CREATE  
....................          Param >= 0 - SAVE in a existing address to OVERWRITE (edit) 
.................... */ 
.................... void saveUser(int * id, int * pass, int status); 
.................... int getAddressByID(int * id);    
.................... void searchUser(int * id); 
.................... int deleteUser(int * id); 
.................... void editUser(); 
.................... void updateUser(int * id, int * pass, int status); 
.................... User receiveUser(); 
.................... // int isIdAvailable(int id);     
.................... void printUser(User user); 
.................... void waitUpdate(); 
.................... void overwriteUser(User user); 
.................... void erase_program_eeprom(int addrr); 
.................... int incrementID(); 
.................... int lastNewUserPosition(); 
.................... void resetMemory(); 
.................... void adminMenu(); 
.................... int login(int * id); 
.................... int checkPassword(int initBlockAddr, int * pass); 
.................... //show = 1 -> Print(Paid/Unpaid) 
.................... int getUserStatus(int address, int show); 
.................... unsigned char readKeyboard();  
.................... int * getAdminsID(); 
.................... void listAdmins(); 
.................... int * strToInt(char * str); 
.................... char * strfromchar(char destination[], char source); 
.................... int * inputId(); 
.................... int * inputToKeyboard(char * msg, int max); 
.................... void inputKeyboardUser(); 
....................  
....................  
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
*
0770:  BSF    03.6
0771:  MOVF   3C,W
0772:  MOVWF  3F
....................    for(su=s;0<n;++su,--n) 
0773:  MOVF   3B,W
0774:  MOVWF  41
0775:  MOVF   3A,W
0776:  MOVWF  40
0777:  MOVF   3E,F
0778:  BTFSS  03.2
0779:  GOTO   77E
077A:  MOVF   3D,W
077B:  SUBLW  00
077C:  BTFSC  03.0
077D:  GOTO   796
....................       if(*su==uc) 
077E:  MOVF   41,W
077F:  MOVWF  7A
0780:  MOVF   40,W
0781:  MOVWF  04
0782:  BCF    03.7
0783:  BTFSC  7A.0
0784:  BSF    03.7
0785:  MOVF   3F,W
0786:  SUBWF  00,W
0787:  BTFSS  03.2
0788:  GOTO   78E
....................       return su; 
0789:  MOVF   40,W
078A:  MOVWF  78
078B:  MOVF   41,W
078C:  MOVWF  79
078D:  GOTO   799
078E:  INCF   40,F
078F:  BTFSC  03.2
0790:  INCF   41,F
0791:  MOVF   3D,W
0792:  BTFSC  03.2
0793:  DECF   3E,F
0794:  DECF   3D,F
0795:  GOTO   777
....................    return NULL; 
0796:  MOVLW  00
0797:  MOVWF  78
0798:  MOVWF  79
0799:  BCF    03.6
079A:  RETURN
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
181A:  BCF    03.5
181B:  CLRF   48
181C:  CLRF   49
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
*
0971:  BSF    03.6
0972:  CLRF   13
0973:  CLRF   12
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
0974:  MOVLW  30
0975:  MOVWF  15
0976:  MOVLW  31
0977:  MOVWF  16
0978:  MOVLW  32
0979:  MOVWF  17
097A:  MOVLW  33
097B:  MOVWF  18
097C:  MOVLW  34
097D:  MOVWF  19
097E:  MOVLW  35
097F:  MOVWF  1A
0980:  MOVLW  36
0981:  MOVWF  1B
0982:  MOVLW  37
0983:  MOVWF  1C
0984:  MOVLW  38
0985:  MOVWF  1D
0986:  MOVLW  39
0987:  MOVWF  1E
0988:  MOVLW  61
0989:  MOVWF  1F
098A:  MOVLW  62
098B:  MOVWF  20
098C:  MOVLW  63
098D:  MOVWF  21
098E:  MOVLW  64
098F:  MOVWF  22
0990:  MOVLW  65
0991:  MOVWF  23
0992:  MOVLW  66
0993:  MOVWF  24
0994:  MOVLW  67
0995:  MOVWF  25
0996:  MOVLW  68
0997:  MOVWF  26
0998:  MOVLW  69
0999:  MOVWF  27
099A:  MOVLW  6A
099B:  MOVWF  28
099C:  MOVLW  6B
099D:  MOVWF  29
099E:  MOVLW  6C
099F:  MOVWF  2A
09A0:  MOVLW  6D
09A1:  MOVWF  2B
09A2:  MOVLW  6E
09A3:  MOVWF  2C
09A4:  MOVLW  6F
09A5:  MOVWF  2D
09A6:  MOVLW  70
09A7:  MOVWF  2E
09A8:  MOVLW  71
09A9:  MOVWF  2F
09AA:  MOVLW  73
09AB:  MOVWF  30
09AC:  MOVLW  74
09AD:  MOVWF  31
09AE:  MOVLW  75
09AF:  MOVWF  32
09B0:  MOVLW  76
09B1:  MOVWF  33
09B2:  MOVLW  77
09B3:  MOVWF  34
09B4:  MOVLW  78
09B5:  MOVWF  35
09B6:  MOVLW  79
09B7:  MOVWF  36
09B8:  MOVLW  7A
09B9:  MOVWF  37
09BA:  CLRF   38
....................    for(sc=s;isspace(*sc);++sc); 
09BB:  BSF    03.5
09BC:  BCF    03.6
09BD:  MOVF   68,W
09BE:  MOVWF  6D
09BF:  MOVF   67,W
09C0:  MOVWF  6C
09C1:  MOVF   6D,W
09C2:  MOVWF  7A
09C3:  MOVF   6C,W
09C4:  MOVWF  04
09C5:  BCF    03.7
09C6:  BTFSC  7A.0
09C7:  BSF    03.7
09C8:  MOVF   00,W
09C9:  SUBLW  20
09CA:  BTFSS  03.2
09CB:  GOTO   1D0
09CC:  INCF   6C,F
09CD:  BTFSC  03.2
09CE:  INCF   6D,F
09CF:  GOTO   1C1
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
09D0:  MOVF   6D,W
09D1:  MOVWF  7A
09D2:  MOVF   6C,W
09D3:  MOVWF  04
09D4:  BCF    03.7
09D5:  BTFSC  6D.0
09D6:  BSF    03.7
09D7:  MOVF   00,W
09D8:  SUBLW  2D
09D9:  BTFSC  03.2
09DA:  GOTO   1E6
09DB:  MOVF   6D,W
09DC:  MOVWF  7A
09DD:  MOVF   6C,W
09DE:  MOVWF  04
09DF:  BCF    03.7
09E0:  BTFSC  6D.0
09E1:  BSF    03.7
09E2:  MOVF   00,W
09E3:  SUBLW  2B
09E4:  BTFSS  03.2
09E5:  GOTO   1F2
09E6:  MOVF   6D,W
09E7:  MOVWF  7A
09E8:  MOVF   6C,W
09E9:  INCF   6C,F
09EA:  BTFSC  03.2
09EB:  INCF   6D,F
09EC:  MOVWF  04
09ED:  BCF    03.7
09EE:  BTFSC  7A.0
09EF:  BSF    03.7
09F0:  MOVF   00,W
09F1:  GOTO   1F3
09F2:  MOVLW  2B
09F3:  BCF    03.5
09F4:  BSF    03.6
09F5:  MOVWF  14
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
09F6:  MOVF   14,W
09F7:  SUBLW  2D
09F8:  BTFSC  03.2
09F9:  GOTO   210
09FA:  BSF    03.5
09FB:  BCF    03.6
09FC:  BTFSS  6B.7
09FD:  GOTO   201
09FE:  BCF    03.5
09FF:  BSF    03.6
0A00:  GOTO   210
0A01:  DECFSZ 6B,W
0A02:  GOTO   208
0A03:  BCF    03.5
0A04:  BSF    03.6
0A05:  GOTO   210
0A06:  BSF    03.5
0A07:  BCF    03.6
0A08:  BTFSC  6B.7
0A09:  GOTO   214
0A0A:  MOVF   6B,W
0A0B:  SUBLW  24
0A0C:  BTFSC  03.0
0A0D:  GOTO   214
0A0E:  BCF    03.5
0A0F:  BSF    03.6
....................    goto StrtoulGO; 
0A10:  GOTO   38A
0A11:  GOTO   2AC
0A12:  BSF    03.5
0A13:  BCF    03.6
....................  
....................    else if (base) 
0A14:  MOVF   6B,F
0A15:  BTFSC  03.2
0A16:  GOTO   26F
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
0A17:  MOVF   6B,W
0A18:  SUBLW  10
0A19:  BTFSS  03.2
0A1A:  GOTO   23E
0A1B:  MOVF   6D,W
0A1C:  MOVWF  7A
0A1D:  MOVF   6C,W
0A1E:  MOVWF  04
0A1F:  BCF    03.7
0A20:  BTFSC  7A.0
0A21:  BSF    03.7
0A22:  MOVF   00,W
0A23:  SUBLW  30
0A24:  BTFSS  03.2
0A25:  GOTO   23E
0A26:  MOVLW  01
0A27:  ADDWF  6C,W
0A28:  MOVWF  04
0A29:  BCF    03.7
0A2A:  BTFSC  6D.0
0A2B:  BSF    03.7
0A2C:  MOVF   00,W
0A2D:  SUBLW  78
0A2E:  BTFSC  03.2
0A2F:  GOTO   23A
0A30:  MOVLW  01
0A31:  ADDWF  6C,W
0A32:  MOVWF  04
0A33:  BCF    03.7
0A34:  BTFSC  6D.0
0A35:  BSF    03.7
0A36:  MOVF   00,W
0A37:  SUBLW  58
0A38:  BTFSS  03.2
0A39:  GOTO   23E
....................          sc+=2; 
0A3A:  MOVLW  02
0A3B:  ADDWF  6C,F
0A3C:  BTFSC  03.0
0A3D:  INCF   6D,F
....................       if(base==8 && *sc =='0') 
0A3E:  MOVF   6B,W
0A3F:  SUBLW  08
0A40:  BTFSS  03.2
0A41:  GOTO   251
0A42:  MOVF   6D,W
0A43:  MOVWF  7A
0A44:  MOVF   6C,W
0A45:  MOVWF  04
0A46:  BCF    03.7
0A47:  BTFSC  7A.0
0A48:  BSF    03.7
0A49:  MOVF   00,W
0A4A:  SUBLW  30
0A4B:  BTFSS  03.2
0A4C:  GOTO   251
....................          sc+=1; 
0A4D:  MOVLW  01
0A4E:  ADDWF  6C,F
0A4F:  BTFSC  03.0
0A50:  INCF   6D,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
0A51:  MOVF   6B,W
0A52:  SUBLW  02
0A53:  BTFSS  03.2
0A54:  GOTO   26E
0A55:  MOVF   6D,W
0A56:  MOVWF  7A
0A57:  MOVF   6C,W
0A58:  MOVWF  04
0A59:  BCF    03.7
0A5A:  BTFSC  7A.0
0A5B:  BSF    03.7
0A5C:  MOVF   00,W
0A5D:  SUBLW  30
0A5E:  BTFSS  03.2
0A5F:  GOTO   26E
0A60:  MOVLW  01
0A61:  ADDWF  6C,W
0A62:  MOVWF  04
0A63:  BCF    03.7
0A64:  BTFSC  6D.0
0A65:  BSF    03.7
0A66:  MOVF   00,W
0A67:  SUBLW  62
0A68:  BTFSS  03.2
0A69:  GOTO   26E
....................          sc+=2; 
0A6A:  MOVLW  02
0A6B:  ADDWF  6C,F
0A6C:  BTFSC  03.0
0A6D:  INCF   6D,F
....................  
....................    } 
0A6E:  GOTO   2AA
....................    else if(*sc!='0') // base is 0, find base 
0A6F:  MOVF   6D,W
0A70:  MOVWF  7A
0A71:  MOVF   6C,W
0A72:  MOVWF  04
0A73:  BCF    03.7
0A74:  BTFSC  7A.0
0A75:  BSF    03.7
0A76:  MOVF   00,W
0A77:  SUBLW  30
0A78:  BTFSC  03.2
0A79:  GOTO   27D
....................       base=10; 
0A7A:  MOVLW  0A
0A7B:  MOVWF  6B
0A7C:  GOTO   2AA
....................    else if (sc[1]=='x' || sc[1]=='X') 
0A7D:  MOVLW  01
0A7E:  ADDWF  6C,W
0A7F:  MOVWF  04
0A80:  BCF    03.7
0A81:  BTFSC  6D.0
0A82:  BSF    03.7
0A83:  MOVF   00,W
0A84:  SUBLW  78
0A85:  BTFSC  03.2
0A86:  GOTO   291
0A87:  MOVLW  01
0A88:  ADDWF  6C,W
0A89:  MOVWF  04
0A8A:  BCF    03.7
0A8B:  BTFSC  6D.0
0A8C:  BSF    03.7
0A8D:  MOVF   00,W
0A8E:  SUBLW  58
0A8F:  BTFSS  03.2
0A90:  GOTO   298
....................       base =16,sc+=2; 
0A91:  MOVLW  10
0A92:  MOVWF  6B
0A93:  MOVLW  02
0A94:  ADDWF  6C,F
0A95:  BTFSC  03.0
0A96:  INCF   6D,F
0A97:  GOTO   2AA
....................    else if(sc[1]=='b') 
0A98:  MOVLW  01
0A99:  ADDWF  6C,W
0A9A:  MOVWF  04
0A9B:  BCF    03.7
0A9C:  BTFSC  6D.0
0A9D:  BSF    03.7
0A9E:  MOVF   00,W
0A9F:  SUBLW  62
0AA0:  BTFSS  03.2
0AA1:  GOTO   2A8
....................       base=2,sc+=2; 
0AA2:  MOVLW  02
0AA3:  MOVWF  6B
0AA4:  ADDWF  6C,F
0AA5:  BTFSC  03.0
0AA6:  INCF   6D,F
0AA7:  GOTO   2AA
....................    else 
....................       base=8; 
0AA8:  MOVLW  08
0AA9:  MOVWF  6B
0AAA:  BCF    03.5
0AAB:  BSF    03.6
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
0AAC:  BSF    03.5
0AAD:  BCF    03.6
0AAE:  MOVF   6D,W
0AAF:  MOVWF  6F
0AB0:  MOVF   6C,W
0AB1:  MOVWF  6E
0AB2:  MOVF   6D,W
0AB3:  MOVWF  7A
0AB4:  MOVF   6C,W
0AB5:  MOVWF  04
0AB6:  BCF    03.7
0AB7:  BTFSC  7A.0
0AB8:  BSF    03.7
0AB9:  MOVF   00,W
0ABA:  SUBLW  30
0ABB:  BTFSS  03.2
0ABC:  GOTO   2C1
0ABD:  INCF   6C,F
0ABE:  BTFSC  03.2
0ABF:  INCF   6D,F
0AC0:  GOTO   2B2
....................    sd=memchr(digits,tolower(*sc),base); 
0AC1:  MOVF   6D,W
0AC2:  MOVWF  7A
0AC3:  MOVF   6C,W
0AC4:  MOVWF  04
0AC5:  BCF    03.7
0AC6:  BTFSC  6D.0
0AC7:  BSF    03.7
0AC8:  MOVF   00,W
0AC9:  BCF    03.5
0ACA:  BSF    03.6
0ACB:  MOVWF  39
0ACC:  SUBLW  40
0ACD:  BTFSC  03.0
0ACE:  GOTO   2D6
0ACF:  MOVF   39,W
0AD0:  SUBLW  5A
0AD1:  BTFSS  03.0
0AD2:  GOTO   2D6
0AD3:  MOVF   39,W
0AD4:  IORLW  20
0AD5:  GOTO   2D7
0AD6:  MOVF   39,W
0AD7:  MOVWF  39
0AD8:  MOVLW  01
0AD9:  MOVWF  3B
0ADA:  MOVLW  15
0ADB:  MOVWF  3A
0ADC:  MOVF   39,W
0ADD:  MOVWF  3C
0ADE:  CLRF   3E
0ADF:  BSF    03.5
0AE0:  BCF    03.6
0AE1:  MOVF   6B,W
0AE2:  BCF    03.5
0AE3:  BSF    03.6
0AE4:  MOVWF  3D
0AE5:  BCF    0A.3
0AE6:  BCF    03.6
0AE7:  CALL   770
0AE8:  BSF    0A.3
0AE9:  MOVF   79,W
0AEA:  BSF    03.6
0AEB:  MOVWF  11
0AEC:  MOVF   78,W
0AED:  MOVWF  10
....................    for(; sd!=0; ) 
0AEE:  MOVF   10,F
0AEF:  BTFSS  03.2
0AF0:  GOTO   2F4
0AF1:  MOVF   11,F
0AF2:  BTFSC  03.2
0AF3:  GOTO   37E
....................    { 
....................       x=x*base+(int16)(sd-digits); 
0AF4:  CLRF   7A
0AF5:  BSF    03.5
0AF6:  BCF    03.6
0AF7:  MOVF   6B,W
0AF8:  MOVWF  77
0AF9:  BTFSC  77.7
0AFA:  DECF   7A,F
0AFB:  BCF    03.5
0AFC:  BSF    03.6
0AFD:  MOVWF  39
0AFE:  MOVF   7A,W
0AFF:  MOVWF  3A
0B00:  MOVF   13,W
0B01:  MOVWF  3C
0B02:  MOVF   12,W
0B03:  MOVWF  3B
0B04:  MOVF   3A,W
0B05:  MOVWF  3E
0B06:  MOVF   39,W
0B07:  MOVWF  3D
*
0B35:  MOVF   79,W
0B36:  MOVWF  3A
0B37:  MOVF   78,W
0B38:  MOVWF  39
0B39:  MOVLW  15
0B3A:  SUBWF  10,W
0B3B:  MOVWF  77
0B3C:  MOVF   11,W
0B3D:  MOVWF  7A
0B3E:  MOVLW  01
0B3F:  BTFSS  03.0
0B40:  MOVLW  02
0B41:  SUBWF  7A,F
0B42:  MOVF   77,W
0B43:  ADDWF  39,W
0B44:  MOVWF  12
0B45:  MOVF   3A,W
0B46:  MOVWF  13
0B47:  MOVF   7A,W
0B48:  BTFSC  03.0
0B49:  INCFSZ 7A,W
0B4A:  ADDWF  13,F
....................       ++sc; 
0B4B:  BSF    03.5
0B4C:  BCF    03.6
0B4D:  INCF   6C,F
0B4E:  BTFSC  03.2
0B4F:  INCF   6D,F
....................       sd=memchr(digits,tolower(*sc),base); 
0B50:  MOVF   6D,W
0B51:  MOVWF  7A
0B52:  MOVF   6C,W
0B53:  MOVWF  04
0B54:  BCF    03.7
0B55:  BTFSC  6D.0
0B56:  BSF    03.7
0B57:  MOVF   00,W
0B58:  BCF    03.5
0B59:  BSF    03.6
0B5A:  MOVWF  39
0B5B:  SUBLW  40
0B5C:  BTFSC  03.0
0B5D:  GOTO   365
0B5E:  MOVF   39,W
0B5F:  SUBLW  5A
0B60:  BTFSS  03.0
0B61:  GOTO   365
0B62:  MOVF   39,W
0B63:  IORLW  20
0B64:  GOTO   366
0B65:  MOVF   39,W
0B66:  MOVWF  39
0B67:  MOVLW  01
0B68:  MOVWF  3B
0B69:  MOVLW  15
0B6A:  MOVWF  3A
0B6B:  MOVF   39,W
0B6C:  MOVWF  3C
0B6D:  CLRF   3E
0B6E:  BSF    03.5
0B6F:  BCF    03.6
0B70:  MOVF   6B,W
0B71:  BCF    03.5
0B72:  BSF    03.6
0B73:  MOVWF  3D
0B74:  BCF    0A.3
0B75:  BCF    03.6
0B76:  CALL   770
0B77:  BSF    0A.3
0B78:  MOVF   79,W
0B79:  BSF    03.6
0B7A:  MOVWF  11
0B7B:  MOVF   78,W
0B7C:  MOVWF  10
0B7D:  GOTO   2EE
....................    } 
....................    if(s1==sc) 
0B7E:  BSF    03.5
0B7F:  BCF    03.6
0B80:  MOVF   6C,W
0B81:  SUBWF  6E,W
0B82:  BTFSS  03.2
0B83:  GOTO   39F
0B84:  MOVF   6D,W
0B85:  SUBWF  6F,W
0B86:  BTFSS  03.2
0B87:  GOTO   39F
0B88:  BCF    03.5
0B89:  BSF    03.6
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
0B8A:  BSF    03.5
0B8B:  BCF    03.6
0B8C:  MOVF   69,W
0B8D:  IORWF  6A,W
0B8E:  BTFSC  03.2
0B8F:  GOTO   39B
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
0B90:  MOVF   69,W
0B91:  MOVWF  04
0B92:  BCF    03.7
0B93:  BTFSC  6A.0
0B94:  BSF    03.7
0B95:  INCF   04,F
0B96:  MOVF   68,W
0B97:  MOVWF  00
0B98:  DECF   04,F
0B99:  MOVF   67,W
0B9A:  MOVWF  00
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
0B9B:  MOVLW  00
0B9C:  MOVWF  78
0B9D:  MOVWF  79
0B9E:  GOTO   3B6
....................    } 
....................    if (endptr) 
0B9F:  MOVF   69,W
0BA0:  IORWF  6A,W
0BA1:  BTFSC  03.2
0BA2:  GOTO   3AE
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
0BA3:  MOVF   69,W
0BA4:  MOVWF  04
0BA5:  BCF    03.7
0BA6:  BTFSC  6A.0
0BA7:  BSF    03.7
0BA8:  INCF   04,F
0BA9:  MOVF   6D,W
0BAA:  MOVWF  00
0BAB:  DECF   04,F
0BAC:  MOVF   6C,W
0BAD:  MOVWF  00
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
0BAE:  BCF    03.5
0BAF:  BSF    03.6
0BB0:  MOVF   12,W
0BB1:  MOVWF  78
0BB2:  MOVF   13,W
0BB3:  MOVWF  79
0BB4:  BSF    03.5
0BB5:  BCF    03.6
0BB6:  BCF    03.5
0BB7:  RETURN
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... void saveUser(int * id, int * pass, int status){ 
....................    if( id[0] <= 99 && id[1] <= 99 && getAddressByID(id) == -1 ){ 
*
0629:  BSF    03.5
062A:  MOVF   49,W
062B:  MOVWF  04
062C:  BCF    03.7
062D:  BTFSC  4A.0
062E:  BSF    03.7
062F:  MOVF   00,W
0630:  SUBLW  63
0631:  BTFSS  03.0
0632:  GOTO   6DB
0633:  MOVLW  01
0634:  ADDWF  49,W
0635:  MOVWF  04
0636:  BCF    03.7
0637:  BTFSC  4A.0
0638:  BSF    03.7
0639:  MOVF   00,W
063A:  SUBLW  63
063B:  BTFSS  03.0
063C:  GOTO   6DB
063D:  MOVF   4A,W
063E:  MOVWF  57
063F:  MOVF   49,W
0640:  MOVWF  56
0641:  BCF    03.5
0642:  CALL   5EF
0643:  MOVF   78,W
0644:  SUBLW  FF
0645:  BTFSC  03.2
0646:  GOTO   649
0647:  BSF    03.5
0648:  GOTO   6DB
....................       int address = lastNewUserPosition(); 
....................  
....................       //recebe os parâmetros do usuário 
....................       User user; 
*
065B:  MOVF   78,W
065C:  MOVWF  4E
....................       user.id[0] = id[0]; 
065D:  MOVF   49,W
065E:  MOVWF  04
065F:  BCF    03.7
0660:  BTFSC  4A.0
0661:  BSF    03.7
0662:  MOVF   00,W
0663:  MOVWF  4F
....................       user.id[1] = id[1]; 
0664:  MOVLW  01
0665:  ADDWF  49,W
0666:  MOVWF  04
0667:  BCF    03.7
0668:  BTFSC  4A.0
0669:  BSF    03.7
066A:  MOVF   00,W
066B:  MOVWF  50
....................       user.pass[0] = pass[0]; 
066C:  MOVF   4B,W
066D:  MOVWF  04
066E:  BCF    03.7
066F:  BTFSC  4C.0
0670:  BSF    03.7
0671:  MOVF   00,W
0672:  MOVWF  51
....................       user.pass[1] = pass[1]; 
0673:  MOVLW  01
0674:  ADDWF  4B,W
0675:  MOVWF  04
0676:  BCF    03.7
0677:  BTFSC  4C.0
0678:  BSF    03.7
0679:  MOVF   00,W
067A:  MOVWF  52
....................       user.pass[2] = pass[2]; 
067B:  MOVLW  02
067C:  ADDWF  4B,W
067D:  MOVWF  04
067E:  BCF    03.7
067F:  BTFSC  4C.0
0680:  BSF    03.7
0681:  MOVF   00,W
0682:  MOVWF  53
....................       user.pass[3] = pass[3]; 
0683:  MOVLW  03
0684:  ADDWF  4B,W
0685:  MOVWF  04
0686:  BCF    03.7
0687:  BTFSC  4C.0
0688:  BSF    03.7
0689:  MOVF   00,W
068A:  MOVWF  54
....................       user.status = status; 
068B:  MOVF   4D,W
068C:  MOVWF  55
....................        
....................       write_ext_eeprom(address, user.id[0]); 
068D:  MOVF   4E,W
068E:  MOVWF  60
068F:  MOVF   4F,W
0690:  MOVWF  61
0691:  BCF    03.5
0692:  CALL   4B2
....................       write_ext_eeprom(address+1, user.id[1]); 
0693:  MOVLW  01
0694:  BSF    03.5
0695:  ADDWF  4E,W
0696:  MOVWF  56
0697:  MOVWF  60
0698:  MOVF   50,W
0699:  MOVWF  61
069A:  BCF    03.5
069B:  CALL   4B2
....................       write_ext_eeprom(address+2, user.pass[0]); 
069C:  MOVLW  02
069D:  BSF    03.5
069E:  ADDWF  4E,W
069F:  MOVWF  56
06A0:  MOVWF  60
06A1:  MOVF   51,W
06A2:  MOVWF  61
06A3:  BCF    03.5
06A4:  CALL   4B2
....................       write_ext_eeprom(address+3, user.pass[1]); 
06A5:  MOVLW  03
06A6:  BSF    03.5
06A7:  ADDWF  4E,W
06A8:  MOVWF  56
06A9:  MOVWF  60
06AA:  MOVF   52,W
06AB:  MOVWF  61
06AC:  BCF    03.5
06AD:  CALL   4B2
....................       write_ext_eeprom(address+4, user.pass[2]); 
06AE:  MOVLW  04
06AF:  BSF    03.5
06B0:  ADDWF  4E,W
06B1:  MOVWF  56
06B2:  MOVWF  60
06B3:  MOVF   53,W
06B4:  MOVWF  61
06B5:  BCF    03.5
06B6:  CALL   4B2
....................       write_ext_eeprom(address+5, user.pass[3]);        
06B7:  MOVLW  05
06B8:  BSF    03.5
06B9:  ADDWF  4E,W
06BA:  MOVWF  56
06BB:  MOVWF  60
06BC:  MOVF   54,W
06BD:  MOVWF  61
06BE:  BCF    03.5
06BF:  CALL   4B2
....................       write_ext_eeprom(address+6, user.status); 
06C0:  MOVLW  06
06C1:  BSF    03.5
06C2:  ADDWF  4E,W
06C3:  MOVWF  56
06C4:  MOVWF  60
06C5:  MOVF   55,W
06C6:  MOVWF  61
06C7:  BCF    03.5
06C8:  CALL   4B2
....................  
....................       printf (lcd_escreve,"\fUsuario Cadastrado"); 
06C9:  MOVLW  6F
06CA:  BSF    03.6
06CB:  MOVWF  0D
06CC:  MOVLW  00
06CD:  MOVWF  0F
06CE:  BCF    03.6
06CF:  CALL   396
....................       delay_ms(500); 
06D0:  MOVLW  02
06D1:  BSF    03.5
06D2:  MOVWF  56
06D3:  MOVLW  FA
06D4:  MOVWF  65
06D5:  BCF    03.5
06D6:  CALL   29E
06D7:  BSF    03.5
06D8:  DECFSZ 56,F
06D9:  GOTO   6D3
....................  
....................    }else{ 
06DA:  GOTO   6F4
....................       printf (lcd_escreve,"\fID incompativel"); 
06DB:  MOVLW  79
06DC:  BCF    03.5
06DD:  BSF    03.6
06DE:  MOVWF  0D
06DF:  MOVLW  00
06E0:  MOVWF  0F
06E1:  BCF    03.6
06E2:  CALL   396
....................       printf (lcd_escreve,"\r\nTente novamente"); 
06E3:  MOVLW  82
06E4:  BSF    03.6
06E5:  MOVWF  0D
06E6:  MOVLW  00
06E7:  MOVWF  0F
06E8:  BCF    03.6
06E9:  CALL   396
....................       delay_ms(1000); 
06EA:  MOVLW  04
06EB:  BSF    03.5
06EC:  MOVWF  56
06ED:  MOVLW  FA
06EE:  MOVWF  65
06EF:  BCF    03.5
06F0:  CALL   29E
06F1:  BSF    03.5
06F2:  DECFSZ 56,F
06F3:  GOTO   6ED
....................  
....................    } 
06F4:  BCF    03.5
06F5:  RETURN
.................... } 
....................  
.................... void updateUser(int * id, int * pass, int status, int address){ 
....................    if( id[0] <= 99 && id[1] <= 99){ 
*
147B:  MOVF   52,W
147C:  MOVWF  04
147D:  BCF    03.7
147E:  BTFSC  53.0
147F:  BSF    03.7
1480:  MOVF   00,W
1481:  SUBLW  63
1482:  BTFSS  03.0
1483:  GOTO   51E
1484:  MOVLW  01
1485:  ADDWF  52,W
1486:  MOVWF  04
1487:  BCF    03.7
1488:  BTFSC  53.0
1489:  BSF    03.7
148A:  MOVF   00,W
148B:  SUBLW  63
148C:  BTFSS  03.0
148D:  GOTO   51E
....................       //recebe os parâmetros do usuário 
....................       User user; 
....................       user.id[0] = id[0]; 
148E:  MOVF   52,W
148F:  MOVWF  04
1490:  BCF    03.7
1491:  BTFSC  53.0
1492:  BSF    03.7
1493:  MOVF   00,W
1494:  MOVWF  58
....................       user.id[1] = id[1]; 
1495:  MOVLW  01
1496:  ADDWF  52,W
1497:  MOVWF  04
1498:  BCF    03.7
1499:  BTFSC  53.0
149A:  BSF    03.7
149B:  MOVF   00,W
149C:  MOVWF  59
....................       user.pass[0] = pass[0]; 
149D:  MOVF   54,W
149E:  MOVWF  04
149F:  BCF    03.7
14A0:  BTFSC  55.0
14A1:  BSF    03.7
14A2:  MOVF   00,W
14A3:  MOVWF  5A
....................       user.pass[1] = pass[1]; 
14A4:  MOVLW  01
14A5:  ADDWF  54,W
14A6:  MOVWF  04
14A7:  BCF    03.7
14A8:  BTFSC  55.0
14A9:  BSF    03.7
14AA:  MOVF   00,W
14AB:  MOVWF  5B
....................       user.pass[2] = pass[2]; 
14AC:  MOVLW  02
14AD:  ADDWF  54,W
14AE:  MOVWF  04
14AF:  BCF    03.7
14B0:  BTFSC  55.0
14B1:  BSF    03.7
14B2:  MOVF   00,W
14B3:  MOVWF  5C
....................       user.pass[3] = pass[3]; 
14B4:  MOVLW  03
14B5:  ADDWF  54,W
14B6:  MOVWF  04
14B7:  BCF    03.7
14B8:  BTFSC  55.0
14B9:  BSF    03.7
14BA:  MOVF   00,W
14BB:  MOVWF  5D
....................       user.status = status; 
14BC:  MOVF   56,W
14BD:  MOVWF  5E
....................        
....................       write_ext_eeprom(address, user.id[0]); 
14BE:  MOVF   57,W
14BF:  MOVWF  60
14C0:  MOVF   58,W
14C1:  MOVWF  61
14C2:  BCF    0A.4
14C3:  BCF    03.5
14C4:  CALL   4B2
14C5:  BSF    0A.4
....................       write_ext_eeprom(address+1, user.id[1]); 
14C6:  MOVLW  01
14C7:  BSF    03.5
14C8:  ADDWF  57,W
14C9:  MOVWF  5F
14CA:  MOVWF  60
14CB:  MOVF   59,W
14CC:  MOVWF  61
14CD:  BCF    0A.4
14CE:  BCF    03.5
14CF:  CALL   4B2
14D0:  BSF    0A.4
....................       write_ext_eeprom(address+2, user.pass[0]); 
14D1:  MOVLW  02
14D2:  BSF    03.5
14D3:  ADDWF  57,W
14D4:  MOVWF  5F
14D5:  MOVWF  60
14D6:  MOVF   5A,W
14D7:  MOVWF  61
14D8:  BCF    0A.4
14D9:  BCF    03.5
14DA:  CALL   4B2
14DB:  BSF    0A.4
....................       write_ext_eeprom(address+3, user.pass[1]); 
14DC:  MOVLW  03
14DD:  BSF    03.5
14DE:  ADDWF  57,W
14DF:  MOVWF  5F
14E0:  MOVWF  60
14E1:  MOVF   5B,W
14E2:  MOVWF  61
14E3:  BCF    0A.4
14E4:  BCF    03.5
14E5:  CALL   4B2
14E6:  BSF    0A.4
....................       write_ext_eeprom(address+4, user.pass[2]); 
14E7:  MOVLW  04
14E8:  BSF    03.5
14E9:  ADDWF  57,W
14EA:  MOVWF  5F
14EB:  MOVWF  60
14EC:  MOVF   5C,W
14ED:  MOVWF  61
14EE:  BCF    0A.4
14EF:  BCF    03.5
14F0:  CALL   4B2
14F1:  BSF    0A.4
....................       write_ext_eeprom(address+5, user.pass[3]);        
14F2:  MOVLW  05
14F3:  BSF    03.5
14F4:  ADDWF  57,W
14F5:  MOVWF  5F
14F6:  MOVWF  60
14F7:  MOVF   5D,W
14F8:  MOVWF  61
14F9:  BCF    0A.4
14FA:  BCF    03.5
14FB:  CALL   4B2
14FC:  BSF    0A.4
....................       write_ext_eeprom(address+6, user.status); 
14FD:  MOVLW  06
14FE:  BSF    03.5
14FF:  ADDWF  57,W
1500:  MOVWF  5F
1501:  MOVWF  60
1502:  MOVF   5E,W
1503:  MOVWF  61
1504:  BCF    0A.4
1505:  BCF    03.5
1506:  CALL   4B2
1507:  BSF    0A.4
....................  
....................       printf (lcd_escreve,"\fUsuario Atualizado"); 
1508:  MOVLW  8B
1509:  BSF    03.6
150A:  MOVWF  0D
150B:  MOVLW  00
150C:  MOVWF  0F
150D:  BCF    0A.4
150E:  BCF    03.6
150F:  CALL   396
1510:  BSF    0A.4
....................       delay_ms(500); 
1511:  MOVLW  02
1512:  BSF    03.5
1513:  MOVWF  5F
1514:  MOVLW  FA
1515:  MOVWF  65
1516:  BCF    0A.4
1517:  BCF    03.5
1518:  CALL   29E
1519:  BSF    0A.4
151A:  BSF    03.5
151B:  DECFSZ 5F,F
151C:  GOTO   514
....................  
....................    }else{ 
151D:  GOTO   53D
....................       printf (lcd_escreve,"\fID incompativel"); 
151E:  MOVLW  95
151F:  BCF    03.5
1520:  BSF    03.6
1521:  MOVWF  0D
1522:  MOVLW  00
1523:  MOVWF  0F
1524:  BCF    0A.4
1525:  BCF    03.6
1526:  CALL   396
1527:  BSF    0A.4
....................       printf (lcd_escreve,"\r\nTente novamente"); 
1528:  MOVLW  9E
1529:  BSF    03.6
152A:  MOVWF  0D
152B:  MOVLW  00
152C:  MOVWF  0F
152D:  BCF    0A.4
152E:  BCF    03.6
152F:  CALL   396
1530:  BSF    0A.4
....................       delay_ms(1000); 
1531:  MOVLW  04
1532:  BSF    03.5
1533:  MOVWF  5F
1534:  MOVLW  FA
1535:  MOVWF  65
1536:  BCF    0A.4
1537:  BCF    03.5
1538:  CALL   29E
1539:  BSF    0A.4
153A:  BSF    03.5
153B:  DECFSZ 5F,F
153C:  GOTO   534
....................    } 
....................  
.................... } 
....................  
.................... void printUser(User user){ 
....................    // printf (lcd_escreve,"\fCliente ID: %u%u",user.id[0],user.id[1]); 
....................    // printf(lcd_escreve, "\r\nPw:%u%u%u%u St:%u",user.pass[0],user.pass[1],user.pass[2],user.pass[3],user.status); 
....................    // printf (lcd_escreve,"\fCliente ID: %u%u",user.id[0],user.id[1]); 
....................    printf(lcd_escreve, "\r\nPw:%u%u%u%u St:%u",user.pass[0],user.pass[1],user.pass[2],user.pass[3],user.status); 
*
163B:  MOVLW  A7
163C:  BCF    03.5
163D:  BSF    03.6
163E:  MOVWF  0D
163F:  MOVLW  00
1640:  MOVWF  0F
1641:  BCF    03.0
1642:  MOVLW  05
1643:  BSF    03.5
1644:  BCF    03.6
1645:  MOVWF  5F
1646:  BCF    0A.4
1647:  BCF    03.5
1648:  CALL   6F6
1649:  BSF    0A.4
164A:  BSF    03.5
164B:  MOVF   29,W
164C:  MOVWF  4D
164D:  MOVLW  1B
164E:  MOVWF  4E
164F:  BCF    0A.4
1650:  BSF    0A.3
1651:  BCF    03.5
1652:  CALL   614
1653:  BSF    0A.4
1654:  BCF    0A.3
1655:  BSF    03.5
1656:  MOVF   2A,W
1657:  MOVWF  4D
1658:  MOVLW  1B
1659:  MOVWF  4E
165A:  BCF    0A.4
165B:  BSF    0A.3
165C:  BCF    03.5
165D:  CALL   614
165E:  BSF    0A.4
165F:  BCF    0A.3
1660:  BSF    03.5
1661:  MOVF   2B,W
1662:  MOVWF  4D
1663:  MOVLW  1B
1664:  MOVWF  4E
1665:  BCF    0A.4
1666:  BSF    0A.3
1667:  BCF    03.5
1668:  CALL   614
1669:  BSF    0A.4
166A:  BCF    0A.3
166B:  BSF    03.5
166C:  MOVF   2C,W
166D:  MOVWF  4D
166E:  MOVLW  1B
166F:  MOVWF  4E
1670:  BCF    0A.4
1671:  BSF    0A.3
1672:  BCF    03.5
1673:  CALL   614
1674:  BSF    0A.4
1675:  BCF    0A.3
1676:  MOVLW  AD
1677:  BSF    03.6
1678:  MOVWF  0D
1679:  MOVLW  00
167A:  MOVWF  0F
167B:  BSF    03.0
167C:  MOVLW  04
167D:  BSF    03.5
167E:  BCF    03.6
167F:  MOVWF  5F
1680:  BCF    0A.4
1681:  BCF    03.5
1682:  CALL   6F6
1683:  BSF    0A.4
1684:  BSF    03.5
1685:  MOVF   2D,W
1686:  MOVWF  4D
1687:  MOVLW  1B
1688:  MOVWF  4E
1689:  BCF    0A.4
168A:  BSF    0A.3
168B:  BCF    03.5
168C:  CALL   614
168D:  BSF    0A.4
168E:  BCF    0A.3
....................    delay_ms(1000); 
168F:  MOVLW  04
1690:  BSF    03.5
1691:  MOVWF  2E
1692:  MOVLW  FA
1693:  MOVWF  65
1694:  BCF    0A.4
1695:  BCF    03.5
1696:  CALL   29E
1697:  BSF    0A.4
1698:  BSF    03.5
1699:  DECFSZ 2E,F
169A:  GOTO   692
.................... } 
....................  
.................... User receiveUser(){ 
....................     
....................    int * rx_buffer_int; 
....................    char string[RX_BUFFER_SIZE]; 
....................    int numbers[RX_BUFFER_SIZE]; 
....................    strcpy(string, rx_buffer); 
*
1593:  BSF    03.5
1594:  CLRF   61
1595:  MOVLW  32
1596:  MOVWF  60
1597:  CLRF   5F
1598:  MOVLW  AF
1599:  MOVWF  5E
159A:  MOVF   60,W
159B:  MOVWF  04
159C:  BCF    03.7
159D:  BTFSC  61.0
159E:  BSF    03.7
159F:  MOVF   00,W
15A0:  MOVWF  62
15A1:  MOVF   5E,W
15A2:  MOVWF  04
15A3:  BCF    03.7
15A4:  BTFSC  5F.0
15A5:  BSF    03.7
15A6:  MOVF   62,W
15A7:  MOVWF  00
15A8:  MOVF   00,F
15A9:  BTFSC  03.2
15AA:  GOTO   5AE
15AB:  INCF   5E,F
15AC:  INCF   60,F
15AD:  GOTO   59A
....................    rx_buffer_int = strToInt(string); 
15AE:  CLRF   60
15AF:  MOVLW  AF
15B0:  MOVWF  5F
15B1:  BCF    0A.4
15B2:  BCF    03.5
15B3:  CALL   79B
15B4:  BSF    0A.4
15B5:  MOVF   79,W
15B6:  BSF    03.5
15B7:  MOVWF  2E
15B8:  MOVF   78,W
15B9:  MOVWF  2D
....................    // for(int i=0;i < RX_BUFFER_SIZE; i++){ 
....................    //    numbers[i] = rx_buffer_int[i]; 
....................    //    write_ext_eeprom(i, numbers[i]); 
....................    // } 
....................    printf (lcd_escreve,"\f%s",string); 
15BA:  MOVLW  0C
15BB:  MOVWF  64
15BC:  BCF    0A.4
15BD:  BCF    03.5
15BE:  CALL   353
15BF:  BSF    0A.4
15C0:  MOVLW  AF
15C1:  MOVWF  04
15C2:  BCF    03.7
15C3:  BCF    0A.4
15C4:  CALL   7DB
15C5:  BSF    0A.4
....................    delay_ms(500); 
15C6:  MOVLW  02
15C7:  BSF    03.5
15C8:  MOVWF  5E
15C9:  MOVLW  FA
15CA:  MOVWF  65
15CB:  BCF    0A.4
15CC:  BCF    03.5
15CD:  CALL   29E
15CE:  BSF    0A.4
15CF:  BSF    03.5
15D0:  DECFSZ 5E,F
15D1:  GOTO   5C9
....................    // printf(lcd_escreve, "\r\nPw:%d%d%d St:%d",user.pass[0],user.pass[1],user.pass[2],user.pass[3],user.status); 
....................    // delay_ms(1000); 
....................    // for(int i =0; i < RX_BUFFER_SIZE; i++){ 
....................    //    printf (lcd_escreve,"\rPos:%d Value:%d",i,rx_buffer_int[i]); 
....................    //    printf (lcd_escreve,"Pos:%d Value:%d",i,rx_buffer_int[i]); 
....................    //    delay_ms(500); 
....................    // } 
....................  
....................    User user; 
....................    user.id[0] = rx_buffer_int[0]; 
15D2:  MOVF   2D,W
15D3:  MOVWF  04
15D4:  BCF    03.7
15D5:  BTFSC  2E.0
15D6:  BSF    03.7
15D7:  MOVF   00,W
15D8:  MOVWF  57
....................    user.id[1] = rx_buffer_int[1]; 
15D9:  MOVLW  01
15DA:  ADDWF  2D,W
15DB:  MOVWF  04
15DC:  BCF    03.7
15DD:  BTFSC  2E.0
15DE:  BSF    03.7
15DF:  MOVF   00,W
15E0:  MOVWF  58
....................    user.pass[0] = rx_buffer_int[2]; 
15E1:  MOVLW  02
15E2:  ADDWF  2D,W
15E3:  MOVWF  04
15E4:  BCF    03.7
15E5:  BTFSC  2E.0
15E6:  BSF    03.7
15E7:  MOVF   00,W
15E8:  MOVWF  59
....................    user.pass[1] = rx_buffer_int[3]; 
15E9:  MOVLW  03
15EA:  ADDWF  2D,W
15EB:  MOVWF  04
15EC:  BCF    03.7
15ED:  BTFSC  2E.0
15EE:  BSF    03.7
15EF:  MOVF   00,W
15F0:  MOVWF  5A
....................    user.pass[2] = rx_buffer_int[4]; 
15F1:  MOVLW  04
15F2:  ADDWF  2D,W
15F3:  MOVWF  04
15F4:  BCF    03.7
15F5:  BTFSC  2E.0
15F6:  BSF    03.7
15F7:  MOVF   00,W
15F8:  MOVWF  5B
....................    user.pass[3] = rx_buffer_int[5]; 
15F9:  MOVLW  05
15FA:  ADDWF  2D,W
15FB:  MOVWF  04
15FC:  BCF    03.7
15FD:  BTFSC  2E.0
15FE:  BSF    03.7
15FF:  MOVF   00,W
1600:  MOVWF  5C
....................    user.status = rx_buffer_int[6]; 
1601:  MOVLW  06
1602:  ADDWF  2D,W
1603:  MOVWF  04
1604:  BCF    03.7
1605:  BTFSC  2E.0
1606:  BSF    03.7
1607:  MOVF   00,W
1608:  MOVWF  5D
....................  
....................    return user; 
1609:  MOVLW  D7
160A:  MOVWF  78
160B:  CLRF   79
.................... } 
....................  
.................... int getAddressByID(int * id){ 
*
05EF:  BSF    03.5
05F0:  CLRF   5A
....................    int id_temp[2]; 
....................    int address = 0; 
....................     
....................    while( read_ext_eeprom(address) != -1){ 
05F1:  MOVF   5A,W
05F2:  MOVWF  5C
05F3:  BCF    03.5
05F4:  CALL   51F
05F5:  MOVF   78,W
05F6:  SUBLW  FF
05F7:  BTFSC  03.2
05F8:  GOTO   624
....................       id_temp[0] = read_ext_eeprom(address); 
05F9:  BSF    03.5
05FA:  MOVF   5A,W
05FB:  MOVWF  5C
05FC:  BCF    03.5
05FD:  CALL   51F
05FE:  MOVF   78,W
05FF:  BSF    03.5
0600:  MOVWF  58
....................       id_temp[1] = read_ext_eeprom(address+1); 
0601:  MOVLW  01
0602:  ADDWF  5A,W
0603:  MOVWF  5B
0604:  MOVWF  5C
0605:  BCF    03.5
0606:  CALL   51F
0607:  MOVF   78,W
0608:  BSF    03.5
0609:  MOVWF  59
....................        
....................       if (id_temp[0] == id[0] && id_temp[1] == id[1]){ 
060A:  MOVF   56,W
060B:  MOVWF  04
060C:  BCF    03.7
060D:  BTFSC  57.0
060E:  BSF    03.7
060F:  MOVF   00,W
0610:  SUBWF  58,W
0611:  BTFSS  03.2
0612:  GOTO   620
0613:  MOVLW  01
0614:  ADDWF  56,W
0615:  MOVWF  04
0616:  BCF    03.7
0617:  BTFSC  57.0
0618:  BSF    03.7
0619:  MOVF   00,W
061A:  SUBWF  59,W
061B:  BTFSS  03.2
061C:  GOTO   620
....................          return address; 
061D:  MOVF   5A,W
061E:  MOVWF  78
061F:  GOTO   627
....................       } 
....................  
....................       address += BLOCK_SIZE;  
0620:  MOVLW  07
0621:  ADDWF  5A,F
0622:  GOTO   5F1
0623:  BCF    03.5
....................    } 
....................    return -1; 
0624:  MOVLW  FF
0625:  MOVWF  78
0626:  BSF    03.5
0627:  BCF    03.5
0628:  RETURN
.................... } 
....................  
.................... void searchUser(int * id){ 
*
11A8:  MOVF   7C,W
11A9:  BSF    03.5
11AA:  MOVWF  57
11AB:  MOVF   7B,W
11AC:  MOVWF  56
11AD:  BCF    0A.4
11AE:  BCF    03.5
11AF:  CALL   5EF
11B0:  BSF    0A.4
11B1:  MOVF   78,W
11B2:  MOVWF  76
....................  
....................    int address = getAddressByID(id); 
....................    if(address != -1){ 
11B3:  MOVF   76,W
11B4:  SUBLW  FF
11B5:  BTFSC  03.2
11B6:  GOTO   1FA
....................       printf (lcd_escreve,"\fID:%u%u",id[0],id[1]); 
11B7:  MOVF   7B,W
11B8:  MOVWF  04
11B9:  BCF    03.7
11BA:  BTFSC  7C.0
11BB:  BSF    03.7
11BC:  MOVF   00,W
11BD:  BSF    03.5
11BE:  MOVWF  20
11BF:  MOVLW  01
11C0:  ADDWF  7B,W
11C1:  MOVWF  04
11C2:  BCF    03.7
11C3:  BTFSC  7C.0
11C4:  BSF    03.7
11C5:  MOVF   00,W
11C6:  MOVWF  21
11C7:  MOVLW  B1
11C8:  BCF    03.5
11C9:  BSF    03.6
11CA:  MOVWF  0D
11CB:  MOVLW  00
11CC:  MOVWF  0F
11CD:  BCF    03.0
11CE:  MOVLW  04
11CF:  BSF    03.5
11D0:  BCF    03.6
11D1:  MOVWF  5F
11D2:  BCF    0A.4
11D3:  BCF    03.5
11D4:  CALL   6F6
11D5:  BSF    0A.4
11D6:  BSF    03.5
11D7:  MOVF   20,W
11D8:  MOVWF  4D
11D9:  MOVLW  1B
11DA:  MOVWF  4E
11DB:  BCF    0A.4
11DC:  BSF    0A.3
11DD:  BCF    03.5
11DE:  CALL   614
11DF:  BSF    0A.4
11E0:  BCF    0A.3
11E1:  BSF    03.5
11E2:  MOVF   21,W
11E3:  MOVWF  4D
11E4:  MOVLW  1B
11E5:  MOVWF  4E
11E6:  BCF    0A.4
11E7:  BSF    0A.3
11E8:  BCF    03.5
11E9:  CALL   614
11EA:  BSF    0A.4
11EB:  BCF    0A.3
....................       int showStatus = 1; 
11EC:  MOVLW  01
11ED:  MOVWF  7D
....................       getUserStatus(address,showStatus); 
11EE:  MOVF   76,W
11EF:  BSF    03.5
11F0:  MOVWF  35
11F1:  MOVF   7D,W
11F2:  MOVWF  36
11F3:  BCF    0A.4
11F4:  BSF    0A.3
11F5:  BCF    03.5
11F6:  CALL   4A5
11F7:  BSF    0A.4
11F8:  BCF    0A.3
....................    }else{ 
11F9:  GOTO   210
....................       printf(lcd_escreve,"\fUsuario N Existe"); 
11FA:  MOVLW  B6
11FB:  BSF    03.6
11FC:  MOVWF  0D
11FD:  MOVLW  00
11FE:  MOVWF  0F
11FF:  BCF    0A.4
1200:  BCF    03.6
1201:  CALL   396
1202:  BSF    0A.4
....................       delay_ms(1000); 
1203:  MOVLW  04
1204:  BSF    03.5
1205:  MOVWF  20
1206:  MOVLW  FA
1207:  MOVWF  65
1208:  BCF    0A.4
1209:  BCF    03.5
120A:  CALL   29E
120B:  BSF    0A.4
120C:  BSF    03.5
120D:  DECFSZ 20,F
120E:  GOTO   206
120F:  BCF    03.5
....................    } 
.................... } 
....................  
.................... void erase_program_eeprom(int addrr){ 
....................    for(int i=0; i < BLOCK_SIZE; i++){ 
*
0E59:  BSF    03.5
0E5A:  CLRF   24
0E5B:  MOVF   24,W
0E5C:  SUBLW  06
0E5D:  BTFSS  03.0
0E5E:  GOTO   66C
....................          write_ext_eeprom(addrr + i, -1); 
0E5F:  MOVF   24,W
0E60:  ADDWF  23,W
0E61:  MOVWF  25
0E62:  MOVWF  60
0E63:  MOVLW  FF
0E64:  MOVWF  61
0E65:  BCF    0A.3
0E66:  BCF    03.5
0E67:  CALL   4B2
0E68:  BSF    0A.3
0E69:  BSF    03.5
0E6A:  INCF   24,F
0E6B:  GOTO   65B
....................    }   
0E6C:  BCF    03.5
0E6D:  RETURN
.................... } 
....................  
.................... int getUserStatus(int address, int show){ 
*
0CA5:  MOVLW  07
0CA6:  BSF    03.5
0CA7:  ADDWF  35,W
0CA8:  ADDLW  FF
0CA9:  MOVWF  42
0CAA:  MOVWF  5C
0CAB:  BCF    0A.3
0CAC:  BCF    03.5
0CAD:  CALL   51F
0CAE:  BSF    0A.3
0CAF:  MOVF   78,W
0CB0:  BSF    03.5
0CB1:  MOVWF  37
....................    int status = read_ext_eeprom(address+BLOCK_SIZE - 1); 
....................  
....................    if(show == 1){ 
0CB2:  DECFSZ 36,W
0CB3:  GOTO   503
....................       char msg_status[10]; 
....................       if( status == 0){ 
0CB4:  MOVF   37,F
0CB5:  BTFSS  03.2
0CB6:  GOTO   4CE
....................          strcpy(msg_status,"NAO PAGO"); 
0CB7:  CLRF   42
0CB8:  CLRF   43
0CB9:  MOVLW  B8
0CBA:  MOVWF  04
0CBB:  BCF    03.7
0CBC:  MOVF   42,W
0CBD:  ADDWF  04,F
0CBE:  MOVF   43,W
0CBF:  BCF    0A.3
0CC0:  BCF    03.5
0CC1:  CALL   059
0CC2:  BSF    0A.3
0CC3:  MOVWF  00
0CC4:  IORLW  00
0CC5:  BTFSC  03.2
0CC6:  GOTO   4CC
0CC7:  BSF    03.5
0CC8:  INCF   43,F
0CC9:  INCF   42,F
0CCA:  GOTO   4B9
0CCB:  BCF    03.5
....................       }else{ 
0CCC:  GOTO   4E3
0CCD:  BSF    03.5
....................          strcpy(msg_status,"PAGO"); 
0CCE:  CLRF   42
0CCF:  CLRF   43
0CD0:  MOVLW  B8
0CD1:  MOVWF  04
0CD2:  BCF    03.7
0CD3:  MOVF   42,W
0CD4:  ADDWF  04,F
0CD5:  MOVF   43,W
0CD6:  BCF    0A.3
0CD7:  BCF    03.5
0CD8:  CALL   066
0CD9:  BSF    0A.3
0CDA:  MOVWF  00
0CDB:  IORLW  00
0CDC:  BTFSC  03.2
0CDD:  GOTO   4E3
0CDE:  BSF    03.5
0CDF:  INCF   43,F
0CE0:  INCF   42,F
0CE1:  GOTO   4D0
0CE2:  BCF    03.5
....................       } 
....................       printf (lcd_escreve,"\r\nStatus:%s",msg_status); 
0CE3:  MOVLW  BF
0CE4:  BSF    03.6
0CE5:  MOVWF  0D
0CE6:  MOVLW  00
0CE7:  MOVWF  0F
0CE8:  BCF    03.0
0CE9:  MOVLW  09
0CEA:  BSF    03.5
0CEB:  BCF    03.6
0CEC:  MOVWF  5F
0CED:  BCF    0A.3
0CEE:  BCF    03.5
0CEF:  CALL   6F6
0CF0:  BSF    0A.3
0CF1:  MOVLW  B8
0CF2:  MOVWF  04
0CF3:  BCF    03.7
0CF4:  BCF    0A.3
0CF5:  CALL   7DB
0CF6:  BSF    0A.3
....................       delay_ms(1500); 
0CF7:  MOVLW  06
0CF8:  BSF    03.5
0CF9:  MOVWF  42
0CFA:  MOVLW  FA
0CFB:  MOVWF  65
0CFC:  BCF    0A.3
0CFD:  BCF    03.5
0CFE:  CALL   29E
0CFF:  BSF    0A.3
0D00:  BSF    03.5
0D01:  DECFSZ 42,F
0D02:  GOTO   4FA
....................    } 
....................    return status; 
0D03:  MOVF   37,W
0D04:  MOVWF  78
0D05:  BCF    03.5
0D06:  RETURN
.................... } 
....................  
.................... int deleteUser(int * id){ 
*
122C:  MOVF   7C,W
122D:  BSF    03.5
122E:  MOVWF  57
122F:  MOVF   7B,W
1230:  MOVWF  56
1231:  BCF    0A.4
1232:  BCF    03.5
1233:  CALL   5EF
1234:  BSF    0A.4
1235:  MOVF   78,W
1236:  MOVWF  76
....................     
....................    int address = getAddressByID(id); 
....................    if(address == -1) 
1237:  MOVF   76,W
1238:  SUBLW  FF
1239:  BTFSS  03.2
123A:  GOTO   23E
....................       return -1; 
123B:  MOVLW  FF
123C:  MOVWF  78
123D:  GOTO   296
....................    int data_temp; 
....................    int previous_block = address; 
....................    int next_block = address + BLOCK_SIZE; 
123E:  MOVF   76,W
123F:  MOVWF  7E
1240:  MOVLW  07
1241:  ADDWF  76,W
1242:  BSF    03.5
1243:  MOVWF  20
....................  
....................    //Case 1: without the next block 
....................    if (read_ext_eeprom(next_block) == -1){ 
1244:  MOVF   20,W
1245:  MOVWF  5C
1246:  BCF    0A.4
1247:  BCF    03.5
1248:  CALL   51F
1249:  BSF    0A.4
124A:  MOVF   78,W
124B:  SUBLW  FF
124C:  BTFSS  03.2
124D:  GOTO   25A
....................       erase_program_eeprom(previous_block);       
124E:  MOVF   7E,W
124F:  BSF    03.5
1250:  MOVWF  23
1251:  BCF    0A.4
1252:  BSF    0A.3
1253:  BCF    03.5
1254:  CALL   659
1255:  BSF    0A.4
1256:  BCF    0A.3
....................       return 1; 
1257:  MOVLW  01
1258:  MOVWF  78
1259:  GOTO   296
....................    } 
....................  
....................    //Case 2: Check whether the data in the next block address is empty 
....................    while(read_ext_eeprom(next_block) != -1){ 
125A:  BSF    03.5
125B:  MOVF   20,W
125C:  MOVWF  5C
125D:  BCF    0A.4
125E:  BCF    03.5
125F:  CALL   51F
1260:  BSF    0A.4
1261:  MOVF   78,W
1262:  SUBLW  FF
1263:  BTFSC  03.2
1264:  GOTO   289
....................       //data_temp[index] = read_ext_eeprom(address); 
....................       for(int i=0; i < BLOCK_SIZE; i++){ 
1265:  BSF    03.5
1266:  CLRF   21
1267:  MOVF   21,W
1268:  SUBLW  06
1269:  BTFSS  03.0
126A:  GOTO   283
....................          //Read the data from the next block  
....................          data_temp = read_ext_eeprom(next_block + i);            
126B:  MOVF   21,W
126C:  ADDWF  20,W
126D:  MOVWF  22
126E:  MOVWF  5C
126F:  BCF    0A.4
1270:  BCF    03.5
1271:  CALL   51F
1272:  BSF    0A.4
1273:  MOVF   78,W
1274:  MOVWF  7D
....................          //overwrite the previous block with the data from the next 
....................          write_ext_eeprom(previous_block + i, data_temp);   
1275:  BSF    03.5
1276:  MOVF   21,W
1277:  ADDWF  7E,W
1278:  MOVWF  22
1279:  MOVWF  60
127A:  MOVF   7D,W
127B:  MOVWF  61
127C:  BCF    0A.4
127D:  BCF    03.5
127E:  CALL   4B2
127F:  BSF    0A.4
1280:  BSF    03.5
1281:  INCF   21,F
1282:  GOTO   267
....................       }   
....................       previous_block = next_block; 
1283:  MOVF   20,W
1284:  MOVWF  7E
....................       next_block += BLOCK_SIZE; 
1285:  MOVLW  07
1286:  ADDWF  20,F
1287:  GOTO   25B
1288:  BCF    03.5
....................    } 
....................    //Go back to erase the block that's duplicated  
....................    next_block -= BLOCK_SIZE; 
1289:  MOVLW  07
128A:  BSF    03.5
128B:  SUBWF  20,F
....................    //Erase the last block since everything  
....................    //moved a block_size to the left 
....................    erase_program_eeprom(next_block); 
128C:  MOVF   20,W
128D:  MOVWF  23
128E:  BCF    0A.4
128F:  BSF    0A.3
1290:  BCF    03.5
1291:  CALL   659
1292:  BSF    0A.4
1293:  BCF    0A.3
....................     
....................    return 1; 
1294:  MOVLW  01
1295:  MOVWF  78
....................  
.................... } 
....................  
.................... int lastNewUserPosition(){ 
*
0649:  BSF    03.5
064A:  CLRF   56
....................    int address = 0; 
....................    while( read_ext_eeprom(address) != -1){ 
064B:  MOVF   56,W
064C:  MOVWF  5C
064D:  BCF    03.5
064E:  CALL   51F
064F:  MOVF   78,W
0650:  SUBLW  FF
0651:  BTFSC  03.2
0652:  GOTO   658
....................       address += BLOCK_SIZE;  
0653:  MOVLW  07
0654:  BSF    03.5
0655:  ADDWF  56,F
0656:  GOTO   64B
0657:  BCF    03.5
....................    } 
....................    return address; 
0658:  BSF    03.5
0659:  MOVF   56,W
065A:  MOVWF  78
.................... } 
....................  
.................... void resetMemory(){ 
....................  
....................    for(int address=0;address<=254;address++){ 
*
0502:  BSF    03.5
0503:  CLRF   27
0504:  MOVF   27,W
0505:  SUBLW  FE
0506:  BTFSS  03.0
0507:  GOTO   511
....................          write_ext_eeprom(address,-1); 
0508:  MOVF   27,W
0509:  MOVWF  60
050A:  MOVLW  FF
050B:  MOVWF  61
050C:  BCF    03.5
050D:  CALL   4B2
050E:  BSF    03.5
050F:  INCF   27,F
0510:  GOTO   504
....................    }    
....................    printf (lcd_escreve,"\fMemory Cleaned"); 
0511:  MOVLW  C5
0512:  BCF    03.5
0513:  BSF    03.6
0514:  MOVWF  0D
0515:  MOVLW  00
0516:  MOVWF  0F
0517:  BCF    03.6
0518:  CALL   396
....................    delay_ms(200); 
0519:  MOVLW  C8
051A:  BSF    03.5
051B:  MOVWF  65
051C:  BCF    03.5
051D:  CALL   29E
051E:  RETURN
.................... } 
....................  
.................... void adminMenu(){ 
....................    unsigned char option; 
....................    unsigned int * temp; 
....................    unsigned int id [2]; 
....................    do{ 
....................       printf(lcd_escreve,"\f1:CAD|2:BUSCAR"); 
*
1000:  MOVLW  CD
1001:  BSF    03.6
1002:  MOVWF  0D
1003:  MOVLW  00
1004:  MOVWF  0F
1005:  BCF    0A.4
1006:  BCF    03.6
1007:  CALL   396
1008:  BSF    0A.4
....................       printf(lcd_escreve,"\r\n3:DEL|4:EDITAR"); 
1009:  MOVLW  D5
100A:  BSF    03.6
100B:  MOVWF  0D
100C:  MOVLW  00
100D:  MOVWF  0F
100E:  BCF    0A.4
100F:  BCF    03.6
1010:  CALL   396
1011:  BSF    0A.4
....................       delay_ms(1000); 
1012:  MOVLW  04
1013:  MOVWF  76
1014:  MOVLW  FA
1015:  BSF    03.5
1016:  MOVWF  65
1017:  BCF    0A.4
1018:  BCF    03.5
1019:  CALL   29E
101A:  BSF    0A.4
101B:  DECFSZ 76,F
101C:  GOTO   014
....................       printf(lcd_escreve,"\f5:Atualizar Base Dados"); 
101D:  MOVLW  DE
101E:  BSF    03.6
101F:  MOVWF  0D
1020:  MOVLW  00
1021:  MOVWF  0F
1022:  BCF    0A.4
1023:  BCF    03.6
1024:  CALL   396
1025:  BSF    0A.4
....................       printf(lcd_escreve,"\r\n6:Enviar Base Dados"); 
1026:  MOVLW  EA
1027:  BSF    03.6
1028:  MOVWF  0D
1029:  MOVLW  00
102A:  MOVWF  0F
102B:  BCF    0A.4
102C:  BCF    03.6
102D:  CALL   396
102E:  BSF    0A.4
....................       delay_ms(500); 
102F:  MOVLW  02
1030:  MOVWF  76
1031:  MOVLW  FA
1032:  BSF    03.5
1033:  MOVWF  65
1034:  BCF    0A.4
1035:  BCF    03.5
1036:  CALL   29E
1037:  BSF    0A.4
1038:  DECFSZ 76,F
1039:  GOTO   031
....................       printf(lcd_escreve,"\n7: SAIR do Menu "); 
103A:  MOVLW  F5
103B:  BSF    03.6
103C:  MOVWF  0D
103D:  MOVLW  00
103E:  MOVWF  0F
103F:  BCF    0A.4
1040:  BCF    03.6
1041:  CALL   396
1042:  BSF    0A.4
....................       delay_ms(100); 
1043:  MOVLW  64
1044:  BSF    03.5
1045:  MOVWF  65
1046:  BCF    0A.4
1047:  BCF    03.5
1048:  CALL   29E
1049:  BSF    0A.4
....................      
....................       option = readKeyboard(); 
104A:  BCF    0A.4
104B:  BSF    0A.3
104C:  CALL   000
104D:  BSF    0A.4
104E:  BCF    0A.3
104F:  MOVF   78,W
1050:  MOVWF  70
....................  
....................       if(option != 255){ 
1051:  INCFSZ 70,W
1052:  GOTO   054
1053:  GOTO   6D4
....................          printf(lcd_escreve,"\f Option: %c", option); 
1054:  MOVLW  FE
1055:  BSF    03.6
1056:  MOVWF  0D
1057:  MOVLW  00
1058:  MOVWF  0F
1059:  BCF    03.0
105A:  MOVLW  0A
105B:  BSF    03.5
105C:  BCF    03.6
105D:  MOVWF  5F
105E:  BCF    0A.4
105F:  BCF    03.5
1060:  CALL   6F6
1061:  BSF    0A.4
1062:  MOVF   70,W
1063:  BSF    03.5
1064:  MOVWF  64
1065:  BCF    0A.4
1066:  BCF    03.5
1067:  CALL   353
1068:  BSF    0A.4
....................          delay_ms(500); 
1069:  MOVLW  02
106A:  MOVWF  76
106B:  MOVLW  FA
106C:  BSF    03.5
106D:  MOVWF  65
106E:  BCF    0A.4
106F:  BCF    03.5
1070:  CALL   29E
1071:  BSF    0A.4
1072:  DECFSZ 76,F
1073:  GOTO   06B
....................  
....................          switch(option){ 
1074:  MOVF   70,W
1075:  XORLW  31
1076:  BTFSC  03.2
1077:  GOTO   085
1078:  XORLW  03
1079:  BTFSC  03.2
107A:  GOTO   18D
107B:  XORLW  01
107C:  BTFSC  03.2
107D:  GOTO   211
107E:  XORLW  07
107F:  BTFSC  03.2
1080:  GOTO   34D
1081:  XORLW  01
1082:  BTFSC  03.2
1083:  GOTO   556
1084:  GOTO   6B7
....................             case '1': 
....................                inputKeyboardUser(); 
....................                break; 
*
118C:  GOTO   6D4
....................             case '2': 
....................                temp = inputId(); 
118D:  BCF    0A.4
118E:  BSF    0A.3
118F:  CALL   3B8
1190:  BSF    0A.4
1191:  BCF    0A.3
1192:  MOVF   79,W
1193:  MOVWF  72
1194:  MOVF   78,W
1195:  MOVWF  71
....................                id[0] = temp[0]; 
1196:  MOVF   71,W
1197:  MOVWF  04
1198:  BCF    03.7
1199:  BTFSC  72.0
119A:  BSF    03.7
119B:  MOVF   00,W
119C:  MOVWF  73
....................                id[1] = temp[1]; 
119D:  MOVLW  01
119E:  ADDWF  71,W
119F:  MOVWF  04
11A0:  BCF    03.7
11A1:  BTFSC  72.0
11A2:  BSF    03.7
11A3:  MOVF   00,W
11A4:  MOVWF  74
....................                searchUser(id); 
11A5:  CLRF   7C
11A6:  MOVLW  73
11A7:  MOVWF  7B
....................                break; 
*
1210:  GOTO   6D4
....................             case '3': 
....................                temp = inputId(); 
1211:  BCF    0A.4
1212:  BSF    0A.3
1213:  CALL   3B8
1214:  BSF    0A.4
1215:  BCF    0A.3
1216:  MOVF   79,W
1217:  MOVWF  72
1218:  MOVF   78,W
1219:  MOVWF  71
....................                id[0] = temp[0]; 
121A:  MOVF   71,W
121B:  MOVWF  04
121C:  BCF    03.7
121D:  BTFSC  72.0
121E:  BSF    03.7
121F:  MOVF   00,W
1220:  MOVWF  73
....................                id[1] = temp[1]; 
1221:  MOVLW  01
1222:  ADDWF  71,W
1223:  MOVWF  04
1224:  BCF    03.7
1225:  BTFSC  72.0
1226:  BSF    03.7
1227:  MOVF   00,W
1228:  MOVWF  74
....................                signed int success = deleteUser(id); 
1229:  CLRF   7C
122A:  MOVLW  73
122B:  MOVWF  7B
*
1296:  MOVF   78,W
1297:  MOVWF  75
....................                printf(lcd_escreve,"\fSuccess -> %d", success); 
1298:  MOVLW  05
1299:  BSF    03.6
129A:  MOVWF  0D
129B:  MOVLW  01
129C:  MOVWF  0F
129D:  BCF    03.0
129E:  MOVLW  0C
129F:  BSF    03.5
12A0:  BCF    03.6
12A1:  MOVWF  5F
12A2:  BCF    0A.4
12A3:  BCF    03.5
12A4:  CALL   6F6
12A5:  BSF    0A.4
12A6:  MOVF   75,W
12A7:  MOVWF  76
12A8:  MOVLW  18
12A9:  MOVWF  7B
....................                delay_ms(500); 
*
131C:  MOVLW  02
131D:  MOVWF  76
131E:  MOVLW  FA
131F:  BSF    03.5
1320:  MOVWF  65
1321:  BCF    0A.4
1322:  BCF    03.5
1323:  CALL   29E
1324:  BSF    0A.4
1325:  DECFSZ 76,F
1326:  GOTO   31E
....................                (success >= 1)?  
....................                printf(lcd_escreve,"\fusuario deletado"): 
....................                printf(lcd_escreve,"\fusuario N Existe"); 
1327:  BTFSC  75.7
1328:  GOTO   338
1329:  MOVF   75,W
132A:  SUBLW  00
132B:  BTFSC  03.0
132C:  GOTO   338
132D:  MOVLW  0D
132E:  BSF    03.6
132F:  MOVWF  0D
1330:  MOVLW  01
1331:  MOVWF  0F
1332:  BCF    0A.4
1333:  BCF    03.6
1334:  CALL   396
1335:  BSF    0A.4
1336:  CLRF   7A
1337:  GOTO   341
1338:  MOVLW  16
1339:  BSF    03.6
133A:  MOVWF  0D
133B:  MOVLW  01
133C:  MOVWF  0F
133D:  BCF    0A.4
133E:  BCF    03.6
133F:  CALL   396
1340:  BSF    0A.4
....................                delay_ms(500); 
1341:  MOVLW  02
1342:  MOVWF  76
1343:  MOVLW  FA
1344:  BSF    03.5
1345:  MOVWF  65
1346:  BCF    0A.4
1347:  BCF    03.5
1348:  CALL   29E
1349:  BSF    0A.4
134A:  DECFSZ 76,F
134B:  GOTO   343
....................                break; 
134C:  GOTO   6D4
....................             case '4': 
....................                editUser(); 
....................                break; 
*
1554:  BCF    03.5
1555:  GOTO   6D4
....................             case '5': 
....................                waitUpdate(); 
....................                break; 
*
16B6:  GOTO   6D4
....................             default: 
....................                printf(lcd_escreve,"\fDigite um valor"); 
16B7:  MOVLW  1F
16B8:  BSF    03.6
16B9:  MOVWF  0D
16BA:  MOVLW  01
16BB:  MOVWF  0F
16BC:  BCF    0A.4
16BD:  BCF    03.6
16BE:  CALL   396
16BF:  BSF    0A.4
....................                printf(lcd_escreve,"\r\nValido!"); 
16C0:  MOVLW  28
16C1:  BSF    03.6
16C2:  MOVWF  0D
16C3:  MOVLW  01
16C4:  MOVWF  0F
16C5:  BCF    0A.4
16C6:  BCF    03.6
16C7:  CALL   396
16C8:  BSF    0A.4
....................                delay_ms(500); 
16C9:  MOVLW  02
16CA:  MOVWF  76
16CB:  MOVLW  FA
16CC:  BSF    03.5
16CD:  MOVWF  65
16CE:  BCF    0A.4
16CF:  BCF    03.5
16D0:  CALL   29E
16D1:  BSF    0A.4
16D2:  DECFSZ 76,F
16D3:  GOTO   6CB
....................                break; 
....................          } 
....................       } 
....................    }while(option != '7'); 
16D4:  MOVF   70,W
16D5:  SUBLW  37
16D6:  BTFSS  03.2
16D7:  GOTO   000
16D8:  BSF    0A.3
16D9:  BSF    0A.4
16DA:  GOTO   1C5 (RETURN)
.................... } 
....................  
....................  
.................... int login(int * id){ 
*
0D07:  MOVF   71,W
0D08:  BSF    03.5
0D09:  MOVWF  57
0D0A:  MOVF   70,W
0D0B:  MOVWF  56
0D0C:  BCF    0A.3
0D0D:  BCF    03.5
0D0E:  CALL   5EF
0D0F:  BSF    0A.3
0D10:  MOVF   78,W
0D11:  MOVWF  72
....................  
....................    int address = getAddressByID(id); 
....................    if(address == -1){ 
0D12:  MOVF   72,W
0D13:  SUBLW  FF
0D14:  BTFSS  03.2
0D15:  GOTO   538
....................       printf(lcd_escreve,"\fID N Existe"); 
0D16:  MOVLW  2D
0D17:  BSF    03.6
0D18:  MOVWF  0D
0D19:  MOVLW  01
0D1A:  MOVWF  0F
0D1B:  BCF    0A.3
0D1C:  BCF    03.6
0D1D:  CALL   396
0D1E:  BSF    0A.3
....................       printf(lcd_escreve,"\r\nTente de novo"); 
0D1F:  MOVLW  34
0D20:  BSF    03.6
0D21:  MOVWF  0D
0D22:  MOVLW  01
0D23:  MOVWF  0F
0D24:  BCF    0A.3
0D25:  BCF    03.6
0D26:  CALL   396
0D27:  BSF    0A.3
....................       delay_ms(1000); 
0D28:  MOVLW  04
0D29:  BSF    03.5
0D2A:  MOVWF  33
0D2B:  MOVLW  FA
0D2C:  MOVWF  65
0D2D:  BCF    0A.3
0D2E:  BCF    03.5
0D2F:  CALL   29E
0D30:  BSF    0A.3
0D31:  BSF    03.5
0D32:  DECFSZ 33,F
0D33:  GOTO   52B
....................       return -1; 
0D34:  MOVLW  FF
0D35:  MOVWF  78
0D36:  GOTO   5FB
0D37:  BCF    03.5
....................    } 
....................    unsigned int * temp; 
....................    unsigned int pass[4]; 
....................  
....................    char msg [] = "Digite a senha: "; 
0D38:  MOVLW  44
0D39:  BSF    03.5
0D3A:  MOVWF  20
0D3B:  MOVLW  69
0D3C:  MOVWF  21
0D3D:  MOVLW  67
0D3E:  MOVWF  22
0D3F:  MOVLW  69
0D40:  MOVWF  23
0D41:  MOVLW  74
0D42:  MOVWF  24
0D43:  MOVLW  65
0D44:  MOVWF  25
0D45:  MOVLW  20
0D46:  MOVWF  26
0D47:  MOVLW  61
0D48:  MOVWF  27
0D49:  MOVLW  20
0D4A:  MOVWF  28
0D4B:  MOVLW  73
0D4C:  MOVWF  29
0D4D:  MOVLW  65
0D4E:  MOVWF  2A
0D4F:  MOVLW  6E
0D50:  MOVWF  2B
0D51:  MOVLW  68
0D52:  MOVWF  2C
0D53:  MOVLW  61
0D54:  MOVWF  2D
0D55:  MOVLW  3A
0D56:  MOVWF  2E
0D57:  MOVLW  20
0D58:  MOVWF  2F
0D59:  CLRF   30
....................    int max = 4; 
0D5A:  MOVLW  04
0D5B:  MOVWF  75
....................    temp = inputToKeyboard(msg, max); 
0D5C:  CLRF   4E
0D5D:  MOVLW  A0
0D5E:  MOVWF  4D
0D5F:  MOVF   75,W
0D60:  MOVWF  4F
0D61:  BCF    03.5
0D62:  CALL   41D
0D63:  MOVF   79,W
0D64:  MOVWF  74
0D65:  MOVF   78,W
0D66:  MOVWF  73
....................    pass[0] = temp[0]; 
0D67:  MOVF   73,W
0D68:  MOVWF  04
0D69:  BCF    03.7
0D6A:  BTFSC  74.0
0D6B:  BSF    03.7
0D6C:  MOVF   00,W
0D6D:  MOVWF  7B
....................    pass[1] = temp[1]; 
0D6E:  MOVLW  01
0D6F:  ADDWF  73,W
0D70:  MOVWF  04
0D71:  BCF    03.7
0D72:  BTFSC  74.0
0D73:  BSF    03.7
0D74:  MOVF   00,W
0D75:  MOVWF  7C
....................    pass[2] = temp[2]; 
0D76:  MOVLW  02
0D77:  ADDWF  73,W
0D78:  MOVWF  04
0D79:  BCF    03.7
0D7A:  BTFSC  74.0
0D7B:  BSF    03.7
0D7C:  MOVF   00,W
0D7D:  MOVWF  7D
....................    pass[3] = temp[3]; 
0D7E:  MOVLW  03
0D7F:  ADDWF  73,W
0D80:  MOVWF  04
0D81:  BCF    03.7
0D82:  BTFSC  74.0
0D83:  BSF    03.7
0D84:  MOVF   00,W
0D85:  MOVWF  7E
....................    // printf(lcd_escreve,"\fPASS(4): %u%u%u%u",pass[0],pass[1],pass[2],pass[3]); 
....................    // delay_ms(1000); 
....................    int result_pass = checkPassword(address,pass); 
0D86:  MOVF   72,W
0D87:  BSF    03.5
0D88:  MOVWF  35
0D89:  CLRF   37
0D8A:  MOVLW  7B
0D8B:  MOVWF  36
*
0DB2:  MOVF   78,W
0DB3:  MOVWF  76
....................    if(result_pass != 0){ 
0DB4:  MOVF   76,F
0DB5:  BTFSC  03.2
0DB6:  GOTO   5EF
....................       printf(lcd_escreve,"\fProcure a secretaria"); 
0DB7:  MOVLW  3C
0DB8:  BCF    03.5
0DB9:  BSF    03.6
0DBA:  MOVWF  0D
0DBB:  MOVLW  01
0DBC:  MOVWF  0F
0DBD:  BCF    0A.3
0DBE:  BCF    03.6
0DBF:  CALL   396
0DC0:  BSF    0A.3
....................       printf(lcd_escreve,"\r\nP/ resolver"); 
0DC1:  MOVLW  47
0DC2:  BSF    03.6
0DC3:  MOVWF  0D
0DC4:  MOVLW  01
0DC5:  MOVWF  0F
0DC6:  BCF    0A.3
0DC7:  BCF    03.6
0DC8:  CALL   396
0DC9:  BSF    0A.3
....................       delay_ms(1000); 
0DCA:  MOVLW  04
0DCB:  BSF    03.5
0DCC:  MOVWF  33
0DCD:  MOVLW  FA
0DCE:  MOVWF  65
0DCF:  BCF    0A.3
0DD0:  BCF    03.5
0DD1:  CALL   29E
0DD2:  BSF    0A.3
0DD3:  BSF    03.5
0DD4:  DECFSZ 33,F
0DD5:  GOTO   5CD
....................       printf(lcd_escreve,"\fNADA eh Ligado!"); 
0DD6:  MOVLW  4E
0DD7:  BCF    03.5
0DD8:  BSF    03.6
0DD9:  MOVWF  0D
0DDA:  MOVLW  01
0DDB:  MOVWF  0F
0DDC:  BCF    0A.3
0DDD:  BCF    03.6
0DDE:  CALL   396
0DDF:  BSF    0A.3
....................       delay_ms(500); 
0DE0:  MOVLW  02
0DE1:  BSF    03.5
0DE2:  MOVWF  33
0DE3:  MOVLW  FA
0DE4:  MOVWF  65
0DE5:  BCF    0A.3
0DE6:  BCF    03.5
0DE7:  CALL   29E
0DE8:  BSF    0A.3
0DE9:  BSF    03.5
0DEA:  DECFSZ 33,F
0DEB:  GOTO   5E3
....................       return -1; 
0DEC:  MOVLW  FF
0DED:  MOVWF  78
0DEE:  GOTO   5FB
....................    } 
....................  
....................    int show = 0; 
....................    int status = getUserStatus(address,show); 
0DEF:  CLRF   31
0DF0:  MOVF   72,W
0DF1:  MOVWF  35
0DF2:  MOVF   31,W
0DF3:  MOVWF  36
0DF4:  BCF    03.5
0DF5:  CALL   4A5
0DF6:  MOVF   78,W
0DF7:  BSF    03.5
0DF8:  MOVWF  32
....................    return status; 
0DF9:  MOVF   32,W
0DFA:  MOVWF  78
0DFB:  BCF    03.5
0DFC:  RETURN
....................  
.................... } 
....................  
.................... int checkPassword(int initBlockAddr, int * pass){ 
*
0D8C:  MOVLW  02
0D8D:  ADDWF  35,W
0D8E:  MOVWF  38
0D8F:  MOVLW  04
0D90:  MOVWF  39
....................    int pass_addr = initBlockAddr + 2; 
....................    int len = 4;  
....................    for(int i=0; i < len;i++,pass_addr++){ 
0D91:  CLRF   3A
0D92:  MOVF   39,W
0D93:  SUBWF  3A,W
0D94:  BTFSC  03.0
0D95:  GOTO   5B0
....................       if(pass[i] != read_ext_eeprom(pass_addr)) 
0D96:  MOVF   3A,W
0D97:  ADDWF  36,W
0D98:  MOVWF  04
0D99:  BCF    03.7
0D9A:  BTFSC  37.0
0D9B:  BSF    03.7
0D9C:  MOVF   00,W
0D9D:  MOVWF  3B
0D9E:  MOVF   38,W
0D9F:  MOVWF  5C
0DA0:  BCF    0A.3
0DA1:  BCF    03.5
0DA2:  CALL   51F
0DA3:  BSF    0A.3
0DA4:  MOVF   78,W
0DA5:  BSF    03.5
0DA6:  SUBWF  3B,W
0DA7:  BTFSC  03.2
0DA8:  GOTO   5AC
....................          return -1; 
0DA9:  MOVLW  FF
0DAA:  MOVWF  78
0DAB:  GOTO   5B2
0DAC:  MOVF   3A,W
0DAD:  INCF   3A,F
0DAE:  INCF   38,F
0DAF:  GOTO   592
....................    } 
....................    return 0; 
0DB0:  MOVLW  00
0DB1:  MOVWF  78
....................  
.................... } 
.................... unsigned char readKeyboard(){ 
....................  
....................    unsigned char tmp; 
....................    unsigned char tmp_result; 
....................     
....................    tmp = tc_tecla(1300); // ms 
*
0800:  MOVLW  14
0801:  BSF    03.5
0802:  MOVWF  61
*
095C:  MOVF   78,W
095D:  MOVWF  5F
....................    if(tmp != 255){ 
095E:  INCFSZ 5F,W
095F:  GOTO   161
0960:  GOTO   162
....................       // write_ext_eeprom(0, tmp); 
....................       // delay_ms(50); 
....................       // tmp_result = read_ext_eeprom(0); 
....................       // delay_ms(50); 
....................       // tmp_result = tmp; 
....................       // printf(lcd_escreve,"\f Button: %c", tmp); 
....................       // delay_ms(50); 
....................    }else{  
0961:  GOTO   16D
....................       printf(lcd_escreve,"\f Digite"); 
0962:  MOVLW  57
0963:  BCF    03.5
0964:  BSF    03.6
0965:  MOVWF  0D
0966:  MOVLW  01
0967:  MOVWF  0F
0968:  BCF    0A.3
0969:  BCF    03.6
096A:  CALL   396
096B:  BSF    0A.3
096C:  BSF    03.5
....................    } 
....................  
....................    return tmp; 
096D:  MOVF   5F,W
096E:  MOVWF  78
096F:  BCF    03.5
0970:  RETURN
.................... } 
....................  
....................  
.................... int * getAdminsID(){ 
....................  
....................    int address = 0; 
....................    int temp_status; 
....................    int index= 0; 
....................    static int admins[BLOCK_SIZE]; 
*
181D:  CLRF   4E
181E:  CLRF   4F
181F:  CLRF   50
1820:  CLRF   51
1821:  CLRF   52
1822:  CLRF   53
1823:  CLRF   54
....................    admins[0] = -1; 
....................    while( read_ext_eeprom(address) != -1){ 
....................       temp_status = read_ext_eeprom(address + (BLOCK_SIZE - 1));//status of the user 
....................       if (temp_status == 3){ 
....................          printf (lcd_escreve,"\fAdmin Encontrado"); 
....................          delay_ms(1000); 
....................          for(int i=0; i < 2; i++){ 
....................             int id = read_ext_eeprom(address+i);    
....................             admins[index] = id; 
....................             index++; 
....................          } 
....................  
....................       } 
....................  
....................       address += BLOCK_SIZE;  
....................    } 
....................  
....................    return admins; 
....................  
.................... } 
....................  
.................... void listAdmins(){ 
....................    int * admins; 
....................  
....................    admins = getAdminsID(); 
....................    printf(lcd_escreve,"\f admins[0]: %d", admins[0]); 
....................    delay_ms(1000); 
....................    if(admins[0] != -1){ 
....................       for (int16 i=0; i < sizeof(admins); i+=2){ 
....................          printf(lcd_escreve, "\fid:%u%u",admins[i], admins[i+1]); 
....................          delay_ms(1000); 
....................       }  
....................    } 
.................... } 
....................  
....................  
.................... int * strToInt(char * str){ 
*
079B:  BSF    03.5
079C:  MOVF   60,W
079D:  MOVWF  62
079E:  MOVF   5F,W
079F:  MOVWF  61
07A0:  CLRF   65
....................  
....................   char *p = str; 
....................   //https://flaviocopes.com/c-array-length/ 
....................   static unsigned int buffer[BLOCK_SIZE];   
*
1824:  CLRF   55
1825:  CLRF   56
1826:  CLRF   57
1827:  CLRF   58
1828:  CLRF   59
1829:  CLRF   5A
182A:  CLRF   5B
....................   char * end; 
....................   int index = 0; 
....................  
.................... //   printf (lcd_escreve,"\fP: %s",p); 
.................... //   delay_ms(1000); 
....................   for (unsigned int number = strtoul(p, &end, 10); 
*
07A1:  MOVF   62,W
07A2:  MOVWF  68
07A3:  MOVF   61,W
07A4:  MOVWF  67
07A5:  CLRF   6A
07A6:  MOVLW  E3
07A7:  MOVWF  69
07A8:  MOVLW  0A
07A9:  MOVWF  6B
07AA:  BSF    0A.3
07AB:  BCF    03.5
07AC:  CALL   171
07AD:  BCF    0A.3
07AE:  MOVF   78,W
07AF:  BSF    03.5
07B0:  MOVWF  66
....................         p != end; 
07B1:  MOVF   63,W
07B2:  SUBWF  61,W
07B3:  BTFSS  03.2
07B4:  GOTO   7B9
07B5:  MOVF   64,W
07B6:  SUBWF  62,W
07B7:  BTFSC  03.2
07B8:  GOTO   7D5
....................         number = strtoul(p, &end, 10)) 
....................   { 
....................     p = end; 
07B9:  MOVF   64,W
07BA:  MOVWF  62
07BB:  MOVF   63,W
07BC:  MOVWF  61
....................  
....................     buffer[index] = number;  
07BD:  MOVLW  55
07BE:  ADDWF  65,W
07BF:  MOVWF  04
07C0:  BCF    03.7
07C1:  MOVF   66,W
07C2:  MOVWF  00
....................    //  printf (lcd_escreve,"\fNumber: %u", number); 
....................    //  printf (lcd_escreve,"\r%u", number); 
....................    //  delay_ms(1000); 
....................     index++; 
07C3:  INCF   65,F
07C4:  MOVF   62,W
07C5:  MOVWF  68
07C6:  MOVF   61,W
07C7:  MOVWF  67
07C8:  CLRF   6A
07C9:  MOVLW  E3
07CA:  MOVWF  69
07CB:  MOVLW  0A
07CC:  MOVWF  6B
07CD:  BSF    0A.3
07CE:  BCF    03.5
07CF:  CALL   171
07D0:  BCF    0A.3
07D1:  MOVF   78,W
07D2:  BSF    03.5
07D3:  MOVWF  66
07D4:  GOTO   7B1
....................   } 
....................  
....................    return buffer; 
07D5:  MOVLW  55
07D6:  MOVWF  78
07D7:  MOVLW  00
07D8:  MOVWF  79
07D9:  BCF    03.5
07DA:  RETURN
.................... } 
....................  
.................... char * strfromchar(char destination[], char source)  
.................... {  
....................    destination[0] = source;   // copy the character into the string  
*
0C68:  MOVF   5D,W
0C69:  MOVWF  04
0C6A:  BCF    03.7
0C6B:  BTFSC  5E.0
0C6C:  BSF    03.7
0C6D:  MOVF   5F,W
0C6E:  MOVWF  00
....................    destination[1] = '\0';      // null-terminate the string  
0C6F:  MOVLW  01
0C70:  ADDWF  5D,W
0C71:  MOVWF  04
0C72:  BCF    03.7
0C73:  BTFSC  5E.0
0C74:  BSF    03.7
0C75:  CLRF   00
....................   
....................    return destination;         // common convention for str functions  
0C76:  MOVF   5D,W
0C77:  MOVWF  78
0C78:  MOVF   5E,W
0C79:  MOVWF  79
.................... }  
....................  
....................  
.................... int * inputId(){ 
*
0BB8:  BSF    03.5
0BB9:  CLRF   5E
....................    unsigned char keyboard_buffer[BLOCK_SIZE * 2]; 
....................    unsigned char option; 
....................  
....................    int * temp; 
....................    int i = 0; 
....................    //The user needs to type 4 digits 
....................    //For example, even if it's just 9 
....................    //He/she will type: 0009 
....................    while(i < 5){ 
0BBA:  MOVF   5E,W
0BBB:  SUBLW  04
0BBC:  BTFSS  03.0
0BBD:  GOTO   40B
....................       printf(lcd_escreve,"\fDigite o ID: "); 
0BBE:  MOVLW  72
0BBF:  BCF    03.5
0BC0:  BSF    03.6
0BC1:  MOVWF  0D
0BC2:  MOVLW  01
0BC3:  MOVWF  0F
0BC4:  BCF    0A.3
0BC5:  BCF    03.6
0BC6:  CALL   396
0BC7:  BSF    0A.3
....................       delay_ms(50); 
0BC8:  MOVLW  32
0BC9:  BSF    03.5
0BCA:  MOVWF  65
0BCB:  BCF    0A.3
0BCC:  BCF    03.5
0BCD:  CALL   29E
0BCE:  BSF    0A.3
....................       option = readKeyboard(); 
0BCF:  CALL   000
0BD0:  MOVF   78,W
0BD1:  BSF    03.5
0BD2:  MOVWF  5B
....................       if(option != 255){ 
0BD3:  INCFSZ 5B,W
0BD4:  GOTO   3D6
0BD5:  GOTO   40A
....................          printf(lcd_escreve,"\n\rTyped:%c", option); 
0BD6:  MOVLW  7A
0BD7:  BCF    03.5
0BD8:  BSF    03.6
0BD9:  MOVWF  0D
0BDA:  MOVLW  01
0BDB:  MOVWF  0F
0BDC:  BCF    03.0
0BDD:  MOVLW  08
0BDE:  BSF    03.5
0BDF:  BCF    03.6
0BE0:  MOVWF  5F
0BE1:  BCF    0A.3
0BE2:  BCF    03.5
0BE3:  CALL   6F6
0BE4:  BSF    0A.3
0BE5:  BSF    03.5
0BE6:  MOVF   5B,W
0BE7:  MOVWF  64
0BE8:  BCF    0A.3
0BE9:  BCF    03.5
0BEA:  CALL   353
0BEB:  BSF    0A.3
....................          delay_ms(400); 
0BEC:  MOVLW  02
0BED:  BSF    03.5
0BEE:  MOVWF  5F
0BEF:  MOVLW  C8
0BF0:  MOVWF  65
0BF1:  BCF    0A.3
0BF2:  BCF    03.5
0BF3:  CALL   29E
0BF4:  BSF    0A.3
0BF5:  BSF    03.5
0BF6:  DECFSZ 5F,F
0BF7:  GOTO   3EF
....................          if(i == 2){ 
0BF8:  MOVF   5E,W
0BF9:  SUBLW  02
0BFA:  BTFSS  03.2
0BFB:  GOTO   403
....................             //To convert to int will be easier with space between them 
....................             keyboard_buffer[i] = ' '; 
0BFC:  MOVLW  CD
0BFD:  ADDWF  5E,W
0BFE:  MOVWF  04
0BFF:  BCF    03.7
0C00:  MOVLW  20
0C01:  MOVWF  00
....................             i++; 
0C02:  INCF   5E,F
....................          } 
....................          keyboard_buffer[i] = option; 
0C03:  MOVLW  CD
0C04:  ADDWF  5E,W
0C05:  MOVWF  04
0C06:  BCF    03.7
0C07:  MOVF   5B,W
0C08:  MOVWF  00
....................          i++; 
0C09:  INCF   5E,F
....................       } 
0C0A:  GOTO   3BA
....................    } 
....................    // unsigned char *id; 
....................    // id = keyboard_buffer; 
....................    temp = strToInt(keyboard_buffer); 
0C0B:  CLRF   60
0C0C:  MOVLW  CD
0C0D:  MOVWF  5F
0C0E:  BCF    0A.3
0C0F:  BCF    03.5
0C10:  CALL   79B
0C11:  BSF    0A.3
0C12:  MOVF   79,W
0C13:  BSF    03.5
0C14:  MOVWF  5D
0C15:  MOVF   78,W
0C16:  MOVWF  5C
....................    return temp; 
0C17:  MOVF   5C,W
0C18:  MOVWF  78
0C19:  MOVF   5D,W
0C1A:  MOVWF  79
0C1B:  BCF    03.5
0C1C:  RETURN
.................... } 
....................  
.................... int * inputToKeyboard(char * msg, int max){ 
0C1D:  BSF    03.5
0C1E:  CLRF   5A
....................    unsigned char option; 
....................    int data[BLOCK_SIZE]; 
....................    int * temp; 
....................    int i = 0; 
....................  
....................    while(i < max){ 
0C1F:  MOVF   4F,W
0C20:  SUBWF  5A,W
0C21:  BTFSC  03.0
0C22:  GOTO   49C
....................  
....................       printf(lcd_escreve,"\f%s", msg); 
0C23:  MOVLW  0C
0C24:  MOVWF  64
0C25:  BCF    0A.3
0C26:  BCF    03.5
0C27:  CALL   353
0C28:  BSF    0A.3
0C29:  BSF    03.5
0C2A:  MOVF   4D,W
0C2B:  MOVWF  04
0C2C:  BCF    03.7
0C2D:  BTFSC  4E.0
0C2E:  BSF    03.7
0C2F:  BCF    0A.3
0C30:  BCF    03.5
0C31:  CALL   7DB
0C32:  BSF    0A.3
....................       delay_ms(50); 
0C33:  MOVLW  32
0C34:  BSF    03.5
0C35:  MOVWF  65
0C36:  BCF    0A.3
0C37:  BCF    03.5
0C38:  CALL   29E
0C39:  BSF    0A.3
....................       option = readKeyboard(); 
0C3A:  CALL   000
0C3B:  MOVF   78,W
0C3C:  BSF    03.5
0C3D:  MOVWF  50
....................       if(option != 255){ 
0C3E:  INCFSZ 50,W
0C3F:  GOTO   441
0C40:  GOTO   49B
....................          printf(lcd_escreve,"\n\rTyped:%c", option); 
0C41:  MOVLW  80
0C42:  BCF    03.5
0C43:  BSF    03.6
0C44:  MOVWF  0D
0C45:  MOVLW  01
0C46:  MOVWF  0F
0C47:  BCF    03.0
0C48:  MOVLW  08
0C49:  BSF    03.5
0C4A:  BCF    03.6
0C4B:  MOVWF  5F
0C4C:  BCF    0A.3
0C4D:  BCF    03.5
0C4E:  CALL   6F6
0C4F:  BSF    0A.3
0C50:  BSF    03.5
0C51:  MOVF   50,W
0C52:  MOVWF  64
0C53:  BCF    0A.3
0C54:  BCF    03.5
0C55:  CALL   353
0C56:  BSF    0A.3
....................          delay_ms(400); 
0C57:  MOVLW  02
0C58:  BSF    03.5
0C59:  MOVWF  5D
0C5A:  MOVLW  C8
0C5B:  MOVWF  65
0C5C:  BCF    0A.3
0C5D:  BCF    03.5
0C5E:  CALL   29E
0C5F:  BSF    0A.3
0C60:  BSF    03.5
0C61:  DECFSZ 5D,F
0C62:  GOTO   45A
....................          unsigned char destination[2]; 
....................          //Convert string from char and return  
....................          //to the left array of char(str_pass) 
....................          strfromchar(destination,option); 
0C63:  CLRF   5E
0C64:  MOVLW  DB
0C65:  MOVWF  5D
0C66:  MOVF   50,W
0C67:  MOVWF  5F
....................          temp = strToInt(destination); 
*
0C7A:  CLRF   60
0C7B:  MOVLW  DB
0C7C:  MOVWF  5F
0C7D:  BCF    0A.3
0C7E:  BCF    03.5
0C7F:  CALL   79B
0C80:  BSF    0A.3
0C81:  MOVF   79,W
0C82:  BSF    03.5
0C83:  MOVWF  59
0C84:  MOVF   78,W
0C85:  MOVWF  58
....................          data[i] = temp[0]; 
0C86:  MOVLW  D1
0C87:  ADDWF  5A,W
0C88:  MOVWF  5D
0C89:  CLRF   5E
0C8A:  BTFSC  03.0
0C8B:  INCF   5E,F
0C8C:  MOVF   58,W
0C8D:  MOVWF  04
0C8E:  BCF    03.7
0C8F:  BTFSC  59.0
0C90:  BSF    03.7
0C91:  MOVF   00,W
0C92:  MOVWF  5F
0C93:  MOVF   5D,W
0C94:  MOVWF  04
0C95:  BCF    03.7
0C96:  BTFSC  5E.0
0C97:  BSF    03.7
0C98:  MOVF   5F,W
0C99:  MOVWF  00
....................          i++; 
0C9A:  INCF   5A,F
....................       } 
0C9B:  GOTO   41F
....................    } 
....................  
....................    temp = data; 
0C9C:  CLRF   59
0C9D:  MOVLW  D1
0C9E:  MOVWF  58
....................    return temp; 
0C9F:  MOVF   58,W
0CA0:  MOVWF  78
0CA1:  MOVF   59,W
0CA2:  MOVWF  79
0CA3:  BCF    03.5
0CA4:  RETURN
....................  
.................... } 
.................... void inputKeyboardUser(){ 
....................  
....................    unsigned int * temp; 
....................    unsigned int id [2]; 
....................    temp = inputId(); 
*
1085:  BCF    0A.4
1086:  BSF    0A.3
1087:  CALL   3B8
1088:  BSF    0A.4
1089:  BCF    0A.3
108A:  MOVF   79,W
108B:  MOVWF  7C
108C:  MOVF   78,W
108D:  MOVWF  7B
....................    id[0] = temp[0]; 
108E:  MOVF   7B,W
108F:  MOVWF  04
1090:  BCF    03.7
1091:  BTFSC  7C.0
1092:  BSF    03.7
1093:  MOVF   00,W
1094:  MOVWF  7D
....................    id[1] = temp[1]; 
1095:  MOVLW  01
1096:  ADDWF  7B,W
1097:  MOVWF  04
1098:  BCF    03.7
1099:  BTFSC  7C.0
109A:  BSF    03.7
109B:  MOVF   00,W
109C:  MOVWF  7E
....................    int address = getAddressByID(id); 
109D:  BSF    03.5
109E:  CLRF   57
109F:  MOVLW  7D
10A0:  MOVWF  56
10A1:  BCF    0A.4
10A2:  BCF    03.5
10A3:  CALL   5EF
10A4:  BSF    0A.4
10A5:  MOVF   78,W
10A6:  MOVWF  76
....................    printf(lcd_escreve,"\fid: %u%u",id[0],id[1]); 
10A7:  MOVLW  86
10A8:  BSF    03.6
10A9:  MOVWF  0D
10AA:  MOVLW  01
10AB:  MOVWF  0F
10AC:  BCF    03.0
10AD:  MOVLW  05
10AE:  BSF    03.5
10AF:  BCF    03.6
10B0:  MOVWF  5F
10B1:  BCF    0A.4
10B2:  BCF    03.5
10B3:  CALL   6F6
10B4:  BSF    0A.4
10B5:  MOVF   7D,W
10B6:  BSF    03.5
10B7:  MOVWF  4D
10B8:  MOVLW  1B
10B9:  MOVWF  4E
10BA:  BCF    0A.4
10BB:  BSF    0A.3
10BC:  BCF    03.5
10BD:  CALL   614
10BE:  BSF    0A.4
10BF:  BCF    0A.3
10C0:  MOVF   7E,W
10C1:  BSF    03.5
10C2:  MOVWF  4D
10C3:  MOVLW  1B
10C4:  MOVWF  4E
10C5:  BCF    0A.4
10C6:  BSF    0A.3
10C7:  BCF    03.5
10C8:  CALL   614
10C9:  BSF    0A.4
10CA:  BCF    0A.3
....................    delay_ms(500); 
10CB:  MOVLW  02
10CC:  BSF    03.5
10CD:  MOVWF  48
10CE:  MOVLW  FA
10CF:  MOVWF  65
10D0:  BCF    0A.4
10D1:  BCF    03.5
10D2:  CALL   29E
10D3:  BSF    0A.4
10D4:  BSF    03.5
10D5:  DECFSZ 48,F
10D6:  GOTO   0CE
....................    if(address == -1){//-1: ID is available to use 
10D7:  MOVF   76,W
10D8:  SUBLW  FF
10D9:  BTFSS  03.2
10DA:  GOTO   175
....................       unsigned int pass[4]; 
....................       unsigned int status; 
....................  
....................       char msg [] = "Digite a senha: "; 
10DB:  MOVLW  44
10DC:  MOVWF  25
10DD:  MOVLW  69
10DE:  MOVWF  26
10DF:  MOVLW  67
10E0:  MOVWF  27
10E1:  MOVLW  69
10E2:  MOVWF  28
10E3:  MOVLW  74
10E4:  MOVWF  29
10E5:  MOVLW  65
10E6:  MOVWF  2A
10E7:  MOVLW  20
10E8:  MOVWF  2B
10E9:  MOVLW  61
10EA:  MOVWF  2C
10EB:  MOVLW  20
10EC:  MOVWF  2D
10ED:  MOVLW  73
10EE:  MOVWF  2E
10EF:  MOVLW  65
10F0:  MOVWF  2F
10F1:  MOVLW  6E
10F2:  MOVWF  30
10F3:  MOVLW  68
10F4:  MOVWF  31
10F5:  MOVLW  61
10F6:  MOVWF  32
10F7:  MOVLW  3A
10F8:  MOVWF  33
10F9:  MOVLW  20
10FA:  MOVWF  34
10FB:  CLRF   35
....................       int max = 4; 
10FC:  MOVLW  04
10FD:  MOVWF  36
....................       temp = inputToKeyboard(msg, max); 
10FE:  CLRF   4E
10FF:  MOVLW  A5
1100:  MOVWF  4D
1101:  MOVF   36,W
1102:  MOVWF  4F
1103:  BCF    0A.4
1104:  BSF    0A.3
1105:  BCF    03.5
1106:  CALL   41D
1107:  BSF    0A.4
1108:  BCF    0A.3
1109:  MOVF   79,W
110A:  MOVWF  7C
110B:  MOVF   78,W
110C:  MOVWF  7B
....................       pass[0] = temp[0]; 
110D:  MOVF   7B,W
110E:  MOVWF  04
110F:  BCF    03.7
1110:  BTFSC  7C.0
1111:  BSF    03.7
1112:  MOVF   00,W
1113:  BSF    03.5
1114:  MOVWF  20
....................       pass[1] = temp[1]; 
1115:  MOVLW  01
1116:  ADDWF  7B,W
1117:  MOVWF  04
1118:  BCF    03.7
1119:  BTFSC  7C.0
111A:  BSF    03.7
111B:  MOVF   00,W
111C:  MOVWF  21
....................       pass[2] = temp[2]; 
111D:  MOVLW  02
111E:  ADDWF  7B,W
111F:  MOVWF  04
1120:  BCF    03.7
1121:  BTFSC  7C.0
1122:  BSF    03.7
1123:  MOVF   00,W
1124:  MOVWF  22
....................       pass[3] = temp[3]; 
1125:  MOVLW  03
1126:  ADDWF  7B,W
1127:  MOVWF  04
1128:  BCF    03.7
1129:  BTFSC  7C.0
112A:  BSF    03.7
112B:  MOVF   00,W
112C:  MOVWF  23
....................  
....................       char msg2 [] = "Status (0,1,3): "; 
112D:  MOVLW  53
112E:  MOVWF  37
112F:  MOVLW  74
1130:  MOVWF  38
1131:  MOVLW  61
1132:  MOVWF  39
1133:  MOVLW  74
1134:  MOVWF  3A
1135:  MOVLW  75
1136:  MOVWF  3B
1137:  MOVLW  73
1138:  MOVWF  3C
1139:  MOVLW  20
113A:  MOVWF  3D
113B:  MOVLW  28
113C:  MOVWF  3E
113D:  MOVLW  30
113E:  MOVWF  3F
113F:  MOVLW  2C
1140:  MOVWF  40
1141:  MOVLW  31
1142:  MOVWF  41
1143:  MOVLW  2C
1144:  MOVWF  42
1145:  MOVLW  33
1146:  MOVWF  43
1147:  MOVLW  29
1148:  MOVWF  44
1149:  MOVLW  3A
114A:  MOVWF  45
114B:  MOVLW  20
114C:  MOVWF  46
114D:  CLRF   47
....................       max = 1; 
114E:  MOVLW  01
114F:  MOVWF  36
....................       temp = inputToKeyboard(msg2, max); 
1150:  CLRF   4E
1151:  MOVLW  B7
1152:  MOVWF  4D
1153:  MOVF   36,W
1154:  MOVWF  4F
1155:  BCF    0A.4
1156:  BSF    0A.3
1157:  BCF    03.5
1158:  CALL   41D
1159:  BSF    0A.4
115A:  BCF    0A.3
115B:  MOVF   79,W
115C:  MOVWF  7C
115D:  MOVF   78,W
115E:  MOVWF  7B
....................       status = temp[0]; 
115F:  MOVF   7B,W
1160:  MOVWF  04
1161:  BCF    03.7
1162:  BTFSC  7C.0
1163:  BSF    03.7
1164:  MOVF   00,W
1165:  BSF    03.5
1166:  MOVWF  24
....................  
....................       saveUser(id,pass,status); 
1167:  CLRF   4A
1168:  MOVLW  7D
1169:  MOVWF  49
116A:  CLRF   4C
116B:  MOVLW  A0
116C:  MOVWF  4B
116D:  MOVF   24,W
116E:  MOVWF  4D
116F:  BCF    0A.4
1170:  BCF    03.5
1171:  CALL   629
1172:  BSF    0A.4
....................    }else{ 
1173:  GOTO   18C
1174:  BSF    03.5
....................       printf (lcd_escreve,"\fID Jah Existe"); 
1175:  MOVLW  8B
1176:  BCF    03.5
1177:  BSF    03.6
1178:  MOVWF  0D
1179:  MOVLW  01
117A:  MOVWF  0F
117B:  BCF    0A.4
117C:  BCF    03.6
117D:  CALL   396
117E:  BSF    0A.4
....................       delay_ms(1000); 
117F:  MOVLW  04
1180:  BSF    03.5
1181:  MOVWF  48
1182:  MOVLW  FA
1183:  MOVWF  65
1184:  BCF    0A.4
1185:  BCF    03.5
1186:  CALL   29E
1187:  BSF    0A.4
1188:  BSF    03.5
1189:  DECFSZ 48,F
118A:  GOTO   182
118B:  BCF    03.5
....................    } 
.................... } 
....................  
.................... void editUser(){ 
....................    unsigned int * temp; 
....................    unsigned int id [2]; 
....................    temp = inputId(); 
*
134D:  BCF    0A.4
134E:  BSF    0A.3
134F:  CALL   3B8
1350:  BSF    0A.4
1351:  BCF    0A.3
1352:  MOVF   79,W
1353:  MOVWF  7C
1354:  MOVF   78,W
1355:  MOVWF  7B
....................    id[0] = temp[0]; 
1356:  MOVF   7B,W
1357:  MOVWF  04
1358:  BCF    03.7
1359:  BTFSC  7C.0
135A:  BSF    03.7
135B:  MOVF   00,W
135C:  MOVWF  7D
....................    id[1] = temp[1]; 
135D:  MOVLW  01
135E:  ADDWF  7B,W
135F:  MOVWF  04
1360:  BCF    03.7
1361:  BTFSC  7C.0
1362:  BSF    03.7
1363:  MOVF   00,W
1364:  MOVWF  7E
....................    int address = getAddressByID(id); 
1365:  BSF    03.5
1366:  CLRF   57
1367:  MOVLW  7D
1368:  MOVWF  56
1369:  BCF    0A.4
136A:  BCF    03.5
136B:  CALL   5EF
136C:  BSF    0A.4
136D:  MOVF   78,W
136E:  MOVWF  76
....................    if(address != -1){ 
136F:  MOVF   76,W
1370:  SUBLW  FF
1371:  BTFSC  03.2
1372:  GOTO   53F
....................       unsigned int * temp; 
....................       unsigned int pass[4]; 
....................       unsigned int status; 
....................  
....................       char msg [] = "Nova senha: "; 
1373:  MOVLW  4E
1374:  BSF    03.5
1375:  MOVWF  27
1376:  MOVLW  6F
1377:  MOVWF  28
1378:  MOVLW  76
1379:  MOVWF  29
137A:  MOVLW  61
137B:  MOVWF  2A
137C:  MOVLW  20
137D:  MOVWF  2B
137E:  MOVLW  73
137F:  MOVWF  2C
1380:  MOVLW  65
1381:  MOVWF  2D
1382:  MOVLW  6E
1383:  MOVWF  2E
1384:  MOVLW  68
1385:  MOVWF  2F
1386:  MOVLW  61
1387:  MOVWF  30
1388:  MOVLW  3A
1389:  MOVWF  31
138A:  MOVLW  20
138B:  MOVWF  32
138C:  CLRF   33
....................       int max = 4; 
138D:  MOVLW  04
138E:  MOVWF  34
....................       temp = inputToKeyboard(msg, max); 
138F:  CLRF   4E
1390:  MOVLW  A7
1391:  MOVWF  4D
1392:  MOVF   34,W
1393:  MOVWF  4F
1394:  BCF    0A.4
1395:  BSF    0A.3
1396:  BCF    03.5
1397:  CALL   41D
1398:  BSF    0A.4
1399:  BCF    0A.3
139A:  MOVF   79,W
139B:  BSF    03.5
139C:  MOVWF  21
139D:  MOVF   78,W
139E:  MOVWF  20
....................       pass[0] = temp[0]; 
139F:  MOVF   20,W
13A0:  MOVWF  04
13A1:  BCF    03.7
13A2:  BTFSC  21.0
13A3:  BSF    03.7
13A4:  MOVF   00,W
13A5:  MOVWF  22
....................       pass[1] = temp[1]; 
13A6:  MOVLW  01
13A7:  ADDWF  20,W
13A8:  MOVWF  04
13A9:  BCF    03.7
13AA:  BTFSC  21.0
13AB:  BSF    03.7
13AC:  MOVF   00,W
13AD:  MOVWF  23
....................       pass[2] = temp[2]; 
13AE:  MOVLW  02
13AF:  ADDWF  20,W
13B0:  MOVWF  04
13B1:  BCF    03.7
13B2:  BTFSC  21.0
13B3:  BSF    03.7
13B4:  MOVF   00,W
13B5:  MOVWF  24
....................       pass[3] = temp[3]; 
13B6:  MOVLW  03
13B7:  ADDWF  20,W
13B8:  MOVWF  04
13B9:  BCF    03.7
13BA:  BTFSC  21.0
13BB:  BSF    03.7
13BC:  MOVF   00,W
13BD:  MOVWF  25
....................       printf(lcd_escreve,"\fPASS(4): %u%u%u%u",pass[0],pass[1],pass[2],pass[3]); 
13BE:  MOVLW  93
13BF:  BCF    03.5
13C0:  BSF    03.6
13C1:  MOVWF  0D
13C2:  MOVLW  01
13C3:  MOVWF  0F
13C4:  BCF    03.0
13C5:  MOVLW  0A
13C6:  BSF    03.5
13C7:  BCF    03.6
13C8:  MOVWF  5F
13C9:  BCF    0A.4
13CA:  BCF    03.5
13CB:  CALL   6F6
13CC:  BSF    0A.4
13CD:  BSF    03.5
13CE:  MOVF   22,W
13CF:  MOVWF  4D
13D0:  MOVLW  1B
13D1:  MOVWF  4E
13D2:  BCF    0A.4
13D3:  BSF    0A.3
13D4:  BCF    03.5
13D5:  CALL   614
13D6:  BSF    0A.4
13D7:  BCF    0A.3
13D8:  BSF    03.5
13D9:  MOVF   23,W
13DA:  MOVWF  4D
13DB:  MOVLW  1B
13DC:  MOVWF  4E
13DD:  BCF    0A.4
13DE:  BSF    0A.3
13DF:  BCF    03.5
13E0:  CALL   614
13E1:  BSF    0A.4
13E2:  BCF    0A.3
13E3:  BSF    03.5
13E4:  MOVF   24,W
13E5:  MOVWF  4D
13E6:  MOVLW  1B
13E7:  MOVWF  4E
13E8:  BCF    0A.4
13E9:  BSF    0A.3
13EA:  BCF    03.5
13EB:  CALL   614
13EC:  BSF    0A.4
13ED:  BCF    0A.3
13EE:  BSF    03.5
13EF:  MOVF   25,W
13F0:  MOVWF  4D
13F1:  MOVLW  1B
13F2:  MOVWF  4E
13F3:  BCF    0A.4
13F4:  BSF    0A.3
13F5:  BCF    03.5
13F6:  CALL   614
13F7:  BSF    0A.4
13F8:  BCF    0A.3
....................       delay_ms(500); 
13F9:  MOVLW  02
13FA:  BSF    03.5
13FB:  MOVWF  4C
13FC:  MOVLW  FA
13FD:  MOVWF  65
13FE:  BCF    0A.4
13FF:  BCF    03.5
1400:  CALL   29E
1401:  BSF    0A.4
1402:  BSF    03.5
1403:  DECFSZ 4C,F
1404:  GOTO   3FC
....................  
....................       char msg2 [] = "Novo Status\r\n(0,1,3): "; 
1405:  MOVLW  4E
1406:  MOVWF  35
1407:  MOVLW  6F
1408:  MOVWF  36
1409:  MOVLW  76
140A:  MOVWF  37
140B:  MOVLW  6F
140C:  MOVWF  38
140D:  MOVLW  20
140E:  MOVWF  39
140F:  MOVLW  53
1410:  MOVWF  3A
1411:  MOVLW  74
1412:  MOVWF  3B
1413:  MOVLW  61
1414:  MOVWF  3C
1415:  MOVLW  74
1416:  MOVWF  3D
1417:  MOVLW  75
1418:  MOVWF  3E
1419:  MOVLW  73
141A:  MOVWF  3F
141B:  MOVLW  0D
141C:  MOVWF  40
141D:  MOVLW  0A
141E:  MOVWF  41
141F:  MOVLW  28
1420:  MOVWF  42
1421:  MOVLW  30
1422:  MOVWF  43
1423:  MOVLW  2C
1424:  MOVWF  44
1425:  MOVLW  31
1426:  MOVWF  45
1427:  MOVLW  2C
1428:  MOVWF  46
1429:  MOVLW  33
142A:  MOVWF  47
142B:  MOVLW  29
142C:  MOVWF  48
142D:  MOVLW  3A
142E:  MOVWF  49
142F:  MOVLW  20
1430:  MOVWF  4A
1431:  CLRF   4B
....................       max = 1; 
1432:  MOVLW  01
1433:  MOVWF  34
....................       temp = inputToKeyboard(msg2, max); 
1434:  CLRF   4E
1435:  MOVLW  B5
1436:  MOVWF  4D
1437:  MOVF   34,W
1438:  MOVWF  4F
1439:  BCF    0A.4
143A:  BSF    0A.3
143B:  BCF    03.5
143C:  CALL   41D
143D:  BSF    0A.4
143E:  BCF    0A.3
143F:  MOVF   79,W
1440:  BSF    03.5
1441:  MOVWF  21
1442:  MOVF   78,W
1443:  MOVWF  20
....................       status = temp[0]; 
1444:  MOVF   20,W
1445:  MOVWF  04
1446:  BCF    03.7
1447:  BTFSC  21.0
1448:  BSF    03.7
1449:  MOVF   00,W
144A:  MOVWF  26
....................       printf(lcd_escreve,"\fSTATUS: %u",status); 
144B:  MOVLW  9D
144C:  BCF    03.5
144D:  BSF    03.6
144E:  MOVWF  0D
144F:  MOVLW  01
1450:  MOVWF  0F
1451:  BCF    03.0
1452:  MOVLW  09
1453:  BSF    03.5
1454:  BCF    03.6
1455:  MOVWF  5F
1456:  BCF    0A.4
1457:  BCF    03.5
1458:  CALL   6F6
1459:  BSF    0A.4
145A:  BSF    03.5
145B:  MOVF   26,W
145C:  MOVWF  4D
145D:  MOVLW  1B
145E:  MOVWF  4E
145F:  BCF    0A.4
1460:  BSF    0A.3
1461:  BCF    03.5
1462:  CALL   614
1463:  BSF    0A.4
1464:  BCF    0A.3
....................       delay_ms(500); 
1465:  MOVLW  02
1466:  BSF    03.5
1467:  MOVWF  4C
1468:  MOVLW  FA
1469:  MOVWF  65
146A:  BCF    0A.4
146B:  BCF    03.5
146C:  CALL   29E
146D:  BSF    0A.4
146E:  BSF    03.5
146F:  DECFSZ 4C,F
1470:  GOTO   468
....................  
....................       updateUser(id,pass,status,address); 
1471:  CLRF   53
1472:  MOVLW  7D
1473:  MOVWF  52
1474:  CLRF   55
1475:  MOVLW  A2
1476:  MOVWF  54
1477:  MOVF   26,W
1478:  MOVWF  56
1479:  MOVF   76,W
147A:  MOVWF  57
....................    }else{ 
*
153D:  GOTO   554
153E:  BCF    03.5
....................       printf (lcd_escreve,"\fID N Existe"); 
153F:  MOVLW  A3
1540:  BSF    03.6
1541:  MOVWF  0D
1542:  MOVLW  01
1543:  MOVWF  0F
1544:  BCF    0A.4
1545:  BCF    03.6
1546:  CALL   396
1547:  BSF    0A.4
....................       delay_ms(1000); 
1548:  MOVLW  04
1549:  BSF    03.5
154A:  MOVWF  4C
154B:  MOVLW  FA
154C:  MOVWF  65
154D:  BCF    0A.4
154E:  BCF    03.5
154F:  CALL   29E
1550:  BSF    0A.4
1551:  BSF    03.5
1552:  DECFSZ 4C,F
1553:  GOTO   54B
....................    } 
.................... } 
....................  
.................... void waitUpdate(){ 
....................    resetMemory(); 
*
1556:  BCF    0A.4
1557:  CALL   502
1558:  BSF    0A.4
....................    printf (lcd_escreve,"\fEm Modo Espera"); 
1559:  MOVLW  AA
155A:  BSF    03.6
155B:  MOVWF  0D
155C:  MOVLW  01
155D:  MOVWF  0F
155E:  BCF    0A.4
155F:  BCF    03.6
1560:  CALL   396
1561:  BSF    0A.4
....................    printf (lcd_escreve,"\r\nde dados ..."); 
1562:  MOVLW  B2
1563:  BSF    03.6
1564:  MOVWF  0D
1565:  MOVLW  01
1566:  MOVWF  0F
1567:  BCF    0A.4
1568:  BCF    03.6
1569:  CALL   396
156A:  BSF    0A.4
....................    delay_ms(100); 
156B:  MOVLW  64
156C:  BSF    03.5
156D:  MOVWF  65
156E:  BCF    0A.4
156F:  BCF    03.5
1570:  CALL   29E
1571:  BSF    0A.4
....................    User user; 
....................    while(true){ 
....................       if(data_avail){ 
1572:  MOVF   30,F
1573:  BTFSC  03.2
1574:  GOTO   6B5
....................          if(rx_buffer[0] =='#' && rx_buffer[2] =='#'){ 
1575:  MOVF   32,W
1576:  SUBLW  23
1577:  BTFSS  03.2
1578:  GOTO   592
1579:  MOVF   34,W
157A:  SUBLW  23
157B:  BTFSS  03.2
157C:  GOTO   592
....................             printf (lcd_escreve,"\fFim da Comunicacao"); 
157D:  MOVLW  BA
157E:  BSF    03.6
157F:  MOVWF  0D
1580:  MOVLW  01
1581:  MOVWF  0F
1582:  BCF    0A.4
1583:  BCF    03.6
1584:  CALL   396
1585:  BSF    0A.4
....................             delay_ms(1000); 
1586:  MOVLW  04
1587:  MOVWF  7B
1588:  MOVLW  FA
1589:  BSF    03.5
158A:  MOVWF  65
158B:  BCF    0A.4
158C:  BCF    03.5
158D:  CALL   29E
158E:  BSF    0A.4
158F:  DECFSZ 7B,F
1590:  GOTO   588
....................             break; 
1591:  GOTO   6B6
....................          } 
....................          data_avail = FALSE; 
1592:  CLRF   30
....................          user = receiveUser(); 
*
160C:  MOVF   79,W
160D:  MOVWF  7A
160E:  MOVF   78,W
160F:  MOVWF  7B
1610:  MOVF   7A,W
1611:  MOVWF  7C
1612:  CLRF   7E
1613:  MOVLW  A0
1614:  MOVWF  7D
1615:  MOVLW  07
1616:  MOVWF  78
1617:  MOVF   7B,W
1618:  MOVWF  04
1619:  BCF    03.7
161A:  BTFSC  7C.0
161B:  BSF    03.7
161C:  MOVF   00,W
161D:  MOVWF  77
161E:  MOVF   7D,W
161F:  MOVWF  04
1620:  BCF    03.7
1621:  BTFSC  7E.0
1622:  BSF    03.7
1623:  MOVF   77,W
1624:  MOVWF  00
1625:  INCF   7D,F
1626:  BTFSC  03.2
1627:  INCF   7E,F
1628:  INCF   7B,F
1629:  BTFSC  03.2
162A:  INCF   7C,F
162B:  DECFSZ 78,F
162C:  GOTO   617
....................          printUser(user); 
162D:  MOVF   20,W
162E:  MOVWF  27
162F:  MOVF   21,W
1630:  MOVWF  28
1631:  MOVF   22,W
1632:  MOVWF  29
1633:  MOVF   23,W
1634:  MOVWF  2A
1635:  MOVF   24,W
1636:  MOVWF  2B
1637:  MOVF   25,W
1638:  MOVWF  2C
1639:  MOVF   26,W
163A:  MOVWF  2D
....................          // overwriteUser(user); 
....................          // rx_wr_index = 0; 
....................          printf (lcd_escreve,"\fPIC em modo Espera"); 
*
169B:  MOVLW  C4
169C:  BCF    03.5
169D:  BSF    03.6
169E:  MOVWF  0D
169F:  MOVLW  01
16A0:  MOVWF  0F
16A1:  BCF    0A.4
16A2:  BCF    03.6
16A3:  CALL   396
16A4:  BSF    0A.4
....................          printf (lcd_escreve,"\r\nEsperando dados..."); 
16A5:  MOVLW  CE
16A6:  BSF    03.6
16A7:  MOVWF  0D
16A8:  MOVLW  01
16A9:  MOVWF  0F
16AA:  BCF    0A.4
16AB:  BCF    03.6
16AC:  CALL   396
16AD:  BSF    0A.4
....................          delay_ms(100); 
16AE:  MOVLW  64
16AF:  BSF    03.5
16B0:  MOVWF  65
16B1:  BCF    0A.4
16B2:  BCF    03.5
16B3:  CALL   29E
16B4:  BSF    0A.4
....................       } 
16B5:  GOTO   572
....................    } 
.................... } 
....................  
.................... void overwriteUser(User user){ 
....................  
....................    if(user.id[0] <= 99 && user.id[1] <= 99 && getAddressByID(user.id) == -1 ){ 
....................       int address = lastNewUserPosition(); 
....................  
....................       write_ext_eeprom(address, user.id[0]); 
....................       write_ext_eeprom(address+1, user.id[1]); 
....................       write_ext_eeprom(address+2, user.pass[0]); 
....................       write_ext_eeprom(address+3, user.pass[1]); 
....................       write_ext_eeprom(address+4, user.pass[2]); 
....................       write_ext_eeprom(address+5, user.pass[3]);        
....................       write_ext_eeprom(address+6, user.status); 
....................  
....................       // printf (lcd_escreve,"\fUsuario Cadastrado"); 
....................       // delay_ms(500); 
....................  
....................    }else{ 
....................       printf (lcd_escreve,"\fID incompativel"); 
....................       printf (lcd_escreve,"\r\nTente novamente"); 
....................       delay_ms(500); 
....................  
....................    } 
.................... } 
....................  
....................  
.................... // ---- MSG from serial communication 
.................... #int_RDA 
.................... void RDA_isr(void){ 
....................    rx_buffer[rx_wr_index] = getc(); 
*
01EB:  MOVLW  32
01EC:  ADDWF  2B,W
01ED:  MOVWF  04
01EE:  BCF    03.7
01EF:  BTFSS  0C.5
01F0:  GOTO   1EF
01F1:  MOVF   1A,W
01F2:  MOVWF  00
....................    rxd = rx_buffer[rx_wr_index]; 
01F3:  MOVLW  32
01F4:  ADDWF  2B,W
01F5:  MOVWF  04
01F6:  BCF    03.7
01F7:  MOVF   00,W
01F8:  MOVWF  2D
....................    rx_wr_index++; 
01F9:  INCF   2B,F
....................  
....................  
....................    if(rx_wr_index > RX_BUFFER_SIZE){ 
01FA:  MOVF   2B,W
01FB:  SUBLW  14
01FC:  BTFSS  03.0
....................       rx_wr_index = 0; 
01FD:  CLRF   2B
....................    } 
....................  
....................    //Look for unique ID: "IFMT" 
....................    if(rxd == 'I' && lock_pos == 0){ 
01FE:  MOVF   2D,W
01FF:  SUBLW  49
0200:  BTFSS  03.2
0201:  GOTO   207
0202:  MOVF   2C,F
0203:  BTFSS  03.2
0204:  GOTO   207
....................       lock_pos++; 
0205:  INCF   2C,F
....................    } 
0206:  GOTO   22A
....................    else if(rxd == 'F' && lock_pos == 1){ 
0207:  MOVF   2D,W
0208:  SUBLW  46
0209:  BTFSS  03.2
020A:  GOTO   20F
020B:  DECFSZ 2C,W
020C:  GOTO   20F
....................       lock_pos++; 
020D:  INCF   2C,F
....................    } 
020E:  GOTO   22A
....................    else if(rxd == 'M' && lock_pos == 2){ 
020F:  MOVF   2D,W
0210:  SUBLW  4D
0211:  BTFSS  03.2
0212:  GOTO   219
0213:  MOVF   2C,W
0214:  SUBLW  02
0215:  BTFSS  03.2
0216:  GOTO   219
....................       lock_pos++; 
0217:  INCF   2C,F
....................    } 
0218:  GOTO   22A
....................    else if(rxd == 'T' && lock_pos == 3){ 
0219:  MOVF   2D,W
021A:  SUBLW  54
021B:  BTFSS  03.2
021C:  GOTO   229
021D:  MOVF   2C,W
021E:  SUBLW  03
021F:  BTFSS  03.2
0220:  GOTO   229
....................       lock_pos=0; //Reset the "combination lock" 
0221:  CLRF   2C
....................       got_id = TRUE; 
0222:  MOVLW  01
0223:  MOVWF  31
....................       read = rxd; 
0224:  MOVF   2D,W
0225:  MOVWF  2E
....................       //get ready to count the number of data bytes 
....................       valid_data_count = 0;  
0226:  CLRF   2F
....................  
....................       //buffer is reset to index 0 
....................       rx_wr_index = 0; 
0227:  CLRF   2B
....................    }else { 
0228:  GOTO   22A
....................       lock_pos = 0; 
0229:  CLRF   2C
....................    } 
....................  
....................    if(got_id && valid_data_count++ >= BLOCK_SIZE){ 
022A:  MOVF   31,F
022B:  BTFSC  03.2
022C:  GOTO   235
022D:  MOVF   2F,W
022E:  INCF   2F,F
022F:  SUBLW  06
0230:  BTFSC  03.0
0231:  GOTO   235
....................       data_avail = TRUE; 
0232:  MOVLW  01
0233:  MOVWF  30
....................       got_id = FALSE; 
0234:  CLRF   31
....................    } 
....................     
0235:  BCF    0C.5
0236:  BCF    0A.3
0237:  BCF    0A.4
0238:  GOTO   02D
.................... } 
....................  
....................  
....................  
....................  
.................... // #int_TIMER1 
.................... // void TIMER1_isr(void) 
.................... // { 
.................... // } 
....................  
.................... // #int_RTCC 
.................... // void RTCC_isr(void) 
.................... // { 
....................  
....................        
.................... // } 
.................... // #INT_EXT 
.................... // void  EXT_isr(void)  
.................... // { 
.................... //    if(++turn_on> 5){ 
.................... //       resetMemory(); 
.................... //       turn_on = 0; 
.................... //    } 
.................... // } 
.................... void main() 
*
1800:  MOVF   03,W
1801:  ANDLW  1F
1802:  MOVWF  03
1803:  MOVLW  81
1804:  BSF    03.5
1805:  MOVWF  19
1806:  MOVLW  A6
1807:  MOVWF  18
1808:  MOVLW  90
1809:  BCF    03.5
180A:  MOVWF  18
180B:  CLRF   2B
180C:  CLRF   2C
180D:  CLRF   30
180E:  CLRF   31
180F:  CLRF   46
1810:  MOVLW  FF
1811:  MOVWF  47
1812:  BSF    03.5
1813:  BSF    1F.0
1814:  BSF    1F.1
1815:  BSF    1F.2
1816:  BCF    1F.3
1817:  MOVLW  07
1818:  MOVWF  1C
1819:  BCF    03.7
.................... { 
....................    //VARIAVEIS 
....................  
....................    // setup_timer_0(RTCC_INTERNAL|RTCC_DIV_256|RTCC_8_bit);      //13.1ms overflow 
....................    // setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); //Overflow in 104ms | Resolution 1.6 us 
....................    init_ext_eeprom(); 
*
182B:  BCF    0A.4
182C:  BCF    0A.3
182D:  GOTO   291
182E:  BSF    0A.4
182F:  BSF    0A.3
....................    // enable_interrupts(INT_TIMER0); 
....................    // enable_interrupts(INT_TIMER1); 
....................    enable_interrupts(INT_EXT); 
1830:  BSF    0B.4
....................    enable_interrupts(INT_RDA); 
1831:  BSF    03.5
1832:  BSF    0C.5
....................    enable_interrupts(GLOBAL); 
1833:  MOVLW  C0
1834:  BCF    03.5
1835:  IORWF  0B,F
....................  
....................    lcd_ini(); 
1836:  BCF    0A.4
1837:  BCF    0A.3
1838:  GOTO   30C
1839:  BSF    0A.4
183A:  BSF    0A.3
....................    delay_us(50); 
183B:  MOVLW  52
183C:  MOVWF  77
183D:  DECFSZ 77,F
183E:  GOTO   03D
183F:  GOTO   040
1840:  NOP
....................  
....................    printf(lcd_escreve, "\f  iniciando... "); 
1841:  MOVLW  39
1842:  BSF    03.6
1843:  MOVWF  0D
1844:  MOVLW  02
1845:  MOVWF  0F
1846:  BCF    0A.4
1847:  BCF    0A.3
1848:  BCF    03.6
1849:  CALL   396
184A:  BSF    0A.4
184B:  BSF    0A.3
....................    delay_ms(500); 
184C:  MOVLW  02
184D:  MOVWF  70
184E:  MOVLW  FA
184F:  BSF    03.5
1850:  MOVWF  65
1851:  BCF    0A.4
1852:  BCF    0A.3
1853:  BCF    03.5
1854:  CALL   29E
1855:  BSF    0A.4
1856:  BSF    0A.3
1857:  DECFSZ 70,F
1858:  GOTO   04E
....................  
....................    printf(lcd_escreve, "\fIFMT - Serial"); 
1859:  MOVLW  42
185A:  BSF    03.6
185B:  MOVWF  0D
185C:  MOVLW  02
185D:  MOVWF  0F
185E:  BCF    0A.4
185F:  BCF    0A.3
1860:  BCF    03.6
1861:  CALL   396
1862:  BSF    0A.4
1863:  BSF    0A.3
....................    delay_ms(500); 
1864:  MOVLW  02
1865:  MOVWF  70
1866:  MOVLW  FA
1867:  BSF    03.5
1868:  MOVWF  65
1869:  BCF    0A.4
186A:  BCF    0A.3
186B:  BCF    03.5
186C:  CALL   29E
186D:  BSF    0A.4
186E:  BSF    0A.3
186F:  DECFSZ 70,F
1870:  GOTO   066
....................  
....................   
....................    // unsigned int * temp; 
....................    // unsigned int id [2]; 
....................    // temp = inputId(); 
....................    // id[0] = temp[0]; 
....................    // id[1] = temp[1]; 
....................    // login(id); 
....................  
....................    // waitUpdate(); 
....................  
....................    // resetMemory(); 
....................  
....................    unsigned char option;  
....................    unsigned int * temp; 
....................    unsigned int id [2]; 
....................  
....................    resetMemory(); 
1871:  BCF    0A.4
1872:  BCF    0A.3
1873:  CALL   502
1874:  BSF    0A.4
1875:  BSF    0A.3
....................     
....................    int id10 [2] = {12,34}; 
1876:  MOVLW  0C
1877:  MOVWF  61
1878:  MOVLW  22
1879:  MOVWF  62
....................    int pass [4] = {1,2,3,4}; 
187A:  MOVLW  01
187B:  MOVWF  63
187C:  MOVLW  02
187D:  MOVWF  64
187E:  MOVLW  03
187F:  MOVWF  65
1880:  MOVLW  04
1881:  MOVWF  66
....................    saveUser(id10, pass, 1); 
1882:  BSF    03.5
1883:  CLRF   4A
1884:  MOVLW  61
1885:  MOVWF  49
1886:  CLRF   4C
1887:  MOVLW  63
1888:  MOVWF  4B
1889:  MOVLW  01
188A:  MOVWF  4D
188B:  BCF    0A.4
188C:  BCF    0A.3
188D:  BCF    03.5
188E:  CALL   629
188F:  BSF    0A.4
1890:  BSF    0A.3
....................    int id1 [2] = {14,0}; 
1891:  MOVLW  0E
1892:  MOVWF  67
1893:  CLRF   68
....................    saveUser(id1, pass, 0); 
1894:  BSF    03.5
1895:  CLRF   4A
1896:  MOVLW  67
1897:  MOVWF  49
1898:  CLRF   4C
1899:  MOVLW  63
189A:  MOVWF  4B
189B:  CLRF   4D
189C:  BCF    0A.4
189D:  BCF    0A.3
189E:  BCF    03.5
189F:  CALL   629
18A0:  BSF    0A.4
18A1:  BSF    0A.3
....................    int id2 [2] = {70,10}; 
18A2:  MOVLW  46
18A3:  MOVWF  69
18A4:  MOVLW  0A
18A5:  MOVWF  6A
....................    saveUser(id2, pass, 1); 
18A6:  BSF    03.5
18A7:  CLRF   4A
18A8:  MOVLW  69
18A9:  MOVWF  49
18AA:  CLRF   4C
18AB:  MOVLW  63
18AC:  MOVWF  4B
18AD:  MOVLW  01
18AE:  MOVWF  4D
18AF:  BCF    0A.4
18B0:  BCF    0A.3
18B1:  BCF    03.5
18B2:  CALL   629
18B3:  BSF    0A.4
18B4:  BSF    0A.3
....................    int id3 [2] = {0,10}; 
18B5:  CLRF   6B
18B6:  MOVLW  0A
18B7:  MOVWF  6C
....................    saveUser(id3, pass, 1); 
18B8:  BSF    03.5
18B9:  CLRF   4A
18BA:  MOVLW  6B
18BB:  MOVWF  49
18BC:  CLRF   4C
18BD:  MOVLW  63
18BE:  MOVWF  4B
18BF:  MOVLW  01
18C0:  MOVWF  4D
18C1:  BCF    0A.4
18C2:  BCF    0A.3
18C3:  BCF    03.5
18C4:  CALL   629
18C5:  BSF    0A.4
18C6:  BSF    0A.3
....................    int id4 [2] = {99,99}; 
18C7:  MOVLW  63
18C8:  MOVWF  6D
18C9:  MOVWF  6E
....................    saveUser(id4, pass, 3);//admin 
18CA:  BSF    03.5
18CB:  CLRF   4A
18CC:  MOVLW  6D
18CD:  MOVWF  49
18CE:  CLRF   4C
18CF:  MOVLW  63
18D0:  MOVWF  4B
18D1:  MOVLW  03
18D2:  MOVWF  4D
18D3:  BCF    0A.4
18D4:  BCF    0A.3
18D5:  BCF    03.5
18D6:  CALL   629
18D7:  BSF    0A.4
18D8:  BSF    0A.3
....................     
....................    int status; 
....................    do{ 
....................       printf(lcd_escreve,"\f1:Login|2:Admin"); 
18D9:  MOVLW  4A
18DA:  BSF    03.6
18DB:  MOVWF  0D
18DC:  MOVLW  02
18DD:  MOVWF  0F
18DE:  BCF    0A.4
18DF:  BCF    0A.3
18E0:  BCF    03.6
18E1:  CALL   396
18E2:  BSF    0A.4
18E3:  BSF    0A.3
....................       delay_ms(500); 
18E4:  MOVLW  02
18E5:  MOVWF  70
18E6:  MOVLW  FA
18E7:  BSF    03.5
18E8:  MOVWF  65
18E9:  BCF    0A.4
18EA:  BCF    0A.3
18EB:  BCF    03.5
18EC:  CALL   29E
18ED:  BSF    0A.4
18EE:  BSF    0A.3
18EF:  DECFSZ 70,F
18F0:  GOTO   0E6
....................       option = readKeyboard(); 
18F1:  BCF    0A.4
18F2:  CALL   000
18F3:  BSF    0A.4
18F4:  MOVF   78,W
18F5:  MOVWF  5C
....................  
....................       if(option != 255){ 
18F6:  INCFSZ 5C,W
18F7:  GOTO   0F9
18F8:  GOTO   203
....................          printf(lcd_escreve,"\r\n Option: %c", option); 
18F9:  MOVLW  53
18FA:  BSF    03.6
18FB:  MOVWF  0D
18FC:  MOVLW  02
18FD:  MOVWF  0F
18FE:  BCF    03.0
18FF:  MOVLW  0B
1900:  BSF    03.5
1901:  BCF    03.6
1902:  MOVWF  5F
1903:  BCF    0A.4
1904:  BCF    0A.3
1905:  BCF    03.5
1906:  CALL   6F6
1907:  BSF    0A.4
1908:  BSF    0A.3
1909:  MOVF   5C,W
190A:  BSF    03.5
190B:  MOVWF  64
190C:  BCF    0A.4
190D:  BCF    0A.3
190E:  BCF    03.5
190F:  CALL   353
1910:  BSF    0A.4
1911:  BSF    0A.3
....................          delay_ms(500); 
1912:  MOVLW  02
1913:  MOVWF  70
1914:  MOVLW  FA
1915:  BSF    03.5
1916:  MOVWF  65
1917:  BCF    0A.4
1918:  BCF    0A.3
1919:  BCF    03.5
191A:  CALL   29E
191B:  BSF    0A.4
191C:  BSF    0A.3
191D:  DECFSZ 70,F
191E:  GOTO   114
....................  
....................          switch(option){ 
191F:  MOVF   5C,W
1920:  XORLW  31
1921:  BTFSC  03.2
1922:  GOTO   127
1923:  XORLW  03
1924:  BTFSC  03.2
1925:  GOTO   1A1
1926:  GOTO   1E0
....................             case '1': 
....................                temp = inputId(); 
1927:  BCF    0A.4
1928:  CALL   3B8
1929:  BSF    0A.4
192A:  MOVF   79,W
192B:  MOVWF  5E
192C:  MOVF   78,W
192D:  MOVWF  5D
....................                id[0] = temp[0]; 
192E:  MOVF   5D,W
192F:  MOVWF  04
1930:  BCF    03.7
1931:  BTFSC  5E.0
1932:  BSF    03.7
1933:  MOVF   00,W
1934:  MOVWF  5F
....................                id[1] = temp[1]; 
1935:  MOVLW  01
1936:  ADDWF  5D,W
1937:  MOVWF  04
1938:  BCF    03.7
1939:  BTFSC  5E.0
193A:  BSF    03.7
193B:  MOVF   00,W
193C:  MOVWF  60
....................                status = login(id); 
193D:  CLRF   71
193E:  MOVLW  5F
193F:  MOVWF  70
1940:  BCF    0A.4
1941:  CALL   507
1942:  BSF    0A.4
1943:  MOVF   78,W
1944:  MOVWF  6F
....................                if(status == 1 || status == 3){ 
1945:  DECFSZ 6F,W
1946:  GOTO   148
1947:  GOTO   14C
1948:  MOVF   6F,W
1949:  SUBLW  03
194A:  BTFSS  03.2
194B:  GOTO   17D
....................                   printf(lcd_escreve,"\fBem Vindo(a)!"); 
194C:  MOVLW  5A
194D:  BSF    03.6
194E:  MOVWF  0D
194F:  MOVLW  02
1950:  MOVWF  0F
1951:  BCF    0A.4
1952:  BCF    0A.3
1953:  BCF    03.6
1954:  CALL   396
1955:  BSF    0A.4
1956:  BSF    0A.3
....................                   delay_ms(1000); 
1957:  MOVLW  04
1958:  MOVWF  70
1959:  MOVLW  FA
195A:  BSF    03.5
195B:  MOVWF  65
195C:  BCF    0A.4
195D:  BCF    0A.3
195E:  BCF    03.5
195F:  CALL   29E
1960:  BSF    0A.4
1961:  BSF    0A.3
1962:  DECFSZ 70,F
1963:  GOTO   159
....................                   printf(lcd_escreve,"\fLiga Led e Rele"); 
1964:  MOVLW  62
1965:  BSF    03.6
1966:  MOVWF  0D
1967:  MOVLW  02
1968:  MOVWF  0F
1969:  BCF    0A.4
196A:  BCF    0A.3
196B:  BCF    03.6
196C:  CALL   396
196D:  BSF    0A.4
196E:  BSF    0A.3
....................                   delay_ms(500); 
196F:  MOVLW  02
1970:  MOVWF  70
1971:  MOVLW  FA
1972:  BSF    03.5
1973:  MOVWF  65
1974:  BCF    0A.4
1975:  BCF    0A.3
1976:  BCF    03.5
1977:  CALL   29E
1978:  BSF    0A.4
1979:  BSF    0A.3
197A:  DECFSZ 70,F
197B:  GOTO   171
....................                }else{//Unpaid 
197C:  GOTO   1A0
....................                   printf(lcd_escreve,"\fConta Existe"); 
197D:  MOVLW  6B
197E:  BSF    03.6
197F:  MOVWF  0D
1980:  MOVLW  02
1981:  MOVWF  0F
1982:  BCF    0A.4
1983:  BCF    0A.3
1984:  BCF    03.6
1985:  CALL   396
1986:  BSF    0A.4
1987:  BSF    0A.3
....................                   printf(lcd_escreve,"\r\r,Mas Falta Pagar!"); 
1988:  MOVLW  72
1989:  BSF    03.6
198A:  MOVWF  0D
198B:  MOVLW  02
198C:  MOVWF  0F
198D:  BCF    0A.4
198E:  BCF    0A.3
198F:  BCF    03.6
1990:  CALL   396
1991:  BSF    0A.4
1992:  BSF    0A.3
....................                   delay_ms(1000); 
1993:  MOVLW  04
1994:  MOVWF  70
1995:  MOVLW  FA
1996:  BSF    03.5
1997:  MOVWF  65
1998:  BCF    0A.4
1999:  BCF    0A.3
199A:  BCF    03.5
199B:  CALL   29E
199C:  BSF    0A.4
199D:  BSF    0A.3
199E:  DECFSZ 70,F
199F:  GOTO   195
....................                } 
....................                break; 
19A0:  GOTO   203
....................             case '2': 
....................                temp = inputId(); 
19A1:  BCF    0A.4
19A2:  CALL   3B8
19A3:  BSF    0A.4
19A4:  MOVF   79,W
19A5:  MOVWF  5E
19A6:  MOVF   78,W
19A7:  MOVWF  5D
....................                id[0] = temp[0]; 
19A8:  MOVF   5D,W
19A9:  MOVWF  04
19AA:  BCF    03.7
19AB:  BTFSC  5E.0
19AC:  BSF    03.7
19AD:  MOVF   00,W
19AE:  MOVWF  5F
....................                id[1] = temp[1]; 
19AF:  MOVLW  01
19B0:  ADDWF  5D,W
19B1:  MOVWF  04
19B2:  BCF    03.7
19B3:  BTFSC  5E.0
19B4:  BSF    03.7
19B5:  MOVF   00,W
19B6:  MOVWF  60
....................                status = login(id); 
19B7:  CLRF   71
19B8:  MOVLW  5F
19B9:  MOVWF  70
19BA:  BCF    0A.4
19BB:  CALL   507
19BC:  BSF    0A.4
19BD:  MOVF   78,W
19BE:  MOVWF  6F
....................                if(status == 3){ 
19BF:  MOVF   6F,W
19C0:  SUBLW  03
19C1:  BTFSS  03.2
19C2:  GOTO   1C7
....................                   adminMenu(); 
19C3:  BCF    0A.3
19C4:  GOTO   000
19C5:  BSF    0A.3
....................                } 
19C6:  GOTO   1DF
....................                else{ 
....................                   printf(lcd_escreve,"\fN Permitido"); 
19C7:  MOVLW  7C
19C8:  BSF    03.6
19C9:  MOVWF  0D
19CA:  MOVLW  02
19CB:  MOVWF  0F
19CC:  BCF    0A.4
19CD:  BCF    0A.3
19CE:  BCF    03.6
19CF:  CALL   396
19D0:  BSF    0A.4
19D1:  BSF    0A.3
....................                   delay_ms(500); 
19D2:  MOVLW  02
19D3:  MOVWF  70
19D4:  MOVLW  FA
19D5:  BSF    03.5
19D6:  MOVWF  65
19D7:  BCF    0A.4
19D8:  BCF    0A.3
19D9:  BCF    03.5
19DA:  CALL   29E
19DB:  BSF    0A.4
19DC:  BSF    0A.3
19DD:  DECFSZ 70,F
19DE:  GOTO   1D4
....................                } 
....................                break; 
19DF:  GOTO   203
....................             default: 
....................                printf(lcd_escreve,"\fDigite um valor"); 
19E0:  MOVLW  83
19E1:  BSF    03.6
19E2:  MOVWF  0D
19E3:  MOVLW  02
19E4:  MOVWF  0F
19E5:  BCF    0A.4
19E6:  BCF    0A.3
19E7:  BCF    03.6
19E8:  CALL   396
19E9:  BSF    0A.4
19EA:  BSF    0A.3
....................                printf(lcd_escreve,"\r\nValido!"); 
19EB:  MOVLW  8C
19EC:  BSF    03.6
19ED:  MOVWF  0D
19EE:  MOVLW  02
19EF:  MOVWF  0F
19F0:  BCF    0A.4
19F1:  BCF    0A.3
19F2:  BCF    03.6
19F3:  CALL   396
19F4:  BSF    0A.4
19F5:  BSF    0A.3
....................                delay_ms(500); 
19F6:  MOVLW  02
19F7:  MOVWF  70
19F8:  MOVLW  FA
19F9:  BSF    03.5
19FA:  MOVWF  65
19FB:  BCF    0A.4
19FC:  BCF    0A.3
19FD:  BCF    03.5
19FE:  CALL   29E
19FF:  BSF    0A.4
1A00:  BSF    0A.3
1A01:  DECFSZ 70,F
1A02:  GOTO   1F8
....................                break; 
....................          } 
....................       } 
....................  
....................  
....................    }while(option != '5'); 
1A03:  MOVF   5C,W
1A04:  SUBLW  35
1A05:  BTFSS  03.2
1A06:  GOTO   0D9
....................  
.................... } 
....................  
1A07:  SLEEP

Configuration Fuses:
   Word  1: 3F32   HS NOWDT PUT NOBROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT

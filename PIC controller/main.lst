CCS PCM C Compiler, Version 5.025, 7201               20-Nov-21 19:34

               Filename:   E:\University\Microcontrollers\PCW Projects\eletronic-lock-system\PIC controller\main.lst

               ROM used:   3462 words (42%)
                           Largest free fragment is 2048
               RAM used:   59 (16%) at main() level
                           160 (43%) worst case
               Stack used: 6 locations (5 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  07
0001:  MOVWF  0A
0002:  GOTO   74F
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  BTFSS  0B.5
0028:  GOTO   02B
0029:  BTFSC  0B.2
002A:  GOTO   052
002B:  MOVLW  8C
002C:  MOVWF  04
002D:  BTFSS  00.0
002E:  GOTO   031
002F:  BTFSC  0C.0
0030:  GOTO   055
0031:  MOVF   22,W
0032:  MOVWF  04
0033:  MOVF   23,W
0034:  MOVWF  77
0035:  MOVF   24,W
0036:  MOVWF  78
0037:  MOVF   25,W
0038:  MOVWF  79
0039:  MOVF   26,W
003A:  MOVWF  7A
003B:  MOVF   27,W
003C:  BSF    03.6
003D:  MOVWF  0D
003E:  BCF    03.6
003F:  MOVF   28,W
0040:  BSF    03.6
0041:  MOVWF  0F
0042:  BCF    03.6
0043:  MOVF   29,W
0044:  BSF    03.6
0045:  MOVWF  0C
0046:  BCF    03.6
0047:  MOVF   2A,W
0048:  BSF    03.6
0049:  MOVWF  0E
004A:  BCF    03.6
004B:  MOVF   20,W
004C:  MOVWF  0A
004D:  SWAPF  21,W
004E:  MOVWF  03
004F:  SWAPF  7F,F
0050:  SWAPF  7F,W
0051:  RETFIE
0052:  BCF    0A.3
0053:  BCF    0A.4
0054:  GOTO   12F
0055:  BCF    0A.3
0056:  BCF    0A.4
0057:  GOTO   12B
....................  
.................... #include <16F877A.h> 
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
0058:  BCF    0A.0
0059:  BCF    0A.1
005A:  BCF    0A.2
005B:  ADDWF  02,F
005C:  RETLW  28
005D:  RETLW  0F
005E:  RETLW  01
005F:  RETLW  06
0060:  DATA 0D,05
0061:  DATA 69,32
0062:  DATA 5B,18
0063:  DATA 5D,1D
0064:  DATA A5,3A
0065:  DATA 00,00
0066:  DATA 8C,2A
0067:  DATA F3,3A
0068:  DATA 61,39
0069:  DATA E9,37
006A:  DATA A0,21
006B:  DATA 61,32
006C:  DATA E1,39
006D:  DATA 74,39
006E:  DATA 61,32
006F:  DATA 6F,00
0070:  DATA 8C,24
0071:  DATA 44,10
0072:  DATA 69,37
0073:  DATA E3,37
0074:  DATA 6D,38
0075:  DATA 61,3A
0076:  DATA 69,3B
0077:  DATA 65,36
0078:  DATA 00,01
0079:  DATA 0D,05
007A:  DATA D4,32
007B:  DATA 6E,3A
007C:  DATA 65,10
007D:  DATA EE,37
007E:  DATA F6,30
007F:  DATA ED,32
0080:  DATA 6E,3A
0081:  DATA 65,00
0082:  DATA 0C,10
0083:  DATA C2,3A
0084:  DATA 74,3A
0085:  DATA 6F,37
0086:  DATA 3A,10
0087:  DATA 25,32
0088:  DATA 00,10
0089:  DATA 0D,05
008A:  DATA D0,3B
008B:  DATA BA,12
008C:  DATA E4,12
008D:  DATA E4,12
008E:  DATA E4,12
008F:  DATA 64,10
0090:  DATA 53,3A
0091:  DATA BA,12
0092:  DATA 64,10
0093:  DATA 25,32
0094:  DATA 00,00
0095:  DATA 8C,24
0096:  DATA 44,10
0097:  DATA 45,37
0098:  DATA E3,37
0099:  DATA 6E,3A
009A:  DATA F2,30
009B:  DATA E4,37
009C:  DATA BA,12
009D:  DATA F5,12
009E:  DATA 75,00
009F:  DATA 0C,10
00A0:  DATA 49,22
00A1:  DATA 20,27
00A2:  DATA A0,22
00A3:  DATA EE,31
00A4:  DATA 6F,37
00A5:  DATA 74,39
00A6:  DATA 61,32
00A7:  DATA 6F,00
00A8:  DATA 0C,10
00A9:  DATA D5,39
00AA:  DATA 65,39
00AB:  DATA A0,32
00AC:  DATA F2,30
00AD:  DATA F3,32
00AE:  DATA 64,10
00AF:  DATA 00,00
00B0:  DATA 8C,20
00B1:  DATA 64,32
00B2:  DATA F2,32
00B3:  DATA F3,39
00B4:  DATA 3A,10
00B5:  DATA 25,32
00B6:  DATA 00,00
00B7:  DATA 8C,24
00B8:  DATA 44,1D
00B9:  DATA A5,3A
00BA:  DATA 2C,10
00BB:  DATA 45,3C
00BC:  DATA E9,39
00BD:  DATA F4,32
00BE:  DATA 00,01
00BF:  DATA 8C,24
00C0:  DATA 44,1D
00C1:  DATA A5,3A
00C2:  DATA 2C,10
00C3:  DATA 4E,10
00C4:  DATA 45,3C
00C5:  DATA E9,39
00C6:  DATA F4,32
00C7:  DATA 00,00
00C8:  DATA 0C,10
00C9:  DATA 4F,38
00CA:  DATA F4,34
00CB:  DATA 6F,37
00CC:  DATA 3A,10
00CD:  DATA A5,31
00CE:  DATA 00,01
00CF:  DATA 0C,22
00D0:  DATA E9,33
00D1:  DATA 69,3A
00D2:  DATA 65,10
00D3:  DATA 6F,10
00D4:  DATA 49,22
00D5:  DATA 00,01
00D6:  DATA 0C,2A
00D7:  DATA 79,38
00D8:  DATA 65,32
00D9:  DATA BA,12
00DA:  DATA 63,00
00DB:  DATA 8C,34
00DC:  DATA 64,1D
00DD:  DATA A0,12
00DE:  DATA F5,12
00DF:  DATA 75,00
00E0:  DATA 0C,22
00E1:  DATA E9,33
00E2:  DATA 69,3A
00E3:  DATA 65,10
00E4:  DATA 61,10
00E5:  DATA F3,32
00E6:  DATA 6E,34
00E7:  DATA 61,00
00E8:  DATA 0C,2A
00E9:  DATA 79,38
00EA:  DATA 65,32
00EB:  DATA BA,12
00EC:  DATA 63,00
00ED:  DATA 0C,28
00EE:  DATA C1,29
00EF:  DATA 53,14
00F0:  DATA B4,14
00F1:  DATA 3A,10
00F2:  DATA A5,3A
00F3:  DATA A5,3A
00F4:  DATA A5,3A
00F5:  DATA A5,3A
00F6:  DATA 00,01
00F7:  DATA 8C,29
00F8:  DATA F4,30
00F9:  DATA F4,3A
00FA:  DATA 73,14
00FB:  DATA 30,16
00FC:  DATA 31,16
00FD:  DATA B3,14
00FE:  DATA 3A,00
00FF:  DATA 0C,2A
0100:  DATA 79,38
0101:  DATA 65,32
0102:  DATA A0,29
0103:  DATA F4,30
0104:  DATA F4,3A
0105:  DATA 73,1D
0106:  DATA A5,31
0107:  DATA 00,01
0108:  DATA 8C,29
0109:  DATA D4,20
010A:  DATA D4,2A
010B:  DATA 53,1D
010C:  DATA A0,12
010D:  DATA 75,00
010E:  DATA 0C,10
010F:  DATA 20,10
0110:  DATA D4,22
0111:  DATA 43,26
0112:  DATA 41,22
0113:  DATA 4F,10
0114:  DATA 20,00
0115:  DATA 8C,20
0116:  DATA E4,36
0117:  DATA 69,37
0118:  DATA A0,22
0119:  DATA EE,31
011A:  DATA 6F,37
011B:  DATA 74,39
011C:  DATA 61,32
011D:  DATA 6F,00
011E:  DATA 0C,10
011F:  DATA 61,32
0120:  DATA ED,34
0121:  DATA EE,39
0122:  DATA 5B,18
0123:  DATA 5D,1D
0124:  DATA A0,12
0125:  DATA 64,00
0126:  DATA 8C,34
0127:  DATA 64,3F
0128:  DATA BA,12
0129:  DATA F5,12
012A:  DATA 75,00
*
0133:  DATA 0C,10
0134:  DATA A0,34
0135:  DATA EE,34
0136:  DATA E3,34
0137:  DATA 61,37
0138:  DATA E4,37
0139:  DATA 2E,17
013A:  DATA 2E,10
013B:  DATA 00,00
*
0243:  MOVF   0B,W
0244:  BSF    03.5
0245:  MOVWF  2C
0246:  BCF    03.5
0247:  BCF    0B.7
0248:  BSF    03.5
0249:  BSF    03.6
024A:  BSF    0C.7
024B:  BSF    0C.0
024C:  NOP
024D:  NOP
024E:  BCF    03.6
024F:  BTFSS  2C.7
0250:  GOTO   254
0251:  BCF    03.5
0252:  BSF    0B.7
0253:  BSF    03.5
0254:  BCF    03.5
0255:  BSF    03.6
0256:  MOVF   0C,W
0257:  ANDLW  7F
0258:  BTFSC  03.2
0259:  GOTO   2B5
025A:  BSF    03.5
025B:  BCF    03.6
025C:  MOVWF  2C
025D:  BCF    03.5
025E:  BSF    03.6
025F:  MOVF   0D,W
0260:  BSF    03.5
0261:  BCF    03.6
0262:  MOVWF  2D
0263:  BCF    03.5
0264:  BSF    03.6
0265:  MOVF   0F,W
0266:  BSF    03.5
0267:  BCF    03.6
0268:  MOVWF  2E
0269:  MOVF   2C,W
026A:  MOVWF  30
026B:  BCF    03.5
026C:  CALL   200
026D:  BSF    03.5
026E:  MOVF   2D,W
026F:  BCF    03.5
0270:  BSF    03.6
0271:  MOVWF  0D
0272:  BSF    03.5
0273:  BCF    03.6
0274:  MOVF   2E,W
0275:  BCF    03.5
0276:  BSF    03.6
0277:  MOVWF  0F
0278:  BCF    03.6
0279:  MOVF   0B,W
027A:  BSF    03.5
027B:  MOVWF  2F
027C:  BCF    03.5
027D:  BCF    0B.7
027E:  BSF    03.5
027F:  BSF    03.6
0280:  BSF    0C.7
0281:  BSF    0C.0
0282:  NOP
0283:  NOP
0284:  BCF    03.6
0285:  BTFSS  2F.7
0286:  GOTO   28A
0287:  BCF    03.5
0288:  BSF    0B.7
0289:  BSF    03.5
028A:  BCF    03.5
028B:  BSF    03.6
028C:  RLF    0C,W
028D:  RLF    0E,W
028E:  ANDLW  7F
028F:  BTFSC  03.2
0290:  GOTO   2B5
0291:  BSF    03.5
0292:  BCF    03.6
0293:  MOVWF  2C
0294:  BCF    03.5
0295:  BSF    03.6
0296:  MOVF   0D,W
0297:  BSF    03.5
0298:  BCF    03.6
0299:  MOVWF  2D
029A:  BCF    03.5
029B:  BSF    03.6
029C:  MOVF   0F,W
029D:  BSF    03.5
029E:  BCF    03.6
029F:  MOVWF  2E
02A0:  MOVF   2C,W
02A1:  MOVWF  30
02A2:  BCF    03.5
02A3:  CALL   200
02A4:  BSF    03.5
02A5:  MOVF   2D,W
02A6:  BCF    03.5
02A7:  BSF    03.6
02A8:  MOVWF  0D
02A9:  BSF    03.5
02AA:  BCF    03.6
02AB:  MOVF   2E,W
02AC:  BCF    03.5
02AD:  BSF    03.6
02AE:  MOVWF  0F
02AF:  INCF   0D,F
02B0:  BTFSC  03.2
02B1:  INCF   0F,F
02B2:  BCF    03.6
02B3:  GOTO   243
02B4:  BSF    03.6
02B5:  BCF    03.6
02B6:  RETURN
*
05F2:  MOVF   0B,W
05F3:  BSF    03.5
05F4:  MOVWF  2D
05F5:  BCF    03.5
05F6:  BCF    0B.7
05F7:  BSF    03.5
05F8:  BSF    03.6
05F9:  BSF    0C.7
05FA:  BSF    0C.0
05FB:  NOP
05FC:  NOP
05FD:  BCF    03.6
05FE:  BTFSS  2D.7
05FF:  GOTO   603
0600:  BCF    03.5
0601:  BSF    0B.7
0602:  BSF    03.5
0603:  BTFSC  03.0
0604:  GOTO   63C
0605:  BCF    03.5
0606:  BSF    03.6
0607:  MOVF   0C,W
0608:  ANDLW  7F
0609:  BSF    03.5
060A:  BCF    03.6
060B:  MOVWF  2D
060C:  BCF    03.5
060D:  BSF    03.6
060E:  MOVF   0D,W
060F:  BSF    03.5
0610:  BCF    03.6
0611:  MOVWF  2E
0612:  BCF    03.5
0613:  BSF    03.6
0614:  MOVF   0F,W
0615:  BSF    03.5
0616:  BCF    03.6
0617:  MOVWF  2F
0618:  MOVF   2D,W
0619:  MOVWF  30
061A:  BCF    03.5
061B:  CALL   200
061C:  BSF    03.5
061D:  MOVF   2E,W
061E:  BCF    03.5
061F:  BSF    03.6
0620:  MOVWF  0D
0621:  BSF    03.5
0622:  BCF    03.6
0623:  MOVF   2F,W
0624:  BCF    03.5
0625:  BSF    03.6
0626:  MOVWF  0F
0627:  BCF    03.6
0628:  MOVF   0B,W
0629:  BSF    03.5
062A:  MOVWF  30
062B:  BCF    03.5
062C:  BCF    0B.7
062D:  BSF    03.5
062E:  BSF    03.6
062F:  BSF    0C.7
0630:  BSF    0C.0
0631:  NOP
0632:  NOP
0633:  BCF    03.6
0634:  BTFSS  30.7
0635:  GOTO   639
0636:  BCF    03.5
0637:  BSF    0B.7
0638:  BSF    03.5
0639:  DECFSZ 2C,F
063A:  GOTO   63C
063B:  GOTO   66A
063C:  BCF    03.5
063D:  BSF    03.6
063E:  RLF    0C,W
063F:  RLF    0E,W
0640:  ANDLW  7F
0641:  BSF    03.5
0642:  BCF    03.6
0643:  MOVWF  2D
0644:  BCF    03.5
0645:  BSF    03.6
0646:  MOVF   0D,W
0647:  BSF    03.5
0648:  BCF    03.6
0649:  MOVWF  2E
064A:  BCF    03.5
064B:  BSF    03.6
064C:  MOVF   0F,W
064D:  BSF    03.5
064E:  BCF    03.6
064F:  MOVWF  2F
0650:  MOVF   2D,W
0651:  MOVWF  30
0652:  BCF    03.5
0653:  CALL   200
0654:  BSF    03.5
0655:  MOVF   2E,W
0656:  BCF    03.5
0657:  BSF    03.6
0658:  MOVWF  0D
0659:  BSF    03.5
065A:  BCF    03.6
065B:  MOVF   2F,W
065C:  BCF    03.5
065D:  BSF    03.6
065E:  MOVWF  0F
065F:  INCF   0D,F
0660:  BTFSC  03.2
0661:  INCF   0F,F
0662:  BCF    03.0
0663:  BSF    03.5
0664:  BCF    03.6
0665:  DECFSZ 2C,F
0666:  GOTO   668
0667:  GOTO   66A
0668:  BCF    03.5
0669:  GOTO   5F2
066A:  BCF    03.5
066B:  RETURN
*
0697:  BSF    03.5
0698:  MOVF   30,W
0699:  CLRF   78
069A:  SUBWF  2F,W
069B:  BTFSC  03.0
069C:  GOTO   6A0
069D:  MOVF   2F,W
069E:  MOVWF  77
069F:  GOTO   6AC
06A0:  CLRF   77
06A1:  MOVLW  08
06A2:  MOVWF  31
06A3:  RLF    2F,F
06A4:  RLF    77,F
06A5:  MOVF   30,W
06A6:  SUBWF  77,W
06A7:  BTFSC  03.0
06A8:  MOVWF  77
06A9:  RLF    78,F
06AA:  DECFSZ 31,F
06AB:  GOTO   6A3
06AC:  BCF    03.5
06AD:  RETURN
06AE:  MOVF   78,W
06AF:  BSF    03.5
06B0:  MOVF   2C,W
06B1:  MOVWF  2F
06B2:  MOVLW  64
06B3:  MOVWF  30
06B4:  BCF    03.5
06B5:  CALL   697
06B6:  MOVF   77,W
06B7:  BSF    03.5
06B8:  MOVWF  2C
06B9:  MOVF   78,W
06BA:  MOVLW  30
06BB:  BTFSS  03.2
06BC:  GOTO   6C4
06BD:  BTFSS  2D.1
06BE:  GOTO   6CD
06BF:  BTFSC  2D.3
06C0:  GOTO   6CD
06C1:  BTFSC  2D.4
06C2:  MOVLW  20
06C3:  GOTO   6C7
06C4:  BCF    2D.3
06C5:  BCF    2D.4
06C6:  BSF    2D.0
06C7:  ADDWF  78,F
06C8:  MOVF   78,W
06C9:  MOVWF  30
06CA:  BCF    03.5
06CB:  CALL   200
06CC:  BSF    03.5
06CD:  MOVF   2C,W
06CE:  MOVWF  2F
06CF:  MOVLW  0A
06D0:  MOVWF  30
06D1:  BCF    03.5
06D2:  CALL   697
06D3:  MOVF   77,W
06D4:  BSF    03.5
06D5:  MOVWF  2C
06D6:  MOVF   78,W
06D7:  MOVLW  30
06D8:  BTFSS  03.2
06D9:  GOTO   6E0
06DA:  BTFSC  2D.3
06DB:  GOTO   6E6
06DC:  BTFSS  2D.0
06DD:  GOTO   6E6
06DE:  BTFSC  2D.4
06DF:  MOVLW  20
06E0:  ADDWF  78,F
06E1:  MOVF   78,W
06E2:  MOVWF  30
06E3:  BCF    03.5
06E4:  CALL   200
06E5:  BSF    03.5
06E6:  MOVLW  30
06E7:  ADDWF  2C,F
06E8:  MOVF   2C,W
06E9:  MOVWF  30
06EA:  BCF    03.5
06EB:  CALL   200
06EC:  RETURN
*
0977:  MOVF   56,W
0978:  XORWF  58,W
0979:  ANDLW  80
097A:  MOVWF  5A
097B:  BTFSS  56.7
097C:  GOTO   182
097D:  COMF   55,F
097E:  COMF   56,F
097F:  INCF   55,F
0980:  BTFSC  03.2
0981:  INCF   56,F
0982:  BTFSS  58.7
0983:  GOTO   189
0984:  COMF   57,F
0985:  COMF   58,F
0986:  INCF   57,F
0987:  BTFSC  03.2
0988:  INCF   58,F
0989:  MOVLW  10
098A:  MOVWF  59
098B:  CLRF   77
098C:  CLRF   7A
098D:  RRF    56,F
098E:  RRF    55,F
098F:  BTFSS  03.0
0990:  GOTO   197
0991:  MOVF   57,W
0992:  ADDWF  77,F
0993:  BTFSC  03.0
0994:  INCF   7A,F
0995:  MOVF   58,W
0996:  ADDWF  7A,F
0997:  RRF    7A,F
0998:  RRF    77,F
0999:  RRF    79,F
099A:  RRF    78,F
099B:  DECFSZ 59,F
099C:  GOTO   18D
099D:  BTFSS  5A.7
099E:  GOTO   1A4
099F:  COMF   78,F
09A0:  COMF   79,F
09A1:  INCF   78,F
09A2:  BTFSC  03.2
09A3:  INCF   79,F
*
0CCD:  MOVLW  20
0CCE:  BTFSS  2A.4
0CCF:  MOVLW  30
0CD0:  MOVWF  2B
0CD1:  MOVF   29,W
0CD2:  MOVWF  77
0CD3:  BTFSS  29.7
0CD4:  GOTO   4DD
0CD5:  COMF   77,F
0CD6:  INCF   77,F
0CD7:  MOVF   77,W
0CD8:  MOVWF  29
0CD9:  MOVLW  2D
0CDA:  MOVWF  2B
0CDB:  BSF    2A.7
0CDC:  BSF    2A.0
0CDD:  MOVF   29,W
0CDE:  MOVWF  2F
0CDF:  MOVLW  64
0CE0:  MOVWF  30
0CE1:  BCF    0A.3
0CE2:  BCF    03.5
0CE3:  CALL   697
0CE4:  BSF    0A.3
0CE5:  MOVF   77,W
0CE6:  BSF    03.5
0CE7:  MOVWF  29
0CE8:  MOVLW  30
0CE9:  ADDWF  78,W
0CEA:  MOVWF  2C
0CEB:  MOVF   29,W
0CEC:  MOVWF  2F
0CED:  MOVLW  0A
0CEE:  MOVWF  30
0CEF:  BCF    0A.3
0CF0:  BCF    03.5
0CF1:  CALL   697
0CF2:  BSF    0A.3
0CF3:  MOVLW  30
0CF4:  ADDWF  77,W
0CF5:  BSF    03.5
0CF6:  MOVWF  2E
0CF7:  MOVLW  30
0CF8:  ADDWF  78,W
0CF9:  MOVWF  2D
0CFA:  MOVF   2B,W
0CFB:  MOVWF  77
0CFC:  MOVLW  30
0CFD:  SUBWF  2C,W
0CFE:  BTFSC  03.2
0CFF:  GOTO   504
0D00:  BSF    2A.1
0D01:  BTFSC  2A.7
0D02:  BSF    2A.2
0D03:  GOTO   518
0D04:  MOVF   2B,W
0D05:  MOVWF  2C
0D06:  MOVLW  20
0D07:  MOVWF  2B
0D08:  MOVLW  30
0D09:  SUBWF  2D,W
0D0A:  BTFSC  03.2
0D0B:  GOTO   510
0D0C:  BSF    2A.0
0D0D:  BTFSC  2A.7
0D0E:  BSF    2A.1
0D0F:  GOTO   518
0D10:  BTFSS  03.2
0D11:  BSF    2A.0
0D12:  BTFSS  03.2
0D13:  GOTO   518
0D14:  MOVF   2C,W
0D15:  MOVWF  2D
0D16:  MOVLW  20
0D17:  MOVWF  2C
0D18:  BTFSC  2A.2
0D19:  GOTO   51F
0D1A:  BTFSC  2A.1
0D1B:  GOTO   526
0D1C:  BTFSC  2A.0
0D1D:  GOTO   52D
0D1E:  GOTO   534
0D1F:  MOVF   2B,W
0D20:  MOVWF  30
0D21:  BCF    0A.3
0D22:  BCF    03.5
0D23:  CALL   200
0D24:  BSF    0A.3
0D25:  BSF    03.5
0D26:  MOVF   2C,W
0D27:  MOVWF  30
0D28:  BCF    0A.3
0D29:  BCF    03.5
0D2A:  CALL   200
0D2B:  BSF    0A.3
0D2C:  BSF    03.5
0D2D:  MOVF   2D,W
0D2E:  MOVWF  30
0D2F:  BCF    0A.3
0D30:  BCF    03.5
0D31:  CALL   200
0D32:  BSF    0A.3
0D33:  BSF    03.5
0D34:  MOVF   2E,W
0D35:  MOVWF  30
0D36:  BCF    0A.3
0D37:  BCF    03.5
0D38:  CALL   200
0D39:  BSF    0A.3
....................  
.................... #list 
....................  
.................... #device ADC=8 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES HS  
....................  
.................... #use delay(crystal=20000000) 
*
0149:  MOVLW  B1
014A:  MOVWF  04
014B:  BCF    03.7
014C:  MOVF   00,W
014D:  BTFSC  03.2
014E:  GOTO   15C
014F:  MOVLW  06
0150:  MOVWF  78
0151:  CLRF   77
0152:  DECFSZ 77,F
0153:  GOTO   152
0154:  DECFSZ 78,F
0155:  GOTO   151
0156:  MOVLW  7B
0157:  MOVWF  77
0158:  DECFSZ 77,F
0159:  GOTO   158
015A:  DECFSZ 00,F
015B:  GOTO   14F
015C:  RETURN
.................... //#use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=PORT1) 
....................  
....................  
.................... // -------Variables' Declaration 
.................... #define RX_BUFFER_SIZE 10 
.................... #define BLOCK_SIZE sizeof(User)  
.................... signed int8 address_data_delete; 
.................... int8 rx_wr_index = 0; 
.................... int8 lock_pos = 0, rxd, read, valid_data_count; 
.................... int data_avail = FALSE, got_id = FALSE; 
.................... unsigned int8 rx_buffer[RX_BUFFER_SIZE]; 
.................... #include "functions.c" 
.................... #include "functions.h" 
....................  
.................... //Define the default pins before calling the LCD driver 
.................... #ifndef lcd_enable  
....................    #define lcd_enable     pin_e1 
....................    #define lcd_rs         pin_e2 
....................    //#define lcd_rw       pin_e2   
....................    #define lcd_d4         pin_d4 
....................    #define lcd_d5         pin_d5 
....................    #define lcd_d6         pin_d6 
....................    #define lcd_d7         pin_d7 
.................... #endif 
....................  
.................... #include "mod_lcd.c" 
.................... /************************************************************************/ 
.................... /*  MOD_LCD.C - Biblioteca de manipulaï¿½ï¿½o de mï¿½dulo LCD                 */ 
.................... /*                                                                      */ 
.................... /*  Autor: Fï¿½bio Pereira                                                */ 
.................... /*                                                                      */ 
.................... /************************************************************************/ 
....................  
.................... // As definiï¿½ï¿½es a seguir sï¿½o utilizadas para acesso aos pinos do display 
.................... // caso o pino RW nï¿½o seja utilizado, comente a definiï¿½ï¿½o lcd_rw 
.................... #ifndef lcd_enable 
.................... 	#define lcd_enable 		pin_e1		// pino enable do LCD 
.................... 	#define lcd_rs			pin_e0		// pino rs do LCD 
.................... 	//#define lcd_rw		pin_e2		// pino rw do LCD 
.................... 	#define lcd_d4			pin_d4		// pino de dados d4 do LCD 
.................... 	#define lcd_d5			pin_d5		// pino de dados d5 do LCD 
.................... 	#define lcd_d6			pin_d6		// pino de dados d6 do LCD 
.................... 	#define lcd_d7			pin_d7		// pino de dados d7 do LCD 
.................... #endif 
....................  
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 linhas 
.................... #define lcd_seg_lin 0x40    // Endereï¿½o da segunda linha na RAM do LCD 
....................  
.................... // a constante abaixo define a seqï¿½ï¿½ncia de inicializaï¿½ï¿½o do mï¿½dulo LCD 
.................... byte CONST INI_LCD[4] = {0x20 | (lcd_type << 2), 0xf, 1, 6}; 
....................  
.................... byte lcd_le_byte() 
.................... // lï¿½ um byte do LCD (somente com pino RW) 
.................... { 
.................... 	byte dado; 
.................... 	// configura os pinos de dados como entradas 
.................... 	input(lcd_d4); 
.................... 	input(lcd_d5); 
.................... 	input(lcd_d6); 
.................... 	input(lcd_d7); 
.................... 	// se o pino rw for utilizado, coloca em 1 
.................... 	#ifdef lcd_rw 
.................... 		output_high(lcd_rw); 
.................... 	#endif 
....................    output_high(lcd_enable); // habilita display 
.................... 	dado = 0;	// zera a variï¿½vel de leitura 
.................... 	// lï¿½ os quatro bits mais significativos 
.................... 	if (input(lcd_d7)) bit_set(dado,7); 
.................... 	if (input(lcd_d6)) bit_set(dado,6); 
.................... 	if (input(lcd_d5)) bit_set(dado,5); 
.................... 	if (input(lcd_d4)) bit_set(dado,4); 
.................... 	// dï¿½ um pulso na linha enable 
.................... 	output_low(lcd_enable); 
.................... 	output_high(lcd_enable); 
.................... 	// lï¿½ os quatro bits menos significativos 
.................... 	if (input(lcd_d7)) bit_set(dado,3); 
.................... 	if (input(lcd_d6)) bit_set(dado,2); 
.................... 	if (input(lcd_d5)) bit_set(dado,1); 
.................... 	if (input(lcd_d4)) bit_set(dado,0); 
.................... 	output_low(lcd_enable);	// desabilita o display 
.................... 	return dado;	// retorna o byte lido 
.................... } 
....................  
.................... void lcd_envia_nibble( byte dado ) 
.................... // envia um dado de quatro bits para o display 
.................... { 
.................... 	// coloca os quatro bits nas saidas 
.................... 	output_bit(lcd_d4,bit_test(dado,0)); 
015D:  BSF    03.5
015E:  BTFSC  38.0
015F:  GOTO   164
0160:  BCF    03.5
0161:  BCF    08.4
0162:  GOTO   166
0163:  BSF    03.5
0164:  BCF    03.5
0165:  BSF    08.4
0166:  BSF    03.5
0167:  BCF    08.4
.................... 	output_bit(lcd_d5,bit_test(dado,1)); 
0168:  BTFSC  38.1
0169:  GOTO   16E
016A:  BCF    03.5
016B:  BCF    08.5
016C:  GOTO   170
016D:  BSF    03.5
016E:  BCF    03.5
016F:  BSF    08.5
0170:  BSF    03.5
0171:  BCF    08.5
.................... 	output_bit(lcd_d6,bit_test(dado,2)); 
0172:  BTFSC  38.2
0173:  GOTO   178
0174:  BCF    03.5
0175:  BCF    08.6
0176:  GOTO   17A
0177:  BSF    03.5
0178:  BCF    03.5
0179:  BSF    08.6
017A:  BSF    03.5
017B:  BCF    08.6
.................... 	output_bit(lcd_d7,bit_test(dado,3)); 
017C:  BTFSC  38.3
017D:  GOTO   182
017E:  BCF    03.5
017F:  BCF    08.7
0180:  GOTO   184
0181:  BSF    03.5
0182:  BCF    03.5
0183:  BSF    08.7
0184:  BSF    03.5
0185:  BCF    08.7
.................... 	// dï¿½ um pulso na linha enable 
.................... 	output_high(lcd_enable); 
0186:  BCF    09.1
0187:  BCF    03.5
0188:  BSF    09.1
.................... 	output_low(lcd_enable); 
0189:  BSF    03.5
018A:  BCF    09.1
018B:  BCF    03.5
018C:  BCF    09.1
018D:  RETURN
.................... } 
....................  
....................  
.................... void lcd_envia_byte( boolean endereco, byte dado ) 
.................... { 
.................... 	// coloca a linha rs em 0 
.................... 	output_low(lcd_rs); 
018E:  BSF    03.5
018F:  BCF    09.2
0190:  BCF    03.5
0191:  BCF    09.2
.................... 	// aguarda o display ficar desocupado 
.................... 	//while ( bit_test(lcd_le_byte(),7) ) ; 
.................... 	// configura a linha rs dependendo do modo selecionado 
.................... 	output_bit(lcd_rs,endereco); 
0192:  BSF    03.5
0193:  MOVF   35,F
0194:  BTFSS  03.2
0195:  GOTO   19A
0196:  BCF    03.5
0197:  BCF    09.2
0198:  GOTO   19C
0199:  BSF    03.5
019A:  BCF    03.5
019B:  BSF    09.2
019C:  BSF    03.5
019D:  BCF    09.2
.................... 	delay_us(100);	// aguarda 100 us 
019E:  MOVLW  A6
019F:  MOVWF  77
01A0:  DECFSZ 77,F
01A1:  GOTO   1A0
01A2:  NOP
.................... 	// caso a linha rw esteja definida, coloca em 0 
.................... 	#ifdef lcd_rw 
.................... 		output_low(lcd_rw); 
.................... 	#endif 
.................... 	// desativa linha enable 
.................... 	output_low(lcd_enable); 
01A3:  BCF    09.1
01A4:  BCF    03.5
01A5:  BCF    09.1
.................... 	// envia a primeira parte do byte 
.................... 	lcd_envia_nibble(dado >> 4); 
01A6:  BSF    03.5
01A7:  SWAPF  36,W
01A8:  MOVWF  37
01A9:  MOVLW  0F
01AA:  ANDWF  37,F
01AB:  MOVF   37,W
01AC:  MOVWF  38
01AD:  BCF    03.5
01AE:  CALL   15D
.................... 	// envia a segunda parte do byte 
.................... 	lcd_envia_nibble(dado & 0x0f); 
01AF:  BSF    03.5
01B0:  MOVF   36,W
01B1:  ANDLW  0F
01B2:  MOVWF  37
01B3:  MOVWF  38
01B4:  BCF    03.5
01B5:  CALL   15D
01B6:  RETURN
.................... } 
....................  
....................  
.................... void lcd_ini() 
.................... // rotina de inicializaï¿½ï¿½o do display 
.................... { 
.................... 	byte conta; 
.................... 	output_low(lcd_d4); 
01B7:  BSF    03.5
01B8:  BCF    08.4
01B9:  BCF    03.5
01BA:  BCF    08.4
.................... 	output_low(lcd_d5); 
01BB:  BSF    03.5
01BC:  BCF    08.5
01BD:  BCF    03.5
01BE:  BCF    08.5
.................... 	output_low(lcd_d6); 
01BF:  BSF    03.5
01C0:  BCF    08.6
01C1:  BCF    03.5
01C2:  BCF    08.6
.................... 	output_low(lcd_d7); 
01C3:  BSF    03.5
01C4:  BCF    08.7
01C5:  BCF    03.5
01C6:  BCF    08.7
.................... 	output_low(lcd_rs); 
01C7:  BSF    03.5
01C8:  BCF    09.2
01C9:  BCF    03.5
01CA:  BCF    09.2
.................... 	#ifdef lcd_rw 
.................... 		output_high(lcd_rw); 
.................... 	#endif 
.................... 	output_low(lcd_enable); 
01CB:  BSF    03.5
01CC:  BCF    09.1
01CD:  BCF    03.5
01CE:  BCF    09.1
.................... 	delay_ms(15); 
01CF:  MOVLW  0F
01D0:  BSF    03.5
01D1:  MOVWF  31
01D2:  BCF    03.5
01D3:  CALL   149
.................... 	// envia uma seqï¿½ï¿½ncia de 3 vezes 0x03 
.................... 	// e depois 0x02 para configurar o mï¿½dulo 
.................... 	// para modo de 4 bits 
.................... 	for(conta=1;conta<=3;++conta) 
01D4:  MOVLW  01
01D5:  MOVWF  55
01D6:  MOVF   55,W
01D7:  SUBLW  03
01D8:  BTFSS  03.0
01D9:  GOTO   1E6
.................... 	{ 
.................... 		lcd_envia_nibble(3); 
01DA:  MOVLW  03
01DB:  BSF    03.5
01DC:  MOVWF  38
01DD:  BCF    03.5
01DE:  CALL   15D
.................... 		delay_ms(5); 
01DF:  MOVLW  05
01E0:  BSF    03.5
01E1:  MOVWF  31
01E2:  BCF    03.5
01E3:  CALL   149
01E4:  INCF   55,F
01E5:  GOTO   1D6
.................... 	} 
.................... 	lcd_envia_nibble(2); 
01E6:  MOVLW  02
01E7:  BSF    03.5
01E8:  MOVWF  38
01E9:  BCF    03.5
01EA:  CALL   15D
.................... 	// envia string de inicializaï¿½ï¿½o do display 
.................... 	for(conta=0;conta<=3;++conta) lcd_envia_byte(0,INI_LCD[conta]); 
01EB:  CLRF   55
01EC:  MOVF   55,W
01ED:  SUBLW  03
01EE:  BTFSS  03.0
01EF:  GOTO   1FD
01F0:  MOVF   55,W
01F1:  CALL   058
01F2:  MOVWF  56
01F3:  BSF    03.5
01F4:  CLRF   35
01F5:  BCF    03.5
01F6:  MOVF   56,W
01F7:  BSF    03.5
01F8:  MOVWF  36
01F9:  BCF    03.5
01FA:  CALL   18E
01FB:  INCF   55,F
01FC:  GOTO   1EC
01FD:  BCF    0A.3
01FE:  BCF    0A.4
01FF:  GOTO   782 (RETURN)
.................... } 
....................  
.................... void lcd_pos_xy( byte x, byte y) 
.................... { 
....................    byte endereco; 
....................    if(y!=1) 
*
0221:  DECFSZ 32,W
0222:  GOTO   224
0223:  GOTO   227
....................    	endereco = lcd_seg_lin; 
0224:  MOVLW  40
0225:  MOVWF  33
0226:  GOTO   228
....................    else 
....................    	endereco = 0; 
0227:  CLRF   33
....................    endereco += x-1; 
0228:  MOVLW  01
0229:  SUBWF  31,W
022A:  ADDWF  33,F
....................    lcd_envia_byte(0,0x80|endereco); 
022B:  MOVF   33,W
022C:  IORLW  80
022D:  MOVWF  34
022E:  CLRF   35
022F:  MOVF   34,W
0230:  MOVWF  36
0231:  BCF    03.5
0232:  CALL   18E
.................... } 
....................  
.................... void lcd_escreve( char c) 
.................... // envia caractere para o display 
.................... { 
....................    switch (c) 
*
0200:  BSF    03.5
0201:  MOVF   30,W
0202:  XORLW  0C
0203:  BCF    03.5
0204:  BTFSC  03.2
0205:  GOTO   210
0206:  XORLW  06
0207:  BTFSC  03.2
0208:  GOTO   21C
0209:  XORLW  07
020A:  BTFSC  03.2
020B:  GOTO   21C
020C:  XORLW  05
020D:  BTFSC  03.2
020E:  GOTO   234
020F:  GOTO   23B
.................... 	{ 
....................      case '\f' 	:	lcd_envia_byte(0,1); 
0210:  BSF    03.5
0211:  CLRF   35
0212:  MOVLW  01
0213:  MOVWF  36
0214:  BCF    03.5
0215:  CALL   18E
.................... 	  			delay_ms(2); 
0216:  MOVLW  02
0217:  BSF    03.5
0218:  MOVWF  31
0219:  BCF    03.5
021A:  CALL   149
.................... 				break; 
021B:  GOTO   242
....................      case '\n'	: 
.................... 	   case '\r' 	:	lcd_pos_xy(1,2); 
021C:  MOVLW  01
021D:  BSF    03.5
021E:  MOVWF  31
021F:  MOVLW  02
0220:  MOVWF  32
.................... 	  			break; 
*
0233:  GOTO   242
....................      case '\b' 	:	lcd_envia_byte(0,0x10); 
0234:  BSF    03.5
0235:  CLRF   35
0236:  MOVLW  10
0237:  MOVWF  36
0238:  BCF    03.5
0239:  CALL   18E
.................... 	  			break; 
023A:  GOTO   242
....................      default	:	lcd_envia_byte(1,c); 
023B:  MOVLW  01
023C:  BSF    03.5
023D:  MOVWF  35
023E:  MOVF   30,W
023F:  MOVWF  36
0240:  BCF    03.5
0241:  CALL   18E
.................... 	  			break; 
....................    } 
0242:  RETURN
.................... } 
....................  
.................... char lcd_le( byte x, byte y) 
.................... // le caractere do display 
.................... { 
.................... 	char valor; 
.................... 	// seleciona a posiï¿½ï¿½o do caractere 
.................... 	lcd_pos_xy(x,y); 
.................... 	// ativa rs 
.................... 	output_high(lcd_rs); 
.................... 	// lï¿½ o caractere 
.................... 	valor = lcd_le_byte(); 
.................... 	// desativa rs 
.................... 	output_low(lcd_rs); 
.................... 	// retorna o valor do caractere 
.................... 	return valor; 
.................... } 
....................  
....................  
.................... #include "2401.c" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a MicroChip 24LC01B configured for a x8 org         //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);  Read the byte d from the address a     //// 
.................... ////                                                                   //// 
.................... ////   b = ext_eeprom_ready();  Returns TRUE if the eeprom is ready    //// 
.................... ////                            to receive opcodes                     //// 
.................... ////                                                                   //// 
.................... ////   The main program may define EEPROM_SDA                          //// 
.................... ////   and EEPROM_SCL to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... ////                            Pin Layout                             //// 
.................... ////   -----------------------------------------------------------     //// 
.................... ////   |                                                         |     //// 
.................... ////   | 1: NC   Not Connected | 8: VCC   +5V                    |     //// 
.................... ////   |                       |                                 |     //// 
.................... ////   | 2: NC   Not Connected | 7: WP    GND                    |     //// 
.................... ////   |                       |                                 |     //// 
.................... ////   | 3: NC   Not Connected | 6: SCL   EEPROM_SCL and Pull-Up |     //// 
.................... ////   |                       |                                 |     //// 
.................... ////   | 4: VSS  GND           | 5: SDA   EEPROM_SDA and Pull-Up |     //// 
.................... ////   -----------------------------------------------------------     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2003 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef EEPROM_SDA 
....................  
.................... #define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C3 
....................  
.................... #endif 
....................  
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
02B7:  MOVLW  08
02B8:  MOVWF  78
02B9:  MOVLW  04
02BA:  MOVWF  77
02BB:  DECFSZ 77,F
02BC:  GOTO   2BB
02BD:  BCF    07.3
02BE:  BCF    3D.3
02BF:  MOVF   3D,W
02C0:  BSF    03.5
02C1:  MOVWF  07
02C2:  MOVLW  03
02C3:  MOVWF  77
02C4:  DECFSZ 77,F
02C5:  GOTO   2C4
02C6:  RLF    30,F
02C7:  BCF    03.5
02C8:  BCF    07.4
02C9:  BTFSS  03.0
02CA:  GOTO   2D1
02CB:  BSF    3D.4
02CC:  MOVF   3D,W
02CD:  BSF    03.5
02CE:  MOVWF  07
02CF:  GOTO   2D5
02D0:  BCF    03.5
02D1:  BCF    3D.4
02D2:  MOVF   3D,W
02D3:  BSF    03.5
02D4:  MOVWF  07
02D5:  NOP
02D6:  BCF    03.5
02D7:  BSF    3D.3
02D8:  MOVF   3D,W
02D9:  BSF    03.5
02DA:  MOVWF  07
02DB:  BCF    03.5
02DC:  BTFSS  07.3
02DD:  GOTO   2DC
02DE:  DECFSZ 78,F
02DF:  GOTO   2B9
02E0:  MOVLW  04
02E1:  MOVWF  77
02E2:  DECFSZ 77,F
02E3:  GOTO   2E2
02E4:  BCF    07.3
02E5:  BCF    3D.3
02E6:  MOVF   3D,W
02E7:  BSF    03.5
02E8:  MOVWF  07
02E9:  NOP
02EA:  BCF    03.5
02EB:  BSF    3D.4
02EC:  MOVF   3D,W
02ED:  BSF    03.5
02EE:  MOVWF  07
02EF:  MOVLW  03
02F0:  MOVWF  77
02F1:  DECFSZ 77,F
02F2:  GOTO   2F1
02F3:  MOVLW  03
02F4:  MOVWF  77
02F5:  DECFSZ 77,F
02F6:  GOTO   2F5
02F7:  BCF    03.5
02F8:  BSF    3D.3
02F9:  MOVF   3D,W
02FA:  BSF    03.5
02FB:  MOVWF  07
02FC:  BCF    03.5
02FD:  BTFSS  07.3
02FE:  GOTO   2FD
02FF:  CLRF   78
0300:  MOVLW  03
0301:  MOVWF  77
0302:  DECFSZ 77,F
0303:  GOTO   302
0304:  BTFSC  07.4
0305:  BSF    78.0
0306:  BCF    07.3
0307:  BCF    3D.3
0308:  MOVF   3D,W
0309:  BSF    03.5
030A:  MOVWF  07
030B:  BCF    03.5
030C:  BCF    07.4
030D:  BCF    3D.4
030E:  MOVF   3D,W
030F:  BSF    03.5
0310:  MOVWF  07
0311:  BCF    03.5
0312:  RETURN
*
03B5:  MOVLW  08
03B6:  BSF    03.5
03B7:  MOVWF  30
03B8:  MOVF   77,W
03B9:  MOVWF  31
03BA:  BCF    03.5
03BB:  BSF    3D.4
03BC:  MOVF   3D,W
03BD:  BSF    03.5
03BE:  MOVWF  07
03BF:  MOVLW  03
03C0:  MOVWF  77
03C1:  DECFSZ 77,F
03C2:  GOTO   3C1
03C3:  BCF    03.5
03C4:  BSF    3D.3
03C5:  MOVF   3D,W
03C6:  BSF    03.5
03C7:  MOVWF  07
03C8:  BCF    03.5
03C9:  BTFSS  07.3
03CA:  GOTO   3C9
03CB:  BTFSC  07.4
03CC:  BSF    03.0
03CD:  BTFSS  07.4
03CE:  BCF    03.0
03CF:  RLF    78,F
03D0:  MOVLW  04
03D1:  MOVWF  77
03D2:  DECFSZ 77,F
03D3:  GOTO   3D2
03D4:  BCF    3D.3
03D5:  MOVF   3D,W
03D6:  BSF    03.5
03D7:  MOVWF  07
03D8:  BCF    03.5
03D9:  BCF    07.3
03DA:  BSF    03.5
03DB:  DECFSZ 30,F
03DC:  GOTO   3BA
03DD:  BCF    03.5
03DE:  BSF    3D.4
03DF:  MOVF   3D,W
03E0:  BSF    03.5
03E1:  MOVWF  07
03E2:  MOVLW  03
03E3:  MOVWF  77
03E4:  DECFSZ 77,F
03E5:  GOTO   3E4
03E6:  BCF    03.5
03E7:  BCF    07.4
03E8:  BSF    03.5
03E9:  MOVF   31,W
03EA:  BTFSC  03.2
03EB:  GOTO   3F1
03EC:  BCF    03.5
03ED:  BCF    3D.4
03EE:  MOVF   3D,W
03EF:  BSF    03.5
03F0:  MOVWF  07
03F1:  NOP
03F2:  BCF    03.5
03F3:  BSF    3D.3
03F4:  MOVF   3D,W
03F5:  BSF    03.5
03F6:  MOVWF  07
03F7:  BCF    03.5
03F8:  BTFSS  07.3
03F9:  GOTO   3F8
03FA:  MOVLW  04
03FB:  MOVWF  77
03FC:  DECFSZ 77,F
03FD:  GOTO   3FC
03FE:  BCF    07.3
03FF:  BCF    3D.3
0400:  MOVF   3D,W
0401:  BSF    03.5
0402:  MOVWF  07
0403:  MOVLW  03
0404:  MOVWF  77
0405:  DECFSZ 77,F
0406:  GOTO   405
0407:  BCF    03.5
0408:  BCF    07.4
0409:  BCF    3D.4
040A:  MOVF   3D,W
040B:  BSF    03.5
040C:  MOVWF  07
....................  
.................... #define EEPROM_ADDRESS BYTE 
.................... #define EEPROM_SIZE    128 
....................  
.................... void init_ext_eeprom() { 
....................    output_float(EEPROM_SCL); 
*
013C:  BSF    3D.3
013D:  MOVF   3D,W
013E:  BSF    03.5
013F:  MOVWF  07
....................    output_float(EEPROM_SDA); 
0140:  BCF    03.5
0141:  BSF    3D.4
0142:  MOVF   3D,W
0143:  BSF    03.5
0144:  MOVWF  07
0145:  BCF    03.5
0146:  BCF    0A.3
0147:  BCF    0A.4
0148:  GOTO   77B (RETURN)
.................... } 
....................  
.................... BOOLEAN ext_eeprom_ready() { 
....................    int1 ack; 
....................    i2c_start();            // If the write command is acknowledged, 
*
0313:  BSF    3D.4
0314:  MOVF   3D,W
0315:  BSF    03.5
0316:  MOVWF  07
0317:  MOVLW  04
0318:  MOVWF  77
0319:  DECFSZ 77,F
031A:  GOTO   319
031B:  BCF    03.5
031C:  BSF    3D.3
031D:  MOVF   3D,W
031E:  BSF    03.5
031F:  MOVWF  07
0320:  MOVLW  03
0321:  MOVWF  77
0322:  DECFSZ 77,F
0323:  GOTO   322
0324:  BCF    03.5
0325:  BCF    07.4
0326:  BCF    3D.4
0327:  MOVF   3D,W
0328:  BSF    03.5
0329:  MOVWF  07
032A:  MOVLW  04
032B:  MOVWF  77
032C:  DECFSZ 77,F
032D:  GOTO   32C
032E:  BCF    03.5
032F:  BCF    07.3
0330:  BCF    3D.3
0331:  MOVF   3D,W
0332:  BSF    03.5
0333:  MOVWF  07
....................    ack = i2c_write(0xa0);  // then the device is ready. 
0334:  MOVLW  A0
0335:  MOVWF  30
0336:  BCF    03.5
0337:  CALL   2B7
0338:  MOVF   78,W
0339:  BSF    03.5
033A:  BCF    2F.0
033B:  BTFSC  78.0
033C:  BSF    2F.0
....................    i2c_stop(); 
033D:  BCF    03.5
033E:  BCF    3D.4
033F:  MOVF   3D,W
0340:  BSF    03.5
0341:  MOVWF  07
0342:  NOP
0343:  BCF    03.5
0344:  BSF    3D.3
0345:  MOVF   3D,W
0346:  BSF    03.5
0347:  MOVWF  07
0348:  BCF    03.5
0349:  BTFSS  07.3
034A:  GOTO   349
034B:  MOVLW  04
034C:  MOVWF  77
034D:  DECFSZ 77,F
034E:  GOTO   34D
034F:  GOTO   350
0350:  NOP
0351:  BSF    3D.4
0352:  MOVF   3D,W
0353:  BSF    03.5
0354:  MOVWF  07
0355:  MOVLW  04
0356:  MOVWF  77
0357:  DECFSZ 77,F
0358:  GOTO   357
....................    return !ack; 
0359:  MOVLW  00
035A:  BTFSS  2F.0
035B:  MOVLW  01
035C:  MOVWF  78
035D:  BCF    03.5
035E:  RETURN
.................... } 
....................  
.................... void write_ext_eeprom(BYTE address, BYTE data) { 
....................    while(!ext_eeprom_ready()); 
*
042F:  CALL   313
0430:  MOVF   78,F
0431:  BTFSC  03.2
0432:  GOTO   42F
....................    i2c_start(); 
0433:  BSF    3D.4
0434:  MOVF   3D,W
0435:  BSF    03.5
0436:  MOVWF  07
0437:  MOVLW  04
0438:  MOVWF  77
0439:  DECFSZ 77,F
043A:  GOTO   439
043B:  BCF    03.5
043C:  BSF    3D.3
043D:  MOVF   3D,W
043E:  BSF    03.5
043F:  MOVWF  07
0440:  MOVLW  03
0441:  MOVWF  77
0442:  DECFSZ 77,F
0443:  GOTO   442
0444:  BCF    03.5
0445:  BCF    07.4
0446:  BCF    3D.4
0447:  MOVF   3D,W
0448:  BSF    03.5
0449:  MOVWF  07
044A:  MOVLW  04
044B:  MOVWF  77
044C:  DECFSZ 77,F
044D:  GOTO   44C
044E:  BCF    03.5
044F:  BCF    07.3
0450:  BCF    3D.3
0451:  MOVF   3D,W
0452:  BSF    03.5
0453:  MOVWF  07
....................    i2c_write(0xa0); 
0454:  MOVLW  A0
0455:  MOVWF  30
0456:  BCF    03.5
0457:  CALL   2B7
....................    i2c_write(address); 
0458:  BSF    03.5
0459:  MOVF   28,W
045A:  MOVWF  30
045B:  BCF    03.5
045C:  CALL   2B7
....................    i2c_write(data); 
045D:  BSF    03.5
045E:  MOVF   29,W
045F:  MOVWF  30
0460:  BCF    03.5
0461:  CALL   2B7
....................    i2c_stop(); 
0462:  BCF    3D.4
0463:  MOVF   3D,W
0464:  BSF    03.5
0465:  MOVWF  07
0466:  NOP
0467:  BCF    03.5
0468:  BSF    3D.3
0469:  MOVF   3D,W
046A:  BSF    03.5
046B:  MOVWF  07
046C:  BCF    03.5
046D:  BTFSS  07.3
046E:  GOTO   46D
046F:  MOVLW  04
0470:  MOVWF  77
0471:  DECFSZ 77,F
0472:  GOTO   471
0473:  GOTO   474
0474:  NOP
0475:  BSF    3D.4
0476:  MOVF   3D,W
0477:  BSF    03.5
0478:  MOVWF  07
0479:  MOVLW  04
047A:  MOVWF  77
047B:  DECFSZ 77,F
047C:  GOTO   47B
047D:  BCF    03.5
047E:  RETURN
.................... } 
....................  
....................  
.................... BYTE read_ext_eeprom(BYTE address) { 
....................    BYTE data; 
....................  
....................    while(!ext_eeprom_ready()); 
*
035F:  CALL   313
0360:  MOVF   78,F
0361:  BTFSC  03.2
0362:  GOTO   35F
....................    i2c_start(); 
0363:  BSF    3D.4
0364:  MOVF   3D,W
0365:  BSF    03.5
0366:  MOVWF  07
0367:  MOVLW  04
0368:  MOVWF  77
0369:  DECFSZ 77,F
036A:  GOTO   369
036B:  BCF    03.5
036C:  BSF    3D.3
036D:  MOVF   3D,W
036E:  BSF    03.5
036F:  MOVWF  07
0370:  MOVLW  03
0371:  MOVWF  77
0372:  DECFSZ 77,F
0373:  GOTO   372
0374:  BCF    03.5
0375:  BCF    07.4
0376:  BCF    3D.4
0377:  MOVF   3D,W
0378:  BSF    03.5
0379:  MOVWF  07
037A:  MOVLW  04
037B:  MOVWF  77
037C:  DECFSZ 77,F
037D:  GOTO   37C
037E:  BCF    03.5
037F:  BCF    07.3
0380:  BCF    3D.3
0381:  MOVF   3D,W
0382:  BSF    03.5
0383:  MOVWF  07
....................    i2c_write(0xa0); 
0384:  MOVLW  A0
0385:  MOVWF  30
0386:  BCF    03.5
0387:  CALL   2B7
....................    i2c_write(address); 
0388:  BSF    03.5
0389:  MOVF   2D,W
038A:  MOVWF  30
038B:  BCF    03.5
038C:  CALL   2B7
....................    i2c_start(); 
038D:  BSF    3D.4
038E:  MOVF   3D,W
038F:  BSF    03.5
0390:  MOVWF  07
0391:  MOVLW  04
0392:  MOVWF  77
0393:  DECFSZ 77,F
0394:  GOTO   393
0395:  BCF    03.5
0396:  BSF    3D.3
0397:  MOVF   3D,W
0398:  BSF    03.5
0399:  MOVWF  07
039A:  MOVLW  03
039B:  MOVWF  77
039C:  DECFSZ 77,F
039D:  GOTO   39C
039E:  BCF    03.5
039F:  BTFSS  07.3
03A0:  GOTO   39F
03A1:  BCF    07.4
03A2:  BCF    3D.4
03A3:  MOVF   3D,W
03A4:  BSF    03.5
03A5:  MOVWF  07
03A6:  MOVLW  04
03A7:  MOVWF  77
03A8:  DECFSZ 77,F
03A9:  GOTO   3A8
03AA:  BCF    03.5
03AB:  BCF    07.3
03AC:  BCF    3D.3
03AD:  MOVF   3D,W
03AE:  BSF    03.5
03AF:  MOVWF  07
....................    i2c_write(0xa1); 
03B0:  MOVLW  A1
03B1:  MOVWF  30
03B2:  BCF    03.5
03B3:  CALL   2B7
....................    data=i2c_read(0); 
03B4:  CLRF   77
*
040D:  MOVF   78,W
040E:  MOVWF  2E
....................    i2c_stop(); 
040F:  BCF    03.5
0410:  BCF    3D.4
0411:  MOVF   3D,W
0412:  BSF    03.5
0413:  MOVWF  07
0414:  NOP
0415:  BCF    03.5
0416:  BSF    3D.3
0417:  MOVF   3D,W
0418:  BSF    03.5
0419:  MOVWF  07
041A:  BCF    03.5
041B:  BTFSS  07.3
041C:  GOTO   41B
041D:  MOVLW  04
041E:  MOVWF  77
041F:  DECFSZ 77,F
0420:  GOTO   41F
0421:  GOTO   422
0422:  NOP
0423:  BSF    3D.4
0424:  MOVF   3D,W
0425:  BSF    03.5
0426:  MOVWF  07
0427:  MOVLW  04
0428:  MOVWF  77
0429:  DECFSZ 77,F
042A:  GOTO   429
....................    return(data); 
042B:  MOVF   2E,W
042C:  MOVWF  78
042D:  BCF    03.5
042E:  RETURN
.................... } 
....................  
.................... #include "kbd_board4.c" 
.................... /*######################################################################  
....................    Rotina utilização do teclado da placa PicSim board4 
....................    Adaptada para o compilador CCS 
....................    Autor: Alberto Willia Mascarenhas (adaptou para o compilador) 
....................    For e-mail suggestions :  awmascarenhas@gmail.com 
.................... ######################################################################## */ 
.................... unsigned char tc_tecla(unsigned int timeout) 
*
04B3:  CLRF   75
04B4:  CLRF   76
.................... { 
....................   unsigned int to=0; 
....................   unsigned char k = 0;   
....................   while(((to < timeout)||(!timeout))&&(!k)){ 
04B5:  MOVF   74,W
04B6:  SUBWF  75,W
04B7:  BTFSS  03.0
04B8:  GOTO   4BC
04B9:  MOVF   74,F
04BA:  BTFSS  03.2
04BB:  GOTO   5DB
04BC:  MOVF   76,F
04BD:  BTFSS  03.2
04BE:  GOTO   5DB
....................       
....................        
....................       //------------------------------------------------------------------------- 
....................       //inicio do programa de varredura do teclado matricial 
....................       //-------------------------------------------------------------------------- 
....................       //habilita primeira coluna do teclado 
....................       output_low(PIN_B0);output_high(PIN_B1);output_high(PIN_B2);output_high(PIN_B3); 
04BF:  BSF    03.5
04C0:  BCF    06.0
04C1:  BCF    03.5
04C2:  BCF    06.0
04C3:  BSF    03.5
04C4:  BCF    06.1
04C5:  BCF    03.5
04C6:  BSF    06.1
04C7:  BSF    03.5
04C8:  BCF    06.2
04C9:  BCF    03.5
04CA:  BSF    06.2
04CB:  BSF    03.5
04CC:  BCF    06.3
04CD:  BCF    03.5
04CE:  BSF    06.3
....................       delay_ms(20); 
04CF:  MOVLW  14
04D0:  BSF    03.5
04D1:  MOVWF  31
04D2:  BCF    03.5
04D3:  CALL   149
....................       if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='1';}; 
04D4:  BSF    03.5
04D5:  BSF    08.0
04D6:  BCF    03.5
04D7:  BTFSC  08.0
04D8:  GOTO   4E0
04D9:  BSF    03.5
04DA:  BSF    08.0
04DB:  BCF    03.5
04DC:  BTFSS  08.0
04DD:  GOTO   4D9
04DE:  MOVLW  31
04DF:  MOVWF  76
....................       if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='4';}; 
04E0:  BSF    03.5
04E1:  BSF    08.1
04E2:  BCF    03.5
04E3:  BTFSC  08.1
04E4:  GOTO   4EC
04E5:  BSF    03.5
04E6:  BSF    08.1
04E7:  BCF    03.5
04E8:  BTFSS  08.1
04E9:  GOTO   4E5
04EA:  MOVLW  34
04EB:  MOVWF  76
....................       if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='7';}; 
04EC:  BSF    03.5
04ED:  BSF    08.2
04EE:  BCF    03.5
04EF:  BTFSC  08.2
04F0:  GOTO   4F8
04F1:  BSF    03.5
04F2:  BSF    08.2
04F3:  BCF    03.5
04F4:  BTFSS  08.2
04F5:  GOTO   4F1
04F6:  MOVLW  37
04F7:  MOVWF  76
....................       if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='*';}; 
04F8:  BSF    03.5
04F9:  BSF    08.3
04FA:  BCF    03.5
04FB:  BTFSC  08.3
04FC:  GOTO   504
04FD:  BSF    03.5
04FE:  BSF    08.3
04FF:  BCF    03.5
0500:  BTFSS  08.3
0501:  GOTO   4FD
0502:  MOVLW  2A
0503:  MOVWF  76
....................       //habilita segunda coluna do teclado 
....................       output_high(PIN_B0);output_low(PIN_B1);output_high(PIN_B2);output_high(PIN_B3); 
0504:  BSF    03.5
0505:  BCF    06.0
0506:  BCF    03.5
0507:  BSF    06.0
0508:  BSF    03.5
0509:  BCF    06.1
050A:  BCF    03.5
050B:  BCF    06.1
050C:  BSF    03.5
050D:  BCF    06.2
050E:  BCF    03.5
050F:  BSF    06.2
0510:  BSF    03.5
0511:  BCF    06.3
0512:  BCF    03.5
0513:  BSF    06.3
....................       delay_ms(20);       
0514:  MOVLW  14
0515:  BSF    03.5
0516:  MOVWF  31
0517:  BCF    03.5
0518:  CALL   149
....................       if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='2';}; 
0519:  BSF    03.5
051A:  BSF    08.0
051B:  BCF    03.5
051C:  BTFSC  08.0
051D:  GOTO   525
051E:  BSF    03.5
051F:  BSF    08.0
0520:  BCF    03.5
0521:  BTFSS  08.0
0522:  GOTO   51E
0523:  MOVLW  32
0524:  MOVWF  76
....................       if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='5';}; 
0525:  BSF    03.5
0526:  BSF    08.1
0527:  BCF    03.5
0528:  BTFSC  08.1
0529:  GOTO   531
052A:  BSF    03.5
052B:  BSF    08.1
052C:  BCF    03.5
052D:  BTFSS  08.1
052E:  GOTO   52A
052F:  MOVLW  35
0530:  MOVWF  76
....................       if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='8';}; 
0531:  BSF    03.5
0532:  BSF    08.2
0533:  BCF    03.5
0534:  BTFSC  08.2
0535:  GOTO   53D
0536:  BSF    03.5
0537:  BSF    08.2
0538:  BCF    03.5
0539:  BTFSS  08.2
053A:  GOTO   536
053B:  MOVLW  38
053C:  MOVWF  76
....................       if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='0';}; 
053D:  BSF    03.5
053E:  BSF    08.3
053F:  BCF    03.5
0540:  BTFSC  08.3
0541:  GOTO   549
0542:  BSF    03.5
0543:  BSF    08.3
0544:  BCF    03.5
0545:  BTFSS  08.3
0546:  GOTO   542
0547:  MOVLW  30
0548:  MOVWF  76
....................        
....................       //habilita terceira coluna do teclado 
....................       output_high(PIN_B0);output_high(PIN_B1);output_low(PIN_B2);output_high(PIN_B3); 
0549:  BSF    03.5
054A:  BCF    06.0
054B:  BCF    03.5
054C:  BSF    06.0
054D:  BSF    03.5
054E:  BCF    06.1
054F:  BCF    03.5
0550:  BSF    06.1
0551:  BSF    03.5
0552:  BCF    06.2
0553:  BCF    03.5
0554:  BCF    06.2
0555:  BSF    03.5
0556:  BCF    06.3
0557:  BCF    03.5
0558:  BSF    06.3
....................       delay_ms(20);       
0559:  MOVLW  14
055A:  BSF    03.5
055B:  MOVWF  31
055C:  BCF    03.5
055D:  CALL   149
....................       if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='3';}; 
055E:  BSF    03.5
055F:  BSF    08.0
0560:  BCF    03.5
0561:  BTFSC  08.0
0562:  GOTO   56A
0563:  BSF    03.5
0564:  BSF    08.0
0565:  BCF    03.5
0566:  BTFSS  08.0
0567:  GOTO   563
0568:  MOVLW  33
0569:  MOVWF  76
....................       if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='6';}; 
056A:  BSF    03.5
056B:  BSF    08.1
056C:  BCF    03.5
056D:  BTFSC  08.1
056E:  GOTO   576
056F:  BSF    03.5
0570:  BSF    08.1
0571:  BCF    03.5
0572:  BTFSS  08.1
0573:  GOTO   56F
0574:  MOVLW  36
0575:  MOVWF  76
....................       if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='9';}; 
0576:  BSF    03.5
0577:  BSF    08.2
0578:  BCF    03.5
0579:  BTFSC  08.2
057A:  GOTO   582
057B:  BSF    03.5
057C:  BSF    08.2
057D:  BCF    03.5
057E:  BTFSS  08.2
057F:  GOTO   57B
0580:  MOVLW  39
0581:  MOVWF  76
....................       if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='#';}; 
0582:  BSF    03.5
0583:  BSF    08.3
0584:  BCF    03.5
0585:  BTFSC  08.3
0586:  GOTO   58E
0587:  BSF    03.5
0588:  BSF    08.3
0589:  BCF    03.5
058A:  BTFSS  08.3
058B:  GOTO   587
058C:  MOVLW  23
058D:  MOVWF  76
....................   
....................        //habilita quarta coluna do teclado 
....................       output_high(PIN_B0);output_high(PIN_B1);output_high(PIN_B2);output_low(PIN_B3); 
058E:  BSF    03.5
058F:  BCF    06.0
0590:  BCF    03.5
0591:  BSF    06.0
0592:  BSF    03.5
0593:  BCF    06.1
0594:  BCF    03.5
0595:  BSF    06.1
0596:  BSF    03.5
0597:  BCF    06.2
0598:  BCF    03.5
0599:  BSF    06.2
059A:  BSF    03.5
059B:  BCF    06.3
059C:  BCF    03.5
059D:  BCF    06.3
....................       delay_ms(20);       
059E:  MOVLW  14
059F:  BSF    03.5
05A0:  MOVWF  31
05A1:  BCF    03.5
05A2:  CALL   149
....................       if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='A';}; 
05A3:  BSF    03.5
05A4:  BSF    08.0
05A5:  BCF    03.5
05A6:  BTFSC  08.0
05A7:  GOTO   5AF
05A8:  BSF    03.5
05A9:  BSF    08.0
05AA:  BCF    03.5
05AB:  BTFSS  08.0
05AC:  GOTO   5A8
05AD:  MOVLW  41
05AE:  MOVWF  76
....................       if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='B';}; 
05AF:  BSF    03.5
05B0:  BSF    08.1
05B1:  BCF    03.5
05B2:  BTFSC  08.1
05B3:  GOTO   5BB
05B4:  BSF    03.5
05B5:  BSF    08.1
05B6:  BCF    03.5
05B7:  BTFSS  08.1
05B8:  GOTO   5B4
05B9:  MOVLW  42
05BA:  MOVWF  76
....................       if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='C';}; 
05BB:  BSF    03.5
05BC:  BSF    08.2
05BD:  BCF    03.5
05BE:  BTFSC  08.2
05BF:  GOTO   5C7
05C0:  BSF    03.5
05C1:  BSF    08.2
05C2:  BCF    03.5
05C3:  BTFSS  08.2
05C4:  GOTO   5C0
05C5:  MOVLW  43
05C6:  MOVWF  76
....................       if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='D';}; 
05C7:  BSF    03.5
05C8:  BSF    08.3
05C9:  BCF    03.5
05CA:  BTFSC  08.3
05CB:  GOTO   5D3
05CC:  BSF    03.5
05CD:  BSF    08.3
05CE:  BCF    03.5
05CF:  BTFSS  08.3
05D0:  GOTO   5CC
05D1:  MOVLW  44
05D2:  MOVWF  76
....................   
....................       //printf (lcd_escreve,"\f saiu geral %u",k); 
....................       //delay_ms(1000); 
....................       delay_ms(5); 
05D3:  MOVLW  05
05D4:  BSF    03.5
05D5:  MOVWF  31
05D6:  BCF    03.5
05D7:  CALL   149
....................       to+=5; 
05D8:  MOVLW  05
05D9:  ADDWF  75,F
05DA:  GOTO   4B5
....................   } 
....................    if(!k)k=255; 
05DB:  MOVF   76,F
05DC:  BTFSS  03.2
05DD:  GOTO   5E0
05DE:  MOVLW  FF
05DF:  MOVWF  76
....................   return k;   
05E0:  MOVF   76,W
05E1:  MOVWF  78
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... // -----------------Functions 
.................... void saveUser(int * id, int * pass, int status); 
.................... int getAddressByID(int * id);    
.................... int deleteUser(int address); 
....................  
.................... int isIdAvailable(int id);     
.................... void printUser(); 
.................... void erase_program_eeprom(int addrr); 
.................... int incrementID(); 
.................... int lastNewUserPosition(); 
.................... void resetMemory(); 
.................... void adminMenu(); 
.................... unsigned char readKeyboard();  
.................... int * getAdminsID(); 
.................... void listAdmins(); 
.................... int * strToInt(char * str); 
....................  
.................... char * strfromchar(char destination[], char source); 
....................  
....................  
.................... typedef struct {  
....................    int id[2]; 
....................    int pass[4]; //password 
....................    int status; //0 - Unpaid, 1 - Paid, 3 - Admin 
.................... }User; 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
*
066C:  BSF    03.5
066D:  MOVF   56,W
066E:  MOVWF  59
....................    for(su=s;0<n;++su,--n) 
066F:  MOVF   55,W
0670:  MOVWF  5B
0671:  MOVF   54,W
0672:  MOVWF  5A
0673:  MOVF   58,F
0674:  BTFSS  03.2
0675:  GOTO   67A
0676:  MOVF   57,W
0677:  SUBLW  00
0678:  BTFSC  03.0
0679:  GOTO   692
....................       if(*su==uc) 
067A:  MOVF   5B,W
067B:  MOVWF  7A
067C:  MOVF   5A,W
067D:  MOVWF  04
067E:  BCF    03.7
067F:  BTFSC  7A.0
0680:  BSF    03.7
0681:  MOVF   59,W
0682:  SUBWF  00,W
0683:  BTFSS  03.2
0684:  GOTO   68A
....................       return su; 
0685:  MOVF   5A,W
0686:  MOVWF  78
0687:  MOVF   5B,W
0688:  MOVWF  79
0689:  GOTO   695
068A:  INCF   5A,F
068B:  BTFSC  03.2
068C:  INCF   5B,F
068D:  MOVF   57,W
068E:  BTFSC  03.2
068F:  DECF   58,F
0690:  DECF   57,F
0691:  GOTO   673
....................    return NULL; 
0692:  MOVLW  00
0693:  MOVWF  78
0694:  MOVWF  79
0695:  BCF    03.5
0696:  RETURN
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
0760:  BCF    03.5
0761:  CLRF   3E
0762:  CLRF   3F
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
*
0800:  BSF    03.5
0801:  CLRF   2D
0802:  CLRF   2C
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
0803:  MOVLW  30
0804:  MOVWF  2F
0805:  MOVLW  31
0806:  MOVWF  30
0807:  MOVLW  32
0808:  MOVWF  31
0809:  MOVLW  33
080A:  MOVWF  32
080B:  MOVLW  34
080C:  MOVWF  33
080D:  MOVLW  35
080E:  MOVWF  34
080F:  MOVLW  36
0810:  MOVWF  35
0811:  MOVLW  37
0812:  MOVWF  36
0813:  MOVLW  38
0814:  MOVWF  37
0815:  MOVLW  39
0816:  MOVWF  38
0817:  MOVLW  61
0818:  MOVWF  39
0819:  MOVLW  62
081A:  MOVWF  3A
081B:  MOVLW  63
081C:  MOVWF  3B
081D:  MOVLW  64
081E:  MOVWF  3C
081F:  MOVLW  65
0820:  MOVWF  3D
0821:  MOVLW  66
0822:  MOVWF  3E
0823:  MOVLW  67
0824:  MOVWF  3F
0825:  MOVLW  68
0826:  MOVWF  40
0827:  MOVLW  69
0828:  MOVWF  41
0829:  MOVLW  6A
082A:  MOVWF  42
082B:  MOVLW  6B
082C:  MOVWF  43
082D:  MOVLW  6C
082E:  MOVWF  44
082F:  MOVLW  6D
0830:  MOVWF  45
0831:  MOVLW  6E
0832:  MOVWF  46
0833:  MOVLW  6F
0834:  MOVWF  47
0835:  MOVLW  70
0836:  MOVWF  48
0837:  MOVLW  71
0838:  MOVWF  49
0839:  MOVLW  73
083A:  MOVWF  4A
083B:  MOVLW  74
083C:  MOVWF  4B
083D:  MOVLW  75
083E:  MOVWF  4C
083F:  MOVLW  76
0840:  MOVWF  4D
0841:  MOVLW  77
0842:  MOVWF  4E
0843:  MOVLW  78
0844:  MOVWF  4F
0845:  MOVLW  79
0846:  MOVWF  50
0847:  MOVLW  7A
0848:  MOVWF  51
0849:  CLRF   52
....................    for(sc=s;isspace(*sc);++sc); 
084A:  MOVF   22,W
084B:  MOVWF  27
084C:  MOVF   21,W
084D:  MOVWF  26
084E:  MOVF   27,W
084F:  MOVWF  7A
0850:  MOVF   26,W
0851:  MOVWF  04
0852:  BCF    03.7
0853:  BTFSC  7A.0
0854:  BSF    03.7
0855:  MOVF   00,W
0856:  SUBLW  20
0857:  BTFSS  03.2
0858:  GOTO   05D
0859:  INCF   26,F
085A:  BTFSC  03.2
085B:  INCF   27,F
085C:  GOTO   04E
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
085D:  MOVF   27,W
085E:  MOVWF  7A
085F:  MOVF   26,W
0860:  MOVWF  04
0861:  BCF    03.7
0862:  BTFSC  27.0
0863:  BSF    03.7
0864:  MOVF   00,W
0865:  SUBLW  2D
0866:  BTFSC  03.2
0867:  GOTO   073
0868:  MOVF   27,W
0869:  MOVWF  7A
086A:  MOVF   26,W
086B:  MOVWF  04
086C:  BCF    03.7
086D:  BTFSC  27.0
086E:  BSF    03.7
086F:  MOVF   00,W
0870:  SUBLW  2B
0871:  BTFSS  03.2
0872:  GOTO   07F
0873:  MOVF   27,W
0874:  MOVWF  7A
0875:  MOVF   26,W
0876:  INCF   26,F
0877:  BTFSC  03.2
0878:  INCF   27,F
0879:  MOVWF  04
087A:  BCF    03.7
087B:  BTFSC  7A.0
087C:  BSF    03.7
087D:  MOVF   00,W
087E:  GOTO   080
087F:  MOVLW  2B
0880:  MOVWF  2E
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
0881:  MOVF   2E,W
0882:  SUBLW  2D
0883:  BTFSC  03.2
0884:  GOTO   090
0885:  BTFSC  25.7
0886:  GOTO   090
0887:  DECFSZ 25,W
0888:  GOTO   08A
0889:  GOTO   090
088A:  BTFSC  25.7
088B:  GOTO   092
088C:  MOVF   25,W
088D:  SUBLW  24
088E:  BTFSC  03.0
088F:  GOTO   092
....................    goto StrtoulGO; 
0890:  GOTO   1EC
0891:  GOTO   128
....................  
....................    else if (base) 
0892:  MOVF   25,F
0893:  BTFSC  03.2
0894:  GOTO   0ED
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
0895:  MOVF   25,W
0896:  SUBLW  10
0897:  BTFSS  03.2
0898:  GOTO   0BC
0899:  MOVF   27,W
089A:  MOVWF  7A
089B:  MOVF   26,W
089C:  MOVWF  04
089D:  BCF    03.7
089E:  BTFSC  7A.0
089F:  BSF    03.7
08A0:  MOVF   00,W
08A1:  SUBLW  30
08A2:  BTFSS  03.2
08A3:  GOTO   0BC
08A4:  MOVLW  01
08A5:  ADDWF  26,W
08A6:  MOVWF  04
08A7:  BCF    03.7
08A8:  BTFSC  27.0
08A9:  BSF    03.7
08AA:  MOVF   00,W
08AB:  SUBLW  78
08AC:  BTFSC  03.2
08AD:  GOTO   0B8
08AE:  MOVLW  01
08AF:  ADDWF  26,W
08B0:  MOVWF  04
08B1:  BCF    03.7
08B2:  BTFSC  27.0
08B3:  BSF    03.7
08B4:  MOVF   00,W
08B5:  SUBLW  58
08B6:  BTFSS  03.2
08B7:  GOTO   0BC
....................          sc+=2; 
08B8:  MOVLW  02
08B9:  ADDWF  26,F
08BA:  BTFSC  03.0
08BB:  INCF   27,F
....................       if(base==8 && *sc =='0') 
08BC:  MOVF   25,W
08BD:  SUBLW  08
08BE:  BTFSS  03.2
08BF:  GOTO   0CF
08C0:  MOVF   27,W
08C1:  MOVWF  7A
08C2:  MOVF   26,W
08C3:  MOVWF  04
08C4:  BCF    03.7
08C5:  BTFSC  7A.0
08C6:  BSF    03.7
08C7:  MOVF   00,W
08C8:  SUBLW  30
08C9:  BTFSS  03.2
08CA:  GOTO   0CF
....................          sc+=1; 
08CB:  MOVLW  01
08CC:  ADDWF  26,F
08CD:  BTFSC  03.0
08CE:  INCF   27,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
08CF:  MOVF   25,W
08D0:  SUBLW  02
08D1:  BTFSS  03.2
08D2:  GOTO   0EC
08D3:  MOVF   27,W
08D4:  MOVWF  7A
08D5:  MOVF   26,W
08D6:  MOVWF  04
08D7:  BCF    03.7
08D8:  BTFSC  7A.0
08D9:  BSF    03.7
08DA:  MOVF   00,W
08DB:  SUBLW  30
08DC:  BTFSS  03.2
08DD:  GOTO   0EC
08DE:  MOVLW  01
08DF:  ADDWF  26,W
08E0:  MOVWF  04
08E1:  BCF    03.7
08E2:  BTFSC  27.0
08E3:  BSF    03.7
08E4:  MOVF   00,W
08E5:  SUBLW  62
08E6:  BTFSS  03.2
08E7:  GOTO   0EC
....................          sc+=2; 
08E8:  MOVLW  02
08E9:  ADDWF  26,F
08EA:  BTFSC  03.0
08EB:  INCF   27,F
....................  
....................    } 
08EC:  GOTO   128
....................    else if(*sc!='0') // base is 0, find base 
08ED:  MOVF   27,W
08EE:  MOVWF  7A
08EF:  MOVF   26,W
08F0:  MOVWF  04
08F1:  BCF    03.7
08F2:  BTFSC  7A.0
08F3:  BSF    03.7
08F4:  MOVF   00,W
08F5:  SUBLW  30
08F6:  BTFSC  03.2
08F7:  GOTO   0FB
....................       base=10; 
08F8:  MOVLW  0A
08F9:  MOVWF  25
08FA:  GOTO   128
....................    else if (sc[1]=='x' || sc[1]=='X') 
08FB:  MOVLW  01
08FC:  ADDWF  26,W
08FD:  MOVWF  04
08FE:  BCF    03.7
08FF:  BTFSC  27.0
0900:  BSF    03.7
0901:  MOVF   00,W
0902:  SUBLW  78
0903:  BTFSC  03.2
0904:  GOTO   10F
0905:  MOVLW  01
0906:  ADDWF  26,W
0907:  MOVWF  04
0908:  BCF    03.7
0909:  BTFSC  27.0
090A:  BSF    03.7
090B:  MOVF   00,W
090C:  SUBLW  58
090D:  BTFSS  03.2
090E:  GOTO   116
....................       base =16,sc+=2; 
090F:  MOVLW  10
0910:  MOVWF  25
0911:  MOVLW  02
0912:  ADDWF  26,F
0913:  BTFSC  03.0
0914:  INCF   27,F
0915:  GOTO   128
....................    else if(sc[1]=='b') 
0916:  MOVLW  01
0917:  ADDWF  26,W
0918:  MOVWF  04
0919:  BCF    03.7
091A:  BTFSC  27.0
091B:  BSF    03.7
091C:  MOVF   00,W
091D:  SUBLW  62
091E:  BTFSS  03.2
091F:  GOTO   126
....................       base=2,sc+=2; 
0920:  MOVLW  02
0921:  MOVWF  25
0922:  ADDWF  26,F
0923:  BTFSC  03.0
0924:  INCF   27,F
0925:  GOTO   128
....................    else 
....................       base=8; 
0926:  MOVLW  08
0927:  MOVWF  25
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
0928:  MOVF   27,W
0929:  MOVWF  29
092A:  MOVF   26,W
092B:  MOVWF  28
092C:  MOVF   27,W
092D:  MOVWF  7A
092E:  MOVF   26,W
092F:  MOVWF  04
0930:  BCF    03.7
0931:  BTFSC  7A.0
0932:  BSF    03.7
0933:  MOVF   00,W
0934:  SUBLW  30
0935:  BTFSS  03.2
0936:  GOTO   13B
0937:  INCF   26,F
0938:  BTFSC  03.2
0939:  INCF   27,F
093A:  GOTO   12C
....................    sd=memchr(digits,tolower(*sc),base); 
093B:  MOVF   27,W
093C:  MOVWF  7A
093D:  MOVF   26,W
093E:  MOVWF  04
093F:  BCF    03.7
0940:  BTFSC  27.0
0941:  BSF    03.7
0942:  MOVF   00,W
0943:  MOVWF  53
0944:  SUBLW  40
0945:  BTFSC  03.0
0946:  GOTO   14E
0947:  MOVF   53,W
0948:  SUBLW  5A
0949:  BTFSS  03.0
094A:  GOTO   14E
094B:  MOVF   53,W
094C:  IORLW  20
094D:  GOTO   14F
094E:  MOVF   53,W
094F:  MOVWF  53
0950:  CLRF   55
0951:  MOVLW  AF
0952:  MOVWF  54
0953:  MOVF   53,W
0954:  MOVWF  56
0955:  CLRF   58
0956:  MOVF   25,W
0957:  MOVWF  57
0958:  BCF    0A.3
0959:  BCF    03.5
095A:  CALL   66C
095B:  BSF    0A.3
095C:  MOVF   79,W
095D:  BSF    03.5
095E:  MOVWF  2B
095F:  MOVF   78,W
0960:  MOVWF  2A
....................    for(; sd!=0; ) 
0961:  MOVF   2A,F
0962:  BTFSS  03.2
0963:  GOTO   167
0964:  MOVF   2B,F
0965:  BTFSC  03.2
0966:  GOTO   1E4
....................    { 
....................       x=x*base+(int16)(sd-digits); 
0967:  CLRF   7A
0968:  MOVF   25,W
0969:  MOVWF  77
096A:  BTFSC  77.7
096B:  DECF   7A,F
096C:  MOVWF  53
096D:  MOVF   7A,W
096E:  MOVWF  54
096F:  MOVF   2D,W
0970:  MOVWF  56
0971:  MOVF   2C,W
0972:  MOVWF  55
0973:  MOVF   54,W
0974:  MOVWF  58
0975:  MOVF   53,W
0976:  MOVWF  57
*
09A4:  MOVF   79,W
09A5:  MOVWF  54
09A6:  MOVF   78,W
09A7:  MOVWF  53
09A8:  MOVLW  AF
09A9:  SUBWF  2A,W
09AA:  MOVWF  77
09AB:  MOVF   2B,W
09AC:  MOVWF  7A
09AD:  MOVLW  00
09AE:  BTFSS  03.0
09AF:  MOVLW  01
09B0:  SUBWF  7A,F
09B1:  MOVF   77,W
09B2:  ADDWF  53,W
09B3:  MOVWF  2C
09B4:  MOVF   54,W
09B5:  MOVWF  2D
09B6:  MOVF   7A,W
09B7:  BTFSC  03.0
09B8:  INCFSZ 7A,W
09B9:  ADDWF  2D,F
....................       ++sc; 
09BA:  INCF   26,F
09BB:  BTFSC  03.2
09BC:  INCF   27,F
....................       sd=memchr(digits,tolower(*sc),base); 
09BD:  MOVF   27,W
09BE:  MOVWF  7A
09BF:  MOVF   26,W
09C0:  MOVWF  04
09C1:  BCF    03.7
09C2:  BTFSC  27.0
09C3:  BSF    03.7
09C4:  MOVF   00,W
09C5:  MOVWF  53
09C6:  SUBLW  40
09C7:  BTFSC  03.0
09C8:  GOTO   1D0
09C9:  MOVF   53,W
09CA:  SUBLW  5A
09CB:  BTFSS  03.0
09CC:  GOTO   1D0
09CD:  MOVF   53,W
09CE:  IORLW  20
09CF:  GOTO   1D1
09D0:  MOVF   53,W
09D1:  MOVWF  53
09D2:  CLRF   55
09D3:  MOVLW  AF
09D4:  MOVWF  54
09D5:  MOVF   53,W
09D6:  MOVWF  56
09D7:  CLRF   58
09D8:  MOVF   25,W
09D9:  MOVWF  57
09DA:  BCF    0A.3
09DB:  BCF    03.5
09DC:  CALL   66C
09DD:  BSF    0A.3
09DE:  MOVF   79,W
09DF:  BSF    03.5
09E0:  MOVWF  2B
09E1:  MOVF   78,W
09E2:  MOVWF  2A
09E3:  GOTO   161
....................    } 
....................    if(s1==sc) 
09E4:  MOVF   26,W
09E5:  SUBWF  28,W
09E6:  BTFSS  03.2
09E7:  GOTO   1FF
09E8:  MOVF   27,W
09E9:  SUBWF  29,W
09EA:  BTFSS  03.2
09EB:  GOTO   1FF
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
09EC:  MOVF   23,W
09ED:  IORWF  24,W
09EE:  BTFSC  03.2
09EF:  GOTO   1FB
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
09F0:  MOVF   23,W
09F1:  MOVWF  04
09F2:  BCF    03.7
09F3:  BTFSC  24.0
09F4:  BSF    03.7
09F5:  INCF   04,F
09F6:  MOVF   22,W
09F7:  MOVWF  00
09F8:  DECF   04,F
09F9:  MOVF   21,W
09FA:  MOVWF  00
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
09FB:  MOVLW  00
09FC:  MOVWF  78
09FD:  MOVWF  79
09FE:  GOTO   212
....................    } 
....................    if (endptr) 
09FF:  MOVF   23,W
0A00:  IORWF  24,W
0A01:  BTFSC  03.2
0A02:  GOTO   20E
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
0A03:  MOVF   23,W
0A04:  MOVWF  04
0A05:  BCF    03.7
0A06:  BTFSC  24.0
0A07:  BSF    03.7
0A08:  INCF   04,F
0A09:  MOVF   27,W
0A0A:  MOVWF  00
0A0B:  DECF   04,F
0A0C:  MOVF   26,W
0A0D:  MOVWF  00
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
0A0E:  MOVF   2C,W
0A0F:  MOVWF  78
0A10:  MOVF   2D,W
0A11:  MOVWF  79
0A12:  BCF    03.5
0A13:  RETURN
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... void saveUser(int * id, int * pass, int status){ 
....................    printf (lcd_escreve,"\r\nid[0]:%u",id[0]); 
*
0BFE:  MOVF   72,W
0BFF:  MOVWF  04
0C00:  BCF    03.7
0C01:  BTFSC  73.0
0C02:  BSF    03.7
0C03:  MOVF   00,W
0C04:  MOVWF  7C
0C05:  MOVLW  60
0C06:  BSF    03.6
0C07:  MOVWF  0D
0C08:  MOVLW  00
0C09:  MOVWF  0F
0C0A:  BCF    03.0
0C0B:  MOVLW  08
0C0C:  BSF    03.5
0C0D:  BCF    03.6
0C0E:  MOVWF  2C
0C0F:  BCF    0A.3
0C10:  BCF    03.5
0C11:  CALL   5F2
0C12:  BSF    0A.3
0C13:  MOVF   7C,W
0C14:  BSF    03.5
0C15:  MOVWF  2C
0C16:  MOVLW  1B
0C17:  MOVWF  2D
0C18:  BCF    0A.3
0C19:  BCF    03.5
0C1A:  CALL   6AE
0C1B:  BSF    0A.3
....................    delay_ms(1000); 
0C1C:  MOVLW  04
0C1D:  MOVWF  7C
0C1E:  MOVLW  FA
0C1F:  BSF    03.5
0C20:  MOVWF  31
0C21:  BCF    0A.3
0C22:  BCF    03.5
0C23:  CALL   149
0C24:  BSF    0A.3
0C25:  DECFSZ 7C,F
0C26:  GOTO   41E
....................    if( id[0] < 256 && id[1] < 256 && getAddressByID(id) > -1 ){ 
0C27:  MOVF   72,W
0C28:  MOVWF  04
0C29:  BCF    03.7
0C2A:  BTFSC  73.0
0C2B:  BSF    03.7
0C2C:  MOVLW  01
0C2D:  ADDWF  72,W
0C2E:  MOVWF  04
0C2F:  BCF    03.7
0C30:  BTFSC  73.0
0C31:  BSF    03.7
0C32:  MOVF   73,W
0C33:  BSF    03.5
0C34:  MOVWF  28
0C35:  MOVF   72,W
0C36:  MOVWF  27
....................       int address = lastNewUserPosition(); 
....................       //recebe os parÃ¢metros do usuÃ¡rio 
....................       User user; 
*
0D48:  MOVF   78,W
0D49:  MOVWF  7B
....................       user.id[0] = id[0]; 
0D4A:  MOVF   72,W
0D4B:  MOVWF  04
0D4C:  BCF    03.7
0D4D:  BTFSC  73.0
0D4E:  BSF    03.7
0D4F:  MOVF   00,W
0D50:  MOVWF  20
....................       user.id[1] = id[1]; 
0D51:  MOVLW  01
0D52:  ADDWF  72,W
0D53:  MOVWF  04
0D54:  BCF    03.7
0D55:  BTFSC  73.0
0D56:  BSF    03.7
0D57:  MOVF   00,W
0D58:  MOVWF  21
....................       user.pass[0] = pass[0]; 
0D59:  MOVF   74,W
0D5A:  MOVWF  04
0D5B:  BCF    03.7
0D5C:  BTFSC  75.0
0D5D:  BSF    03.7
0D5E:  MOVF   00,W
0D5F:  MOVWF  22
....................       user.pass[1] = pass[1]; 
0D60:  MOVLW  01
0D61:  ADDWF  74,W
0D62:  MOVWF  04
0D63:  BCF    03.7
0D64:  BTFSC  75.0
0D65:  BSF    03.7
0D66:  MOVF   00,W
0D67:  MOVWF  23
....................       user.pass[2] = pass[2]; 
0D68:  MOVLW  02
0D69:  ADDWF  74,W
0D6A:  MOVWF  04
0D6B:  BCF    03.7
0D6C:  BTFSC  75.0
0D6D:  BSF    03.7
0D6E:  MOVF   00,W
0D6F:  MOVWF  24
....................       user.pass[3] = pass[3]; 
0D70:  MOVLW  03
0D71:  ADDWF  74,W
0D72:  MOVWF  04
0D73:  BCF    03.7
0D74:  BTFSC  75.0
0D75:  BSF    03.7
0D76:  MOVF   00,W
0D77:  MOVWF  25
....................       user.status = status; 
0D78:  MOVF   76,W
0D79:  MOVWF  26
....................        
....................  
....................       //Corrigir isso, o endereÃ§o tem que ser "dinÃ¢mico" 
....................        
....................       write_ext_eeprom(address, user.id[0]); 
0D7A:  MOVF   7B,W
0D7B:  MOVWF  28
0D7C:  MOVF   20,W
0D7D:  MOVWF  29
0D7E:  BCF    0A.3
0D7F:  BCF    03.5
0D80:  CALL   42F
0D81:  BSF    0A.3
....................       write_ext_eeprom(address+1, user.id[1]); 
0D82:  MOVLW  01
0D83:  ADDWF  7B,W
0D84:  MOVWF  7C
0D85:  BSF    03.5
0D86:  MOVWF  28
0D87:  MOVF   21,W
0D88:  MOVWF  29
0D89:  BCF    0A.3
0D8A:  BCF    03.5
0D8B:  CALL   42F
0D8C:  BSF    0A.3
....................       write_ext_eeprom(address+2, user.pass[0]); 
0D8D:  MOVLW  02
0D8E:  ADDWF  7B,W
0D8F:  MOVWF  7C
0D90:  BSF    03.5
0D91:  MOVWF  28
0D92:  MOVF   22,W
0D93:  MOVWF  29
0D94:  BCF    0A.3
0D95:  BCF    03.5
0D96:  CALL   42F
0D97:  BSF    0A.3
....................       write_ext_eeprom(address+3, user.pass[1]); 
0D98:  MOVLW  03
0D99:  ADDWF  7B,W
0D9A:  MOVWF  7C
0D9B:  BSF    03.5
0D9C:  MOVWF  28
0D9D:  MOVF   23,W
0D9E:  MOVWF  29
0D9F:  BCF    0A.3
0DA0:  BCF    03.5
0DA1:  CALL   42F
0DA2:  BSF    0A.3
....................       write_ext_eeprom(address+4, user.pass[2]); 
0DA3:  MOVLW  04
0DA4:  ADDWF  7B,W
0DA5:  MOVWF  7C
0DA6:  BSF    03.5
0DA7:  MOVWF  28
0DA8:  MOVF   24,W
0DA9:  MOVWF  29
0DAA:  BCF    0A.3
0DAB:  BCF    03.5
0DAC:  CALL   42F
0DAD:  BSF    0A.3
....................       write_ext_eeprom(address+5, user.pass[3]);        
0DAE:  MOVLW  05
0DAF:  ADDWF  7B,W
0DB0:  MOVWF  7C
0DB1:  BSF    03.5
0DB2:  MOVWF  28
0DB3:  MOVF   25,W
0DB4:  MOVWF  29
0DB5:  BCF    0A.3
0DB6:  BCF    03.5
0DB7:  CALL   42F
0DB8:  BSF    0A.3
....................       write_ext_eeprom(address+6, user.status); 
0DB9:  MOVLW  06
0DBA:  ADDWF  7B,W
0DBB:  MOVWF  7C
0DBC:  BSF    03.5
0DBD:  MOVWF  28
0DBE:  MOVF   26,W
0DBF:  MOVWF  29
0DC0:  BCF    0A.3
0DC1:  BCF    03.5
0DC2:  CALL   42F
0DC3:  BSF    0A.3
....................     
....................  
....................       printf (lcd_escreve,"\fUsuario Cadastrado"); 
0DC4:  MOVLW  66
0DC5:  BSF    03.6
0DC6:  MOVWF  0D
0DC7:  MOVLW  00
0DC8:  MOVWF  0F
0DC9:  BCF    0A.3
0DCA:  BCF    03.6
0DCB:  CALL   243
0DCC:  BSF    0A.3
....................       delay_ms(500); 
0DCD:  MOVLW  02
0DCE:  MOVWF  7C
0DCF:  MOVLW  FA
0DD0:  BSF    03.5
0DD1:  MOVWF  31
0DD2:  BCF    0A.3
0DD3:  BCF    03.5
0DD4:  CALL   149
0DD5:  BSF    0A.3
0DD6:  DECFSZ 7C,F
0DD7:  GOTO   5CF
....................  
....................    }else{ 
....................       printf (lcd_escreve,"\fID incompativel"); 
....................       printf (lcd_escreve,"\r\nTente novamente"); 
....................       delay_ms(1000); 
....................  
....................    } 
.................... } 
....................  
.................... void printUser(){ 
....................    //delay_ms(50); 
....................    int tmp_result = read_ext_eeprom(0);   
....................     
....................    delay_ms(50);   
....................     
....................    printf (lcd_escreve,"\f Button: %d", tmp_result); 
....................    printf(lcd_escreve, "\r\nPw:%d%d%d%d St:%d %d", read_ext_eeprom(1), read_ext_eeprom(2), read_ext_eeprom(3), read_ext_eeprom(4), read_ext_eeprom(5), read_ext_eeprom(6)); 
....................     
....................    //printf(lcd_escreve, "\f Client () elseÂ´{}{} 
....................    // printf(lcd_escreve, "\r\nPw:%c%c%c%c St:%c %c", U1.pass[0], U1.pass[1], U1.pass[2], U1.pass[3], U1.status, U1.type_usr); 
.................... } 
....................  
.................... int getAddressByID(int * id){ 
*
0C37:  CLRF   2B
....................    int id_temp[2]; 
....................    int address = 0; 
....................     
....................    while( read_ext_eeprom(address) != -1){ 
0C38:  MOVF   2B,W
0C39:  MOVWF  2D
0C3A:  BCF    0A.3
0C3B:  BCF    03.5
0C3C:  CALL   35F
0C3D:  BSF    0A.3
0C3E:  MOVF   78,W
0C3F:  SUBLW  FF
0C40:  BTFSC  03.2
0C41:  GOTO   49E
....................       id_temp[0] = read_ext_eeprom(address); 
0C42:  BSF    03.5
0C43:  MOVF   2B,W
0C44:  MOVWF  2D
0C45:  BCF    0A.3
0C46:  BCF    03.5
0C47:  CALL   35F
0C48:  BSF    0A.3
0C49:  MOVF   78,W
0C4A:  BSF    03.5
0C4B:  MOVWF  29
....................       id_temp[1] = read_ext_eeprom(address+1); 
0C4C:  MOVLW  01
0C4D:  ADDWF  2B,W
0C4E:  MOVWF  2C
0C4F:  MOVWF  2D
0C50:  BCF    0A.3
0C51:  BCF    03.5
0C52:  CALL   35F
0C53:  BSF    0A.3
0C54:  MOVF   78,W
0C55:  BSF    03.5
0C56:  MOVWF  2A
....................        
....................       if (id_temp[0] == id[0] && id_temp[1] == id[1]){ 
0C57:  MOVF   27,W
0C58:  MOVWF  04
0C59:  BCF    03.7
0C5A:  BTFSC  28.0
0C5B:  BSF    03.7
0C5C:  MOVF   00,W
0C5D:  SUBWF  29,W
0C5E:  BTFSS  03.2
0C5F:  GOTO   49A
0C60:  MOVLW  01
0C61:  ADDWF  27,W
0C62:  MOVWF  04
0C63:  BCF    03.7
0C64:  BTFSC  28.0
0C65:  BSF    03.7
0C66:  MOVF   00,W
0C67:  SUBWF  2A,W
0C68:  BTFSS  03.2
0C69:  GOTO   49A
....................          printf (lcd_escreve,"\fID Encontrado:%u%u", id_temp[0],id_temp[1]); 
0C6A:  MOVLW  95
0C6B:  BCF    03.5
0C6C:  BSF    03.6
0C6D:  MOVWF  0D
0C6E:  MOVLW  00
0C6F:  MOVWF  0F
0C70:  BCF    03.0
0C71:  MOVLW  0F
0C72:  BSF    03.5
0C73:  BCF    03.6
0C74:  MOVWF  2C
0C75:  BCF    0A.3
0C76:  BCF    03.5
0C77:  CALL   5F2
0C78:  BSF    0A.3
0C79:  BSF    03.5
0C7A:  MOVF   29,W
0C7B:  MOVWF  2C
0C7C:  MOVLW  1B
0C7D:  MOVWF  2D
0C7E:  BCF    0A.3
0C7F:  BCF    03.5
0C80:  CALL   6AE
0C81:  BSF    0A.3
0C82:  BSF    03.5
0C83:  MOVF   2A,W
0C84:  MOVWF  2C
0C85:  MOVLW  1B
0C86:  MOVWF  2D
0C87:  BCF    0A.3
0C88:  BCF    03.5
0C89:  CALL   6AE
0C8A:  BSF    0A.3
....................          delay_ms(1000); 
0C8B:  MOVLW  04
0C8C:  BSF    03.5
0C8D:  MOVWF  2C
0C8E:  MOVLW  FA
0C8F:  MOVWF  31
0C90:  BCF    0A.3
0C91:  BCF    03.5
0C92:  CALL   149
0C93:  BSF    0A.3
0C94:  BSF    03.5
0C95:  DECFSZ 2C,F
0C96:  GOTO   48E
....................          return address; 
0C97:  MOVF   2B,W
0C98:  MOVWF  78
0C99:  GOTO   4AA
....................       } 
....................  
....................       address += BLOCK_SIZE;  
0C9A:  MOVLW  07
0C9B:  ADDWF  2B,F
0C9C:  GOTO   438
0C9D:  BCF    03.5
....................    } 
....................    printf (lcd_escreve,"\f ID N Encontrado"); 
0C9E:  MOVLW  9F
0C9F:  BSF    03.6
0CA0:  MOVWF  0D
0CA1:  MOVLW  00
0CA2:  MOVWF  0F
0CA3:  BCF    0A.3
0CA4:  BCF    03.6
0CA5:  CALL   243
0CA6:  BSF    0A.3
....................    return -1; 
0CA7:  MOVLW  FF
0CA8:  MOVWF  78
0CA9:  BSF    03.5
....................     
.................... } 
....................  
.................... void erase_program_eeprom(int addrr){ 
....................    for(int i=0; i < BLOCK_SIZE; i++){ 
*
048B:  CLRF   57
048C:  MOVF   57,W
048D:  SUBLW  06
048E:  BTFSS  03.0
048F:  GOTO   49B
....................          write_ext_eeprom(addrr + i, -1); 
0490:  MOVF   57,W
0491:  ADDWF  56,W
0492:  MOVWF  58
0493:  BSF    03.5
0494:  MOVWF  28
0495:  MOVLW  FF
0496:  MOVWF  29
0497:  BCF    03.5
0498:  CALL   42F
0499:  INCF   57,F
049A:  GOTO   48C
....................    }   
....................    printf (lcd_escreve,"\f User erased "); 
049B:  MOVLW  A8
049C:  BSF    03.6
049D:  MOVWF  0D
049E:  MOVLW  00
049F:  MOVWF  0F
04A0:  BCF    03.6
04A1:  CALL   243
....................    delay_ms(500); 
04A2:  MOVLW  02
04A3:  MOVWF  58
04A4:  MOVLW  FA
04A5:  BSF    03.5
04A6:  MOVWF  31
04A7:  BCF    03.5
04A8:  CALL   149
04A9:  DECFSZ 58,F
04AA:  GOTO   4A4
.................... } 
....................  
.................... int deleteUser(int8 address){ 
....................     
....................    int data_temp; 
....................    int previous_block = address; 
....................    int next_block = address + BLOCK_SIZE; 
....................  
....................    //Case 1: without next block 
....................    if (read_ext_eeprom(next_block) == -1){ 
....................       erase_program_eeprom(previous_block);       
....................       return 1; 
....................    } 
....................  
....................    //Case 2: Check whether the data in the address is empty 
....................    while(read_ext_eeprom(next_block) != -1){ 
....................       //data_temp[index] = read_ext_eeprom(address); 
....................       for(int i=0; i < BLOCK_SIZE; i++){ 
....................          data_temp = read_ext_eeprom(next_block + i);            
....................          write_ext_eeprom(previous_block + i, data_temp);    //overwrite delete block 
....................       }   
....................  
....................       previous_block = next_block; 
....................       next_block += BLOCK_SIZE; 
....................    } 
....................     
....................    next_block -= BLOCK_SIZE; 
....................     
....................    //Erase last block   
....................    erase_program_eeprom(next_block); 
....................     
....................    return 1; 
....................  
.................... } 
....................  
.................... int lastNewUserPosition(){ 
*
0CAA:  CLRF   27
....................    int address = 0; 
....................    int id_temp; 
....................  
....................    while( read_ext_eeprom(address) != -1){ 
0CAB:  MOVF   27,W
0CAC:  MOVWF  2D
0CAD:  BCF    0A.3
0CAE:  BCF    03.5
0CAF:  CALL   35F
0CB0:  BSF    0A.3
0CB1:  MOVF   78,W
0CB2:  SUBLW  FF
0CB3:  BTFSC  03.2
0CB4:  GOTO   4BA
....................       address += BLOCK_SIZE;  
0CB5:  MOVLW  07
0CB6:  BSF    03.5
0CB7:  ADDWF  27,F
0CB8:  GOTO   4AB
0CB9:  BCF    03.5
....................    } 
....................    printf (lcd_escreve,"\fAddress: %d", address); 
0CBA:  MOVLW  B0
0CBB:  BSF    03.6
0CBC:  MOVWF  0D
0CBD:  MOVLW  00
0CBE:  MOVWF  0F
0CBF:  BCF    03.0
0CC0:  MOVLW  0A
0CC1:  BSF    03.5
0CC2:  BCF    03.6
0CC3:  MOVWF  2C
0CC4:  BCF    0A.3
0CC5:  BCF    03.5
0CC6:  CALL   5F2
0CC7:  BSF    0A.3
0CC8:  BSF    03.5
0CC9:  MOVF   27,W
0CCA:  MOVWF  29
0CCB:  MOVLW  18
0CCC:  MOVWF  2A
....................    delay_ms(1000); 
*
0D3A:  MOVLW  04
0D3B:  BSF    03.5
0D3C:  MOVWF  29
0D3D:  MOVLW  FA
0D3E:  MOVWF  31
0D3F:  BCF    0A.3
0D40:  BCF    03.5
0D41:  CALL   149
0D42:  BSF    0A.3
0D43:  BSF    03.5
0D44:  DECFSZ 29,F
0D45:  GOTO   53D
....................     
....................    return address; 
0D46:  MOVF   27,W
0D47:  MOVWF  78
....................  
.................... } 
....................  
.................... int isIdAvailable(int * id){ 
....................    unsigned int address = 0; 
....................    int id_temp; 
....................    while( read_ext_eeprom(address) != -1){ 
....................       id_temp = read_ext_eeprom(address); 
....................       if (id_temp == id){ 
....................           printf (lcd_escreve,"\fID:%u, Existe", id_temp); 
....................           delay_ms(1000); 
....................          return 0;//Sucessful 
....................       } 
....................  
....................       address += BLOCK_SIZE;  
....................    } 
....................    printf (lcd_escreve,"\fID:%u, N Existe", id_temp); 
....................    delay_ms(1000); 
....................    return -1; 
.................... } 
....................  
.................... void resetMemory(){ 
*
047F:  CLRF   55
....................    int address = 0; 
....................    for(; read_ext_eeprom(address) != -1; 
0480:  MOVF   55,W
0481:  BSF    03.5
0482:  MOVWF  2D
0483:  BCF    03.5
0484:  CALL   35F
0485:  MOVF   78,W
0486:  SUBLW  FF
0487:  BTFSC  03.2
0488:  GOTO   4AE
....................     erase_program_eeprom(address), address += BLOCK_SIZE); 
0489:  MOVF   55,W
048A:  MOVWF  56
*
04AB:  MOVLW  07
04AC:  ADDWF  55,F
04AD:  GOTO   480
04AE:  BCF    0A.3
04AF:  BCF    0A.4
04B0:  GOTO   799 (RETURN)
.................... } 
....................  
.................... void adminMenu(){ 
....................  
....................  
....................   unsigned char keyboard_buffer[BLOCK_SIZE * 2]; 
....................   unsigned char option; 
....................    // printf(lcd_escreve,"\f1: CAD Cliente "); 
....................    // delay_ms(500); 
....................    // printf(lcd_escreve,"\r\n2: DEL Cliente"); 
....................    // delay_ms(500); 
....................    // printf(lcd_escreve,"\f3: Buscar Cliente "); 
....................    // delay_ms(500); 
....................    // printf(lcd_escreve,"\r\n4: Editar Cliente"); 
....................    // delay_ms(500); 
....................    // printf(lcd_escreve,"\f5: SAIR do Menu "); 
....................    // delay_ms(500); 
....................   do{ 
....................      
....................      option = readKeyboard(); 
*
0A14:  BCF    0A.3
0A15:  CALL   4B1
0A16:  BSF    0A.3
0A17:  MOVF   78,W
0A18:  MOVWF  63
....................      printf(lcd_escreve,"\f Option: %c", option); 
0A19:  MOVLW  C8
0A1A:  BSF    03.6
0A1B:  MOVWF  0D
0A1C:  MOVLW  00
0A1D:  MOVWF  0F
0A1E:  BCF    03.0
0A1F:  MOVLW  0A
0A20:  BSF    03.5
0A21:  BCF    03.6
0A22:  MOVWF  2C
0A23:  BCF    0A.3
0A24:  BCF    03.5
0A25:  CALL   5F2
0A26:  BSF    0A.3
0A27:  MOVF   63,W
0A28:  BSF    03.5
0A29:  MOVWF  30
0A2A:  BCF    0A.3
0A2B:  BCF    03.5
0A2C:  CALL   200
0A2D:  BSF    0A.3
....................      delay_ms(500); 
0A2E:  MOVLW  02
0A2F:  MOVWF  72
0A30:  MOVLW  FA
0A31:  BSF    03.5
0A32:  MOVWF  31
0A33:  BCF    0A.3
0A34:  BCF    03.5
0A35:  CALL   149
0A36:  BSF    0A.3
0A37:  DECFSZ 72,F
0A38:  GOTO   230
....................  
....................  
....................     switch(option){ 
0A39:  MOVF   63,W
0A3A:  XORLW  31
0A3B:  BTFSC  03.2
0A3C:  GOTO   247
0A3D:  XORLW  33
0A3E:  BTFSC  03.2
0A3F:  GOTO   5D9
0A40:  XORLW  01
0A41:  BTFSC  03.2
0A42:  GOTO   5DA
0A43:  XORLW  07
0A44:  BTFSC  03.2
0A45:  GOTO   5DB
0A46:  GOTO   5DC
....................        case '1': 
....................          unsigned int * temp; 
....................          unsigned int id [2]; 
....................          unsigned int pass[4]; 
....................          unsigned int status; 
....................          int i = 0; 
0A47:  CLRF   6D
....................            //The user needs to type 4 digits 
....................            //For example, even if it's just 9 
....................            //He/she will type: 0009 
....................            while(i < 5){ 
0A48:  MOVF   6D,W
0A49:  SUBLW  04
0A4A:  BTFSS  03.0
0A4B:  GOTO   297
....................  
....................             printf(lcd_escreve,"\fDigite o ID"); 
0A4C:  MOVLW  CF
0A4D:  BSF    03.6
0A4E:  MOVWF  0D
0A4F:  MOVLW  00
0A50:  MOVWF  0F
0A51:  BCF    0A.3
0A52:  BCF    03.6
0A53:  CALL   243
0A54:  BSF    0A.3
....................             delay_ms(50); 
0A55:  MOVLW  32
0A56:  BSF    03.5
0A57:  MOVWF  31
0A58:  BCF    0A.3
0A59:  BCF    03.5
0A5A:  CALL   149
0A5B:  BSF    0A.3
....................             option = readKeyboard(); 
0A5C:  BCF    0A.3
0A5D:  CALL   4B1
0A5E:  BSF    0A.3
0A5F:  MOVF   78,W
0A60:  MOVWF  63
....................             printf(lcd_escreve,"\fTyped:%c", option); 
0A61:  MOVLW  D6
0A62:  BSF    03.6
0A63:  MOVWF  0D
0A64:  MOVLW  00
0A65:  MOVWF  0F
0A66:  BCF    03.0
0A67:  MOVLW  07
0A68:  BSF    03.5
0A69:  BCF    03.6
0A6A:  MOVWF  2C
0A6B:  BCF    0A.3
0A6C:  BCF    03.5
0A6D:  CALL   5F2
0A6E:  BSF    0A.3
0A6F:  MOVF   63,W
0A70:  BSF    03.5
0A71:  MOVWF  30
0A72:  BCF    0A.3
0A73:  BCF    03.5
0A74:  CALL   200
0A75:  BSF    0A.3
....................             delay_ms(500); 
0A76:  MOVLW  02
0A77:  MOVWF  72
0A78:  MOVLW  FA
0A79:  BSF    03.5
0A7A:  MOVWF  31
0A7B:  BCF    0A.3
0A7C:  BCF    03.5
0A7D:  CALL   149
0A7E:  BSF    0A.3
0A7F:  DECFSZ 72,F
0A80:  GOTO   278
....................             if(option != 255){ 
0A81:  INCFSZ 63,W
0A82:  GOTO   284
0A83:  GOTO   296
....................                if(i == 2){ 
0A84:  MOVF   6D,W
0A85:  SUBLW  02
0A86:  BTFSS  03.2
0A87:  GOTO   28F
....................                   //To convert to int will be easier with space between them 
....................                   keyboard_buffer[i] = ' '; 
0A88:  MOVLW  55
0A89:  ADDWF  6D,W
0A8A:  MOVWF  04
0A8B:  BCF    03.7
0A8C:  MOVLW  20
0A8D:  MOVWF  00
....................                   i++; 
0A8E:  INCF   6D,F
....................                } 
....................                keyboard_buffer[i] = option; 
0A8F:  MOVLW  55
0A90:  ADDWF  6D,W
0A91:  MOVWF  04
0A92:  BCF    03.7
0A93:  MOVF   63,W
0A94:  MOVWF  00
....................                i++; 
0A95:  INCF   6D,F
....................             } 
0A96:  GOTO   248
....................            } 
....................             // unsigned char *id; 
....................             // id = keyboard_buffer; 
....................             temp = strToInt(keyboard_buffer); 
0A97:  CLRF   73
0A98:  MOVLW  55
0A99:  MOVWF  72
0A9A:  BCF    0A.3
0A9B:  CALL   6ED
0A9C:  BSF    0A.3
0A9D:  MOVF   79,W
0A9E:  MOVWF  65
0A9F:  MOVF   78,W
0AA0:  MOVWF  64
....................             id[0] = temp[0]; 
0AA1:  MOVF   64,W
0AA2:  MOVWF  04
0AA3:  BCF    03.7
0AA4:  BTFSC  65.0
0AA5:  BSF    03.7
0AA6:  MOVF   00,W
0AA7:  MOVWF  66
....................             id[1] = temp[1]; 
0AA8:  MOVLW  01
0AA9:  ADDWF  64,W
0AAA:  MOVWF  04
0AAB:  BCF    03.7
0AAC:  BTFSC  65.0
0AAD:  BSF    03.7
0AAE:  MOVF   00,W
0AAF:  MOVWF  67
....................             //https://www.tutorialspoint.com/cprogramming/c_pointer_to_an_array.htm 
....................             //*(id+1) == id[1] 
....................             printf(lcd_escreve,"\fid: %u%u",id[0],id[1]); 
0AB0:  MOVLW  DB
0AB1:  BSF    03.6
0AB2:  MOVWF  0D
0AB3:  MOVLW  00
0AB4:  MOVWF  0F
0AB5:  BCF    03.0
0AB6:  MOVLW  05
0AB7:  BSF    03.5
0AB8:  BCF    03.6
0AB9:  MOVWF  2C
0ABA:  BCF    0A.3
0ABB:  BCF    03.5
0ABC:  CALL   5F2
0ABD:  BSF    0A.3
0ABE:  MOVF   66,W
0ABF:  BSF    03.5
0AC0:  MOVWF  2C
0AC1:  MOVLW  1B
0AC2:  MOVWF  2D
0AC3:  BCF    0A.3
0AC4:  BCF    03.5
0AC5:  CALL   6AE
0AC6:  BSF    0A.3
0AC7:  MOVF   67,W
0AC8:  BSF    03.5
0AC9:  MOVWF  2C
0ACA:  MOVLW  1B
0ACB:  MOVWF  2D
0ACC:  BCF    0A.3
0ACD:  BCF    03.5
0ACE:  CALL   6AE
0ACF:  BSF    0A.3
....................             delay_ms(1000); 
0AD0:  MOVLW  04
0AD1:  MOVWF  72
0AD2:  MOVLW  FA
0AD3:  BSF    03.5
0AD4:  MOVWF  31
0AD5:  BCF    0A.3
0AD6:  BCF    03.5
0AD7:  CALL   149
0AD8:  BSF    0A.3
0AD9:  DECFSZ 72,F
0ADA:  GOTO   2D2
....................        
....................          //password 
....................  
....................          i = 0; 
0ADB:  CLRF   6D
....................            while(i < 4){ 
0ADC:  MOVF   6D,W
0ADD:  SUBLW  03
0ADE:  BTFSS  03.0
0ADF:  GOTO   340
....................  
....................             printf(lcd_escreve,"\fDigite a senha"); 
0AE0:  MOVLW  E0
0AE1:  BSF    03.6
0AE2:  MOVWF  0D
0AE3:  MOVLW  00
0AE4:  MOVWF  0F
0AE5:  BCF    0A.3
0AE6:  BCF    03.6
0AE7:  CALL   243
0AE8:  BSF    0A.3
....................             delay_ms(50); 
0AE9:  MOVLW  32
0AEA:  BSF    03.5
0AEB:  MOVWF  31
0AEC:  BCF    0A.3
0AED:  BCF    03.5
0AEE:  CALL   149
0AEF:  BSF    0A.3
....................             option = readKeyboard(); 
0AF0:  BCF    0A.3
0AF1:  CALL   4B1
0AF2:  BSF    0A.3
0AF3:  MOVF   78,W
0AF4:  MOVWF  63
....................             printf(lcd_escreve,"\fTyped:%c", option); 
0AF5:  MOVLW  E8
0AF6:  BSF    03.6
0AF7:  MOVWF  0D
0AF8:  MOVLW  00
0AF9:  MOVWF  0F
0AFA:  BCF    03.0
0AFB:  MOVLW  07
0AFC:  BSF    03.5
0AFD:  BCF    03.6
0AFE:  MOVWF  2C
0AFF:  BCF    0A.3
0B00:  BCF    03.5
0B01:  CALL   5F2
0B02:  BSF    0A.3
0B03:  MOVF   63,W
0B04:  BSF    03.5
0B05:  MOVWF  30
0B06:  BCF    0A.3
0B07:  BCF    03.5
0B08:  CALL   200
0B09:  BSF    0A.3
....................             delay_ms(500); 
0B0A:  MOVLW  02
0B0B:  MOVWF  72
0B0C:  MOVLW  FA
0B0D:  BSF    03.5
0B0E:  MOVWF  31
0B0F:  BCF    0A.3
0B10:  BCF    03.5
0B11:  CALL   149
0B12:  BSF    0A.3
0B13:  DECFSZ 72,F
0B14:  GOTO   30C
....................             if(option != 255){ 
0B15:  INCFSZ 63,W
0B16:  GOTO   318
0B17:  GOTO   33F
....................                // keyboard_buffer[i] = option; 
....................                unsigned char destination[2]; 
....................                //Convert string from char and return  
....................                //to the left array of char(str_pass) 
....................                strfromchar(destination,option); 
0B18:  CLRF   73
0B19:  MOVLW  6E
0B1A:  MOVWF  72
0B1B:  MOVF   63,W
0B1C:  MOVWF  74
0B1D:  BCF    0A.3
0B1E:  CALL   73C
0B1F:  BSF    0A.3
....................                temp = strToInt(destination); 
0B20:  CLRF   73
0B21:  MOVLW  6E
0B22:  MOVWF  72
0B23:  BCF    0A.3
0B24:  CALL   6ED
0B25:  BSF    0A.3
0B26:  MOVF   79,W
0B27:  MOVWF  65
0B28:  MOVF   78,W
0B29:  MOVWF  64
....................                pass[i] = temp[0]; 
0B2A:  MOVLW  68
0B2B:  ADDWF  6D,W
0B2C:  MOVWF  72
0B2D:  CLRF   73
0B2E:  BTFSC  03.0
0B2F:  INCF   73,F
0B30:  MOVF   64,W
0B31:  MOVWF  04
0B32:  BCF    03.7
0B33:  BTFSC  65.0
0B34:  BSF    03.7
0B35:  MOVF   00,W
0B36:  MOVWF  74
0B37:  MOVF   72,W
0B38:  MOVWF  04
0B39:  BCF    03.7
0B3A:  BTFSC  73.0
0B3B:  BSF    03.7
0B3C:  MOVF   74,W
0B3D:  MOVWF  00
....................                i++; 
0B3E:  INCF   6D,F
....................             } 
0B3F:  GOTO   2DC
....................            } 
....................             printf(lcd_escreve,"\fPASS(4): %u%u%u%u",pass[0],pass[1],pass[2],pass[3]); 
0B40:  MOVLW  ED
0B41:  BSF    03.6
0B42:  MOVWF  0D
0B43:  MOVLW  00
0B44:  MOVWF  0F
0B45:  BCF    03.0
0B46:  MOVLW  0A
0B47:  BSF    03.5
0B48:  BCF    03.6
0B49:  MOVWF  2C
0B4A:  BCF    0A.3
0B4B:  BCF    03.5
0B4C:  CALL   5F2
0B4D:  BSF    0A.3
0B4E:  MOVF   68,W
0B4F:  BSF    03.5
0B50:  MOVWF  2C
0B51:  MOVLW  1B
0B52:  MOVWF  2D
0B53:  BCF    0A.3
0B54:  BCF    03.5
0B55:  CALL   6AE
0B56:  BSF    0A.3
0B57:  MOVF   69,W
0B58:  BSF    03.5
0B59:  MOVWF  2C
0B5A:  MOVLW  1B
0B5B:  MOVWF  2D
0B5C:  BCF    0A.3
0B5D:  BCF    03.5
0B5E:  CALL   6AE
0B5F:  BSF    0A.3
0B60:  MOVF   6A,W
0B61:  BSF    03.5
0B62:  MOVWF  2C
0B63:  MOVLW  1B
0B64:  MOVWF  2D
0B65:  BCF    0A.3
0B66:  BCF    03.5
0B67:  CALL   6AE
0B68:  BSF    0A.3
0B69:  MOVF   6B,W
0B6A:  BSF    03.5
0B6B:  MOVWF  2C
0B6C:  MOVLW  1B
0B6D:  MOVWF  2D
0B6E:  BCF    0A.3
0B6F:  BCF    03.5
0B70:  CALL   6AE
0B71:  BSF    0A.3
....................             delay_ms(1000); 
0B72:  MOVLW  04
0B73:  MOVWF  72
0B74:  MOVLW  FA
0B75:  BSF    03.5
0B76:  MOVWF  31
0B77:  BCF    0A.3
0B78:  BCF    03.5
0B79:  CALL   149
0B7A:  BSF    0A.3
0B7B:  DECFSZ 72,F
0B7C:  GOTO   374
....................  
....................  
....................          i = 0; 
0B7D:  CLRF   6D
....................            while(i < 1){ 
0B7E:  MOVF   6D,F
0B7F:  BTFSS  03.2
0B80:  GOTO   3D4
....................  
....................             printf(lcd_escreve,"\fStatus(0,1,3):"); 
0B81:  MOVLW  F7
0B82:  BSF    03.6
0B83:  MOVWF  0D
0B84:  MOVLW  00
0B85:  MOVWF  0F
0B86:  BCF    0A.3
0B87:  BCF    03.6
0B88:  CALL   243
0B89:  BSF    0A.3
....................             delay_ms(50); 
0B8A:  MOVLW  32
0B8B:  BSF    03.5
0B8C:  MOVWF  31
0B8D:  BCF    0A.3
0B8E:  BCF    03.5
0B8F:  CALL   149
0B90:  BSF    0A.3
....................             option = readKeyboard(); 
0B91:  BCF    0A.3
0B92:  CALL   4B1
0B93:  BSF    0A.3
0B94:  MOVF   78,W
0B95:  MOVWF  63
....................             printf(lcd_escreve,"\fTyped Status:%c", option); 
0B96:  MOVLW  FF
0B97:  BSF    03.6
0B98:  MOVWF  0D
0B99:  MOVLW  00
0B9A:  MOVWF  0F
0B9B:  BCF    03.0
0B9C:  MOVLW  0E
0B9D:  BSF    03.5
0B9E:  BCF    03.6
0B9F:  MOVWF  2C
0BA0:  BCF    0A.3
0BA1:  BCF    03.5
0BA2:  CALL   5F2
0BA3:  BSF    0A.3
0BA4:  MOVF   63,W
0BA5:  BSF    03.5
0BA6:  MOVWF  30
0BA7:  BCF    0A.3
0BA8:  BCF    03.5
0BA9:  CALL   200
0BAA:  BSF    0A.3
....................             delay_ms(500); 
0BAB:  MOVLW  02
0BAC:  MOVWF  72
0BAD:  MOVLW  FA
0BAE:  BSF    03.5
0BAF:  MOVWF  31
0BB0:  BCF    0A.3
0BB1:  BCF    03.5
0BB2:  CALL   149
0BB3:  BSF    0A.3
0BB4:  DECFSZ 72,F
0BB5:  GOTO   3AD
....................             if(option != 255){ 
0BB6:  INCFSZ 63,W
0BB7:  GOTO   3B9
0BB8:  GOTO   3D3
....................                unsigned char destination[2]; 
....................                strfromchar(destination,option); 
0BB9:  CLRF   73
0BBA:  MOVLW  70
0BBB:  MOVWF  72
0BBC:  MOVF   63,W
0BBD:  MOVWF  74
0BBE:  BCF    0A.3
0BBF:  CALL   73C
0BC0:  BSF    0A.3
....................                temp = strToInt(destination); 
0BC1:  CLRF   73
0BC2:  MOVLW  70
0BC3:  MOVWF  72
0BC4:  BCF    0A.3
0BC5:  CALL   6ED
0BC6:  BSF    0A.3
0BC7:  MOVF   79,W
0BC8:  MOVWF  65
0BC9:  MOVF   78,W
0BCA:  MOVWF  64
....................                status = temp[0];  
0BCB:  MOVF   64,W
0BCC:  MOVWF  04
0BCD:  BCF    03.7
0BCE:  BTFSC  65.0
0BCF:  BSF    03.7
0BD0:  MOVF   00,W
0BD1:  MOVWF  6C
....................                i++; 
0BD2:  INCF   6D,F
....................             } 
0BD3:  GOTO   37E
....................            } 
....................             printf(lcd_escreve,"\fSTATUS: %u",status); 
0BD4:  MOVLW  08
0BD5:  BSF    03.6
0BD6:  MOVWF  0D
0BD7:  MOVLW  01
0BD8:  MOVWF  0F
0BD9:  BCF    03.0
0BDA:  MOVLW  09
0BDB:  BSF    03.5
0BDC:  BCF    03.6
0BDD:  MOVWF  2C
0BDE:  BCF    0A.3
0BDF:  BCF    03.5
0BE0:  CALL   5F2
0BE1:  BSF    0A.3
0BE2:  MOVF   6C,W
0BE3:  BSF    03.5
0BE4:  MOVWF  2C
0BE5:  MOVLW  1B
0BE6:  MOVWF  2D
0BE7:  BCF    0A.3
0BE8:  BCF    03.5
0BE9:  CALL   6AE
0BEA:  BSF    0A.3
....................             delay_ms(1000); 
0BEB:  MOVLW  04
0BEC:  MOVWF  72
0BED:  MOVLW  FA
0BEE:  BSF    03.5
0BEF:  MOVWF  31
0BF0:  BCF    0A.3
0BF1:  BCF    03.5
0BF2:  CALL   149
0BF3:  BSF    0A.3
0BF4:  DECFSZ 72,F
0BF5:  GOTO   3ED
....................  
....................  
....................             saveUser(id,pass,status); 
0BF6:  CLRF   73
0BF7:  MOVLW  66
0BF8:  MOVWF  72
0BF9:  CLRF   75
0BFA:  MOVLW  68
0BFB:  MOVWF  74
0BFC:  MOVF   6C,W
0BFD:  MOVWF  76
....................             break; 
*
0DD8:  GOTO   5DC
....................        case 2: 
....................             // listar(); 
....................             break; 
0DD9:  GOTO   5DC
....................        case 3: 
....................             // mostrarMes(); 
....................             break; 
0DDA:  GOTO   5DC
....................        case 4: 
....................             //  printf("\nTENHA UM BOM DIA\n"); 
....................             break; 
0DDB:  GOTO   5DC
....................        default: 
....................             // printf("\nDIGITE UM VALOR VÃLIDO\n"); 
....................             break; 
....................  
....................       } 
....................    }while(option != 4);//sÃ³ termina quando for 4  
0DDC:  MOVF   63,W
0DDD:  SUBLW  04
0DDE:  BTFSS  03.2
0DDF:  GOTO   214
0DE0:  BCF    0A.3
0DE1:  BCF    0A.4
0DE2:  GOTO   79B (RETURN)
....................     
....................   
....................  
....................     
.................... } 
....................  
.................... unsigned char readKeyboard(){ 
....................    unsigned char tmp; 
....................    unsigned char tmp_result; 
....................     
....................    tmp = tc_tecla(1500); // ms 
*
04B1:  MOVLW  DC
04B2:  MOVWF  74
*
05E2:  MOVF   78,W
05E3:  MOVWF  72
....................    if(tmp != 255){ 
05E4:  INCFSZ 72,W
05E5:  GOTO   5E7
05E6:  GOTO   5E8
....................       // write_ext_eeprom(0, tmp); 
....................       // delay_ms(50); 
....................       // tmp_result = read_ext_eeprom(0); 
....................       // delay_ms(50); 
....................       // tmp_result = tmp; 
....................       // printf(lcd_escreve,"\f Button: %c", tmp); 
....................       // delay_ms(50); 
....................    }else{  
05E7:  GOTO   5EF
....................       printf(lcd_escreve,"\f   TECLADO  "); 
05E8:  MOVLW  0E
05E9:  BSF    03.6
05EA:  MOVWF  0D
05EB:  MOVLW  01
05EC:  MOVWF  0F
05ED:  BCF    03.6
05EE:  CALL   243
....................    } 
....................  
....................    return tmp; 
05EF:  MOVF   72,W
05F0:  MOVWF  78
05F1:  RETURN
.................... } 
....................  
....................  
.................... int * getAdminsID(){ 
....................  
....................    int address = 0; 
....................    int temp_status; 
....................    int index= 0; 
....................    static int admins[BLOCK_SIZE]; 
*
0763:  CLRF   44
0764:  CLRF   45
0765:  CLRF   46
0766:  CLRF   47
0767:  CLRF   48
0768:  CLRF   49
0769:  CLRF   4A
....................    admins[0] = -1; 
....................    while( read_ext_eeprom(address) != -1){ 
....................       temp_status = read_ext_eeprom(address + (BLOCK_SIZE - 1));//status of the user 
....................       if (temp_status == 3){ 
....................          printf (lcd_escreve,"\fAdmin Encontrado"); 
....................          delay_ms(1000); 
....................          for(int i=0; i < 2; i++){ 
....................             int id = read_ext_eeprom(address+i);    
....................             admins[index] = id; 
....................             index++; 
....................          } 
....................  
....................       } 
....................  
....................       address += BLOCK_SIZE;  
....................    } 
....................  
....................    return admins; 
....................  
.................... } 
....................  
.................... void listAdmins(){ 
....................    int * admins; 
....................  
....................    admins = getAdminsID(); 
....................    printf(lcd_escreve,"\f admins[0]: %d", admins[0]); 
....................    delay_ms(1000); 
....................    if(admins[0] != -1){ 
....................       for (int16 i=0; i < sizeof(admins); i+=2){ 
....................          printf(lcd_escreve, "\fid~:%u%u",admins[i], admins[i+1]); 
....................          delay_ms(1000); 
....................       }  
....................    } 
.................... } 
....................  
....................  
.................... int * strToInt(char * str){ 
*
06ED:  MOVF   73,W
06EE:  MOVWF  75
06EF:  MOVF   72,W
06F0:  MOVWF  74
06F1:  CLRF   76
....................  
....................   char *p = str; 
....................   //https://flaviocopes.com/c-array-length/ 
.................... //   int size = (sizeof str) / (sizeof * str); 
....................   static unsigned int buffer[BLOCK_SIZE];   
*
076A:  CLRF   4B
076B:  CLRF   4C
076C:  CLRF   4D
076D:  CLRF   4E
076E:  CLRF   4F
076F:  CLRF   50
0770:  CLRF   51
.................... //   printf(lcd_escreve,"\fParsing: %s",p); 
.................... //   delay_ms(1000); 
....................   char * end; 
....................   int index = 0; 
....................  
....................   for (unsigned int number = strtoul(p, &end, 10); 
*
06F2:  MOVF   75,W
06F3:  BSF    03.5
06F4:  MOVWF  22
06F5:  MOVF   74,W
06F6:  MOVWF  21
06F7:  CLRF   24
06F8:  MOVLW  7B
06F9:  MOVWF  23
06FA:  MOVLW  0A
06FB:  MOVWF  25
06FC:  BSF    0A.3
06FD:  BCF    03.5
06FE:  CALL   000
06FF:  BCF    0A.3
0700:  MOVF   78,W
0701:  MOVWF  7D
....................         p != end; 
0702:  MOVF   7B,W
0703:  SUBWF  74,W
0704:  BTFSS  03.2
0705:  GOTO   70A
0706:  MOVF   7C,W
0707:  SUBWF  75,W
0708:  BTFSC  03.2
0709:  GOTO   737
....................         number = strtoul(p, &end, 10)) 
....................   { 
....................     printf(lcd_escreve,"\n%u",number ); 
070A:  MOVLW  0A
070B:  BSF    03.5
070C:  MOVWF  30
070D:  BCF    03.5
070E:  CALL   200
070F:  MOVF   7D,W
0710:  BSF    03.5
0711:  MOVWF  2C
0712:  MOVLW  1B
0713:  MOVWF  2D
0714:  BCF    03.5
0715:  CALL   6AE
....................     delay_ms(50); 
0716:  MOVLW  32
0717:  BSF    03.5
0718:  MOVWF  31
0719:  BCF    03.5
071A:  CALL   149
....................     p = end; 
071B:  MOVF   7C,W
071C:  MOVWF  75
071D:  MOVF   7B,W
071E:  MOVWF  74
....................  
....................     buffer[index] = number;  
071F:  MOVLW  4B
0720:  ADDWF  76,W
0721:  MOVWF  04
0722:  BCF    03.7
0723:  MOVF   7D,W
0724:  MOVWF  00
....................     index++; 
0725:  INCF   76,F
0726:  MOVF   75,W
0727:  BSF    03.5
0728:  MOVWF  22
0729:  MOVF   74,W
072A:  MOVWF  21
072B:  CLRF   24
072C:  MOVLW  7B
072D:  MOVWF  23
072E:  MOVLW  0A
072F:  MOVWF  25
0730:  BSF    0A.3
0731:  BCF    03.5
0732:  CALL   000
0733:  BCF    0A.3
0734:  MOVF   78,W
0735:  MOVWF  7D
0736:  GOTO   702
....................   } 
....................  
....................    return buffer; 
0737:  MOVLW  4B
0738:  MOVWF  78
0739:  MOVLW  00
073A:  MOVWF  79
073B:  RETURN
.................... } 
....................  
.................... char * strfromchar(char destination[], char source)  
.................... {  
....................    destination[0] = source;   // copy the character into the string  
073C:  MOVF   72,W
073D:  MOVWF  04
073E:  BCF    03.7
073F:  BTFSC  73.0
0740:  BSF    03.7
0741:  MOVF   74,W
0742:  MOVWF  00
....................    destination[1] = '\0';      // null-terminate the string  
0743:  MOVLW  01
0744:  ADDWF  72,W
0745:  MOVWF  04
0746:  BCF    03.7
0747:  BTFSC  73.0
0748:  BSF    03.7
0749:  CLRF   00
....................   
....................    return destination;         // common convention for str functions  
074A:  MOVF   72,W
074B:  MOVWF  78
074C:  MOVF   73,W
074D:  MOVWF  79
074E:  RETURN
.................... }  
....................  
....................  
.................... /* 
.................... // ---- MSG from serial communication 
.................... #int_RDA 
.................... void RDA_isr(void){ 
....................    rx_buffer[rx_wr_index] = getc(); 
....................    rxd = rx_buffer[rx_wr_index]; 
....................    rx_wr_index++; 
....................  
....................    if(rx_wr_index > RX_BUFFER_SIZE){ 
....................       rx_wr_index = 0; 
....................    } 
....................  
....................    //Look for unique ID: "IFMT" 
....................    if(rxd == 'I' && lock_pos == 0){ 
....................       lock_pos++; 
....................    } 
....................    else if(rxd == 'F' && lock_pos == 1){ 
....................       lock_pos++; 
....................    } 
....................    else if(rxd == 'M' && lock_pos == 2){ 
....................       lock_pos++; 
....................    } 
....................    else if(rxd == 'T' && lock_pos == 3){ 
....................       lock_pos=0; //Reset the "combination lock" 
....................       got_id = TRUE; 
....................       read = rxd; 
....................       //get ready to count the number of data bytes 
....................       valid_data_count = 0xff;  
....................  
....................       //buffer is reset to index 0 
....................       rx_wr_index = 0; 
....................    }else { 
....................       lock_pos = 0; 
....................    } 
....................  
....................    if(got_id && ++valid_data_count >= 6){ 
....................       data_avail = TRUE; 
....................       got_id = FALSE; 
....................    } 
....................     
.................... } 
.................... */ 
....................  
....................  
....................  
....................  
.................... #int_TIMER1 
.................... void TIMER1_isr(void) 
.................... { 
.................... } 
....................  
*
012B:  BCF    0C.0
012C:  BCF    0A.3
012D:  BCF    0A.4
012E:  GOTO   031
.................... #int_RTCC 
.................... void RTCC_isr(void) 
.................... { 
....................  
....................        
012F:  BCF    0B.2
0130:  BCF    0A.3
0131:  BCF    0A.4
0132:  GOTO   031
.................... } 
....................  
.................... void main() 
*
074F:  MOVF   03,W
0750:  ANDLW  1F
0751:  MOVWF  03
0752:  CLRF   2C
0753:  CLRF   2D
0754:  CLRF   31
0755:  CLRF   32
0756:  MOVLW  FF
0757:  MOVWF  3D
0758:  BSF    03.5
0759:  BSF    1F.0
075A:  BSF    1F.1
075B:  BSF    1F.2
075C:  BCF    1F.3
075D:  MOVLW  07
075E:  MOVWF  1C
075F:  BCF    03.7
*
0771:  CLRF   54
.................... { 
....................    //VARIAVEIS 
....................    byte result; 
....................    unsigned char option; 
....................     
....................    eeprom_address address = 0; 
....................  
....................    // unsigned char tmp_result; 
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_256|RTCC_8_bit);      //13.1ms overflow 
0772:  BSF    03.5
0773:  MOVF   01,W
0774:  ANDLW  C0
0775:  IORLW  07
0776:  MOVWF  01
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); //Overflow in 104ms | Resolution 1.6 us 
0777:  MOVLW  B5
0778:  BCF    03.5
0779:  MOVWF  10
....................  
....................    init_ext_eeprom(); 
077A:  GOTO   13C
....................  
....................    enable_interrupts(INT_TIMER0); 
077B:  BSF    0B.5
....................    enable_interrupts(INT_TIMER1); 
077C:  BSF    03.5
077D:  BSF    0C.0
....................  
....................    enable_interrupts(GLOBAL); 
077E:  MOVLW  C0
077F:  BCF    03.5
0780:  IORWF  0B,F
....................  
....................  
....................    lcd_ini(); 
0781:  GOTO   1B7
....................    delay_us(50); 
0782:  MOVLW  52
0783:  MOVWF  77
0784:  DECFSZ 77,F
0785:  GOTO   784
0786:  GOTO   787
0787:  NOP
....................    printf(lcd_escreve, "\f  iniciando... "); 
0788:  MOVLW  33
0789:  BSF    03.6
078A:  MOVWF  0D
078B:  MOVLW  01
078C:  MOVWF  0F
078D:  BCF    03.6
078E:  CALL   243
....................    delay_ms(500); 
078F:  MOVLW  02
0790:  MOVWF  55
0791:  MOVLW  FA
0792:  BSF    03.5
0793:  MOVWF  31
0794:  BCF    03.5
0795:  CALL   149
0796:  DECFSZ 55,F
0797:  GOTO   791
....................  
....................    // printf(lcd_escreve, "\fIFMT - Serial"); 
....................    // delay_ms(50); 
....................  
....................    // int size = BLOCK_SIZE; 
....................    // printf(lcd_escreve, "\fBlock_Size:%u", size); 
....................    // delay_ms(500); 
....................  
....................    resetMemory(); 
0798:  GOTO   47F
....................  
....................    // data_avail = FALSE; 
....................    // int id [2] = {12,34}; 
....................    // int pass [4] = {1,2,3,4}; 
....................    // saveUser(id, pass, 1); 
....................    // int id1 [2] = {14,0}; 
....................    // saveuser(id1, pass, 0); 
....................    // int id2 [2] = {5,5}; 
....................    // saveuser(id2, pass, 1); 
....................    // int id3 [2] = {70,00}; 
....................    // saveuser(id3, pass, 1); 
....................    // int id4 [2] = {254,254}; 
....................    // saveuser(id4, pass, 3);//admin 
....................    // adminMenu(); 
....................     
....................    //// listAdmins(); 
....................    adminMenu(); 
0799:  BSF    0A.3
079A:  GOTO   214
079B:  BCF    0A.3
....................  
....................  
....................  
....................  
....................    // char keyboard_buffer[]= '6'; 
....................    // char n = '9'; 
....................    // unsigned char temp_pass[2]; 
....................    // unsigned int * buffer; 
....................    // unsigned int pass[4]; 
....................    // strfromchar(temp_pass,n); 
....................    // buffer = strToInt(temp_pass); 
....................    // pass[0] = buffer[0]; 
....................  
....................    // printf(lcd_escreve,"\foutside:%u", pass[0]); 
....................    // delay_ms(800); 
....................  
....................  
....................    // int index = 2; 
....................    // if(index>0){//for testing purposes 
....................    //    for(int i=0; i < index; i++){ 
....................    //       printf(lcd_escreve,"\foutside:%u", buffer[i]); 
....................    //       delay_ms(800); 
....................    //    } 
....................    // } 
....................   
....................   
....................   // address_data_delete = getAddressByID(6); 
....................   // printf(lcd_escreve, "\f Address ID = %d", address_data_delete); 
....................  //  deleteBlock(address_data_delete); 
....................    delay_ms(50); 
079C:  MOVLW  32
079D:  BSF    03.5
079E:  MOVWF  31
079F:  BCF    03.5
07A0:  CALL   149
....................     
....................    while(TRUE) 
....................    { 
07A1:  GOTO   7A1
....................    } 
....................  
.................... } 
....................  
07A2:  SLEEP

Configuration Fuses:
   Word  1: 3F32   HS NOWDT PUT NOBROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT

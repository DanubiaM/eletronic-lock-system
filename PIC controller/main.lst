CCS PCM C Compiler, Version 5.025, 7201               23-nov-21 08:10

               Filename:   C:\Users\danub\OneDrive\Área de Trabalho\git\eletronic-lock-system\PIC controller\main.lst

               ROM used:   1942 words (24%)
                           Largest free fragment is 2048
               RAM used:   75 (20%) at main() level
                           156 (42%) worst case
               Stack used: 5 locations (4 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  07
0001:  MOVWF  0A
0002:  GOTO   734
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  MOVLW  8C
0028:  MOVWF  04
0029:  BTFSS  00.5
002A:  GOTO   02D
002B:  BTFSC  0C.5
002C:  GOTO   04E
002D:  MOVF   22,W
002E:  MOVWF  04
002F:  MOVF   23,W
0030:  MOVWF  77
0031:  MOVF   24,W
0032:  MOVWF  78
0033:  MOVF   25,W
0034:  MOVWF  79
0035:  MOVF   26,W
0036:  MOVWF  7A
0037:  MOVF   27,W
0038:  BSF    03.6
0039:  MOVWF  0D
003A:  BCF    03.6
003B:  MOVF   28,W
003C:  BSF    03.6
003D:  MOVWF  0F
003E:  BCF    03.6
003F:  MOVF   29,W
0040:  BSF    03.6
0041:  MOVWF  0C
0042:  BCF    03.6
0043:  MOVF   2A,W
0044:  BSF    03.6
0045:  MOVWF  0E
0046:  BCF    03.6
0047:  MOVF   20,W
0048:  MOVWF  0A
0049:  SWAPF  21,W
004A:  MOVWF  03
004B:  SWAPF  7F,F
004C:  SWAPF  7F,W
004D:  RETFIE
004E:  BCF    0A.3
004F:  BCF    0A.4
0050:  GOTO   186
....................  
.................... #include <16F877A.h> 
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
0051:  BCF    0A.0
0052:  BCF    0A.1
0053:  BCF    0A.2
0054:  ADDWF  02,F
0055:  RETLW  28
0056:  RETLW  0F
0057:  RETLW  01
0058:  RETLW  06
0059:  DATA 8C,2A
005A:  DATA F3,3A
005B:  DATA 61,39
005C:  DATA E9,37
005D:  DATA A0,21
005E:  DATA 61,32
005F:  DATA E1,39
0060:  DATA 74,39
0061:  DATA 61,32
0062:  DATA 6F,00
0063:  DATA 8C,24
0064:  DATA 44,10
0065:  DATA 69,37
0066:  DATA E3,37
0067:  DATA 6D,38
0068:  DATA 61,3A
0069:  DATA 69,3B
006A:  DATA 65,36
006B:  DATA 00,01
006C:  DATA 0D,05
006D:  DATA D4,32
006E:  DATA 6E,3A
006F:  DATA 65,10
0070:  DATA EE,37
0071:  DATA F6,30
0072:  DATA ED,32
0073:  DATA 6E,3A
0074:  DATA 65,00
0075:  DATA 8C,2A
0076:  DATA F3,3A
0077:  DATA 61,39
0078:  DATA E9,37
0079:  DATA A0,20
007A:  DATA F4,3A
007B:  DATA 61,36
007C:  DATA 69,3D
007D:  DATA 61,32
007E:  DATA 6F,00
007F:  DATA 8C,24
0080:  DATA 44,10
0081:  DATA 69,37
0082:  DATA E3,37
0083:  DATA 6D,38
0084:  DATA 61,3A
0085:  DATA 69,3B
0086:  DATA 65,36
0087:  DATA 00,01
0088:  DATA 0D,05
0089:  DATA D4,32
008A:  DATA 6E,3A
008B:  DATA 65,10
008C:  DATA EE,37
008D:  DATA F6,30
008E:  DATA ED,32
008F:  DATA 6E,3A
0090:  DATA 65,00
0091:  DATA 8C,21
0092:  DATA EC,34
0093:  DATA 65,37
0094:  DATA F4,32
0095:  DATA A0,24
0096:  DATA 44,1D
0097:  DATA A0,12
0098:  DATA F5,12
0099:  DATA 75,00
009A:  DATA 0D,05
009B:  DATA D0,3B
009C:  DATA BA,12
009D:  DATA F5,12
009E:  DATA F5,12
009F:  DATA F5,12
00A0:  DATA 75,10
00A1:  DATA 53,3A
00A2:  DATA BA,12
00A3:  DATA 75,00
00A4:  DATA 8C,24
00A5:  DATA 44,1D
00A6:  DATA A5,3A
00A7:  DATA A5,3A
00A8:  DATA 00,01
00A9:  DATA 8C,2A
00AA:  DATA F3,3A
00AB:  DATA 61,39
00AC:  DATA E9,37
00AD:  DATA 20,27
00AE:  DATA A0,22
00AF:  DATA F8,34
00B0:  DATA 73,3A
00B1:  DATA 65,00
00B2:  DATA 0C,10
00B3:  DATA D5,39
00B4:  DATA 65,39
00B5:  DATA A0,32
00B6:  DATA F2,30
00B7:  DATA F3,32
00B8:  DATA 64,10
00B9:  DATA 00,00
00BA:  DATA 0D,05
00BB:  DATA 53,3A
00BC:  DATA 61,3A
00BD:  DATA F5,39
00BE:  DATA BA,12
00BF:  DATA 73,00
00C0:  DATA 8C,18
00C1:  DATA BA,21
00C2:  DATA 41,22
00C3:  DATA 7C,19
00C4:  DATA 3A,21
00C5:  DATA D5,29
00C6:  DATA C3,20
00C7:  DATA 52,00
00C8:  DATA 0D,05
00C9:  DATA 33,1D
00CA:  DATA C4,22
00CB:  DATA 4C,3E
00CC:  DATA 34,1D
00CD:  DATA 45,22
00CE:  DATA 49,2A
00CF:  DATA 41,29
00D0:  DATA 00,01
00D1:  DATA 8C,1A
00D2:  DATA 3A,10
00D3:  DATA D3,20
00D4:  DATA 49,29
00D5:  DATA 20,32
00D6:  DATA 6F,10
00D7:  DATA CD,32
00D8:  DATA EE,3A
00D9:  DATA 20,00
00DA:  DATA 0C,10
00DB:  DATA 4F,38
00DC:  DATA F4,34
00DD:  DATA 6F,37
00DE:  DATA 3A,10
00DF:  DATA A5,31
00E0:  DATA 00,01
00E1:  DATA 8C,29
00E2:  DATA F5,31
00E3:  DATA E3,32
00E4:  DATA F3,39
00E5:  DATA A0,16
00E6:  DATA 3E,10
00E7:  DATA 25,32
00E8:  DATA 00,10
00E9:  DATA 8C,3A
00EA:  DATA F3,3A
00EB:  DATA 61,39
00EC:  DATA E9,37
00ED:  DATA 20,32
00EE:  DATA 65,36
00EF:  DATA 65,3A
00F0:  DATA 61,32
00F1:  DATA 6F,00
00F2:  DATA 8C,3A
00F3:  DATA F3,3A
00F4:  DATA 61,39
00F5:  DATA E9,37
00F6:  DATA 20,27
00F7:  DATA A0,22
00F8:  DATA F8,34
00F9:  DATA 73,3A
00FA:  DATA 65,00
00FB:  DATA 0C,22
00FC:  DATA E9,33
00FD:  DATA 69,3A
00FE:  DATA 65,10
00FF:  DATA F5,36
0100:  DATA 20,3B
0101:  DATA 61,36
0102:  DATA 6F,39
0103:  DATA 00,01
0104:  DATA 0D,05
0105:  DATA D6,30
0106:  DATA EC,34
0107:  DATA E4,37
0108:  DATA 21,00
0109:  DATA 8C,24
010A:  DATA 44,10
010B:  DATA 4E,10
010C:  DATA 45,3C
010D:  DATA E9,39
010E:  DATA F4,32
010F:  DATA 00,01
0110:  DATA 0D,05
0111:  DATA D4,32
0112:  DATA 6E,3A
0113:  DATA 65,10
0114:  DATA E4,32
0115:  DATA 20,37
0116:  DATA 6F,3B
0117:  DATA 6F,00
0118:  DATA 0C,28
0119:  DATA F2,37
011A:  DATA E3,3A
011B:  DATA F2,32
011C:  DATA A0,30
011D:  DATA A0,39
011E:  DATA E5,31
011F:  DATA F2,32
0120:  DATA F4,30
0121:  DATA F2,34
0122:  DATA 61,00
0123:  DATA 0D,05
0124:  DATA D0,17
0125:  DATA 20,39
0126:  DATA E5,39
0127:  DATA 6F,36
0128:  DATA F6,32
0129:  DATA 72,00
012A:  DATA 0C,27
012B:  DATA 41,22
012C:  DATA 41,10
012D:  DATA 65,34
012E:  DATA 20,26
012F:  DATA E9,33
0130:  DATA 61,32
0131:  DATA EF,10
0132:  DATA 00,00
0133:  DATA 0C,10
0134:  DATA C4,34
0135:  DATA E7,34
0136:  DATA F4,32
0137:  DATA 00,00
0138:  DATA 8C,20
0139:  DATA E4,36
013A:  DATA 69,37
013B:  DATA A0,22
013C:  DATA EE,31
013D:  DATA 6F,37
013E:  DATA 74,39
013F:  DATA 61,32
0140:  DATA 6F,00
0141:  DATA 0C,10
0142:  DATA 61,32
0143:  DATA ED,34
0144:  DATA EE,39
0145:  DATA 5B,18
0146:  DATA 5D,1D
0147:  DATA A0,12
0148:  DATA 64,00
0149:  DATA 8C,34
014A:  DATA 64,1D
014B:  DATA A5,3A
014C:  DATA A5,3A
014D:  DATA 00,00
014E:  DATA 0C,22
014F:  DATA E9,33
0150:  DATA 69,3A
0151:  DATA 65,10
0152:  DATA 6F,10
0153:  DATA 49,22
0154:  DATA 3A,10
0155:  DATA 00,01
0156:  DATA 8A,06
0157:  DATA D4,3C
0158:  DATA F0,32
0159:  DATA 64,1D
015A:  DATA A5,31
015B:  DATA 00,00
015C:  DATA 8A,06
015D:  DATA D4,3C
015E:  DATA F0,32
015F:  DATA 64,1D
0160:  DATA A5,31
0161:  DATA 00,00
0162:  DATA 8C,34
0163:  DATA 64,1D
0164:  DATA A0,12
0165:  DATA F5,12
0166:  DATA 75,00
0167:  DATA 8C,24
0168:  DATA 44,10
0169:  DATA CA,30
016A:  DATA 68,10
016B:  DATA 45,3C
016C:  DATA E9,39
016D:  DATA F4,32
016E:  DATA 00,00
016F:  DATA 0C,28
0170:  DATA C1,29
0171:  DATA 53,14
0172:  DATA B4,14
0173:  DATA 3A,10
0174:  DATA A5,3A
0175:  DATA A5,3A
0176:  DATA A5,3A
0177:  DATA A5,3A
0178:  DATA 00,01
0179:  DATA 8C,29
017A:  DATA D4,20
017B:  DATA D4,2A
017C:  DATA 53,1D
017D:  DATA A0,12
017E:  DATA 75,00
017F:  DATA 8C,24
0180:  DATA 44,10
0181:  DATA 4E,10
0182:  DATA 45,3C
0183:  DATA E9,39
0184:  DATA F4,32
0185:  DATA 00,00
*
01EF:  DATA 0C,10
01F0:  DATA A0,34
01F1:  DATA EE,34
01F2:  DATA E3,34
01F3:  DATA 61,37
01F4:  DATA E4,37
01F5:  DATA 2E,17
01F6:  DATA 2E,10
01F7:  DATA 00,01
01F8:  DATA 8C,24
01F9:  DATA C6,26
01FA:  DATA 54,10
01FB:  DATA 2D,10
01FC:  DATA D3,32
01FD:  DATA F2,34
01FE:  DATA 61,36
01FF:  DATA 00,00
*
0305:  MOVF   0B,W
0306:  MOVWF  65
0307:  BCF    0B.7
0308:  BSF    03.5
0309:  BSF    03.6
030A:  BSF    0C.7
030B:  BSF    0C.0
030C:  NOP
030D:  NOP
030E:  BCF    03.5
030F:  BCF    03.6
0310:  BTFSC  65.7
0311:  BSF    0B.7
0312:  BSF    03.6
0313:  MOVF   0C,W
0314:  ANDLW  7F
0315:  BTFSC  03.2
0316:  GOTO   359
0317:  BCF    03.6
0318:  MOVWF  65
0319:  BSF    03.6
031A:  MOVF   0D,W
031B:  BCF    03.6
031C:  MOVWF  66
031D:  BSF    03.6
031E:  MOVF   0F,W
031F:  BCF    03.6
0320:  MOVWF  67
0321:  MOVF   65,W
0322:  MOVWF  7E
0323:  CALL   2C4
0324:  MOVF   66,W
0325:  BSF    03.6
0326:  MOVWF  0D
0327:  BCF    03.6
0328:  MOVF   67,W
0329:  BSF    03.6
032A:  MOVWF  0F
032B:  BCF    03.6
032C:  MOVF   0B,W
032D:  MOVWF  68
032E:  BCF    0B.7
032F:  BSF    03.5
0330:  BSF    03.6
0331:  BSF    0C.7
0332:  BSF    0C.0
0333:  NOP
0334:  NOP
0335:  BCF    03.5
0336:  BCF    03.6
0337:  BTFSC  68.7
0338:  BSF    0B.7
0339:  BSF    03.6
033A:  RLF    0C,W
033B:  RLF    0E,W
033C:  ANDLW  7F
033D:  BTFSC  03.2
033E:  GOTO   359
033F:  BCF    03.6
0340:  MOVWF  65
0341:  BSF    03.6
0342:  MOVF   0D,W
0343:  BCF    03.6
0344:  MOVWF  66
0345:  BSF    03.6
0346:  MOVF   0F,W
0347:  BCF    03.6
0348:  MOVWF  67
0349:  MOVF   65,W
034A:  MOVWF  7E
034B:  CALL   2C4
034C:  MOVF   66,W
034D:  BSF    03.6
034E:  MOVWF  0D
034F:  BCF    03.6
0350:  MOVF   67,W
0351:  BSF    03.6
0352:  MOVWF  0F
0353:  INCF   0D,F
0354:  BTFSC  03.2
0355:  INCF   0F,F
0356:  BCF    03.6
0357:  GOTO   305
0358:  BSF    03.6
0359:  BCF    03.6
035A:  RETURN
*
04FB:  MOVF   51,W
04FC:  XORWF  53,W
04FD:  ANDLW  80
04FE:  MOVWF  55
04FF:  BTFSS  51.7
0500:  GOTO   506
0501:  COMF   50,F
0502:  COMF   51,F
0503:  INCF   50,F
0504:  BTFSC  03.2
0505:  INCF   51,F
0506:  BTFSS  53.7
0507:  GOTO   50D
0508:  COMF   52,F
0509:  COMF   53,F
050A:  INCF   52,F
050B:  BTFSC  03.2
050C:  INCF   53,F
050D:  MOVLW  10
050E:  MOVWF  54
050F:  CLRF   77
0510:  CLRF   7A
0511:  RRF    51,F
0512:  RRF    50,F
0513:  BTFSS  03.0
0514:  GOTO   51B
0515:  MOVF   52,W
0516:  ADDWF  77,F
0517:  BTFSC  03.0
0518:  INCF   7A,F
0519:  MOVF   53,W
051A:  ADDWF  7A,F
051B:  RRF    7A,F
051C:  RRF    77,F
051D:  RRF    79,F
051E:  RRF    78,F
051F:  DECFSZ 54,F
0520:  GOTO   511
0521:  BTFSS  55.7
0522:  GOTO   528
0523:  COMF   78,F
0524:  COMF   79,F
0525:  INCF   78,F
0526:  BTFSC  03.2
0527:  INCF   79,F
*
0598:  MOVF   0B,W
0599:  MOVWF  7B
059A:  BCF    0B.7
059B:  BSF    03.5
059C:  BSF    03.6
059D:  BSF    0C.7
059E:  BSF    0C.0
059F:  NOP
05A0:  NOP
05A1:  BTFSS  7B.7
05A2:  GOTO   5A8
05A3:  BCF    03.5
05A4:  BCF    03.6
05A5:  BSF    0B.7
05A6:  BSF    03.5
05A7:  BSF    03.6
05A8:  BTFSC  03.0
05A9:  GOTO   5CF
05AA:  BCF    03.5
05AB:  MOVF   0C,W
05AC:  ANDLW  7F
05AD:  MOVWF  7B
05AE:  MOVF   0D,W
05AF:  MOVWF  7C
05B0:  MOVF   0F,W
05B1:  MOVWF  7D
05B2:  MOVF   7B,W
05B3:  MOVWF  7E
05B4:  BCF    03.6
05B5:  CALL   2C4
05B6:  MOVF   7C,W
05B7:  BSF    03.6
05B8:  MOVWF  0D
05B9:  MOVF   7D,W
05BA:  MOVWF  0F
05BB:  BCF    03.6
05BC:  MOVF   0B,W
05BD:  MOVWF  7E
05BE:  BCF    0B.7
05BF:  BSF    03.5
05C0:  BSF    03.6
05C1:  BSF    0C.7
05C2:  BSF    0C.0
05C3:  NOP
05C4:  NOP
05C5:  BTFSS  7E.7
05C6:  GOTO   5CC
05C7:  BCF    03.5
05C8:  BCF    03.6
05C9:  BSF    0B.7
05CA:  BSF    03.5
05CB:  BSF    03.6
05CC:  DECFSZ 75,F
05CD:  GOTO   5CF
05CE:  GOTO   5EB
05CF:  BCF    03.5
05D0:  RLF    0C,W
05D1:  RLF    0E,W
05D2:  ANDLW  7F
05D3:  MOVWF  7B
05D4:  MOVF   0D,W
05D5:  MOVWF  7C
05D6:  MOVF   0F,W
05D7:  MOVWF  7D
05D8:  MOVF   7B,W
05D9:  MOVWF  7E
05DA:  BCF    03.6
05DB:  CALL   2C4
05DC:  MOVF   7C,W
05DD:  BSF    03.6
05DE:  MOVWF  0D
05DF:  MOVF   7D,W
05E0:  MOVWF  0F
05E1:  INCF   0D,F
05E2:  BTFSC  03.2
05E3:  INCF   0F,F
05E4:  BCF    03.0
05E5:  DECFSZ 75,F
05E6:  GOTO   5E8
05E7:  GOTO   5EA
05E8:  BCF    03.6
05E9:  GOTO   598
05EA:  BSF    03.5
05EB:  BCF    03.5
05EC:  BCF    03.6
05ED:  RETURN
05EE:  MOVF   7C,W
05EF:  CLRF   78
05F0:  SUBWF  7B,W
05F1:  BTFSC  03.0
05F2:  GOTO   5F6
05F3:  MOVF   7B,W
05F4:  MOVWF  77
05F5:  GOTO   602
05F6:  CLRF   77
05F7:  MOVLW  08
05F8:  MOVWF  7D
05F9:  RLF    7B,F
05FA:  RLF    77,F
05FB:  MOVF   7C,W
05FC:  SUBWF  77,W
05FD:  BTFSC  03.0
05FE:  MOVWF  77
05FF:  RLF    78,F
0600:  DECFSZ 7D,F
0601:  GOTO   5F9
0602:  RETURN
0603:  MOVF   78,W
0604:  MOVF   75,W
0605:  MOVWF  7B
0606:  MOVLW  64
0607:  MOVWF  7C
0608:  CALL   5EE
0609:  MOVF   77,W
060A:  MOVWF  75
060B:  MOVF   78,W
060C:  MOVLW  30
060D:  BTFSS  03.2
060E:  GOTO   616
060F:  BTFSS  76.1
0610:  GOTO   61D
0611:  BTFSC  76.3
0612:  GOTO   61D
0613:  BTFSC  76.4
0614:  MOVLW  20
0615:  GOTO   619
0616:  BCF    76.3
0617:  BCF    76.4
0618:  BSF    76.0
0619:  ADDWF  78,F
061A:  MOVF   78,W
061B:  MOVWF  7E
061C:  CALL   2C4
061D:  MOVF   75,W
061E:  MOVWF  7B
061F:  MOVLW  0A
0620:  MOVWF  7C
0621:  CALL   5EE
0622:  MOVF   77,W
0623:  MOVWF  75
0624:  MOVF   78,W
0625:  MOVLW  30
0626:  BTFSS  03.2
0627:  GOTO   62E
0628:  BTFSC  76.3
0629:  GOTO   632
062A:  BTFSS  76.0
062B:  GOTO   632
062C:  BTFSC  76.4
062D:  MOVLW  20
062E:  ADDWF  78,F
062F:  MOVF   78,W
0630:  MOVWF  7E
0631:  CALL   2C4
0632:  MOVLW  30
0633:  ADDWF  75,F
0634:  MOVF   75,W
0635:  MOVWF  7E
0636:  CALL   2C4
0637:  RETURN
*
063E:  MOVF   00,F
063F:  BTFSC  03.2
0640:  GOTO   653
0641:  CLRF   6F
0642:  MOVF   04,W
0643:  MOVWF  6E
0644:  BCF    6F.0
0645:  BTFSC  03.7
0646:  BSF    6F.0
0647:  MOVF   00,W
0648:  MOVWF  7E
0649:  CALL   2C4
064A:  MOVF   6E,W
064B:  MOVWF  04
064C:  BCF    03.7
064D:  BTFSC  6F.0
064E:  BSF    03.7
064F:  INCF   04,F
0650:  BTFSC  03.2
0651:  INCF   05,F
0652:  GOTO   63E
....................  
.................... #list 
....................  
.................... #device ADC=8 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES HS  
....................  
.................... #use delay(crystal=20000000) 
*
020D:  MOVLW  A0
020E:  MOVWF  04
020F:  BCF    03.7
0210:  MOVF   00,W
0211:  BTFSC  03.2
0212:  GOTO   220
0213:  MOVLW  06
0214:  MOVWF  78
0215:  CLRF   77
0216:  DECFSZ 77,F
0217:  GOTO   216
0218:  DECFSZ 78,F
0219:  GOTO   215
021A:  MOVLW  7B
021B:  MOVWF  77
021C:  DECFSZ 77,F
021D:  GOTO   21C
021E:  DECFSZ 00,F
021F:  GOTO   213
0220:  RETURN
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=Wireless) 
....................  
....................  
.................... // -------Variables' Declaration 
.................... #define BLOCK_SIZE sizeof(User)  
.................... #define RX_BUFFER_SIZE 15 
.................... int8 rx_wr_index = 0; 
.................... int8 lock_pos = 0, rxd, read, valid_data_count; 
.................... int data_avail = FALSE, got_id = FALSE; 
.................... unsigned int8 rx_buffer[RX_BUFFER_SIZE]; 
.................... char string [RX_BUFFER_SIZE]; 
.................... #include "functions.c" 
.................... #include "functions.h" 
....................  
.................... //Define the default pins before calling the LCD driver 
.................... #ifndef lcd_enable  
....................    #define lcd_enable     pin_e1 
....................    #define lcd_rs         pin_e2 
....................    //#define lcd_rw       pin_e2   
....................    #define lcd_d4         pin_d4 
....................    #define lcd_d5         pin_d5 
....................    #define lcd_d6         pin_d6 
....................    #define lcd_d7         pin_d7 
.................... #endif 
....................  
.................... #include "mod_lcd.c" 
.................... /************************************************************************/ 
.................... /*  MOD_LCD.C - Biblioteca de manipulação de módulo LCD                 */ 
.................... /*                                                                      */ 
.................... /*  Autor: Fábio Pereira                                                */ 
.................... /*                                                                      */ 
.................... /************************************************************************/ 
....................  
.................... // As definições a seguir são utilizadas para acesso aos pinos do display 
.................... // caso o pino RW não seja utilizado, comente a definição lcd_rw 
.................... #ifndef lcd_enable 
....................    #define lcd_enable       pin_e1      // pino enable do LCD 
....................    #define lcd_rs         pin_e0      // pino rs do LCD 
....................    //#define lcd_rw      pin_e2      // pino rw  do LCD 
....................    #define lcd_d4         pin_d4      // pino de dados d4 do LCD 
....................    #define lcd_d5         pin_d5      // pino de dados d5 do LCD 
....................    #define lcd_d6         pin_d6      // pino de dados d6 do LCD 
....................    #define lcd_d7         pin_d7      // pino de dados d7 do LCD 
.................... #endif 
....................  
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 linhas 
.................... #define lcd_seg_lin 0x40    // Endereço da segunda linha na RAM do LCD 
....................  
.................... // a constante abaixo define a seqüência de inicialização do módulo LCD 
.................... byte CONST INI_LCD[4] = {0x20 | (lcd_type << 2), 0xf, 1, 6}; 
....................  
.................... byte lcd_le_byte() 
.................... // lê um byte do LCD (somente com pino RW) 
.................... { 
....................    byte dado; 
....................    // configura os pinos de dados como entradas 
....................    input(lcd_d4); 
....................    input(lcd_d5); 
....................    input(lcd_d6); 
....................    input(lcd_d7); 
....................    // se o pino rw for utilizado, coloca em 1 
....................    #ifdef lcd_rw 
....................       output_high(lcd_rw); 
....................    #endif 
....................    output_high(lcd_enable); // habilita display 
....................    dado = 0;   // zera a variável de leitura 
....................    // lê os quatro bits mais significativos 
....................    if (input(lcd_d7)) bit_set(dado,7); 
....................    if (input(lcd_d6)) bit_set(dado,6); 
....................    if (input(lcd_d5)) bit_set(dado,5); 
....................    if (input(lcd_d4)) bit_set(dado,4); 
....................    // dá um pulso na linha enable 
....................    output_low(lcd_enable); 
....................    output_high(lcd_enable); 
....................    // lê os quatro bits menos significativos 
....................    if (input(lcd_d7)) bit_set(dado,3); 
....................    if (input(lcd_d6)) bit_set(dado,2); 
....................    if (input(lcd_d5)) bit_set(dado,1); 
....................    if (input(lcd_d4)) bit_set(dado,0); 
....................    output_low(lcd_enable);   // desabilita o display 
....................    return dado;   // retorna o byte lido 
.................... } 
....................  
.................... void lcd_envia_nibble( byte dado ) 
.................... // envia um dado de quatro bits para o display 
.................... { 
....................    // coloca os quatro bits nas saidas 
....................    output_bit(lcd_d4,bit_test(dado,0)); 
0221:  BSF    03.5
0222:  BTFSC  27.0
0223:  GOTO   228
0224:  BCF    03.5
0225:  BCF    08.4
0226:  GOTO   22A
0227:  BSF    03.5
0228:  BCF    03.5
0229:  BSF    08.4
022A:  BSF    03.5
022B:  BCF    08.4
....................    output_bit(lcd_d5,bit_test(dado,1)); 
022C:  BTFSC  27.1
022D:  GOTO   232
022E:  BCF    03.5
022F:  BCF    08.5
0230:  GOTO   234
0231:  BSF    03.5
0232:  BCF    03.5
0233:  BSF    08.5
0234:  BSF    03.5
0235:  BCF    08.5
....................    output_bit(lcd_d6,bit_test(dado,2)); 
0236:  BTFSC  27.2
0237:  GOTO   23C
0238:  BCF    03.5
0239:  BCF    08.6
023A:  GOTO   23E
023B:  BSF    03.5
023C:  BCF    03.5
023D:  BSF    08.6
023E:  BSF    03.5
023F:  BCF    08.6
....................    output_bit(lcd_d7,bit_test(dado,3)); 
0240:  BTFSC  27.3
0241:  GOTO   246
0242:  BCF    03.5
0243:  BCF    08.7
0244:  GOTO   248
0245:  BSF    03.5
0246:  BCF    03.5
0247:  BSF    08.7
0248:  BSF    03.5
0249:  BCF    08.7
....................    // dá um pulso na linha enable 
....................    output_high(lcd_enable); 
024A:  BCF    09.1
024B:  BCF    03.5
024C:  BSF    09.1
....................    output_low(lcd_enable); 
024D:  BSF    03.5
024E:  BCF    09.1
024F:  BCF    03.5
0250:  BCF    09.1
0251:  RETURN
.................... } 
....................  
....................  
.................... void lcd_envia_byte( boolean endereco, byte dado ) 
.................... { 
....................    // coloca a linha rs em 0 
....................    output_low(lcd_rs); 
0252:  BSF    03.5
0253:  BCF    09.2
0254:  BCF    03.5
0255:  BCF    09.2
....................    // aguarda o display ficar desocupado 
....................    //while ( bit_test(lcd_le_byte(),7) ) ; 
....................    // configura a linha rs dependendo do modo selecionado 
....................    output_bit(lcd_rs,endereco); 
0256:  BSF    03.5
0257:  MOVF   24,F
0258:  BTFSS  03.2
0259:  GOTO   25E
025A:  BCF    03.5
025B:  BCF    09.2
025C:  GOTO   260
025D:  BSF    03.5
025E:  BCF    03.5
025F:  BSF    09.2
0260:  BSF    03.5
0261:  BCF    09.2
....................    delay_us(100);   // aguarda 100 us 
0262:  MOVLW  A6
0263:  MOVWF  77
0264:  DECFSZ 77,F
0265:  GOTO   264
0266:  NOP
....................    // caso a linha rw esteja definida, coloca em 0 
....................    #ifdef lcd_rw 
....................       output_low(lcd_rw); 
....................    #endif 
....................    // desativa linha enable 
....................    output_low(lcd_enable); 
0267:  BCF    09.1
0268:  BCF    03.5
0269:  BCF    09.1
....................    // envia a primeira parte do byte 
....................    lcd_envia_nibble(dado >> 4); 
026A:  BSF    03.5
026B:  SWAPF  25,W
026C:  MOVWF  26
026D:  MOVLW  0F
026E:  ANDWF  26,F
026F:  MOVF   26,W
0270:  MOVWF  27
0271:  BCF    03.5
0272:  CALL   221
....................    // envia a segunda parte do byte 
....................    lcd_envia_nibble(dado & 0x0f); 
0273:  BSF    03.5
0274:  MOVF   25,W
0275:  ANDLW  0F
0276:  MOVWF  26
0277:  MOVWF  27
0278:  BCF    03.5
0279:  CALL   221
027A:  RETURN
.................... } 
....................  
....................  
.................... void lcd_ini() 
.................... // rotina de inicialização do display 
.................... { 
....................    byte conta; 
....................    output_low(lcd_d4); 
027B:  BSF    03.5
027C:  BCF    08.4
027D:  BCF    03.5
027E:  BCF    08.4
....................    output_low(lcd_d5); 
027F:  BSF    03.5
0280:  BCF    08.5
0281:  BCF    03.5
0282:  BCF    08.5
....................    output_low(lcd_d6); 
0283:  BSF    03.5
0284:  BCF    08.6
0285:  BCF    03.5
0286:  BCF    08.6
....................    output_low(lcd_d7); 
0287:  BSF    03.5
0288:  BCF    08.7
0289:  BCF    03.5
028A:  BCF    08.7
....................    output_low(lcd_rs); 
028B:  BSF    03.5
028C:  BCF    09.2
028D:  BCF    03.5
028E:  BCF    09.2
....................    #ifdef lcd_rw 
....................       output_high(lcd_rw); 
....................    #endif 
....................    output_low(lcd_enable); 
028F:  BSF    03.5
0290:  BCF    09.1
0291:  BCF    03.5
0292:  BCF    09.1
....................    delay_ms(15); 
0293:  MOVLW  0F
0294:  BSF    03.5
0295:  MOVWF  20
0296:  BCF    03.5
0297:  CALL   20D
....................    // envia uma seqüência de 3 vezes 0x03 
....................    // e depois 0x02 para configurar o módulo 
....................    // para modo de 4 bits 
....................    for(conta=1;conta<=3;++conta) 
0298:  MOVLW  01
0299:  MOVWF  65
029A:  MOVF   65,W
029B:  SUBLW  03
029C:  BTFSS  03.0
029D:  GOTO   2AA
....................    { 
....................       lcd_envia_nibble(3); 
029E:  MOVLW  03
029F:  BSF    03.5
02A0:  MOVWF  27
02A1:  BCF    03.5
02A2:  CALL   221
....................       delay_ms(5); 
02A3:  MOVLW  05
02A4:  BSF    03.5
02A5:  MOVWF  20
02A6:  BCF    03.5
02A7:  CALL   20D
02A8:  INCF   65,F
02A9:  GOTO   29A
....................    } 
....................    lcd_envia_nibble(2); 
02AA:  MOVLW  02
02AB:  BSF    03.5
02AC:  MOVWF  27
02AD:  BCF    03.5
02AE:  CALL   221
....................    // envia string de inicialização do display 
....................    for(conta=0;conta<=3;++conta) lcd_envia_byte(0,INI_LCD[conta]); 
02AF:  CLRF   65
02B0:  MOVF   65,W
02B1:  SUBLW  03
02B2:  BTFSS  03.0
02B3:  GOTO   2C1
02B4:  MOVF   65,W
02B5:  CALL   051
02B6:  MOVWF  66
02B7:  BSF    03.5
02B8:  CLRF   24
02B9:  BCF    03.5
02BA:  MOVF   66,W
02BB:  BSF    03.5
02BC:  MOVWF  25
02BD:  BCF    03.5
02BE:  CALL   252
02BF:  INCF   65,F
02C0:  GOTO   2B0
02C1:  BCF    0A.3
02C2:  BCF    0A.4
02C3:  GOTO   765 (RETURN)
.................... } 
....................  
.................... void lcd_pos_xy( byte x, byte y) 
.................... { 
....................    byte endereco; 
....................    if(y!=1) 
*
02E3:  DECFSZ 21,W
02E4:  GOTO   2E6
02E5:  GOTO   2E9
....................       endereco = lcd_seg_lin; 
02E6:  MOVLW  40
02E7:  MOVWF  22
02E8:  GOTO   2EA
....................    else 
....................       endereco = 0; 
02E9:  CLRF   22
....................    endereco += x-1; 
02EA:  MOVLW  01
02EB:  SUBWF  20,W
02EC:  ADDWF  22,F
....................    lcd_envia_byte(0,0x80|endereco); 
02ED:  MOVF   22,W
02EE:  IORLW  80
02EF:  MOVWF  23
02F0:  CLRF   24
02F1:  MOVF   23,W
02F2:  MOVWF  25
02F3:  BCF    03.5
02F4:  CALL   252
.................... } 
....................  
.................... void lcd_escreve( char c) 
.................... // envia caractere para o display 
.................... { 
....................    switch (c) 
*
02C4:  MOVF   7E,W
02C5:  XORLW  0C
02C6:  BTFSC  03.2
02C7:  GOTO   2D2
02C8:  XORLW  06
02C9:  BTFSC  03.2
02CA:  GOTO   2DE
02CB:  XORLW  07
02CC:  BTFSC  03.2
02CD:  GOTO   2DE
02CE:  XORLW  05
02CF:  BTFSC  03.2
02D0:  GOTO   2F6
02D1:  GOTO   2FD
....................    { 
....................      case '\f'    :   lcd_envia_byte(0,1); 
02D2:  BSF    03.5
02D3:  CLRF   24
02D4:  MOVLW  01
02D5:  MOVWF  25
02D6:  BCF    03.5
02D7:  CALL   252
....................               delay_ms(2); 
02D8:  MOVLW  02
02D9:  BSF    03.5
02DA:  MOVWF  20
02DB:  BCF    03.5
02DC:  CALL   20D
....................             break; 
02DD:  GOTO   304
....................      case '\n'   : 
....................      case '\r'    :   lcd_pos_xy(1,2); 
02DE:  MOVLW  01
02DF:  BSF    03.5
02E0:  MOVWF  20
02E1:  MOVLW  02
02E2:  MOVWF  21
....................               break; 
*
02F5:  GOTO   304
....................      case '\b'    :   lcd_envia_byte(0,0x10); 
02F6:  BSF    03.5
02F7:  CLRF   24
02F8:  MOVLW  10
02F9:  MOVWF  25
02FA:  BCF    03.5
02FB:  CALL   252
....................               break; 
02FC:  GOTO   304
....................      default   :   lcd_envia_byte(1,c); 
02FD:  MOVLW  01
02FE:  BSF    03.5
02FF:  MOVWF  24
0300:  MOVF   7E,W
0301:  MOVWF  25
0302:  BCF    03.5
0303:  CALL   252
....................               break; 
....................    } 
0304:  RETURN
.................... } 
....................  
.................... char lcd_le( byte x, byte y) 
.................... // le caractere do display 
.................... { 
....................    char valor; 
....................    // seleciona a posição do caractere 
....................    lcd_pos_xy(x,y); 
....................    // ativa rs 
....................    output_high(lcd_rs); 
....................    // lê o caractere 
....................    valor = lcd_le_byte(); 
....................    // desativa rs 
....................    output_low(lcd_rs); 
....................    // retorna o valor do caractere 
....................    return valor; 
.................... } 
....................  
....................  
.................... #include "2401.c" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a MicroChip 24LC01B configured for a x8 org         //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);  Read the byte d from the address a     //// 
.................... ////                                                                   //// 
.................... ////   b = ext_eeprom_ready();  Returns TRUE if the eeprom is ready    //// 
.................... ////                            to receive opcodes                     //// 
.................... ////                                                                   //// 
.................... ////   The main program may define EEPROM_SDA                          //// 
.................... ////   and EEPROM_SCL to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... ////                            Pin Layout                             //// 
.................... ////   -----------------------------------------------------------     //// 
.................... ////   |                                                         |     //// 
.................... ////   | 1: NC   Not Connected | 8: VCC   +5V                    |     //// 
.................... ////   |                       |                                 |     //// 
.................... ////   | 2: NC   Not Connected | 7: WP    GND                    |     //// 
.................... ////   |                       |                                 |     //// 
.................... ////   | 3: NC   Not Connected | 6: SCL   EEPROM_SCL and Pull-Up |     //// 
.................... ////   |                       |                                 |     //// 
.................... ////   | 4: VSS  GND           | 5: SDA   EEPROM_SDA and Pull-Up |     //// 
.................... ////   -----------------------------------------------------------     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2003 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef EEPROM_SDA 
....................  
.................... #define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C3 
....................  
.................... #endif 
....................  
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
....................  
.................... #define EEPROM_ADDRESS BYTE 
.................... #define EEPROM_SIZE    128 
....................  
.................... void init_ext_eeprom() { 
....................    output_float(EEPROM_SCL); 
*
0200:  BSF    50.3
0201:  MOVF   50,W
0202:  BSF    03.5
0203:  MOVWF  07
....................    output_float(EEPROM_SDA); 
0204:  BCF    03.5
0205:  BSF    50.4
0206:  MOVF   50,W
0207:  BSF    03.5
0208:  MOVWF  07
0209:  BCF    03.5
020A:  BCF    0A.3
020B:  BCF    0A.4
020C:  GOTO   75F (RETURN)
.................... } 
....................  
.................... BOOLEAN ext_eeprom_ready() { 
....................    int1 ack; 
....................    i2c_start();            // If the write command is acknowledged, 
....................    ack = i2c_write(0xa0);  // then the device is ready. 
....................    i2c_stop(); 
....................    return !ack; 
.................... } 
....................  
.................... void write_ext_eeprom(BYTE address, BYTE data) { 
....................    while(!ext_eeprom_ready()); 
....................    i2c_start(); 
....................    i2c_write(0xa0); 
....................    i2c_write(address); 
....................    i2c_write(data); 
....................    i2c_stop(); 
.................... } 
....................  
....................  
.................... BYTE read_ext_eeprom(BYTE address) { 
....................    BYTE data; 
....................  
....................    while(!ext_eeprom_ready()); 
....................    i2c_start(); 
....................    i2c_write(0xa0); 
....................    i2c_write(address); 
....................    i2c_start(); 
....................    i2c_write(0xa1); 
....................    data=i2c_read(0); 
....................    i2c_stop(); 
....................    return(data); 
.................... } 
....................  
.................... #include "kbd_board4.c" 
.................... /*######################################################################  
....................    Rotina utilização do teclado da placa PicSim board4 
....................    Adaptada para o compilador CCS 
....................    Autor: Alberto Willia Mascarenhas (adaptou para o compilador) 
....................    For e-mail suggestions :  awmascarenhas@gmail.com 
.................... ######################################################################## */ 
.................... unsigned char tc_tecla(unsigned int timeout) 
.................... { 
....................   unsigned int to=0; 
....................   unsigned char k = 0;   
....................   while(((to < timeout)||(!timeout))&&(!k)){ 
....................       
....................        
....................       //------------------------------------------------------------------------- 
....................       //inicio do programa de varredura do teclado matricial 
....................       //-------------------------------------------------------------------------- 
....................       //habilita primeira coluna do teclado 
....................       output_low(PIN_B0);output_high(PIN_B1);output_high(PIN_B2);output_high(PIN_B3); 
....................       delay_ms(20); 
....................       if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='1';}; 
....................       if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='4';}; 
....................       if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='7';}; 
....................       if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='*';}; 
....................       //habilita segunda coluna do teclado 
....................       output_high(PIN_B0);output_low(PIN_B1);output_high(PIN_B2);output_high(PIN_B3); 
....................       delay_ms(20);       
....................       if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='2';}; 
....................       if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='5';}; 
....................       if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='8';}; 
....................       if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='0';}; 
....................        
....................       //habilita terceira coluna do teclado 
....................       output_high(PIN_B0);output_high(PIN_B1);output_low(PIN_B2);output_high(PIN_B3); 
....................       delay_ms(20);       
....................       if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='3';}; 
....................       if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='6';}; 
....................       if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='9';}; 
....................       if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='#';}; 
....................   
....................        //habilita quarta coluna do teclado 
....................       output_high(PIN_B0);output_high(PIN_B1);output_high(PIN_B2);output_low(PIN_B3); 
....................       delay_ms(20);       
....................       if (input(PIN_D0) == 0){while(input(PIN_D0) == 0);k='A';}; 
....................       if (input(PIN_D1) == 0){while(input(PIN_D1) == 0);k='B';}; 
....................       if (input(PIN_D2) == 0){while(input(PIN_D2) == 0);k='C';}; 
....................       if (input(PIN_D3) == 0){while(input(PIN_D3) == 0);k='D';}; 
....................   
....................       //printf (lcd_escreve,"\f saiu geral %u",k); 
....................       //delay_ms(1000); 
....................       delay_ms(5); 
....................       to+=5; 
....................   } 
....................    if(!k)k=255; 
....................   return k;   
.................... } 
....................  
....................  
.................... typedef struct {  
....................    int id[2];   
....................    int pass[4]; //password 
....................    int status; //0 - Unpaid, 1 - Paid, 3 - Admin 
.................... }User; 
....................  
....................  
....................  
....................  
.................... /* 
.................... int status -> 0 - Unpaid, 1 - Paid, 3 - Admin 
.................... int chooseAddr: 
....................          Param < 0 - SAVE in a available address to CREATE  
....................          Param >= 0 - SAVE in a existing address to OVERWRITE (edit) 
.................... */ 
.................... void saveUser(int * id, int * pass, int status); 
.................... int getAddressByID(int * id);    
.................... void searchUser(int * id); 
.................... int deleteUser(int * id); 
.................... void editUser(); 
.................... void updateUser(int * id, int * pass, int status); 
.................... void receiveClient(); 
.................... // int isIdAvailable(int id);     
.................... void printUser(User user); 
.................... void erase_program_eeprom(int addrr); 
.................... int incrementID(); 
.................... int lastNewUserPosition(); 
.................... void resetMemory(); 
.................... void adminMenu(); 
.................... int login(int * id); 
.................... int checkPassword(int initBlockAddr, int * pass); 
.................... //show = 1 -> Print(Paid/Unpaid) 
.................... int getUserStatus(int address, int show); 
.................... unsigned char readKeyboard();  
.................... int * getAdminsID(); 
.................... void listAdmins(); 
.................... int * strToInt(char * str); 
.................... char * strfromchar(char destination[], char source); 
.................... int * inputId(); 
.................... int * inputToKeyboard(char * msg, int max); 
.................... void inputKeyboardUser(); 
....................  
....................  
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
*
035B:  BSF    03.5
035C:  MOVF   51,W
035D:  MOVWF  54
....................    for(su=s;0<n;++su,--n) 
035E:  MOVF   50,W
035F:  MOVWF  56
0360:  MOVF   4F,W
0361:  MOVWF  55
0362:  MOVF   53,F
0363:  BTFSS  03.2
0364:  GOTO   369
0365:  MOVF   52,W
0366:  SUBLW  00
0367:  BTFSC  03.0
0368:  GOTO   381
....................       if(*su==uc) 
0369:  MOVF   56,W
036A:  MOVWF  7A
036B:  MOVF   55,W
036C:  MOVWF  04
036D:  BCF    03.7
036E:  BTFSC  7A.0
036F:  BSF    03.7
0370:  MOVF   54,W
0371:  SUBWF  00,W
0372:  BTFSS  03.2
0373:  GOTO   379
....................       return su; 
0374:  MOVF   55,W
0375:  MOVWF  78
0376:  MOVF   56,W
0377:  MOVWF  79
0378:  GOTO   384
0379:  INCF   55,F
037A:  BTFSC  03.2
037B:  INCF   56,F
037C:  MOVF   52,W
037D:  BTFSC  03.2
037E:  DECF   53,F
037F:  DECF   52,F
0380:  GOTO   362
....................    return NULL; 
0381:  MOVLW  00
0382:  MOVWF  78
0383:  MOVWF  79
0384:  BCF    03.5
0385:  RETURN
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
074D:  BCF    03.5
074E:  CLRF   51
074F:  CLRF   52
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
*
0386:  BSF    03.5
0387:  CLRF   28
0388:  CLRF   27
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
0389:  MOVLW  30
038A:  MOVWF  2A
038B:  MOVLW  31
038C:  MOVWF  2B
038D:  MOVLW  32
038E:  MOVWF  2C
038F:  MOVLW  33
0390:  MOVWF  2D
0391:  MOVLW  34
0392:  MOVWF  2E
0393:  MOVLW  35
0394:  MOVWF  2F
0395:  MOVLW  36
0396:  MOVWF  30
0397:  MOVLW  37
0398:  MOVWF  31
0399:  MOVLW  38
039A:  MOVWF  32
039B:  MOVLW  39
039C:  MOVWF  33
039D:  MOVLW  61
039E:  MOVWF  34
039F:  MOVLW  62
03A0:  MOVWF  35
03A1:  MOVLW  63
03A2:  MOVWF  36
03A3:  MOVLW  64
03A4:  MOVWF  37
03A5:  MOVLW  65
03A6:  MOVWF  38
03A7:  MOVLW  66
03A8:  MOVWF  39
03A9:  MOVLW  67
03AA:  MOVWF  3A
03AB:  MOVLW  68
03AC:  MOVWF  3B
03AD:  MOVLW  69
03AE:  MOVWF  3C
03AF:  MOVLW  6A
03B0:  MOVWF  3D
03B1:  MOVLW  6B
03B2:  MOVWF  3E
03B3:  MOVLW  6C
03B4:  MOVWF  3F
03B5:  MOVLW  6D
03B6:  MOVWF  40
03B7:  MOVLW  6E
03B8:  MOVWF  41
03B9:  MOVLW  6F
03BA:  MOVWF  42
03BB:  MOVLW  70
03BC:  MOVWF  43
03BD:  MOVLW  71
03BE:  MOVWF  44
03BF:  MOVLW  73
03C0:  MOVWF  45
03C1:  MOVLW  74
03C2:  MOVWF  46
03C3:  MOVLW  75
03C4:  MOVWF  47
03C5:  MOVLW  76
03C6:  MOVWF  48
03C7:  MOVLW  77
03C8:  MOVWF  49
03C9:  MOVLW  78
03CA:  MOVWF  4A
03CB:  MOVLW  79
03CC:  MOVWF  4B
03CD:  MOVLW  7A
03CE:  MOVWF  4C
03CF:  CLRF   4D
....................    for(sc=s;isspace(*sc);++sc); 
03D0:  MOVF   7C,W
03D1:  MOVWF  22
03D2:  MOVF   7B,W
03D3:  MOVWF  21
03D4:  MOVF   22,W
03D5:  MOVWF  7A
03D6:  MOVF   21,W
03D7:  MOVWF  04
03D8:  BCF    03.7
03D9:  BTFSC  7A.0
03DA:  BSF    03.7
03DB:  MOVF   00,W
03DC:  SUBLW  20
03DD:  BTFSS  03.2
03DE:  GOTO   3E3
03DF:  INCF   21,F
03E0:  BTFSC  03.2
03E1:  INCF   22,F
03E2:  GOTO   3D4
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
03E3:  MOVF   22,W
03E4:  MOVWF  7A
03E5:  MOVF   21,W
03E6:  MOVWF  04
03E7:  BCF    03.7
03E8:  BTFSC  22.0
03E9:  BSF    03.7
03EA:  MOVF   00,W
03EB:  SUBLW  2D
03EC:  BTFSC  03.2
03ED:  GOTO   3F9
03EE:  MOVF   22,W
03EF:  MOVWF  7A
03F0:  MOVF   21,W
03F1:  MOVWF  04
03F2:  BCF    03.7
03F3:  BTFSC  22.0
03F4:  BSF    03.7
03F5:  MOVF   00,W
03F6:  SUBLW  2B
03F7:  BTFSS  03.2
03F8:  GOTO   405
03F9:  MOVF   22,W
03FA:  MOVWF  7A
03FB:  MOVF   21,W
03FC:  INCF   21,F
03FD:  BTFSC  03.2
03FE:  INCF   22,F
03FF:  MOVWF  04
0400:  BCF    03.7
0401:  BTFSC  7A.0
0402:  BSF    03.7
0403:  MOVF   00,W
0404:  GOTO   406
0405:  MOVLW  2B
0406:  MOVWF  29
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
0407:  MOVF   29,W
0408:  SUBLW  2D
0409:  BTFSC  03.2
040A:  GOTO   416
040B:  BTFSC  20.7
040C:  GOTO   416
040D:  DECFSZ 20,W
040E:  GOTO   410
040F:  GOTO   416
0410:  BTFSC  20.7
0411:  GOTO   418
0412:  MOVF   20,W
0413:  SUBLW  24
0414:  BTFSC  03.0
0415:  GOTO   418
....................    goto StrtoulGO; 
0416:  GOTO   570
0417:  GOTO   4AE
....................  
....................    else if (base) 
0418:  MOVF   20,F
0419:  BTFSC  03.2
041A:  GOTO   473
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
041B:  MOVF   20,W
041C:  SUBLW  10
041D:  BTFSS  03.2
041E:  GOTO   442
041F:  MOVF   22,W
0420:  MOVWF  7A
0421:  MOVF   21,W
0422:  MOVWF  04
0423:  BCF    03.7
0424:  BTFSC  7A.0
0425:  BSF    03.7
0426:  MOVF   00,W
0427:  SUBLW  30
0428:  BTFSS  03.2
0429:  GOTO   442
042A:  MOVLW  01
042B:  ADDWF  21,W
042C:  MOVWF  04
042D:  BCF    03.7
042E:  BTFSC  22.0
042F:  BSF    03.7
0430:  MOVF   00,W
0431:  SUBLW  78
0432:  BTFSC  03.2
0433:  GOTO   43E
0434:  MOVLW  01
0435:  ADDWF  21,W
0436:  MOVWF  04
0437:  BCF    03.7
0438:  BTFSC  22.0
0439:  BSF    03.7
043A:  MOVF   00,W
043B:  SUBLW  58
043C:  BTFSS  03.2
043D:  GOTO   442
....................          sc+=2; 
043E:  MOVLW  02
043F:  ADDWF  21,F
0440:  BTFSC  03.0
0441:  INCF   22,F
....................       if(base==8 && *sc =='0') 
0442:  MOVF   20,W
0443:  SUBLW  08
0444:  BTFSS  03.2
0445:  GOTO   455
0446:  MOVF   22,W
0447:  MOVWF  7A
0448:  MOVF   21,W
0449:  MOVWF  04
044A:  BCF    03.7
044B:  BTFSC  7A.0
044C:  BSF    03.7
044D:  MOVF   00,W
044E:  SUBLW  30
044F:  BTFSS  03.2
0450:  GOTO   455
....................          sc+=1; 
0451:  MOVLW  01
0452:  ADDWF  21,F
0453:  BTFSC  03.0
0454:  INCF   22,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
0455:  MOVF   20,W
0456:  SUBLW  02
0457:  BTFSS  03.2
0458:  GOTO   472
0459:  MOVF   22,W
045A:  MOVWF  7A
045B:  MOVF   21,W
045C:  MOVWF  04
045D:  BCF    03.7
045E:  BTFSC  7A.0
045F:  BSF    03.7
0460:  MOVF   00,W
0461:  SUBLW  30
0462:  BTFSS  03.2
0463:  GOTO   472
0464:  MOVLW  01
0465:  ADDWF  21,W
0466:  MOVWF  04
0467:  BCF    03.7
0468:  BTFSC  22.0
0469:  BSF    03.7
046A:  MOVF   00,W
046B:  SUBLW  62
046C:  BTFSS  03.2
046D:  GOTO   472
....................          sc+=2; 
046E:  MOVLW  02
046F:  ADDWF  21,F
0470:  BTFSC  03.0
0471:  INCF   22,F
....................  
....................    } 
0472:  GOTO   4AE
....................    else if(*sc!='0') // base is 0, find base 
0473:  MOVF   22,W
0474:  MOVWF  7A
0475:  MOVF   21,W
0476:  MOVWF  04
0477:  BCF    03.7
0478:  BTFSC  7A.0
0479:  BSF    03.7
047A:  MOVF   00,W
047B:  SUBLW  30
047C:  BTFSC  03.2
047D:  GOTO   481
....................       base=10; 
047E:  MOVLW  0A
047F:  MOVWF  20
0480:  GOTO   4AE
....................    else if (sc[1]=='x' || sc[1]=='X') 
0481:  MOVLW  01
0482:  ADDWF  21,W
0483:  MOVWF  04
0484:  BCF    03.7
0485:  BTFSC  22.0
0486:  BSF    03.7
0487:  MOVF   00,W
0488:  SUBLW  78
0489:  BTFSC  03.2
048A:  GOTO   495
048B:  MOVLW  01
048C:  ADDWF  21,W
048D:  MOVWF  04
048E:  BCF    03.7
048F:  BTFSC  22.0
0490:  BSF    03.7
0491:  MOVF   00,W
0492:  SUBLW  58
0493:  BTFSS  03.2
0494:  GOTO   49C
....................       base =16,sc+=2; 
0495:  MOVLW  10
0496:  MOVWF  20
0497:  MOVLW  02
0498:  ADDWF  21,F
0499:  BTFSC  03.0
049A:  INCF   22,F
049B:  GOTO   4AE
....................    else if(sc[1]=='b') 
049C:  MOVLW  01
049D:  ADDWF  21,W
049E:  MOVWF  04
049F:  BCF    03.7
04A0:  BTFSC  22.0
04A1:  BSF    03.7
04A2:  MOVF   00,W
04A3:  SUBLW  62
04A4:  BTFSS  03.2
04A5:  GOTO   4AC
....................       base=2,sc+=2; 
04A6:  MOVLW  02
04A7:  MOVWF  20
04A8:  ADDWF  21,F
04A9:  BTFSC  03.0
04AA:  INCF   22,F
04AB:  GOTO   4AE
....................    else 
....................       base=8; 
04AC:  MOVLW  08
04AD:  MOVWF  20
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
04AE:  MOVF   22,W
04AF:  MOVWF  24
04B0:  MOVF   21,W
04B1:  MOVWF  23
04B2:  MOVF   22,W
04B3:  MOVWF  7A
04B4:  MOVF   21,W
04B5:  MOVWF  04
04B6:  BCF    03.7
04B7:  BTFSC  7A.0
04B8:  BSF    03.7
04B9:  MOVF   00,W
04BA:  SUBLW  30
04BB:  BTFSS  03.2
04BC:  GOTO   4C1
04BD:  INCF   21,F
04BE:  BTFSC  03.2
04BF:  INCF   22,F
04C0:  GOTO   4B2
....................    sd=memchr(digits,tolower(*sc),base); 
04C1:  MOVF   22,W
04C2:  MOVWF  7A
04C3:  MOVF   21,W
04C4:  MOVWF  04
04C5:  BCF    03.7
04C6:  BTFSC  22.0
04C7:  BSF    03.7
04C8:  MOVF   00,W
04C9:  MOVWF  4E
04CA:  SUBLW  40
04CB:  BTFSC  03.0
04CC:  GOTO   4D4
04CD:  MOVF   4E,W
04CE:  SUBLW  5A
04CF:  BTFSS  03.0
04D0:  GOTO   4D4
04D1:  MOVF   4E,W
04D2:  IORLW  20
04D3:  GOTO   4D5
04D4:  MOVF   4E,W
04D5:  MOVWF  4E
04D6:  CLRF   50
04D7:  MOVLW  AA
04D8:  MOVWF  4F
04D9:  MOVF   4E,W
04DA:  MOVWF  51
04DB:  CLRF   53
04DC:  MOVF   20,W
04DD:  MOVWF  52
04DE:  BCF    03.5
04DF:  CALL   35B
04E0:  MOVF   79,W
04E1:  BSF    03.5
04E2:  MOVWF  26
04E3:  MOVF   78,W
04E4:  MOVWF  25
....................    for(; sd!=0; ) 
04E5:  MOVF   25,F
04E6:  BTFSS  03.2
04E7:  GOTO   4EB
04E8:  MOVF   26,F
04E9:  BTFSC  03.2
04EA:  GOTO   568
....................    { 
....................       x=x*base+(int16)(sd-digits); 
04EB:  CLRF   7A
04EC:  MOVF   20,W
04ED:  MOVWF  77
04EE:  BTFSC  77.7
04EF:  DECF   7A,F
04F0:  MOVWF  4E
04F1:  MOVF   7A,W
04F2:  MOVWF  4F
04F3:  MOVF   28,W
04F4:  MOVWF  51
04F5:  MOVF   27,W
04F6:  MOVWF  50
04F7:  MOVF   4F,W
04F8:  MOVWF  53
04F9:  MOVF   4E,W
04FA:  MOVWF  52
*
0528:  MOVF   79,W
0529:  MOVWF  4F
052A:  MOVF   78,W
052B:  MOVWF  4E
052C:  MOVLW  AA
052D:  SUBWF  25,W
052E:  MOVWF  77
052F:  MOVF   26,W
0530:  MOVWF  7A
0531:  MOVLW  00
0532:  BTFSS  03.0
0533:  MOVLW  01
0534:  SUBWF  7A,F
0535:  MOVF   77,W
0536:  ADDWF  4E,W
0537:  MOVWF  78
0538:  MOVF   4F,W
0539:  BTFSC  03.0
053A:  INCFSZ 4F,W
053B:  ADDWF  7A,F
053C:  MOVF   78,W
053D:  MOVWF  27
053E:  MOVF   7A,W
053F:  MOVWF  28
....................       ++sc; 
0540:  INCF   21,F
0541:  BTFSC  03.2
0542:  INCF   22,F
....................       sd=memchr(digits,tolower(*sc),base); 
0543:  MOVF   22,W
0544:  MOVWF  7A
0545:  MOVF   21,W
0546:  MOVWF  04
0547:  BCF    03.7
0548:  BTFSC  22.0
0549:  BSF    03.7
054A:  MOVF   00,W
054B:  MOVWF  4E
054C:  SUBLW  40
054D:  BTFSC  03.0
054E:  GOTO   556
054F:  MOVF   4E,W
0550:  SUBLW  5A
0551:  BTFSS  03.0
0552:  GOTO   556
0553:  MOVF   4E,W
0554:  IORLW  20
0555:  GOTO   557
0556:  MOVF   4E,W
0557:  MOVWF  4E
0558:  CLRF   50
0559:  MOVLW  AA
055A:  MOVWF  4F
055B:  MOVF   4E,W
055C:  MOVWF  51
055D:  CLRF   53
055E:  MOVF   20,W
055F:  MOVWF  52
0560:  BCF    03.5
0561:  CALL   35B
0562:  MOVF   79,W
0563:  BSF    03.5
0564:  MOVWF  26
0565:  MOVF   78,W
0566:  MOVWF  25
0567:  GOTO   4E5
....................    } 
....................    if(s1==sc) 
0568:  MOVF   21,W
0569:  SUBWF  23,W
056A:  BTFSS  03.2
056B:  GOTO   583
056C:  MOVF   22,W
056D:  SUBWF  24,W
056E:  BTFSS  03.2
056F:  GOTO   583
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
0570:  MOVF   7D,W
0571:  IORWF  7E,W
0572:  BTFSC  03.2
0573:  GOTO   57F
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
0574:  MOVF   7D,W
0575:  MOVWF  04
0576:  BCF    03.7
0577:  BTFSC  7E.0
0578:  BSF    03.7
0579:  INCF   04,F
057A:  MOVF   7C,W
057B:  MOVWF  00
057C:  DECF   04,F
057D:  MOVF   7B,W
057E:  MOVWF  00
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
057F:  MOVLW  00
0580:  MOVWF  78
0581:  MOVWF  79
0582:  GOTO   596
....................    } 
....................    if (endptr) 
0583:  MOVF   7D,W
0584:  IORWF  7E,W
0585:  BTFSC  03.2
0586:  GOTO   592
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
0587:  MOVF   7D,W
0588:  MOVWF  04
0589:  BCF    03.7
058A:  BTFSC  7E.0
058B:  BSF    03.7
058C:  INCF   04,F
058D:  MOVF   22,W
058E:  MOVWF  00
058F:  DECF   04,F
0590:  MOVF   21,W
0591:  MOVWF  00
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
0592:  MOVF   27,W
0593:  MOVWF  78
0594:  MOVF   28,W
0595:  MOVWF  79
0596:  BCF    03.5
0597:  RETURN
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... void saveUser(int * id, int * pass, int status){ 
....................    if( id[0] <= 99 && id[1] <= 99 && getAddressByID(id) == -1 ){ 
....................       int address = lastNewUserPosition(); 
....................  
....................       //recebe os parÃ¢metros do usuÃ¡rio 
....................       User user; 
....................       user.id[0] = id[0]; 
....................       user.id[1] = id[1]; 
....................       user.pass[0] = pass[0]; 
....................       user.pass[1] = pass[1]; 
....................       user.pass[2] = pass[2]; 
....................       user.pass[3] = pass[3]; 
....................       user.status = status; 
....................        
....................       write_ext_eeprom(address, user.id[0]); 
....................       write_ext_eeprom(address+1, user.id[1]); 
....................       write_ext_eeprom(address+2, user.pass[0]); 
....................       write_ext_eeprom(address+3, user.pass[1]); 
....................       write_ext_eeprom(address+4, user.pass[2]); 
....................       write_ext_eeprom(address+5, user.pass[3]);        
....................       write_ext_eeprom(address+6, user.status); 
....................  
....................       printf (lcd_escreve,"\fUsuario Cadastrado"); 
....................       delay_ms(500); 
....................  
....................    }else{ 
....................       printf (lcd_escreve,"\fID incompativel"); 
....................       printf (lcd_escreve,"\r\nTente novamente"); 
....................       delay_ms(1000); 
....................  
....................    } 
.................... } 
....................  
.................... void updateUser(int * id, int * pass, int status, int address){ 
....................    if( id[0] <= 99 && id[1] <= 99){ 
....................       //recebe os parÃ¢metros do usuÃ¡rio 
....................       User user; 
....................       user.id[0] = id[0]; 
....................       user.id[1] = id[1]; 
....................       user.pass[0] = pass[0]; 
....................       user.pass[1] = pass[1]; 
....................       user.pass[2] = pass[2]; 
....................       user.pass[3] = pass[3]; 
....................       user.status = status; 
....................        
....................       write_ext_eeprom(address, user.id[0]); 
....................       write_ext_eeprom(address+1, user.id[1]); 
....................       write_ext_eeprom(address+2, user.pass[0]); 
....................       write_ext_eeprom(address+3, user.pass[1]); 
....................       write_ext_eeprom(address+4, user.pass[2]); 
....................       write_ext_eeprom(address+5, user.pass[3]);        
....................       write_ext_eeprom(address+6, user.status); 
....................  
....................       printf (lcd_escreve,"\fUsuario Atualizado"); 
....................       delay_ms(500); 
....................  
....................    }else{ 
....................       printf (lcd_escreve,"\fID incompativel"); 
....................       printf (lcd_escreve,"\r\nTente novamente"); 
....................       delay_ms(1000); 
....................    } 
....................  
.................... } 
....................  
.................... void printUser(User user){ 
....................    printf (lcd_escreve,"\fCliente ID: %u%u",user.id[0],user.id[1]); 
*
06E7:  MOVLW  91
06E8:  BSF    03.6
06E9:  MOVWF  0D
06EA:  MOVLW  00
06EB:  MOVWF  0F
06EC:  BCF    03.0
06ED:  MOVLW  0D
06EE:  MOVWF  75
06EF:  BCF    03.6
06F0:  CALL   598
06F1:  MOVF   6E,W
06F2:  MOVWF  75
06F3:  MOVLW  1B
06F4:  MOVWF  76
06F5:  CALL   603
06F6:  MOVF   6F,W
06F7:  MOVWF  75
06F8:  MOVLW  1B
06F9:  MOVWF  76
06FA:  CALL   603
....................    printf(lcd_escreve, "\r\nPw:%u%u%u%u St:%u",user.pass[0],user.pass[1],user.pass[2],user.pass[3],user.status); 
06FB:  MOVLW  9A
06FC:  BSF    03.6
06FD:  MOVWF  0D
06FE:  MOVLW  00
06FF:  MOVWF  0F
0700:  BCF    03.0
0701:  MOVLW  05
0702:  MOVWF  75
0703:  BCF    03.6
0704:  CALL   598
0705:  MOVF   70,W
0706:  MOVWF  75
0707:  MOVLW  1B
0708:  MOVWF  76
0709:  CALL   603
070A:  MOVF   71,W
070B:  MOVWF  75
070C:  MOVLW  1B
070D:  MOVWF  76
070E:  CALL   603
070F:  MOVF   72,W
0710:  MOVWF  75
0711:  MOVLW  1B
0712:  MOVWF  76
0713:  CALL   603
0714:  MOVF   73,W
0715:  MOVWF  75
0716:  MOVLW  1B
0717:  MOVWF  76
0718:  CALL   603
0719:  MOVLW  A0
071A:  BSF    03.6
071B:  MOVWF  0D
071C:  MOVLW  00
071D:  MOVWF  0F
071E:  BSF    03.0
071F:  MOVLW  04
0720:  MOVWF  75
0721:  BCF    03.6
0722:  CALL   598
0723:  MOVF   74,W
0724:  MOVWF  75
0725:  MOVLW  1B
0726:  MOVWF  76
0727:  CALL   603
....................    delay_ms(1000); 
0728:  MOVLW  04
0729:  MOVWF  75
072A:  MOVLW  FA
072B:  BSF    03.5
072C:  MOVWF  20
072D:  BCF    03.5
072E:  CALL   20D
072F:  DECFSZ 75,F
0730:  GOTO   72A
.................... } 
....................  
.................... void receiveClient(){ 
....................     
....................    int * rx_buffer_int; 
....................    printf (lcd_escreve,"\f%s\r\n",string); 
*
0638:  MOVLW  0C
0639:  MOVWF  7E
063A:  CALL   2C4
063B:  MOVLW  41
063C:  MOVWF  04
063D:  BCF    03.7
*
0653:  MOVLW  0D
0654:  MOVWF  7E
0655:  CALL   2C4
0656:  MOVLW  0A
0657:  MOVWF  7E
0658:  CALL   2C4
....................    delay_ms(1000); 
0659:  MOVLW  04
065A:  MOVWF  6E
065B:  MOVLW  FA
065C:  BSF    03.5
065D:  MOVWF  20
065E:  BCF    03.5
065F:  CALL   20D
0660:  DECFSZ 6E,F
0661:  GOTO   65B
....................    rx_buffer_int = strToInt(string); 
0662:  CLRF   6F
0663:  MOVLW  41
0664:  MOVWF  6E
*
069E:  MOVF   79,W
069F:  MOVWF  66
06A0:  MOVF   78,W
06A1:  MOVWF  65
....................    // for(int i =0; i < RX_BUFFER_SIZE; i++){ 
....................    //    printf (lcd_escreve,"\fPos:%d Value:%d",i,rx_buffer_int[i]); 
....................    //    delay_ms(500); 
....................    // } 
....................  
....................    User user; 
....................    user.id[0] = rx_buffer_int[0]; 
06A2:  MOVF   65,W
06A3:  MOVWF  04
06A4:  BCF    03.7
06A5:  BTFSC  66.0
06A6:  BSF    03.7
06A7:  MOVF   00,W
06A8:  MOVWF  67
....................    user.id[1] = rx_buffer_int[1]; 
06A9:  MOVLW  01
06AA:  ADDWF  65,W
06AB:  MOVWF  04
06AC:  BCF    03.7
06AD:  BTFSC  66.0
06AE:  BSF    03.7
06AF:  MOVF   00,W
06B0:  MOVWF  68
....................    user.pass[0] = rx_buffer_int[2]; 
06B1:  MOVLW  02
06B2:  ADDWF  65,W
06B3:  MOVWF  04
06B4:  BCF    03.7
06B5:  BTFSC  66.0
06B6:  BSF    03.7
06B7:  MOVF   00,W
06B8:  MOVWF  69
....................    user.pass[1] = rx_buffer_int[3]; 
06B9:  MOVLW  03
06BA:  ADDWF  65,W
06BB:  MOVWF  04
06BC:  BCF    03.7
06BD:  BTFSC  66.0
06BE:  BSF    03.7
06BF:  MOVF   00,W
06C0:  MOVWF  6A
....................    user.pass[2] = rx_buffer_int[4]; 
06C1:  MOVLW  04
06C2:  ADDWF  65,W
06C3:  MOVWF  04
06C4:  BCF    03.7
06C5:  BTFSC  66.0
06C6:  BSF    03.7
06C7:  MOVF   00,W
06C8:  MOVWF  6B
....................    user.pass[3] = rx_buffer_int[5]; 
06C9:  MOVLW  05
06CA:  ADDWF  65,W
06CB:  MOVWF  04
06CC:  BCF    03.7
06CD:  BTFSC  66.0
06CE:  BSF    03.7
06CF:  MOVF   00,W
06D0:  MOVWF  6C
....................    user.status = rx_buffer_int[6]; 
06D1:  MOVLW  06
06D2:  ADDWF  65,W
06D3:  MOVWF  04
06D4:  BCF    03.7
06D5:  BTFSC  66.0
06D6:  BSF    03.7
06D7:  MOVF   00,W
06D8:  MOVWF  6D
....................    printUser(user); 
06D9:  MOVF   67,W
06DA:  MOVWF  6E
06DB:  MOVF   68,W
06DC:  MOVWF  6F
06DD:  MOVF   69,W
06DE:  MOVWF  70
06DF:  MOVF   6A,W
06E0:  MOVWF  71
06E1:  MOVF   6B,W
06E2:  MOVWF  72
06E3:  MOVF   6C,W
06E4:  MOVWF  73
06E5:  MOVF   6D,W
06E6:  MOVWF  74
*
0731:  BCF    0A.3
0732:  BCF    0A.4
0733:  GOTO   794 (RETURN)
.................... } 
....................  
.................... int getAddressByID(int * id){ 
....................    int id_temp[2]; 
....................    int address = 0; 
....................     
....................    while( read_ext_eeprom(address) != -1){ 
....................       id_temp[0] = read_ext_eeprom(address); 
....................       id_temp[1] = read_ext_eeprom(address+1); 
....................        
....................       if (id_temp[0] == id[0] && id_temp[1] == id[1]){ 
....................          return address; 
....................       } 
....................  
....................       address += BLOCK_SIZE;  
....................    } 
....................    return -1; 
.................... } 
....................  
.................... void searchUser(int * id){ 
....................  
....................    int address = getAddressByID(id); 
....................    if(address != -1){ 
....................       printf (lcd_escreve,"\fID:%u%u",id[0],id[1]); 
....................       int showStatus = 1; 
....................       getUserStatus(address,showStatus); 
....................    }else{ 
....................       printf(lcd_escreve,"\fUsuario N Existe"); 
....................       delay_ms(1000); 
....................    } 
.................... } 
....................  
.................... void erase_program_eeprom(int addrr){ 
....................    for(int i=0; i < BLOCK_SIZE; i++){ 
....................          write_ext_eeprom(addrr + i, -1); 
....................    }   
....................    printf (lcd_escreve,"\f User erased "); 
....................    delay_ms(200); 
.................... } 
....................  
.................... int getUserStatus(int address, int show){ 
....................    int status = read_ext_eeprom(address+BLOCK_SIZE - 1); 
....................  
....................    if(show == 1){ 
....................       char msg_status[10]; 
....................       if( status == 0){ 
....................          strcpy(msg_status,"NAO PAGO"); 
....................       }else{ 
....................          strcpy(msg_status,"PAGO"); 
....................       } 
....................       printf (lcd_escreve,"\r\nStatus:%s",msg_status); 
....................       delay_ms(1500); 
....................    } 
....................    return status; 
.................... } 
....................  
.................... int deleteUser(int * id){ 
....................     
....................    int address = getAddressByID(id); 
....................    if(address == -1) 
....................       return -1; 
....................    int data_temp; 
....................    int previous_block = address; 
....................    int next_block = address + BLOCK_SIZE; 
....................  
....................    //Case 1: without the next block 
....................    if (read_ext_eeprom(next_block) == -1){ 
....................       erase_program_eeprom(previous_block);       
....................       return 1; 
....................    } 
....................  
....................    //Case 2: Check whether the data in the next block address is empty 
....................    while(read_ext_eeprom(next_block) != -1){ 
....................       //data_temp[index] = read_ext_eeprom(address); 
....................       for(int i=0; i < BLOCK_SIZE; i++){ 
....................          //Read the data from the next block  
....................          data_temp = read_ext_eeprom(next_block + i);            
....................          //overwrite the previous block with the data from the next 
....................          write_ext_eeprom(previous_block + i, data_temp);   
....................       }   
....................       previous_block = next_block; 
....................       next_block += BLOCK_SIZE; 
....................    } 
....................    //Go back to erase the block that's duplicated  
....................    next_block -= BLOCK_SIZE; 
....................    //Erase the last block since everything  
....................    //moved a block_size to the left 
....................    erase_program_eeprom(next_block); 
....................     
....................    return 1; 
....................  
.................... } 
....................  
.................... int lastNewUserPosition(){ 
....................    int address = 0; 
....................     
....................  
....................    while( read_ext_eeprom(address) != -1){ 
....................       address += BLOCK_SIZE;  
....................    } 
....................    // printf (lcd_escreve,"\fAddress: %u", address); 
....................    // delay_ms(500); 
....................     
....................    return address; 
....................  
.................... } 
....................  
.................... void resetMemory(){ 
....................    int address = 0; 
....................    for(; read_ext_eeprom(address) != -1; 
....................     erase_program_eeprom(address), address += BLOCK_SIZE); 
.................... } 
....................  
.................... void adminMenu(){ 
....................    unsigned char option; 
....................    unsigned int * temp; 
....................    unsigned int id [2]; 
....................    do{ 
....................       printf(lcd_escreve,"\f1:CAD|2:BUSCAR"); 
....................       printf(lcd_escreve,"\r\n3:DEL|4:EDITAR"); 
....................       delay_ms(1000); 
....................       printf(lcd_escreve,"\f5: SAIR do Menu "); 
....................       delay_ms(100); 
....................      
....................       option = readKeyboard(); 
....................  
....................       if(option != 255){ 
....................          printf(lcd_escreve,"\f Option: %c", option); 
....................          delay_ms(500); 
....................  
....................          switch(option){ 
....................             case '1': 
....................                inputKeyboardUser(); 
....................                break; 
....................             case '2': 
....................                temp = inputId(); 
....................                id[0] = temp[0]; 
....................                id[1] = temp[1]; 
....................                searchUser(id); 
....................                break; 
....................             case '3': 
....................                temp = inputId(); 
....................                id[0] = temp[0]; 
....................                id[1] = temp[1]; 
....................                signed int success = deleteUser(id); 
....................                printf(lcd_escreve,"\fSuccess -> %d", success); 
....................                delay_ms(500); 
....................                (success >= 1)?  
....................                printf(lcd_escreve,"\fusuario deletado"): 
....................                printf(lcd_escreve,"\fusuario N Existe"); 
....................                delay_ms(500); 
....................                break; 
....................             case '4': 
....................                editUser(); 
....................                break; 
....................             default: 
....................                printf(lcd_escreve,"\fDigite um valor"); 
....................                printf(lcd_escreve,"\r\nValido!"); 
....................                delay_ms(500); 
....................                break; 
....................          } 
....................       } 
....................    }while(option != '5'); 
.................... } 
....................  
....................  
.................... int login(int * id){ 
....................  
....................    int address = getAddressByID(id); 
....................    if(address == -1){ 
....................       printf(lcd_escreve,"\fID N Existe"); 
....................       printf(lcd_escreve,"\r\nTente de novo"); 
....................       delay_ms(1000); 
....................       return -1; 
....................    } 
....................    unsigned int * temp; 
....................    unsigned int pass[4]; 
....................  
....................    char msg [] = "Digite a senha: "; 
....................    int max = 4; 
....................    temp = inputToKeyboard(msg, max); 
....................    pass[0] = temp[0]; 
....................    pass[1] = temp[1]; 
....................    pass[2] = temp[2]; 
....................    pass[3] = temp[3]; 
....................    // printf(lcd_escreve,"\fPASS(4): %u%u%u%u",pass[0],pass[1],pass[2],pass[3]); 
....................    // delay_ms(1000); 
....................    int result_pass = checkPassword(address,pass); 
....................    if(result_pass != 0){ 
....................       printf(lcd_escreve,"\fProcure a secretaria"); 
....................       printf(lcd_escreve,"\r\nP/ resolver"); 
....................       delay_ms(1000); 
....................       printf(lcd_escreve,"\fNADA eh Ligado!"); 
....................       delay_ms(500); 
....................       return -1; 
....................    } 
....................  
....................    int show = 0; 
....................    int status = getUserStatus(address,show); 
....................    return status; 
....................  
.................... } 
....................  
.................... int checkPassword(int initBlockAddr, int * pass){ 
....................    int pass_addr = initBlockAddr + 2; 
....................    int len = 4;  
....................    for(int i=0; i < len;i++,pass_addr++){ 
....................       if(pass[i] != read_ext_eeprom(pass_addr)) 
....................          return -1; 
....................    } 
....................    return 0; 
....................  
.................... } 
.................... unsigned char readKeyboard(){ 
....................  
....................    unsigned char tmp; 
....................    unsigned char tmp_result; 
....................     
....................    tmp = tc_tecla(1300); // ms 
....................    if(tmp != 255){ 
....................       // write_ext_eeprom(0, tmp); 
....................       // delay_ms(50); 
....................       // tmp_result = read_ext_eeprom(0); 
....................       // delay_ms(50); 
....................       // tmp_result = tmp; 
....................       // printf(lcd_escreve,"\f Button: %c", tmp); 
....................       // delay_ms(50); 
....................    }else{  
....................       printf(lcd_escreve,"\f Digite"); 
....................    } 
....................  
....................    return tmp; 
.................... } 
....................  
....................  
.................... int * getAdminsID(){ 
....................  
....................    int address = 0; 
....................    int temp_status; 
....................    int index= 0; 
....................    static int admins[BLOCK_SIZE]; 
*
0750:  CLRF   57
0751:  CLRF   58
0752:  CLRF   59
0753:  CLRF   5A
0754:  CLRF   5B
0755:  CLRF   5C
0756:  CLRF   5D
....................    admins[0] = -1; 
....................    while( read_ext_eeprom(address) != -1){ 
....................       temp_status = read_ext_eeprom(address + (BLOCK_SIZE - 1));//status of the user 
....................       if (temp_status == 3){ 
....................          printf (lcd_escreve,"\fAdmin Encontrado"); 
....................          delay_ms(1000); 
....................          for(int i=0; i < 2; i++){ 
....................             int id = read_ext_eeprom(address+i);    
....................             admins[index] = id; 
....................             index++; 
....................          } 
....................  
....................       } 
....................  
....................       address += BLOCK_SIZE;  
....................    } 
....................  
....................    return admins; 
....................  
.................... } 
....................  
.................... void listAdmins(){ 
....................    int * admins; 
....................  
....................    admins = getAdminsID(); 
....................    printf(lcd_escreve,"\f admins[0]: %d", admins[0]); 
....................    delay_ms(1000); 
....................    if(admins[0] != -1){ 
....................       for (int16 i=0; i < sizeof(admins); i+=2){ 
....................          printf(lcd_escreve, "\fid:%u%u",admins[i], admins[i+1]); 
....................          delay_ms(1000); 
....................       }  
....................    } 
.................... } 
....................  
....................  
.................... int * strToInt(char * str){ 
*
0665:  MOVF   6F,W
0666:  MOVWF  71
0667:  MOVF   6E,W
0668:  MOVWF  70
0669:  CLRF   74
....................  
....................   char *p = str; 
....................   //https://flaviocopes.com/c-array-length/ 
....................   static unsigned int buffer[BLOCK_SIZE];   
*
0757:  CLRF   5E
0758:  CLRF   5F
0759:  CLRF   60
075A:  CLRF   61
075B:  CLRF   62
075C:  CLRF   63
075D:  CLRF   64
....................   char * end; 
....................   int index = 0; 
....................  
....................   for (unsigned int number = strtoul(p, &end, 10); 
*
066A:  MOVF   71,W
066B:  MOVWF  7C
066C:  MOVF   70,W
066D:  MOVWF  7B
066E:  CLRF   7E
066F:  MOVLW  72
0670:  MOVWF  7D
0671:  MOVLW  0A
0672:  BSF    03.5
0673:  MOVWF  20
0674:  BCF    03.5
0675:  CALL   386
0676:  MOVF   78,W
0677:  MOVWF  75
....................         p != end; 
0678:  MOVF   72,W
0679:  SUBWF  70,W
067A:  BTFSS  03.2
067B:  GOTO   680
067C:  MOVF   73,W
067D:  SUBWF  71,W
067E:  BTFSC  03.2
067F:  GOTO   69A
....................         number = strtoul(p, &end, 10)) 
....................   { 
....................     p = end; 
0680:  MOVF   73,W
0681:  MOVWF  71
0682:  MOVF   72,W
0683:  MOVWF  70
....................  
....................     buffer[index] = number;  
0684:  MOVLW  5E
0685:  ADDWF  74,W
0686:  MOVWF  04
0687:  BCF    03.7
0688:  MOVF   75,W
0689:  MOVWF  00
....................     index++; 
068A:  INCF   74,F
068B:  MOVF   71,W
068C:  MOVWF  7C
068D:  MOVF   70,W
068E:  MOVWF  7B
068F:  CLRF   7E
0690:  MOVLW  72
0691:  MOVWF  7D
0692:  MOVLW  0A
0693:  BSF    03.5
0694:  MOVWF  20
0695:  BCF    03.5
0696:  CALL   386
0697:  MOVF   78,W
0698:  MOVWF  75
0699:  GOTO   678
....................   } 
....................  
....................    return buffer; 
069A:  MOVLW  5E
069B:  MOVWF  78
069C:  MOVLW  00
069D:  MOVWF  79
.................... } 
....................  
.................... char * strfromchar(char destination[], char source)  
.................... {  
....................    destination[0] = source;   // copy the character into the string  
....................    destination[1] = '\0';      // null-terminate the string  
....................   
....................    return destination;         // common convention for str functions  
.................... }  
....................  
....................  
.................... int * inputId(){ 
....................    unsigned char keyboard_buffer[BLOCK_SIZE * 2]; 
....................    unsigned char option; 
....................  
....................    int * temp; 
....................    int i = 0; 
....................    //The user needs to type 4 digits 
....................    //For example, even if it's just 9 
....................    //He/she will type: 0009 
....................    while(i < 5){ 
....................       printf(lcd_escreve,"\fDigite o ID: "); 
....................       delay_ms(50); 
....................       option = readKeyboard(); 
....................       if(option != 255){ 
....................          printf(lcd_escreve,"\n\rTyped:%c", option); 
....................          delay_ms(400); 
....................          if(i == 2){ 
....................             //To convert to int will be easier with space between them 
....................             keyboard_buffer[i] = ' '; 
....................             i++; 
....................          } 
....................          keyboard_buffer[i] = option; 
....................          i++; 
....................       } 
....................    } 
....................    // unsigned char *id; 
....................    // id = keyboard_buffer; 
....................    temp = strToInt(keyboard_buffer); 
....................    return temp; 
.................... } 
....................  
.................... int * inputToKeyboard(char * msg, int max){ 
....................    unsigned char option; 
....................    int data[BLOCK_SIZE]; 
....................    int * temp; 
....................    int i = 0; 
....................  
....................    while(i < max){ 
....................  
....................       printf(lcd_escreve,"\f%s", msg); 
....................       delay_ms(50); 
....................       option = readKeyboard(); 
....................       if(option != 255){ 
....................          printf(lcd_escreve,"\n\rTyped:%c", option); 
....................          delay_ms(400); 
....................          unsigned char destination[2]; 
....................          //Convert string from char and return  
....................          //to the left array of char(str_pass) 
....................          strfromchar(destination,option); 
....................          temp = strToInt(destination); 
....................          data[i] = temp[0]; 
....................          i++; 
....................       } 
....................    } 
....................  
....................    temp = data; 
....................    return temp; 
....................  
.................... } 
.................... void inputKeyboardUser(){ 
....................  
....................    unsigned int * temp; 
....................    unsigned int id [2]; 
....................    temp = inputId(); 
....................    id[0] = temp[0]; 
....................    id[1] = temp[1]; 
....................    int address = getAddressByID(id); 
....................    printf(lcd_escreve,"\fid: %u%u",id[0],id[1]); 
....................    delay_ms(500); 
....................    if(address == -1){//-1: ID is available to use 
....................       unsigned int pass[4]; 
....................       unsigned int status; 
....................  
....................       char msg [] = "Digite a senha: "; 
....................       int max = 4; 
....................       temp = inputToKeyboard(msg, max); 
....................       pass[0] = temp[0]; 
....................       pass[1] = temp[1]; 
....................       pass[2] = temp[2]; 
....................       pass[3] = temp[3]; 
....................  
....................       char msg2 [] = "Status (0,1,3): "; 
....................       max = 1; 
....................       temp = inputToKeyboard(msg2, max); 
....................       status = temp[0]; 
....................  
....................       saveUser(id,pass,status); 
....................    }else{ 
....................       printf (lcd_escreve,"\fID Jah Existe"); 
....................       delay_ms(1000); 
....................    } 
.................... } 
....................  
.................... void editUser(){ 
....................    unsigned int * temp; 
....................    unsigned int id [2]; 
....................    temp = inputId(); 
....................    id[0] = temp[0]; 
....................    id[1] = temp[1]; 
....................    int address = getAddressByID(id); 
....................    if(address != -1){ 
....................       unsigned int * temp; 
....................       unsigned int pass[4]; 
....................       unsigned int status; 
....................  
....................       char msg [] = "Nova senha: "; 
....................       int max = 4; 
....................       temp = inputToKeyboard(msg, max); 
....................       pass[0] = temp[0]; 
....................       pass[1] = temp[1]; 
....................       pass[2] = temp[2]; 
....................       pass[3] = temp[3]; 
....................       printf(lcd_escreve,"\fPASS(4): %u%u%u%u",pass[0],pass[1],pass[2],pass[3]); 
....................       delay_ms(500); 
....................  
....................       char msg2 [] = "Novo Status\r\n(0,1,3): "; 
....................       max = 1; 
....................       temp = inputToKeyboard(msg2, max); 
....................       status = temp[0]; 
....................       printf(lcd_escreve,"\fSTATUS: %u",status); 
....................       delay_ms(500); 
....................  
....................       updateUser(id,pass,status,address); 
....................    }else{ 
....................       printf (lcd_escreve,"\fID N Existe"); 
....................       delay_ms(1000); 
....................    } 
.................... } 
....................  
....................  
.................... // ---- MSG from serial communication 
.................... #int_RDA 
.................... void RDA_isr(void){ 
....................    rx_buffer[rx_wr_index] = getc(); 
*
0186:  MOVLW  32
0187:  ADDWF  2B,W
0188:  MOVWF  04
0189:  BCF    03.7
018A:  BTFSS  0C.5
018B:  GOTO   18A
018C:  MOVF   1A,W
018D:  MOVWF  00
....................    string[rx_wr_index] = rx_buffer[rx_wr_index]; 
018E:  MOVLW  41
018F:  ADDWF  2B,W
0190:  MOVWF  78
0191:  CLRF   7A
0192:  BTFSC  03.0
0193:  INCF   7A,F
0194:  MOVF   78,W
0195:  BSF    03.5
0196:  MOVWF  59
0197:  MOVF   7A,W
0198:  MOVWF  5A
0199:  MOVLW  32
019A:  BCF    03.5
019B:  ADDWF  2B,W
019C:  MOVWF  04
019D:  BCF    03.7
019E:  MOVF   00,W
019F:  BSF    03.5
01A0:  MOVWF  5B
01A1:  MOVF   59,W
01A2:  MOVWF  04
01A3:  BCF    03.7
01A4:  BTFSC  5A.0
01A5:  BSF    03.7
01A6:  MOVF   5B,W
01A7:  MOVWF  00
....................    rxd = rx_buffer[rx_wr_index]; 
01A8:  MOVLW  32
01A9:  BCF    03.5
01AA:  ADDWF  2B,W
01AB:  MOVWF  04
01AC:  BCF    03.7
01AD:  MOVF   00,W
01AE:  MOVWF  2D
....................    rx_wr_index++; 
01AF:  INCF   2B,F
....................  
....................    if(rx_wr_index > RX_BUFFER_SIZE){ 
01B0:  MOVF   2B,W
01B1:  SUBLW  0F
01B2:  BTFSS  03.0
....................       rx_wr_index = 0; 
01B3:  CLRF   2B
....................    } 
....................  
....................    //Look for unique ID: "IFMT" 
....................    if(rxd == 'I' && lock_pos == 0){ 
01B4:  MOVF   2D,W
01B5:  SUBLW  49
01B6:  BTFSS  03.2
01B7:  GOTO   1BD
01B8:  MOVF   2C,F
01B9:  BTFSS  03.2
01BA:  GOTO   1BD
....................       lock_pos++; 
01BB:  INCF   2C,F
....................    } 
01BC:  GOTO   1E0
....................    else if(rxd == 'F' && lock_pos == 1){ 
01BD:  MOVF   2D,W
01BE:  SUBLW  46
01BF:  BTFSS  03.2
01C0:  GOTO   1C5
01C1:  DECFSZ 2C,W
01C2:  GOTO   1C5
....................       lock_pos++; 
01C3:  INCF   2C,F
....................    } 
01C4:  GOTO   1E0
....................    else if(rxd == 'M' && lock_pos == 2){ 
01C5:  MOVF   2D,W
01C6:  SUBLW  4D
01C7:  BTFSS  03.2
01C8:  GOTO   1CF
01C9:  MOVF   2C,W
01CA:  SUBLW  02
01CB:  BTFSS  03.2
01CC:  GOTO   1CF
....................       lock_pos++; 
01CD:  INCF   2C,F
....................    } 
01CE:  GOTO   1E0
....................    else if(rxd == 'T' && lock_pos == 3){ 
01CF:  MOVF   2D,W
01D0:  SUBLW  54
01D1:  BTFSS  03.2
01D2:  GOTO   1DF
01D3:  MOVF   2C,W
01D4:  SUBLW  03
01D5:  BTFSS  03.2
01D6:  GOTO   1DF
....................       lock_pos=0; //Reset the "combination lock" 
01D7:  CLRF   2C
....................       got_id = TRUE; 
01D8:  MOVLW  01
01D9:  MOVWF  31
....................       read = rxd; 
01DA:  MOVF   2D,W
01DB:  MOVWF  2E
....................       //get ready to count the number of data bytes 
....................       valid_data_count = 0;  
01DC:  CLRF   2F
....................  
....................       //buffer is reset to index 0 
....................       rx_wr_index = 0; 
01DD:  CLRF   2B
....................    }else { 
01DE:  GOTO   1E0
....................       lock_pos = 0; 
01DF:  CLRF   2C
....................    } 
....................  
....................    if(got_id && valid_data_count++ >= BLOCK_SIZE){ 
01E0:  MOVF   31,F
01E1:  BTFSC  03.2
01E2:  GOTO   1EB
01E3:  MOVF   2F,W
01E4:  INCF   2F,F
01E5:  SUBLW  06
01E6:  BTFSC  03.0
01E7:  GOTO   1EB
....................       data_avail = TRUE; 
01E8:  MOVLW  01
01E9:  MOVWF  30
....................       got_id = FALSE; 
01EA:  CLRF   31
....................    } 
....................     
01EB:  BCF    0C.5
01EC:  BCF    0A.3
01ED:  BCF    0A.4
01EE:  GOTO   02D
.................... } 
....................  
....................  
....................  
....................  
.................... // #int_TIMER1 
.................... // void TIMER1_isr(void) 
.................... // { 
.................... // } 
....................  
.................... // #int_RTCC 
.................... // void RTCC_isr(void) 
.................... // { 
....................  
....................        
.................... // } 
....................  
.................... void main() 
*
0734:  MOVF   03,W
0735:  ANDLW  1F
0736:  MOVWF  03
0737:  MOVLW  81
0738:  BSF    03.5
0739:  MOVWF  19
073A:  MOVLW  A6
073B:  MOVWF  18
073C:  MOVLW  90
073D:  BCF    03.5
073E:  MOVWF  18
073F:  CLRF   2B
0740:  CLRF   2C
0741:  CLRF   30
0742:  CLRF   31
0743:  MOVLW  FF
0744:  MOVWF  50
0745:  BSF    03.5
0746:  BSF    1F.0
0747:  BSF    1F.1
0748:  BSF    1F.2
0749:  BCF    1F.3
074A:  MOVLW  07
074B:  MOVWF  1C
074C:  BCF    03.7
.................... { 
....................    //VARIAVEIS 
....................  
....................    // setup_timer_0(RTCC_INTERNAL|RTCC_DIV_256|RTCC_8_bit);      //13.1ms overflow 
....................    // setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); //Overflow in 104ms | Resolution 1.6 us 
....................    init_ext_eeprom(); 
*
075E:  GOTO   200
....................    // enable_interrupts(INT_TIMER0); 
....................    // enable_interrupts(INT_TIMER1); 
....................    enable_interrupts(INT_RDA); 
075F:  BSF    03.5
0760:  BSF    0C.5
....................    enable_interrupts(GLOBAL); 
0761:  MOVLW  C0
0762:  BCF    03.5
0763:  IORWF  0B,F
....................  
....................    lcd_ini(); 
0764:  GOTO   27B
....................    delay_us(50); 
0765:  MOVLW  52
0766:  MOVWF  77
0767:  DECFSZ 77,F
0768:  GOTO   767
0769:  GOTO   76A
076A:  NOP
....................  
....................    printf(lcd_escreve, "\f  iniciando... "); 
076B:  MOVLW  EF
076C:  BSF    03.6
076D:  MOVWF  0D
076E:  MOVLW  01
076F:  MOVWF  0F
0770:  BCF    03.6
0771:  CALL   305
....................    delay_ms(500); 
0772:  MOVLW  02
0773:  MOVWF  65
0774:  MOVLW  FA
0775:  BSF    03.5
0776:  MOVWF  20
0777:  BCF    03.5
0778:  CALL   20D
0779:  DECFSZ 65,F
077A:  GOTO   774
....................  
....................    printf(lcd_escreve, "\fIFMT - Serial"); 
077B:  MOVLW  F8
077C:  BSF    03.6
077D:  MOVWF  0D
077E:  MOVLW  01
077F:  MOVWF  0F
0780:  BCF    03.6
0781:  CALL   305
....................    delay_ms(500); 
0782:  MOVLW  02
0783:  MOVWF  65
0784:  MOVLW  FA
0785:  BSF    03.5
0786:  MOVWF  20
0787:  BCF    03.5
0788:  CALL   20D
0789:  DECFSZ 65,F
078A:  GOTO   784
....................  
....................    // resetmemory(); 
....................  
....................    // int id [2] = {12,34}; 
....................    // int pass [4] = {1,2,3,4}; 
....................    // saveuser(id, pass, 1); 
....................    // int id1 [2] = {14,0}; 
....................    // saveuser(id1, pass, 0); 
....................    // int id2 [2] = {70,10}; 
....................    // saveuser(id2, pass, 1); 
....................    // int id3 [2] = {0,10}; 
....................    // saveuser(id3, pass, 1); 
....................    // int id4 [2] = {99,99}; 
....................    // saveuser(id4, pass, 3);//admin 
....................     
....................     
....................    // unsigned int * temp; 
....................    // unsigned int id [2]; 
....................    // temp = inputId(); 
....................    // id[0] = temp[0]; 
....................    // id[1] = temp[1]; 
....................    // login(id); 
....................  
....................    while(true){ 
....................       if(data_avail){ 
078B:  MOVF   30,F
078C:  BTFSC  03.2
078D:  GOTO   794
....................          output_high(PIN_D3); 
078E:  BSF    03.5
078F:  BCF    08.3
0790:  BCF    03.5
0791:  BSF    08.3
....................          data_avail = FALSE; 
0792:  CLRF   30
....................          receiveClient(); 
0793:  GOTO   638
....................       } 
0794:  GOTO   78B
....................    } 
....................  
....................  
....................    // unsigned char option; unsigned int * temp; 
....................    // unsigned int id [2]; 
....................    // int status; 
....................    // do{ 
....................    //    printf(lcd_escreve,"\f1:Login|2:Admin"); 
....................    //    delay_ms(500); 
....................    //    option = readKeyboard(); 
....................  
....................    //    if(option != 255){ 
....................    //       printf(lcd_escreve,"\r\n Option: %c", option); 
....................    //       delay_ms(500); 
....................  
....................    //       switch(option){ 
....................    //          case '1': 
....................    //             temp = inputId(); 
....................    //             id[0] = temp[0]; 
....................    //             id[1] = temp[1]; 
....................    //             status = login(id); 
....................    //             if(status == 1 || status == 3){ 
....................    //                printf(lcd_escreve,"\fBem Vindo(a)!"); 
....................    //                delay_ms(1000); 
....................    //                printf(lcd_escreve,"\fLiga Led e Rele"); 
....................    //                delay_ms(500); 
....................    //             }else{//Unpaid 
....................    //                printf(lcd_escreve,"\fConta Existe"); 
....................    //                printf(lcd_escreve,"\r\r,Mas Falta Pagar!"); 
....................    //                delay_ms(1000); 
....................    //             } 
....................    //             break; 
....................    //          case '2': 
....................    //             temp = inputId(); 
....................    //             id[0] = temp[0]; 
....................    //             id[1] = temp[1]; 
....................    //             status = login(id); 
....................    //             if(status == 3){ 
....................    //                adminMenu(); 
....................    //             } 
....................    //             else{ 
....................    //                printf(lcd_escreve,"\fN Permitido"); 
....................    //                delay_ms(500); 
....................    //             } 
....................    //             break; 
....................    //          default: 
....................    //             printf(lcd_escreve,"\fDigite um valor"); 
....................    //             printf(lcd_escreve,"\r\nValido!"); 
....................    //             delay_ms(500); 
....................    //             break; 
....................    //       } 
....................    //    } 
....................  
....................  
....................    // }while(option != '5'); 
....................  
.................... } 
....................  
0795:  SLEEP

Configuration Fuses:
   Word  1: 3F32   HS NOWDT PUT NOBROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
